# compiler: R8
# compiler_version: 3.2.47
# min_api: 21
# common_typos_disable
# {"id":"com.android.tools.r8.mapping","version":"2.0"}
# pg_map_id: 040d42b
# pg_map_hash: SHA-256 040d42bd693eecf915203b62d4cc50743c4e671d4c96c67afd5f8cb4dfb85167
a3.KeyEventChannel$$ExternalSyntheticLambda0 -> a3.c:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.engine.systemchannels.KeyEventChannel$EventResponseHandler io.flutter.embedding.engine.systemchannels.KeyEventChannel$$InternalSyntheticLambda$1$2a0e2abef616d6cea4b4f1a8a10072820346c8d644dd4afd70e232766d86619d$0.f$0 -> a
    void io.flutter.embedding.engine.systemchannels.KeyEventChannel$$InternalSyntheticLambda$1$2a0e2abef616d6cea4b4f1a8a10072820346c8d644dd4afd70e232766d86619d$0.<init>(io.flutter.embedding.engine.systemchannels.KeyEventChannel$EventResponseHandler) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.engine.systemchannels.KeyEventChannel$$InternalSyntheticLambda$1$2a0e2abef616d6cea4b4f1a8a10072820346c8d644dd4afd70e232766d86619d$0.reply(java.lang.Object) -> a
      # {"id":"com.android.tools.r8.synthesized"}
a3.PlatformViewsChannel$1$$ExternalSyntheticLambda0 -> a3.j:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MethodChannel$Result io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$1$$InternalSyntheticLambda$1$06a0318edf43c68b535b7196357da0ff9ff18d83e350c6ea0dc6b00c1c7bbad1$0.f$0 -> a
    void io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$1$$InternalSyntheticLambda$1$06a0318edf43c68b535b7196357da0ff9ff18d83e350c6ea0dc6b00c1c7bbad1$0.<init>(io.flutter.plugin.common.MethodChannel$Result) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$1$$InternalSyntheticLambda$1$06a0318edf43c68b535b7196357da0ff9ff18d83e350c6ea0dc6b00c1c7bbad1$0.run(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferSize) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.activity.Cancellable -> androidx.activity.a:
androidx.activity.ComponentActivity$2 -> androidx.activity.ComponentActivity$2:
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.activity.ComponentActivity$3 -> androidx.activity.ComponentActivity$3:
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.activity.ImmLeaksCleaner -> androidx.activity.ImmLeaksCleaner:
    java.lang.reflect.Field sServedViewField -> d
    java.lang.reflect.Field sNextServedViewField -> e
    java.lang.reflect.Field sHField -> c
    android.app.Activity mActivity -> a
    int sReflectedFieldsInitialized -> b
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
    void initializeReflectiveFields() -> h
androidx.activity.OnBackPressedDispatcher$LifecycleOnBackPressedCancellable -> androidx.activity.OnBackPressedDispatcher$LifecycleOnBackPressedCancellable:
    androidx.lifecycle.Lifecycle mLifecycle -> a
    androidx.activity.Cancellable mCurrentCancellable -> b
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.activity.OnBackPressedDispatcherOwner -> androidx.activity.b:
    androidx.activity.OnBackPressedDispatcher getOnBackPressedDispatcher() -> i
androidx.arch.core.executor.ArchTaskExecutor -> a.a:
    androidx.arch.core.executor.ArchTaskExecutor sInstance -> c
    java.util.concurrent.Executor sMainThreadExecutor -> d
    java.util.concurrent.Executor sIOThreadExecutor -> e
    androidx.arch.core.executor.TaskExecutor mDefaultTaskExecutor -> b
    androidx.arch.core.executor.TaskExecutor mDelegate -> a
    void executeOnDiskIO(java.lang.Runnable) -> a
    boolean isMainThread() -> b
    void postToMainThread(java.lang.Runnable) -> c
    androidx.arch.core.executor.ArchTaskExecutor getInstance() -> d
androidx.arch.core.executor.ArchTaskExecutor$1 -> a.a$a:
androidx.arch.core.executor.ArchTaskExecutor$2 -> a.a$b:
androidx.arch.core.executor.DefaultTaskExecutor -> a.b:
    android.os.Handler mMainHandler -> c
    java.lang.Object mLock -> a
    java.util.concurrent.ExecutorService mDiskIO -> b
    void executeOnDiskIO(java.lang.Runnable) -> a
    boolean isMainThread() -> b
    void postToMainThread(java.lang.Runnable) -> c
    android.os.Handler createAsync(android.os.Looper) -> d
androidx.arch.core.executor.DefaultTaskExecutor$1 -> a.b$a:
    java.util.concurrent.atomic.AtomicInteger mThreadId -> a
    androidx.arch.core.executor.DefaultTaskExecutor this$0 -> b
androidx.arch.core.executor.TaskExecutor -> a.c:
    void executeOnDiskIO(java.lang.Runnable) -> a
    boolean isMainThread() -> b
    void postToMainThread(java.lang.Runnable) -> c
androidx.arch.core.internal.FastSafeIterableMap -> b.a:
    java.util.HashMap mHashMap -> U2
    androidx.arch.core.internal.SafeIterableMap$Entry get(java.lang.Object) -> e
    java.lang.Object remove(java.lang.Object) -> i
    java.util.Map$Entry ceil(java.lang.Object) -> j
    java.lang.Object putIfAbsent(java.lang.Object,java.lang.Object) -> k
androidx.arch.core.internal.SafeIterableMap -> b.b:
    int mSize -> T2
    androidx.arch.core.internal.SafeIterableMap$Entry mStart -> Q2
    androidx.arch.core.internal.SafeIterableMap$Entry mEnd -> R2
    java.util.WeakHashMap mIterators -> S2
    java.util.Iterator descendingIterator() -> a
    java.util.Map$Entry eldest() -> b
    androidx.arch.core.internal.SafeIterableMap$Entry get(java.lang.Object) -> e
    androidx.arch.core.internal.SafeIterableMap$IteratorWithAdditions iteratorWithAdditions() -> f
    java.util.Map$Entry newest() -> g
    androidx.arch.core.internal.SafeIterableMap$Entry put(java.lang.Object,java.lang.Object) -> h
    java.lang.Object remove(java.lang.Object) -> i
androidx.arch.core.internal.SafeIterableMap$AscendingIterator -> b.b$a:
    androidx.arch.core.internal.SafeIterableMap$Entry backward(androidx.arch.core.internal.SafeIterableMap$Entry) -> b
    androidx.arch.core.internal.SafeIterableMap$Entry forward(androidx.arch.core.internal.SafeIterableMap$Entry) -> c
androidx.arch.core.internal.SafeIterableMap$DescendingIterator -> b.b$b:
    androidx.arch.core.internal.SafeIterableMap$Entry backward(androidx.arch.core.internal.SafeIterableMap$Entry) -> b
    androidx.arch.core.internal.SafeIterableMap$Entry forward(androidx.arch.core.internal.SafeIterableMap$Entry) -> c
androidx.arch.core.internal.SafeIterableMap$Entry -> b.b$c:
    androidx.arch.core.internal.SafeIterableMap$Entry mPrevious -> T2
    java.lang.Object mKey -> Q2
    java.lang.Object mValue -> R2
    androidx.arch.core.internal.SafeIterableMap$Entry mNext -> S2
androidx.arch.core.internal.SafeIterableMap$IteratorWithAdditions -> b.b$d:
    boolean mBeforeStart -> R2
    androidx.arch.core.internal.SafeIterableMap this$0 -> S2
    androidx.arch.core.internal.SafeIterableMap$Entry mCurrent -> Q2
    void supportRemove(androidx.arch.core.internal.SafeIterableMap$Entry) -> a
    java.util.Map$Entry next() -> b
androidx.arch.core.internal.SafeIterableMap$ListIterator -> b.b$e:
    androidx.arch.core.internal.SafeIterableMap$Entry mExpectedEnd -> Q2
    androidx.arch.core.internal.SafeIterableMap$Entry mNext -> R2
    void supportRemove(androidx.arch.core.internal.SafeIterableMap$Entry) -> a
    androidx.arch.core.internal.SafeIterableMap$Entry backward(androidx.arch.core.internal.SafeIterableMap$Entry) -> b
    androidx.arch.core.internal.SafeIterableMap$Entry forward(androidx.arch.core.internal.SafeIterableMap$Entry) -> c
    java.util.Map$Entry next() -> d
    androidx.arch.core.internal.SafeIterableMap$Entry nextNode() -> e
androidx.arch.core.internal.SafeIterableMap$SupportRemove -> b.b$f:
    void supportRemove(androidx.arch.core.internal.SafeIterableMap$Entry) -> a
androidx.collection.ArrayMap -> c.a:
    androidx.collection.MapCollections mCollections -> X2
    androidx.collection.MapCollections getCollection() -> m
androidx.collection.ArrayMap$1 -> c.a$a:
    androidx.collection.ArrayMap this$0 -> d
    void colClear() -> a
    java.lang.Object colGetEntry(int,int) -> b
    java.util.Map colGetMap() -> c
    int colGetSize() -> d
    int colIndexOfKey(java.lang.Object) -> e
    int colIndexOfValue(java.lang.Object) -> f
    void colPut(java.lang.Object,java.lang.Object) -> g
    void colRemoveAt(int) -> h
    java.lang.Object colSetValue(int,java.lang.Object) -> i
androidx.collection.ContainerHelpers -> c.b:
    java.lang.Object[] EMPTY_OBJECTS -> c
    long[] EMPTY_LONGS -> b
    int[] EMPTY_INTS -> a
    int binarySearch(int[],int,int) -> a
    boolean equal(java.lang.Object,java.lang.Object) -> b
androidx.collection.MapCollections -> c.c:
    androidx.collection.MapCollections$KeySet mKeySet -> b
    androidx.collection.MapCollections$ValuesCollection mValues -> c
    androidx.collection.MapCollections$EntrySet mEntrySet -> a
    void colClear() -> a
    java.lang.Object colGetEntry(int,int) -> b
    java.util.Map colGetMap() -> c
    int colGetSize() -> d
    int colIndexOfKey(java.lang.Object) -> e
    int colIndexOfValue(java.lang.Object) -> f
    void colPut(java.lang.Object,java.lang.Object) -> g
    void colRemoveAt(int) -> h
    java.lang.Object colSetValue(int,java.lang.Object) -> i
    boolean containsAllHelper(java.util.Map,java.util.Collection) -> j
    boolean equalsSetHelper(java.util.Set,java.lang.Object) -> k
    java.util.Set getEntrySet() -> l
    java.util.Set getKeySet() -> m
    java.util.Collection getValues() -> n
    boolean removeAllHelper(java.util.Map,java.util.Collection) -> o
    boolean retainAllHelper(java.util.Map,java.util.Collection) -> p
    java.lang.Object[] toArrayHelper(int) -> q
    java.lang.Object[] toArrayHelper(java.lang.Object[],int) -> r
androidx.collection.MapCollections$ArrayIterator -> c.c$a:
    int mIndex -> S2
    boolean mCanRemove -> T2
    androidx.collection.MapCollections this$0 -> U2
    int mOffset -> Q2
    int mSize -> R2
androidx.collection.MapCollections$EntrySet -> c.c$b:
    androidx.collection.MapCollections this$0 -> Q2
    boolean add(java.util.Map$Entry) -> a
androidx.collection.MapCollections$KeySet -> c.c$c:
    androidx.collection.MapCollections this$0 -> Q2
androidx.collection.MapCollections$MapIterator -> c.c$d:
    boolean mEntryValid -> S2
    androidx.collection.MapCollections this$0 -> T2
    int mEnd -> Q2
    int mIndex -> R2
    java.util.Map$Entry next() -> a
androidx.collection.MapCollections$ValuesCollection -> c.c$e:
    androidx.collection.MapCollections this$0 -> Q2
androidx.collection.SimpleArrayMap -> c.d:
    int mBaseCacheSize -> U2
    int mSize -> S2
    java.lang.Object[] mBaseCache -> T2
    int mTwiceBaseCacheSize -> W2
    java.lang.Object[] mArray -> R2
    java.lang.Object[] mTwiceBaseCache -> V2
    int[] mHashes -> Q2
    void allocArrays(int) -> a
    int binarySearchHashes(int[],int,int) -> b
    void ensureCapacity(int) -> c
    void freeArrays(int[],java.lang.Object[],int) -> d
    int indexOf(java.lang.Object,int) -> e
    int indexOfKey(java.lang.Object) -> f
    int indexOfNull() -> g
    int indexOfValue(java.lang.Object) -> h
    java.lang.Object keyAt(int) -> i
    java.lang.Object removeAt(int) -> j
    java.lang.Object setValueAt(int,java.lang.Object) -> k
    java.lang.Object valueAt(int) -> l
androidx.core.app.ActivityCompat -> androidx.core.app.a:
    androidx.core.app.ActivityCompat$PermissionCompatDelegate sDelegate -> c
    void requestPermissions(android.app.Activity,java.lang.String[],int) -> e
    boolean shouldShowRequestPermissionRationale(android.app.Activity,java.lang.String) -> f
androidx.core.app.ActivityCompat$1 -> androidx.core.app.a$a:
    int val$requestCode -> S2
    android.app.Activity val$activity -> R2
    java.lang.String[] val$permissionsArray -> Q2
androidx.core.app.ActivityCompat$Api23Impl -> androidx.core.app.a$b:
    void onSharedElementsReady(java.lang.Object) -> a
    void requestPermissions(android.app.Activity,java.lang.String[],int) -> b
    boolean shouldShowRequestPermissionRationale(android.app.Activity,java.lang.String) -> c
androidx.core.app.ActivityCompat$OnRequestPermissionsResultCallback -> androidx.core.app.a$c:
    void onRequestPermissionsResult(int,java.lang.String[],int[]) -> a
androidx.core.app.ActivityCompat$PermissionCompatDelegate -> androidx.core.app.a$d:
    boolean requestPermissions(android.app.Activity,java.lang.String[],int) -> a
androidx.core.app.ActivityCompat$RequestPermissionsRequestCodeValidator -> androidx.core.app.a$e:
    void validateRequestPermissionsRequestCode(int) -> a
androidx.core.app.CoreComponentFactory -> androidx.core.app.CoreComponentFactory:
    java.lang.Object checkCompatWrapper(java.lang.Object) -> a
androidx.core.app.CoreComponentFactory$CompatWrapped -> androidx.core.app.CoreComponentFactory$a:
    java.lang.Object getWrapper() -> a
androidx.core.app.NotificationManagerCompat -> androidx.core.app.b:
    android.content.Context mContext -> a
    java.util.Set sEnabledNotificationListenerPackages -> d
    android.app.NotificationManager mNotificationManager -> b
    java.lang.Object sLock -> e
    java.lang.Object sEnabledNotificationListenersLock -> c
    boolean areNotificationsEnabled() -> a
    androidx.core.app.NotificationManagerCompat from(android.content.Context) -> b
androidx.core.app.RemoteActionCompat -> androidx.core.app.RemoteActionCompat:
    androidx.core.graphics.drawable.IconCompat mIcon -> a
    java.lang.CharSequence mTitle -> b
    java.lang.CharSequence mContentDescription -> c
    boolean mEnabled -> e
    boolean mShouldShowIcon -> f
    android.app.PendingIntent mActionIntent -> d
androidx.core.content.ContextCompat -> androidx.core.content.a:
    java.lang.Object sSync -> b
    java.lang.Object sLock -> a
    int checkSelfPermission(android.content.Context,java.lang.String) -> a
    java.io.File[] getExternalCacheDirs(android.content.Context) -> b
    java.io.File[] getExternalFilesDirs(android.content.Context,java.lang.String) -> c
    java.util.concurrent.Executor getMainExecutor(android.content.Context) -> d
androidx.core.content.ContextCompat$Api19Impl -> androidx.core.content.a$a:
    java.io.File[] getExternalCacheDirs(android.content.Context) -> a
    java.io.File[] getExternalFilesDirs(android.content.Context,java.lang.String) -> b
    java.io.File[] getObbDirs(android.content.Context) -> c
androidx.core.content.ContextCompat$Api28Impl -> androidx.core.content.a$b:
    java.util.concurrent.Executor getMainExecutor(android.content.Context) -> a
androidx.core.content.FileProvider -> androidx.core.content.b:
    java.io.File DEVICE_ROOT -> d
    androidx.core.content.FileProvider$PathStrategy mStrategy -> a
    int mResourceId -> b
    java.util.HashMap sCache -> e
    java.lang.String[] COLUMNS -> c
    java.io.File buildPath(java.io.File,java.lang.String[]) -> a
    java.lang.Object[] copyOf(java.lang.Object[],int) -> b
    java.lang.String[] copyOf(java.lang.String[],int) -> c
    android.content.res.XmlResourceParser getFileProviderPathsMetaData(android.content.Context,java.lang.String,android.content.pm.ProviderInfo,int) -> d
    androidx.core.content.FileProvider$PathStrategy getPathStrategy(android.content.Context,java.lang.String,int) -> e
    android.net.Uri getUriForFile(android.content.Context,java.lang.String,java.io.File) -> f
    int modeToMode(java.lang.String) -> g
    androidx.core.content.FileProvider$PathStrategy parsePathStrategy(android.content.Context,java.lang.String,int) -> h
androidx.core.content.FileProvider$Api21Impl -> androidx.core.content.b$a:
    java.io.File[] getExternalMediaDirs(android.content.Context) -> a
androidx.core.content.FileProvider$PathStrategy -> androidx.core.content.b$b:
    java.io.File getFileForUri(android.net.Uri) -> a
    android.net.Uri getUriForFile(java.io.File) -> b
androidx.core.content.FileProvider$SimplePathStrategy -> androidx.core.content.b$c:
    java.util.HashMap mRoots -> b
    java.lang.String mAuthority -> a
    java.io.File getFileForUri(android.net.Uri) -> a
    android.net.Uri getUriForFile(java.io.File) -> b
    void addRoot(java.lang.String,java.io.File) -> c
androidx.core.content.res.ResourcesCompat -> androidx.core.content.res.a:
    java.lang.ThreadLocal sTempTypedValue -> a
    java.lang.Object sColorStateCacheLock -> c
    java.util.WeakHashMap sColorStateCaches -> b
    android.graphics.drawable.Drawable getDrawable(android.content.res.Resources,int,android.content.res.Resources$Theme) -> a
androidx.core.content.res.ResourcesCompat$Api21Impl -> androidx.core.content.res.a$a:
    android.graphics.drawable.Drawable getDrawable(android.content.res.Resources,int,android.content.res.Resources$Theme) -> a
    android.graphics.drawable.Drawable getDrawableForDensity(android.content.res.Resources,int,int,android.content.res.Resources$Theme) -> b
androidx.core.graphics.drawable.IconCompat -> androidx.core.graphics.drawable.IconCompat:
    java.lang.String mTintModeStr -> i
    android.graphics.PorterDuff$Mode DEFAULT_TINT_MODE -> k
    java.lang.String mString1 -> j
    android.graphics.PorterDuff$Mode mTintMode -> h
    android.os.Parcelable mParcelable -> d
    java.lang.Object mObj1 -> b
    int mInt2 -> f
    android.content.res.ColorStateList mTintList -> g
    int mInt1 -> e
    byte[] mData -> c
    int mType -> a
    android.graphics.Bitmap createLegacyIconFromAdaptiveIcon(android.graphics.Bitmap,boolean) -> a
    int getResId() -> b
    java.lang.String getResPackage() -> c
    android.net.Uri getUri() -> d
    java.io.InputStream getUriInputStream(android.content.Context) -> e
    void onPostParceling() -> f
    void onPreParceling(boolean) -> g
    java.lang.String typeToString(int) -> h
androidx.core.graphics.drawable.IconCompat$Api23Impl -> androidx.core.graphics.drawable.IconCompat$a:
    int getResId(java.lang.Object) -> a
    java.lang.String getResPackage(java.lang.Object) -> b
    android.net.Uri getUri(java.lang.Object) -> c
    android.graphics.drawable.Drawable loadDrawable(android.graphics.drawable.Icon,android.content.Context) -> d
    android.graphics.drawable.Icon toIcon(androidx.core.graphics.drawable.IconCompat,android.content.Context) -> e
androidx.core.graphics.drawable.IconCompat$Api26Impl -> androidx.core.graphics.drawable.IconCompat$b:
    android.graphics.drawable.Drawable createAdaptiveIconDrawable(android.graphics.drawable.Drawable,android.graphics.drawable.Drawable) -> a
    android.graphics.drawable.Icon createWithAdaptiveBitmap(android.graphics.Bitmap) -> b
androidx.core.graphics.drawable.IconCompat$Api28Impl -> androidx.core.graphics.drawable.IconCompat$c:
    int getResId(java.lang.Object) -> a
    java.lang.String getResPackage(java.lang.Object) -> b
    int getType(java.lang.Object) -> c
    android.net.Uri getUri(java.lang.Object) -> d
androidx.core.graphics.drawable.IconCompat$Api30Impl -> androidx.core.graphics.drawable.IconCompat$d:
    android.graphics.drawable.Icon createWithAdaptiveBitmapContentUri(android.net.Uri) -> a
androidx.core.os.BuildCompat -> d.a:
    boolean isAtLeastPreReleaseCodename(java.lang.String,java.lang.String) -> a
    boolean isAtLeastT() -> b
androidx.core.os.ExecutorCompat -> d.b:
    java.util.concurrent.Executor create(android.os.Handler) -> a
androidx.core.os.ExecutorCompat$HandlerExecutor -> d.b$a:
    android.os.Handler mHandler -> Q2
androidx.core.util.Consumer -> e.a:
androidx.core.util.ObjectsCompat -> e.b:
    java.lang.Object requireNonNull(java.lang.Object,java.lang.String) -> a
androidx.core.util.Preconditions -> e.c:
    java.lang.Object checkNotNull(java.lang.Object) -> a
androidx.core.view.WindowInsetsControllerCompat -> f.a:
    androidx.core.view.WindowInsetsControllerCompat$Impl mImpl -> a
    void setAppearanceLightNavigationBars(boolean) -> a
    void setAppearanceLightStatusBars(boolean) -> b
androidx.core.view.WindowInsetsControllerCompat$Impl -> f.a$e:
    void setAppearanceLightNavigationBars(boolean) -> a
    void setAppearanceLightStatusBars(boolean) -> b
androidx.core.view.WindowInsetsControllerCompat$Impl20 -> f.a$a:
    android.view.View mView -> b
    android.view.Window mWindow -> a
    void setSystemUiFlag(int) -> c
    void setWindowFlag(int) -> d
    void unsetSystemUiFlag(int) -> e
    void unsetWindowFlag(int) -> f
androidx.core.view.WindowInsetsControllerCompat$Impl23 -> f.a$b:
    void setAppearanceLightStatusBars(boolean) -> b
androidx.core.view.WindowInsetsControllerCompat$Impl26 -> f.a$c:
    void setAppearanceLightNavigationBars(boolean) -> a
androidx.core.view.WindowInsetsControllerCompat$Impl30 -> f.a$d:
    android.view.Window mWindow -> d
    androidx.collection.SimpleArrayMap mListeners -> c
    android.view.WindowInsetsController mInsetsController -> b
    androidx.core.view.WindowInsetsControllerCompat mCompatController -> a
    void setAppearanceLightNavigationBars(boolean) -> a
    void setAppearanceLightStatusBars(boolean) -> b
    void setSystemUiFlag(int) -> c
    void unsetSystemUiFlag(int) -> d
androidx.core.view.inputmethod.EditorInfoCompat -> g.a:
    java.lang.String[] EMPTY_STRING_ARRAY -> a
    void setContentMimeTypes(android.view.inputmethod.EditorInfo,java.lang.String[]) -> a
androidx.fragment.app.Fragment$2 -> androidx.fragment.app.Fragment$2:
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.lifecycle.ClassesInfoCache -> androidx.lifecycle.a:
    java.util.Map mCallbackMap -> a
    java.util.Map mHasLifecycleMethods -> b
    androidx.lifecycle.ClassesInfoCache sInstance -> c
    androidx.lifecycle.ClassesInfoCache$CallbackInfo createInfo(java.lang.Class,java.lang.reflect.Method[]) -> a
    java.lang.reflect.Method[] getDeclaredMethods(java.lang.Class) -> b
    androidx.lifecycle.ClassesInfoCache$CallbackInfo getInfo(java.lang.Class) -> c
    boolean hasLifecycleMethods(java.lang.Class) -> d
    void verifyAndPutHandler(java.util.Map,androidx.lifecycle.ClassesInfoCache$MethodReference,androidx.lifecycle.Lifecycle$Event,java.lang.Class) -> e
androidx.lifecycle.ClassesInfoCache$CallbackInfo -> androidx.lifecycle.a$a:
    java.util.Map mEventToHandlers -> a
    java.util.Map mHandlerToEvent -> b
    void invokeCallbacks(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event,java.lang.Object) -> a
    void invokeMethodsForEvent(java.util.List,androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event,java.lang.Object) -> b
androidx.lifecycle.ClassesInfoCache$MethodReference -> androidx.lifecycle.a$b:
    int mCallType -> a
    java.lang.reflect.Method mMethod -> b
    void invokeCallback(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event,java.lang.Object) -> a
androidx.lifecycle.CompositeGeneratedAdaptersObserver -> androidx.lifecycle.CompositeGeneratedAdaptersObserver:
    androidx.lifecycle.GeneratedAdapter[] mGeneratedAdapters -> a
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.lifecycle.FullLifecycleObserver -> androidx.lifecycle.b:
    void onResume(androidx.lifecycle.LifecycleOwner) -> a
    void onDestroy(androidx.lifecycle.LifecycleOwner) -> b
    void onCreate(androidx.lifecycle.LifecycleOwner) -> c
    void onPause(androidx.lifecycle.LifecycleOwner) -> e
    void onStop(androidx.lifecycle.LifecycleOwner) -> f
    void onStart(androidx.lifecycle.LifecycleOwner) -> g
androidx.lifecycle.FullLifecycleObserverAdapter -> androidx.lifecycle.FullLifecycleObserverAdapter:
    androidx.lifecycle.FullLifecycleObserver mFullLifecycleObserver -> a
    androidx.lifecycle.LifecycleEventObserver mLifecycleEventObserver -> b
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.lifecycle.FullLifecycleObserverAdapter$1 -> androidx.lifecycle.FullLifecycleObserverAdapter$a:
    int[] $SwitchMap$androidx$lifecycle$Lifecycle$Event -> a
androidx.lifecycle.GeneratedAdapter -> androidx.lifecycle.c:
    void callMethods(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event,boolean,androidx.lifecycle.MethodCallsLogger) -> a
androidx.lifecycle.Lifecycle -> androidx.lifecycle.d:
    java.util.concurrent.atomic.AtomicReference mInternalScopeRef -> a
    void addObserver(androidx.lifecycle.LifecycleObserver) -> a
    androidx.lifecycle.Lifecycle$State getCurrentState() -> b
    void removeObserver(androidx.lifecycle.LifecycleObserver) -> c
androidx.lifecycle.Lifecycle$1 -> androidx.lifecycle.d$a:
    int[] $SwitchMap$androidx$lifecycle$Lifecycle$Event -> b
    int[] $SwitchMap$androidx$lifecycle$Lifecycle$State -> a
androidx.lifecycle.Lifecycle$Event -> androidx.lifecycle.d$b:
    androidx.lifecycle.Lifecycle$Event downFrom(androidx.lifecycle.Lifecycle$State) -> a
    androidx.lifecycle.Lifecycle$State getTargetState() -> c
    androidx.lifecycle.Lifecycle$Event upFrom(androidx.lifecycle.Lifecycle$State) -> d
androidx.lifecycle.Lifecycle$State -> androidx.lifecycle.d$c:
    androidx.lifecycle.Lifecycle$State INITIALIZED -> R2
    androidx.lifecycle.Lifecycle$State CREATED -> S2
    androidx.lifecycle.Lifecycle$State DESTROYED -> Q2
    androidx.lifecycle.Lifecycle$State[] $VALUES -> V2
    androidx.lifecycle.Lifecycle$State STARTED -> T2
    androidx.lifecycle.Lifecycle$State RESUMED -> U2
    boolean isAtLeast(androidx.lifecycle.Lifecycle$State) -> a
androidx.lifecycle.LifecycleEventObserver -> androidx.lifecycle.e:
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.lifecycle.LifecycleObserver -> androidx.lifecycle.f:
androidx.lifecycle.LifecycleOwner -> androidx.lifecycle.g:
    androidx.lifecycle.Lifecycle getLifecycle() -> a
androidx.lifecycle.LifecycleRegistry -> androidx.lifecycle.h:
    androidx.arch.core.internal.FastSafeIterableMap mObserverMap -> b
    boolean mEnforceMainThread -> i
    androidx.lifecycle.Lifecycle$State mState -> c
    java.util.ArrayList mParentStates -> h
    java.lang.ref.WeakReference mLifecycleOwner -> d
    boolean mHandlingEvent -> f
    boolean mNewEventOccurred -> g
    int mAddingObserverCounter -> e
    void addObserver(androidx.lifecycle.LifecycleObserver) -> a
    androidx.lifecycle.Lifecycle$State getCurrentState() -> b
    void removeObserver(androidx.lifecycle.LifecycleObserver) -> c
    void backwardPass(androidx.lifecycle.LifecycleOwner) -> d
    androidx.lifecycle.Lifecycle$State calculateTargetState(androidx.lifecycle.LifecycleObserver) -> e
    void enforceMainThreadIfNeeded(java.lang.String) -> f
    void forwardPass(androidx.lifecycle.LifecycleOwner) -> g
    void handleLifecycleEvent(androidx.lifecycle.Lifecycle$Event) -> h
    boolean isSynced() -> i
    androidx.lifecycle.Lifecycle$State min(androidx.lifecycle.Lifecycle$State,androidx.lifecycle.Lifecycle$State) -> j
    void moveToState(androidx.lifecycle.Lifecycle$State) -> k
    void popParentState() -> l
    void pushParentState(androidx.lifecycle.Lifecycle$State) -> m
    void sync() -> n
androidx.lifecycle.LifecycleRegistry$ObserverWithState -> androidx.lifecycle.h$a:
    androidx.lifecycle.Lifecycle$State mState -> a
    androidx.lifecycle.LifecycleEventObserver mLifecycleObserver -> b
    void dispatchEvent(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> a
androidx.lifecycle.Lifecycling -> androidx.lifecycle.i:
    java.util.Map sCallbackCache -> a
    java.util.Map sClassToAdapters -> b
    androidx.lifecycle.GeneratedAdapter createGeneratedAdapter(java.lang.reflect.Constructor,java.lang.Object) -> a
    java.lang.reflect.Constructor generatedConstructor(java.lang.Class) -> b
    java.lang.String getAdapterName(java.lang.String) -> c
    int getObserverConstructorType(java.lang.Class) -> d
    boolean isLifecycleParent(java.lang.Class) -> e
    androidx.lifecycle.LifecycleEventObserver lifecycleEventObserver(java.lang.Object) -> f
    int resolveObserverCallbackType(java.lang.Class) -> g
androidx.lifecycle.Lifecycling$1 -> androidx.lifecycle.Lifecycling$1:
    androidx.lifecycle.LifecycleEventObserver val$observer -> a
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.lifecycle.LiveData$LifecycleBoundObserver -> androidx.lifecycle.LiveData$LifecycleBoundObserver:
    androidx.lifecycle.LifecycleOwner mOwner -> b
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
    boolean shouldBeActive() -> i
androidx.lifecycle.LiveData$ObserverWrapper -> androidx.lifecycle.j:
    boolean mActive -> a
    void activeStateChanged(boolean) -> h
androidx.lifecycle.MethodCallsLogger -> androidx.lifecycle.k:
    java.util.Map mCalledMethods -> a
androidx.lifecycle.OnLifecycleEvent -> androidx.lifecycle.l:
androidx.lifecycle.ReflectiveGenericLifecycleObserver -> androidx.lifecycle.ReflectiveGenericLifecycleObserver:
    androidx.lifecycle.ClassesInfoCache$CallbackInfo mInfo -> b
    java.lang.Object mWrapped -> a
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.lifecycle.SingleGeneratedAdapterObserver -> androidx.lifecycle.SingleGeneratedAdapterObserver:
    androidx.lifecycle.GeneratedAdapter mGeneratedAdapter -> a
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.savedstate.Recreator -> androidx.savedstate.Recreator:
    androidx.savedstate.SavedStateRegistryOwner mOwner -> a
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.savedstate.SavedStateRegistry -> androidx.savedstate.a:
androidx.savedstate.SavedStateRegistry$1 -> androidx.savedstate.SavedStateRegistry$1:
    void onStateChanged(androidx.lifecycle.LifecycleOwner,androidx.lifecycle.Lifecycle$Event) -> d
androidx.savedstate.SavedStateRegistryOwner -> androidx.savedstate.b:
    androidx.savedstate.SavedStateRegistry getSavedStateRegistry() -> j
androidx.tracing.Trace -> h.a:
    java.lang.reflect.Method sAsyncTraceEndMethod -> c
    long sTraceTagApp -> a
    java.lang.reflect.Method sAsyncTraceBeginMethod -> b
    void beginAsyncSection(java.lang.String,int) -> a
    void beginAsyncSectionFallback(java.lang.String,int) -> b
    void beginSection(java.lang.String) -> c
    void endAsyncSection(java.lang.String,int) -> d
    void endAsyncSectionFallback(java.lang.String,int) -> e
    void endSection() -> f
    void handleException(java.lang.String,java.lang.Exception) -> g
androidx.tracing.TraceApi18Impl -> h.b:
    void beginSection(java.lang.String) -> a
    void endSection() -> b
androidx.tracing.TraceApi29Impl -> h.c:
    void beginAsyncSection(java.lang.String,int) -> a
    void endAsyncSection(java.lang.String,int) -> b
androidx.versionedparcelable.ParcelImpl -> androidx.versionedparcelable.ParcelImpl:
    androidx.versionedparcelable.VersionedParcelable mParcel -> Q2
androidx.versionedparcelable.ParcelImpl$1 -> androidx.versionedparcelable.ParcelImpl$a:
    androidx.versionedparcelable.ParcelImpl createFromParcel(android.os.Parcel) -> a
    androidx.versionedparcelable.ParcelImpl[] newArray(int) -> b
androidx.versionedparcelable.VersionedParcel -> androidx.versionedparcelable.a:
    androidx.collection.ArrayMap mParcelizerCache -> c
    androidx.collection.ArrayMap mReadCache -> a
    androidx.collection.ArrayMap mWriteCache -> b
    void writeByteArray(byte[]) -> A
    void writeByteArray(byte[],int) -> B
    void writeCharSequence(java.lang.CharSequence) -> C
    void writeCharSequence(java.lang.CharSequence,int) -> D
    void writeInt(int) -> E
    void writeInt(int,int) -> F
    void writeParcelable(android.os.Parcelable) -> G
    void writeParcelable(android.os.Parcelable,int) -> H
    void writeString(java.lang.String) -> I
    void writeString(java.lang.String,int) -> J
    void writeToParcel(androidx.versionedparcelable.VersionedParcelable,androidx.versionedparcelable.VersionedParcel) -> K
    void writeVersionedParcelable(androidx.versionedparcelable.VersionedParcelable) -> L
    void writeVersionedParcelable(androidx.versionedparcelable.VersionedParcelable,int) -> M
    void writeVersionedParcelableCreator(androidx.versionedparcelable.VersionedParcelable) -> N
    void closeField() -> a
    androidx.versionedparcelable.VersionedParcel createSubParcel() -> b
    java.lang.Class findParcelClass(java.lang.Class) -> c
    java.lang.reflect.Method getReadMethod(java.lang.String) -> d
    java.lang.reflect.Method getWriteMethod(java.lang.Class) -> e
    boolean isStream() -> f
    boolean readBoolean() -> g
    boolean readBoolean(boolean,int) -> h
    byte[] readByteArray() -> i
    byte[] readByteArray(byte[],int) -> j
    java.lang.CharSequence readCharSequence() -> k
    java.lang.CharSequence readCharSequence(java.lang.CharSequence,int) -> l
    boolean readField(int) -> m
    androidx.versionedparcelable.VersionedParcelable readFromParcel(java.lang.String,androidx.versionedparcelable.VersionedParcel) -> n
    int readInt() -> o
    int readInt(int,int) -> p
    android.os.Parcelable readParcelable() -> q
    android.os.Parcelable readParcelable(android.os.Parcelable,int) -> r
    java.lang.String readString() -> s
    java.lang.String readString(java.lang.String,int) -> t
    androidx.versionedparcelable.VersionedParcelable readVersionedParcelable() -> u
    androidx.versionedparcelable.VersionedParcelable readVersionedParcelable(androidx.versionedparcelable.VersionedParcelable,int) -> v
    void setOutputField(int) -> w
    void setSerializationFlags(boolean,boolean) -> x
    void writeBoolean(boolean) -> y
    void writeBoolean(boolean,int) -> z
androidx.versionedparcelable.VersionedParcelParcel -> androidx.versionedparcelable.b:
    android.util.SparseIntArray mPositionLookup -> d
    java.lang.String mPrefix -> h
    int mNextRead -> j
    android.os.Parcel mParcel -> e
    int mFieldId -> k
    int mCurrentField -> i
    int mOffset -> f
    int mEnd -> g
    void writeByteArray(byte[]) -> A
    void writeCharSequence(java.lang.CharSequence) -> C
    void writeInt(int) -> E
    void writeParcelable(android.os.Parcelable) -> G
    void writeString(java.lang.String) -> I
    void closeField() -> a
    androidx.versionedparcelable.VersionedParcel createSubParcel() -> b
    boolean readBoolean() -> g
    byte[] readByteArray() -> i
    java.lang.CharSequence readCharSequence() -> k
    boolean readField(int) -> m
    int readInt() -> o
    android.os.Parcelable readParcelable() -> q
    java.lang.String readString() -> s
    void setOutputField(int) -> w
    void writeBoolean(boolean) -> y
androidx.versionedparcelable.VersionedParcelable -> i.a:
androidx.window.embedding.ActivityRule$$ExternalSyntheticBackport0 -> androidx.window.embedding.a:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    int androidx.window.embedding.ActivityRule$$InternalSyntheticBackport$0$57015352647c9b5f6e99273f8e318b867bf89959750c028d100e7119a4ad43c9$0.m(boolean) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.embedding.EmbeddingAdapter -> androidx.window.embedding.EmbeddingAdapter:
    boolean $r8$lambda$-QlFe7fckaSVTLCegr9_8uxVaa4(java.util.Set,android.app.Activity) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    boolean $r8$lambda$nSea4sfI4EFFkXqov0va87aZ_68(androidx.window.embedding.SplitRule,android.view.WindowMetrics) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    boolean $r8$lambda$x8eGFLpnqP7STokqkg3obw9dl5Q(androidx.window.embedding.EmbeddingAdapter,java.util.Set,android.util.Pair) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    boolean $r8$lambda$xf-Lop7h3ngH6EmzyuDyOYtb8Lk(androidx.window.embedding.EmbeddingAdapter,java.util.Set,android.util.Pair) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    boolean $r8$lambda$yScxR8XDNmwEhhX_T4Oe1hesc-c(java.util.Set,android.content.Intent) -> e
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.embedding.EmbeddingAdapter$$ExternalSyntheticLambda0 -> androidx.window.embedding.b:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    java.util.Set androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$03ecc9c59d87b1a1b86b93b877542e64ef969e188e9be59a383400f0e7ff390a$0.f$1 -> b
    androidx.window.embedding.EmbeddingAdapter androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$03ecc9c59d87b1a1b86b93b877542e64ef969e188e9be59a383400f0e7ff390a$0.f$0 -> a
    void androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$03ecc9c59d87b1a1b86b93b877542e64ef969e188e9be59a383400f0e7ff390a$0.<init>(androidx.window.embedding.EmbeddingAdapter,java.util.Set) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    boolean androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$03ecc9c59d87b1a1b86b93b877542e64ef969e188e9be59a383400f0e7ff390a$0.test(java.lang.Object) -> test
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.embedding.EmbeddingAdapter$$ExternalSyntheticLambda1 -> androidx.window.embedding.c:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    java.util.Set androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$fd1a730e5b7264b9028d9f971be13fef260300e492ca4da6ebf6b772237369a1$0.f$1 -> b
    androidx.window.embedding.EmbeddingAdapter androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$fd1a730e5b7264b9028d9f971be13fef260300e492ca4da6ebf6b772237369a1$0.f$0 -> a
    void androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$fd1a730e5b7264b9028d9f971be13fef260300e492ca4da6ebf6b772237369a1$0.<init>(androidx.window.embedding.EmbeddingAdapter,java.util.Set) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    boolean androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$fd1a730e5b7264b9028d9f971be13fef260300e492ca4da6ebf6b772237369a1$0.test(java.lang.Object) -> test
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.embedding.EmbeddingAdapter$$ExternalSyntheticLambda2 -> androidx.window.embedding.d:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    androidx.window.embedding.SplitRule androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$459153b90e92800dc33b4811d6dc980d22e6c3867fabae96872edb1765f46160$0.f$0 -> a
    void androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$459153b90e92800dc33b4811d6dc980d22e6c3867fabae96872edb1765f46160$0.<init>(androidx.window.embedding.SplitRule) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    boolean androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$459153b90e92800dc33b4811d6dc980d22e6c3867fabae96872edb1765f46160$0.test(java.lang.Object) -> test
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.embedding.EmbeddingAdapter$$ExternalSyntheticLambda3 -> androidx.window.embedding.e:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    java.util.Set androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$0c62e02bfd53c2d1118e7e3eb4e1f91c946b3a111882fec8f4568b4dcc3d4eaa$0.f$0 -> a
    void androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$0c62e02bfd53c2d1118e7e3eb4e1f91c946b3a111882fec8f4568b4dcc3d4eaa$0.<init>(java.util.Set) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    boolean androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$0c62e02bfd53c2d1118e7e3eb4e1f91c946b3a111882fec8f4568b4dcc3d4eaa$0.test(java.lang.Object) -> test
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.embedding.EmbeddingAdapter$$ExternalSyntheticLambda4 -> androidx.window.embedding.f:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    java.util.Set androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$9a38556e09076f6a9578448f49f35f6271758f5fb0b7411a6545c09b0fbf4f6e$0.f$0 -> a
    void androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$9a38556e09076f6a9578448f49f35f6271758f5fb0b7411a6545c09b0fbf4f6e$0.<init>(java.util.Set) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    boolean androidx.window.embedding.EmbeddingAdapter$$InternalSyntheticLambda$0$9a38556e09076f6a9578448f49f35f6271758f5fb0b7411a6545c09b0fbf4f6e$0.test(java.lang.Object) -> test
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.embedding.ExtensionEmbeddingBackend$SplitListenerWrapper -> androidx.window.embedding.ExtensionEmbeddingBackend$SplitListenerWrapper:
    void $r8$lambda$R0583vPiK5P4651WzcCfIdW6hLQ(androidx.window.embedding.ExtensionEmbeddingBackend$SplitListenerWrapper,java.util.List) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.embedding.ExtensionEmbeddingBackend$SplitListenerWrapper$$ExternalSyntheticLambda0 -> androidx.window.embedding.g:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    androidx.window.embedding.ExtensionEmbeddingBackend$SplitListenerWrapper androidx.window.embedding.ExtensionEmbeddingBackend$SplitListenerWrapper$$InternalSyntheticLambda$0$185c1ab82e66811f01c2caa4cdb93f72db854ddebb21d8ef1c846664ffbdef52$0.f$0 -> Q2
    java.util.List androidx.window.embedding.ExtensionEmbeddingBackend$SplitListenerWrapper$$InternalSyntheticLambda$0$185c1ab82e66811f01c2caa4cdb93f72db854ddebb21d8ef1c846664ffbdef52$0.f$1 -> R2
    void androidx.window.embedding.ExtensionEmbeddingBackend$SplitListenerWrapper$$InternalSyntheticLambda$0$185c1ab82e66811f01c2caa4cdb93f72db854ddebb21d8ef1c846664ffbdef52$0.<init>(androidx.window.embedding.ExtensionEmbeddingBackend$SplitListenerWrapper,java.util.List) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void androidx.window.embedding.ExtensionEmbeddingBackend$SplitListenerWrapper$$InternalSyntheticLambda$0$185c1ab82e66811f01c2caa4cdb93f72db854ddebb21d8ef1c846664ffbdef52$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.layout.SidecarWindowBackend$WindowLayoutChangeCallbackWrapper -> androidx.window.layout.SidecarWindowBackend$WindowLayoutChangeCallbackWrapper:
    void $r8$lambda$jkQHaIq6yFprTVBW9h6wk0oO_6g(androidx.window.layout.SidecarWindowBackend$WindowLayoutChangeCallbackWrapper,androidx.window.layout.WindowLayoutInfo) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.layout.SidecarWindowBackend$WindowLayoutChangeCallbackWrapper$$ExternalSyntheticLambda0 -> androidx.window.layout.a:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    androidx.window.layout.WindowLayoutInfo androidx.window.layout.SidecarWindowBackend$WindowLayoutChangeCallbackWrapper$$InternalSyntheticLambda$0$5b297a89a87dc75c426200de0eed5984b5587cef241f854e8c1c129f35b724d6$0.f$1 -> R2
    androidx.window.layout.SidecarWindowBackend$WindowLayoutChangeCallbackWrapper androidx.window.layout.SidecarWindowBackend$WindowLayoutChangeCallbackWrapper$$InternalSyntheticLambda$0$5b297a89a87dc75c426200de0eed5984b5587cef241f854e8c1c129f35b724d6$0.f$0 -> Q2
    void androidx.window.layout.SidecarWindowBackend$WindowLayoutChangeCallbackWrapper$$InternalSyntheticLambda$0$5b297a89a87dc75c426200de0eed5984b5587cef241f854e8c1c129f35b724d6$0.<init>(androidx.window.layout.SidecarWindowBackend$WindowLayoutChangeCallbackWrapper,androidx.window.layout.WindowLayoutInfo) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void androidx.window.layout.SidecarWindowBackend$WindowLayoutChangeCallbackWrapper$$InternalSyntheticLambda$0$5b297a89a87dc75c426200de0eed5984b5587cef241f854e8c1c129f35b724d6$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.layout.WindowInfoTracker$-CC -> androidx.window.layout.b:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    androidx.window.layout.WindowInfoTracker getOrCreate(android.content.Context) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    void overrideDecorator(androidx.window.layout.WindowInfoTrackerDecorator) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void reset() -> c
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1 -> androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1:
    void $r8$lambda$LgDWJbk4b494d79uZZm3iJ0WM6A(kotlinx.coroutines.channels.Channel,androidx.window.layout.WindowLayoutInfo) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1$$ExternalSyntheticLambda0 -> androidx.window.layout.c:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    kotlinx.coroutines.channels.Channel androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1$$InternalSyntheticLambda$0$5eed977099402dd0630f468cdc7dbc00c97a3870a6a03630bb84a9e1c0afeca0$0.f$0 -> a
    void androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1$$InternalSyntheticLambda$0$5eed977099402dd0630f468cdc7dbc00c97a3870a6a03630bb84a9e1c0afeca0$0.<init>(kotlinx.coroutines.channels.Channel) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1$$InternalSyntheticLambda$0$5eed977099402dd0630f468cdc7dbc00c97a3870a6a03630bb84a9e1c0afeca0$0.accept(java.lang.Object) -> accept
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1$$ExternalSyntheticLambda1 -> androidx.window.layout.d:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1$$InternalSyntheticLambda$0$5eed977099402dd0630f468cdc7dbc00c97a3870a6a03630bb84a9e1c0afeca0$1 androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1$$InternalSyntheticLambda$0$5eed977099402dd0630f468cdc7dbc00c97a3870a6a03630bb84a9e1c0afeca0$1.INSTANCE -> Q2
    void androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1$$InternalSyntheticLambda$0$5eed977099402dd0630f468cdc7dbc00c97a3870a6a03630bb84a9e1c0afeca0$1.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1$$InternalSyntheticLambda$0$5eed977099402dd0630f468cdc7dbc00c97a3870a6a03630bb84a9e1c0afeca0$1.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void androidx.window.layout.WindowInfoTrackerImpl$windowLayoutInfo$1$$InternalSyntheticLambda$0$5eed977099402dd0630f468cdc7dbc00c97a3870a6a03630bb84a9e1c0afeca0$1.execute(java.lang.Runnable) -> execute
      # {"id":"com.android.tools.r8.synthesized"}
androidx.window.layout.WindowMetricsCalculator$-CC -> androidx.window.layout.e:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    void <clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    androidx.window.layout.WindowMetricsCalculator getOrCreate() -> a
      # {"id":"com.android.tools.r8.synthesized"}
    void overrideDecorator(androidx.window.layout.WindowMetricsCalculatorDecorator) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void reset() -> c
      # {"id":"com.android.tools.r8.synthesized"}
b1.DestinationResolverCopyFilter$$ExternalSyntheticLambda0 -> b1.b:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.PdfObject com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$0.f$2 -> c
    com.itextpdf.kernel.pdf.DestinationResolverCopyFilter com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$0.f$0 -> a
    com.itextpdf.kernel.pdf.PdfDictionary com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$0.f$1 -> b
    com.itextpdf.kernel.pdf.PdfName com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$0.f$3 -> d
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$0.<init>(com.itextpdf.kernel.pdf.DestinationResolverCopyFilter,com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$0.accept(java.lang.Object) -> accept
      # {"id":"com.android.tools.r8.synthesized"}
b1.DestinationResolverCopyFilter$$ExternalSyntheticLambda1 -> b1.c:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.PdfObject com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$2.f$1 -> b
    com.itextpdf.kernel.pdf.PdfObject com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$2.f$2 -> c
    com.itextpdf.kernel.pdf.DestinationResolverCopyFilter com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$2.f$0 -> a
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$2.<init>(com.itextpdf.kernel.pdf.DestinationResolverCopyFilter,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfObject) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$2.accept(java.lang.Object) -> accept
      # {"id":"com.android.tools.r8.synthesized"}
b1.DestinationResolverCopyFilter$$ExternalSyntheticLambda2 -> b1.d:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.PdfObject com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$0.f$1 -> b
    com.itextpdf.kernel.pdf.PdfObject com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$0.f$2 -> c
    com.itextpdf.kernel.pdf.DestinationResolverCopyFilter com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$0.f$0 -> a
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$0.<init>(com.itextpdf.kernel.pdf.DestinationResolverCopyFilter,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfObject) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$0.accept(java.lang.Object) -> accept
      # {"id":"com.android.tools.r8.synthesized"}
b1.DestinationResolverCopyFilter$$ExternalSyntheticLambda3 -> b1.e:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$1 com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$1.INSTANCE -> a
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$1.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$1.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$1.accept(java.lang.Object) -> accept
      # {"id":"com.android.tools.r8.synthesized"}
b1.DestinationResolverCopyFilter$$ExternalSyntheticLambda4 -> b1.f:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$3 com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$3.INSTANCE -> a
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$3.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$3.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$f7f2b9c8e36efbed0282183e1fa21294057a37a86a6162c3e61f8cd9abd9786b$3.accept(java.lang.Object) -> accept
      # {"id":"com.android.tools.r8.synthesized"}
b1.DestinationResolverCopyFilter$$ExternalSyntheticLambda5 -> b1.g:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$1 com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$1.INSTANCE -> a
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$1.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$1.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.DestinationResolverCopyFilter$$InternalSyntheticLambda$1$1bf2cd00bf15ce25e14e40c0f4ddbce977134f8dfe2456855e52708adf532f8f$1.accept(java.lang.Object) -> accept
      # {"id":"com.android.tools.r8.synthesized"}
c4.CancellableContinuationImpl$$ExternalSyntheticBackportWithForwarding0 -> c4.l:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    boolean kotlinx.coroutines.CancellableContinuationImpl$$InternalSyntheticBackportWithForwarding$0$14938e86c53bbc417d960c3db093d9c528eee461fa47b6759be891f884702045$0.m(java.util.concurrent.atomic.AtomicReferenceFieldUpdater,java.lang.Object,java.lang.Object,java.lang.Object) -> a
      # {"id":"com.android.tools.r8.synthesized"}
c4.CommonPool$$ExternalSyntheticLambda0 -> c4.u:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    kotlinx.coroutines.CommonPool$$InternalSyntheticLambda$0$33cf08de088b18c91e02307959e276d3c395f29befe056cf9ab47fdb40d4a2cc$0 kotlinx.coroutines.CommonPool$$InternalSyntheticLambda$0$33cf08de088b18c91e02307959e276d3c395f29befe056cf9ab47fdb40d4a2cc$0.INSTANCE -> Q2
    void kotlinx.coroutines.CommonPool$$InternalSyntheticLambda$0$33cf08de088b18c91e02307959e276d3c395f29befe056cf9ab47fdb40d4a2cc$0.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void kotlinx.coroutines.CommonPool$$InternalSyntheticLambda$0$33cf08de088b18c91e02307959e276d3c395f29befe056cf9ab47fdb40d4a2cc$0.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void kotlinx.coroutines.CommonPool$$InternalSyntheticLambda$0$33cf08de088b18c91e02307959e276d3c395f29befe056cf9ab47fdb40d4a2cc$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
c4.CommonPool$$ExternalSyntheticLambda1 -> c4.v:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    java.util.concurrent.atomic.AtomicInteger kotlinx.coroutines.CommonPool$$InternalSyntheticLambda$0$2e22430f2290953c9fd4d47c143f9cb01b3dc22cd584198a8f560f31bd94ffbd$0.f$0 -> a
    void kotlinx.coroutines.CommonPool$$InternalSyntheticLambda$0$2e22430f2290953c9fd4d47c143f9cb01b3dc22cd584198a8f560f31bd94ffbd$0.<init>(java.util.concurrent.atomic.AtomicInteger) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Thread kotlinx.coroutines.CommonPool$$InternalSyntheticLambda$0$2e22430f2290953c9fd4d47c143f9cb01b3dc22cd584198a8f560f31bd94ffbd$0.newThread(java.lang.Runnable) -> newThread
      # {"id":"com.android.tools.r8.synthesized"}
com.baseflow.permissionhandler.AppSettingsManager -> j.a:
    void openAppSettings(android.content.Context,com.baseflow.permissionhandler.AppSettingsManager$OpenAppSettingsSuccessCallback,com.baseflow.permissionhandler.ErrorCallback) -> a
com.baseflow.permissionhandler.AppSettingsManager$OpenAppSettingsSuccessCallback -> j.a$a:
    void onSuccess(boolean) -> a
com.baseflow.permissionhandler.ErrorCallback -> j.b:
    void onError(java.lang.String,java.lang.String) -> a
com.baseflow.permissionhandler.MethodCallHandlerImpl -> j.l:
    android.content.Context applicationContext -> a
    android.app.Activity activity -> e
    com.baseflow.permissionhandler.AppSettingsManager appSettingsManager -> b
    com.baseflow.permissionhandler.PermissionManager permissionManager -> c
    com.baseflow.permissionhandler.ServiceManager serviceManager -> d
    void $r8$lambda$AaygE11VixcKoKxi2oierHUCg_U(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$lk5T7z9CZr_kRsdWPJdSt_kHRsU(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$q7Tl8y0r1dZ06shK3VJv08xkMY8(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
    void $r8$lambda$z-5Y05bp5oQnzz_VynnxR9WkAQM(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String) -> e
      # {"id":"com.android.tools.r8.synthesized"}
    void lambda$onMethodCall$0(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String) -> f
    void lambda$onMethodCall$1(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String) -> g
    void lambda$onMethodCall$2(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String) -> h
    void lambda$onMethodCall$3(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String) -> i
    void setActivity(android.app.Activity) -> j
com.baseflow.permissionhandler.PermissionHandlerPlugin -> j.m:
    io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding pluginBinding -> d
    com.baseflow.permissionhandler.PermissionManager permissionManager -> a
    io.flutter.plugin.common.PluginRegistry$Registrar pluginRegistrar -> c
    com.baseflow.permissionhandler.MethodCallHandlerImpl methodCallHandler -> e
    io.flutter.plugin.common.MethodChannel methodChannel -> b
    void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> a
    void onReattachedToActivityForConfigChanges(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> b
    void onDetachedFromActivity() -> c
    void deregisterListeners() -> d
    void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> e
    void onAttachedToActivity(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> f
    void onDetachedFromActivityForConfigChanges() -> g
    void registerListeners() -> h
    void startListening(android.content.Context,io.flutter.plugin.common.BinaryMessenger) -> i
    void startListeningToActivity(android.app.Activity) -> j
    void stopListening() -> k
    void stopListeningToActivity() -> l
com.baseflow.permissionhandler.PermissionManager -> j.n:
    java.util.Map requestResults -> c
    com.baseflow.permissionhandler.PermissionManager$RequestPermissionsSuccessCallback successCallback -> a
    android.app.Activity activity -> b
    boolean ongoing -> d
    boolean onRequestPermissionsResult(int,java.lang.String[],int[]) -> a
    boolean onActivityResult(int,int,android.content.Intent) -> b
    int checkBluetoothPermissionStatus(android.content.Context) -> c
    int checkNotificationPermissionStatus(android.content.Context) -> d
    void checkPermissionStatus(int,android.content.Context,com.baseflow.permissionhandler.PermissionManager$CheckPermissionsSuccessCallback) -> e
    int determinePermissionStatus(int,android.content.Context) -> f
    void executeIntent(java.lang.String,int) -> g
    void executeSimpleIntent(java.lang.String,int) -> h
    void requestPermissions(java.util.List,android.app.Activity,com.baseflow.permissionhandler.PermissionManager$RequestPermissionsSuccessCallback,com.baseflow.permissionhandler.ErrorCallback) -> i
    void shouldShowRequestPermissionRationale(int,android.app.Activity,com.baseflow.permissionhandler.PermissionManager$ShouldShowRequestPermissionRationaleSuccessCallback,com.baseflow.permissionhandler.ErrorCallback) -> j
com.baseflow.permissionhandler.PermissionManager$CheckPermissionsSuccessCallback -> j.n$a:
    void onSuccess(int) -> a
com.baseflow.permissionhandler.PermissionManager$RequestPermissionsSuccessCallback -> j.n$b:
    void onSuccess(java.util.Map) -> a
com.baseflow.permissionhandler.PermissionManager$ShouldShowRequestPermissionRationaleSuccessCallback -> j.n$c:
    void onSuccess(boolean) -> a
com.baseflow.permissionhandler.PermissionUtils -> j.o:
    java.lang.String determineBluetoothPermission(android.content.Context,java.lang.String) -> a
    java.util.List getManifestNames(android.content.Context,int) -> b
    android.content.pm.PackageInfo getPackageInfo(android.content.Context) -> c
    boolean hasPermissionInManifest(android.content.Context,java.util.ArrayList,java.lang.String) -> d
    boolean isNeverAskAgainSelected(android.app.Activity,java.lang.String) -> e
    int parseManifestName(java.lang.String) -> f
    int toPermissionStatus(android.app.Activity,java.lang.String,int) -> g
    void updatePermissionShouldShowStatus(android.app.Activity,int) -> h
com.baseflow.permissionhandler.ServiceManager -> j.p:
    void checkServiceStatus(int,android.content.Context,com.baseflow.permissionhandler.ServiceManager$SuccessCallback,com.baseflow.permissionhandler.ErrorCallback) -> a
    java.util.List getCallAppsList(android.content.pm.PackageManager) -> b
    boolean isBluetoothServiceEnabled(android.content.Context) -> c
    boolean isLocationServiceEnabled(android.content.Context) -> d
    boolean isLocationServiceEnabledKitKat(android.content.Context) -> e
com.baseflow.permissionhandler.ServiceManager$SuccessCallback -> j.p$a:
    void onSuccess(int) -> a
com.deepanshuchaudhary.pdf_manipulator.ImageToPdfKt -> k.a:
    java.lang.Object getPdfsFromImages(java.util.List,boolean,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.ImageToPdfKt$getPdfsFromImages$1 -> k.a$a:
    int label -> U2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object L$2 -> S2
    java.lang.Object result -> T2
com.deepanshuchaudhary.pdf_manipulator.ImageToPdfKt$getPdfsFromImages$2 -> k.a$b:
    java.util.List $imagesTempFiles -> b3
    java.util.List $result -> d3
    boolean $createSinglePdf -> c3
    long J$0 -> Q2
    android.app.Activity $context -> Y2
    java.util.List $sourceImagesPaths -> Z2
    com.deepanshuchaudhary.pdf_manipulator.Utils $utils -> a3
    int I$0 -> V2
    int I$1 -> W2
    int label -> X2
    java.lang.Object L$0 -> R2
    java.lang.Object L$3 -> U2
    java.lang.Object L$1 -> S2
    java.lang.Object L$2 -> T2
com.deepanshuchaudhary.pdf_manipulator.PageRotationInfo -> k.b:
    int rotationAngle -> b
    int pageNumber -> a
    int getPageNumber() -> a
    int getRotationAngle() -> b
com.deepanshuchaudhary.pdf_manipulator.PdfCompressorKt -> k.c:
    java.lang.Object getCompressedPDFPath(java.lang.String,int,double,boolean,android.app.Activity,kotlin.coroutines.Continuation) -> a
    void resetImageStream(com.itextpdf.kernel.pdf.PdfStream,byte[],int,int) -> b
    void unEmbedTTF(com.itextpdf.kernel.pdf.PdfDictionary) -> c
com.deepanshuchaudhary.pdf_manipulator.PdfCompressorKt$getCompressedPDFPath$1 -> k.c$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfCompressorKt$getCompressedPDFPath$2 -> k.c$b:
    boolean $unEmbedFonts -> c3
    double $imageScale -> a3
    kotlin.jvm.internal.Ref$ObjectRef $resultPDFPath -> d3
    android.app.Activity $context -> Y2
    java.lang.String $sourceFilePath -> Z2
    long J$0 -> W2
    int label -> X2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object L$4 -> U2
    java.lang.Object L$5 -> V2
    int $imageQuality -> b3
    java.lang.Object L$2 -> S2
    java.lang.Object L$3 -> T2
    java.lang.Object access$invokeSuspend$reduceImagesSize(com.itextpdf.kernel.pdf.PdfDocument,double,int,kotlin.coroutines.Continuation) -> a
    java.lang.Object access$invokeSuspend$removeFont(com.itextpdf.kernel.pdf.PdfDocument,kotlin.coroutines.Continuation) -> b
    java.lang.Object invokeSuspend$reduceImagesSize(com.itextpdf.kernel.pdf.PdfDocument,double,int,kotlin.coroutines.Continuation) -> c
    java.lang.Object invokeSuspend$removeFont(com.itextpdf.kernel.pdf.PdfDocument,kotlin.coroutines.Continuation) -> d
com.deepanshuchaudhary.pdf_manipulator.PdfCompressorKt$getCompressedPDFPath$2$reduceImagesSize$1 -> k.c$b$a:
    int label -> V2
    int I$0 -> Q2
    java.lang.Object result -> U2
    float F$0 -> R2
    java.lang.Object L$0 -> S2
    java.lang.Object L$1 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfCompressorKt$getCompressedPDFPath$2$removeFont$1 -> k.c$b$b:
    int label -> U2
    int I$1 -> S2
    java.lang.Object L$0 -> Q2
    int I$0 -> R2
    java.lang.Object result -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfDecrypterKt -> k.d:
    java.lang.Object getPdfDecrypted(java.lang.String,java.lang.String,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.PdfDecrypterKt$getPdfDecrypted$1 -> k.d$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfDecrypterKt$getPdfDecrypted$2 -> k.d$b:
    java.lang.String $userOrOwnerPassword -> T2
    java.lang.String $sourceFilePath -> S2
    kotlin.jvm.internal.Ref$ObjectRef $result -> U2
    int label -> Q2
    android.app.Activity $context -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfEncrypterKt -> k.e:
    java.lang.Object getPdfEncrypted(java.lang.String,java.lang.String,java.lang.String,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.PdfEncrypterKt$getPdfEncrypted$1 -> k.e$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfEncrypterKt$getPdfEncrypted$2 -> k.e$b:
    boolean $standardEncryptionAES128 -> c3
    boolean $encryptionAES128 -> d3
    java.lang.String $ownerPassword -> h3
    boolean $encryptEmbeddedFilesOnly -> e3
    java.lang.String $userPassword -> g3
    boolean $doNotEncryptMetadata -> f3
    boolean $allowDegradedPrinting -> a3
    boolean $standardEncryptionAES40 -> b3
    int label -> Q2
    boolean $allowAssembly -> Z2
    boolean $allowCopy -> V2
    boolean $allowModifyAnnotations -> W2
    boolean $allowFillIn -> X2
    boolean $allowScreenReaders -> Y2
    boolean $allowPrinting -> T2
    boolean $allowModifyContents -> U2
    kotlin.jvm.internal.Ref$ObjectRef $result -> i3
    java.lang.String $sourceFilePath -> S2
    android.app.Activity $context -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator -> k.f:
    com.deepanshuchaudhary.pdf_manipulator.Utils utils -> c
    kotlinx.coroutines.Job job -> b
    android.app.Activity activity -> a
    android.app.Activity access$getActivity$p(com.deepanshuchaudhary.pdf_manipulator.PdfManipulator) -> a
    com.deepanshuchaudhary.pdf_manipulator.Utils access$getUtils$p(com.deepanshuchaudhary.pdf_manipulator.PdfManipulator) -> b
    void cancelManipulations() -> c
    void imagesToPdfs(io.flutter.plugin.common.MethodChannel$Result,java.util.List,java.lang.Boolean) -> d
    void mergePdfs(io.flutter.plugin.common.MethodChannel$Result,java.util.List) -> e
    void pdfCompressor(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.Integer,java.lang.Double,java.lang.Boolean) -> f
    void pdfDecryption(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String) -> g
    void pdfEncryption(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String,java.lang.String,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean) -> h
    void pdfPageDeleter(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.util.List) -> i
    void pdfPageReorder(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.util.List) -> j
    void pdfPageRotator(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.util.List) -> k
    void pdfPageRotatorDeleterReorder(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.util.List,java.util.List,java.util.List) -> l
    void pdfPagesSize(io.flutter.plugin.common.MethodChannel$Result,java.lang.String) -> m
    void pdfValidityAndProtection(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String) -> n
    void splitPdf(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,int,java.lang.Number,java.util.List,java.util.List,java.lang.String) -> o
    void watermarkPdf(io.flutter.plugin.common.MethodChannel$Result,java.lang.String,java.lang.String,java.lang.Double,com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer,java.lang.Double,java.lang.Double,java.lang.String,com.deepanshuchaudhary.pdf_manipulator.PositionType,java.util.List,java.util.List) -> p
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$imagesToPdfs$1 -> k.f$a:
    java.util.List $sourceImagesPaths -> R2
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> U2
    java.lang.Boolean $createSinglePdf -> S2
    int label -> Q2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$mergePdfs$1 -> k.f$b:
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> T2
    java.util.List $sourceFilesPaths -> R2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> S2
    int label -> Q2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$pdfCompressor$1 -> k.f$c:
    java.lang.Integer $imageQuality -> S2
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> W2
    java.lang.Double $imageScale -> T2
    java.lang.Boolean $unEmbedFonts -> U2
    java.lang.String $sourceFilePath -> R2
    int label -> Q2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> V2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$pdfDecryption$1 -> k.f$d:
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> U2
    java.lang.String $userOrOwnerPassword -> S2
    java.lang.String $sourceFilePath -> R2
    int label -> Q2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$pdfEncryption$1 -> k.f$e:
    boolean $doNotEncryptMetadata -> g3
    boolean $standardEncryptionAES40 -> c3
    boolean $standardEncryptionAES128 -> d3
    boolean $encryptionAES128 -> e3
    boolean $encryptEmbeddedFilesOnly -> f3
    boolean $allowAssembly -> a3
    boolean $allowDegradedPrinting -> b3
    int label -> Q2
    boolean $allowScreenReaders -> Z2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> h3
    boolean $allowModifyContents -> V2
    boolean $allowCopy -> W2
    boolean $allowModifyAnnotations -> X2
    boolean $allowFillIn -> Y2
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> i3
    boolean $allowPrinting -> U2
    java.lang.String $userPassword -> T2
    java.lang.String $ownerPassword -> S2
    java.lang.String $sourceFilePath -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$pdfPageDeleter$1 -> k.f$f:
    java.util.List $pageNumbers -> S2
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> U2
    java.lang.String $sourceFilePath -> R2
    int label -> Q2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$pdfPageReorder$1 -> k.f$g:
    java.util.List $pageNumbers -> S2
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> U2
    java.lang.String $sourceFilePath -> R2
    int label -> Q2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$pdfPageRotator$1 -> k.f$h:
    java.util.List $pagesRotationInfo -> R2
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> U2
    java.lang.String $sourceFilePath -> S2
    int label -> Q2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$pdfPageRotatorDeleterReorder$1 -> k.f$i:
    java.util.List $pagesRotationInfo -> R2
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> W2
    java.lang.String $sourceFilePath -> S2
    int label -> Q2
    java.util.List $pageNumbersForDeleter -> U2
    java.util.List $pageNumbersForReorder -> T2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> V2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$pdfPagesSize$1 -> k.f$j:
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> T2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> S2
    java.lang.String $sourceFilePath -> R2
    int label -> Q2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$pdfValidityAndProtection$1 -> k.f$k:
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> U2
    java.lang.String $userOrOwnerPassword -> S2
    java.lang.String $sourceFilePath -> R2
    int label -> Q2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$splitPdf$1 -> k.f$l:
    java.lang.String $pageRange -> W2
    int $pageCount -> X2
    java.lang.String $sourceFilePath -> S2
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> Y2
    int label -> Q2
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> T2
    java.util.List $pageNumbers -> U2
    java.lang.Number $byteSize -> R2
    java.util.List $pageRanges -> V2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulator$watermarkPdf$1 -> k.f$m:
    java.util.List $customPositionYCoordinatesList -> a3
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator this$0 -> b3
    java.lang.Double $fontSize -> T2
    java.lang.Double $opacity -> V2
    java.lang.Double $rotationAngle -> W2
    java.util.List $customPositionXCoordinatesList -> Z2
    int label -> Q2
    com.deepanshuchaudhary.pdf_manipulator.PositionType $positionType -> Y2
    io.flutter.plugin.common.MethodChannel$Result $resultCallback -> c3
    java.lang.String $watermarkColor -> X2
    com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer $watermarkLayer -> U2
    java.lang.String $text -> S2
    java.lang.String $sourceFilePath -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfManipulatorPlugin -> k.g:
    io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding activityBinding -> d
    io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding pluginBinding -> c
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulator pdfManipulator -> b
    io.flutter.plugin.common.MethodChannel channel -> a
    com.deepanshuchaudhary.pdf_manipulator.PdfManipulatorPlugin$Companion Companion -> e
    void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> a
    void onReattachedToActivityForConfigChanges(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> b
    void onDetachedFromActivity() -> c
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
    void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> e
    void onAttachedToActivity(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> f
    void onDetachedFromActivityForConfigChanges() -> g
    boolean createPickOrSave() -> h
    void doOnAttachedToActivity(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> i
    void doOnAttachedToEngine(io.flutter.plugin.common.BinaryMessenger) -> j
    void doOnDetachedFromActivity() -> k
    void doOnDetachedFromEngine() -> l
    java.util.List parseMethodCallArrayOfDoubleArgument(io.flutter.plugin.common.MethodCall,java.lang.String) -> m
    java.util.List parseMethodCallArrayOfIntArgument(io.flutter.plugin.common.MethodCall,java.lang.String) -> n
    java.util.List parseMethodCallArrayOfMapArgument(io.flutter.plugin.common.MethodCall,java.lang.String) -> o
    java.util.List parseMethodCallArrayOfStringArgument(io.flutter.plugin.common.MethodCall,java.lang.String) -> p
    com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer parseMethodCallWatermarkLayerTypeArgument(io.flutter.plugin.common.MethodCall) -> q
    com.deepanshuchaudhary.pdf_manipulator.PositionType parseMethodCallWatermarkPositionTypeArgument(io.flutter.plugin.common.MethodCall) -> r
com.deepanshuchaudhary.pdf_manipulator.PdfManipulatorPlugin$Companion -> k.g$a:
com.deepanshuchaudhary.pdf_manipulator.PdfMergerKt -> k.h:
    java.lang.Object getMergedPDFPath(java.util.List,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.PdfMergerKt$getMergedPDFPath$1 -> k.h$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfMergerKt$getMergedPDFPath$2 -> k.h$b:
    int label -> d3
    android.app.Activity $context -> e3
    java.lang.Object L$8 -> Y2
    java.lang.Object L$9 -> Z2
    java.lang.Object L$6 -> W2
    java.lang.Object L$7 -> X2
    kotlin.jvm.internal.Ref$ObjectRef $mergedPDFPath -> g3
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object L$4 -> U2
    int I$1 -> c3
    java.util.List $sourceFilesPaths -> f3
    java.lang.Object L$5 -> V2
    int I$0 -> b3
    java.lang.Object L$2 -> S2
    long J$0 -> a3
    java.lang.Object L$3 -> T2
    java.lang.Object access$invokeSuspend$checkForPDFTagging(java.util.List,com.deepanshuchaudhary.pdf_manipulator.Utils,android.content.ContentResolver,kotlin.coroutines.Continuation) -> a
    java.lang.Object invokeSuspend$checkForPDFTagging(java.util.List,com.deepanshuchaudhary.pdf_manipulator.Utils,android.content.ContentResolver,kotlin.coroutines.Continuation) -> b
    java.io.File invokeSuspend$tempTaggedPdfCreator() -> c
com.deepanshuchaudhary.pdf_manipulator.PdfMergerKt$getMergedPDFPath$2$checkForPDFTagging$1 -> k.h$b$a:
    int I$0 -> V2
    java.lang.Object result -> X2
    int label -> Y2
    int I$1 -> W2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object L$4 -> U2
    java.lang.Object L$2 -> S2
    java.lang.Object L$3 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfPagesSizeKt -> k.i:
    java.lang.Object getPDFPagesSize(java.lang.String,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.PdfPagesSizeKt$getPDFPagesSize$1 -> k.i$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfPagesSizeKt$getPDFPagesSize$2 -> k.i$b:
    java.lang.String $sourceFilePath -> S2
    int label -> Q2
    android.app.Activity $context -> R2
    java.util.List $result -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt -> k.j:
    java.lang.Object getSplitPDFPathsByByteSize(java.lang.String,long,android.app.Activity,kotlin.coroutines.Continuation) -> a
    java.lang.Object getSplitPDFPathsByPageCount(java.lang.String,int,android.app.Activity,kotlin.coroutines.Continuation) -> b
    java.lang.Object getSplitPDFPathsByPageNumbers(java.lang.String,java.util.List,android.app.Activity,kotlin.coroutines.Continuation) -> c
    java.lang.Object getSplitPDFPathsByPageRange(java.lang.String,java.lang.String,android.app.Activity,kotlin.coroutines.Continuation) -> d
    java.lang.Object getSplitPDFPathsByPageRanges(java.lang.String,java.util.List,android.app.Activity,kotlin.coroutines.Continuation) -> e
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByByteSize$1 -> k.j$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByByteSize$2 -> k.j$b:
    android.app.Activity $context -> a3
    kotlin.jvm.internal.Ref$ObjectRef $splitPDFPaths -> d3
    java.lang.String $sourceFilePath -> b3
    java.lang.Object L$6 -> W2
    int I$0 -> Y2
    int label -> Z2
    long J$0 -> X2
    java.lang.Object L$0 -> Q2
    long $byteSize -> c3
    java.lang.Object L$1 -> R2
    java.lang.Object L$4 -> U2
    java.lang.Object L$5 -> V2
    java.lang.Object L$2 -> S2
    java.lang.Object L$3 -> T2
    java.lang.Object access$invokeSuspend$splitPDF(java.util.List,java.util.List,java.io.File,long,kotlin.coroutines.Continuation) -> a
    java.lang.Object invokeSuspend$splitPDF(java.util.List,java.util.List,java.io.File,long,kotlin.coroutines.Continuation) -> b
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByByteSize$2$splitPDF$1 -> k.j$b$a:
    int label -> V2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    long J$0 -> T2
    java.lang.Object result -> U2
    java.lang.Object L$2 -> S2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByByteSize$2$splitPDF$splitDocuments$1 -> k.j$b$b:
    java.util.List $splitTempFilesList -> f
    int partNumber -> e
    java.util.List $pdfWritersList -> g
    com.itextpdf.kernel.pdf.PdfWriter getNextPdfWriter(com.itextpdf.kernel.utils.PageRange) -> d
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageCount$1 -> k.j$c:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageCount$2 -> k.j$d:
    android.app.Activity $context -> a3
    kotlin.jvm.internal.Ref$ObjectRef $splitPDFPaths -> d3
    java.lang.String $sourceFilePath -> b3
    java.lang.Object L$6 -> W2
    int I$0 -> Y2
    int label -> Z2
    long J$0 -> X2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object L$4 -> U2
    int $pageCount -> c3
    java.lang.Object L$5 -> V2
    java.lang.Object L$2 -> S2
    java.lang.Object L$3 -> T2
    void $r8$lambda$SX0SF-ZYhaHUmQG0TGSGHpY-vMQ(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.PageRange) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object access$invokeSuspend$splitPDF(java.util.List,java.util.List,java.io.File,int,kotlin.coroutines.Continuation) -> b
    java.lang.Object invokeSuspend$splitPDF(java.util.List,java.util.List,java.io.File,int,kotlin.coroutines.Continuation) -> c
    void invokeSuspend$splitPDF$lambda-0(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.PageRange) -> d
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageCount$2$splitPDF$1 -> k.j$d$a:
    int label -> V2
    int I$0 -> T2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object result -> U2
    java.lang.Object L$2 -> S2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageCount$2$splitPDF$2 -> k.j$d$b:
    java.util.List $splitTempFilesList -> f
    int partNumber -> e
    java.util.List $pdfWritersList -> g
    com.itextpdf.kernel.pdf.PdfWriter getNextPdfWriter(com.itextpdf.kernel.utils.PageRange) -> d
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageNumbers$1 -> k.j$e:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageNumbers$2 -> k.j$f:
    android.app.Activity $context -> a3
    java.util.List $pageNumbers -> c3
    kotlin.jvm.internal.Ref$ObjectRef $splitPDFPaths -> d3
    java.lang.String $sourceFilePath -> b3
    java.lang.Object L$6 -> W2
    int I$0 -> Y2
    int label -> Z2
    long J$0 -> X2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object L$4 -> U2
    java.lang.Object L$5 -> V2
    java.lang.Object L$2 -> S2
    java.lang.Object L$3 -> T2
    void $r8$lambda$B23TR86sSYN7RNPAbxVoCkYmQ60(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.PageRange) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object access$invokeSuspend$splitPDF(java.util.List,java.util.List,java.io.File,java.util.List,kotlin.coroutines.Continuation) -> b
    java.lang.Object invokeSuspend$splitPDF(java.util.List,java.util.List,java.io.File,java.util.List,kotlin.coroutines.Continuation) -> c
    void invokeSuspend$splitPDF$lambda-0(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.PageRange) -> d
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageNumbers$2$splitPDF$1 -> k.j$f$a:
    int label -> V2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object result -> U2
    java.lang.Object L$2 -> S2
    java.lang.Object L$3 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageNumbers$2$splitPDF$2 -> k.j$f$b:
    java.util.List $splitTempFilesList -> f
    int partNumber -> e
    java.util.List $pdfWritersList -> g
    com.itextpdf.kernel.pdf.PdfWriter getNextPdfWriter(com.itextpdf.kernel.utils.PageRange) -> d
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageRange$1 -> k.j$g:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageRange$2 -> k.j$h:
    android.app.Activity $context -> a3
    kotlin.jvm.internal.Ref$ObjectRef $splitPDFPaths -> d3
    java.lang.String $pageRange -> c3
    java.lang.String $sourceFilePath -> b3
    java.lang.Object L$6 -> W2
    int I$0 -> Y2
    int label -> Z2
    long J$0 -> X2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object L$4 -> U2
    java.lang.Object L$5 -> V2
    java.lang.Object L$2 -> S2
    java.lang.Object L$3 -> T2
    java.lang.Object access$invokeSuspend$splitPDF(java.util.List,java.util.List,java.io.File,com.itextpdf.kernel.utils.PageRange,kotlin.coroutines.Continuation) -> a
    java.lang.Object invokeSuspend$splitPDF(java.util.List,java.util.List,java.io.File,com.itextpdf.kernel.utils.PageRange,kotlin.coroutines.Continuation) -> b
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageRange$2$splitPDF$1 -> k.j$h$a:
    int label -> V2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object result -> U2
    java.lang.Object L$2 -> S2
    java.lang.Object L$3 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageRange$2$splitPDF$splitDocument$1 -> k.j$h$b:
    java.util.List $pdfWritersList -> f
    java.util.List $splitTempFilesList -> e
    com.itextpdf.kernel.pdf.PdfWriter getNextPdfWriter(com.itextpdf.kernel.utils.PageRange) -> d
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageRanges$1 -> k.j$i:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageRanges$2 -> k.j$j:
    android.app.Activity $context -> c3
    java.lang.String $sourceFilePath -> d3
    kotlin.jvm.internal.Ref$ObjectRef $splitPDFPaths -> f3
    java.lang.Object L$8 -> Y2
    long J$0 -> Z2
    java.lang.Object L$6 -> W2
    java.lang.Object L$7 -> X2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object L$4 -> U2
    java.lang.Object L$5 -> V2
    int label -> b3
    java.util.List $pageRanges -> e3
    java.lang.Object L$2 -> S2
    int I$0 -> a3
    java.lang.Object L$3 -> T2
    java.lang.Object access$invokeSuspend$splitPDF(java.util.List,java.util.List,java.io.File,java.util.List,kotlin.coroutines.Continuation) -> a
    java.lang.Object invokeSuspend$splitPDF(java.util.List,java.util.List,java.io.File,java.util.List,kotlin.coroutines.Continuation) -> b
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageRanges$2$splitPDF$1 -> k.j$j$a:
    int label -> V2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object result -> U2
    java.lang.Object L$2 -> S2
    java.lang.Object L$3 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageRanges$2$splitPDF$splitDocuments$1 -> k.j$j$b:
    java.util.List $splitTempFilesList -> f
    int partNumber -> e
    java.util.List $pdfWritersList -> g
    com.itextpdf.kernel.pdf.PdfWriter getNextPdfWriter(com.itextpdf.kernel.utils.PageRange) -> d
com.deepanshuchaudhary.pdf_manipulator.PdfValidityAndProtectionKt -> k.m:
    java.lang.Object getPdfValidityAndProtection(java.lang.String,java.lang.String,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.PdfValidityAndProtectionKt$getPdfValidityAndProtection$1 -> k.m$a:
    int label -> W2
    java.lang.Object L$0 -> Q2
    java.lang.Object L$1 -> R2
    java.lang.Object L$4 -> U2
    java.lang.Object result -> V2
    java.lang.Object L$2 -> S2
    java.lang.Object L$3 -> T2
com.deepanshuchaudhary.pdf_manipulator.PdfValidityAndProtectionKt$getPdfValidityAndProtection$2 -> k.m$b:
    kotlin.jvm.internal.Ref$BooleanRef $isOpenPasswordProtected -> X2
    kotlin.jvm.internal.Ref$BooleanRef $isPDFValid -> Y2
    kotlin.jvm.internal.Ref$ObjectRef $isPrintingAllowed -> V2
    kotlin.jvm.internal.Ref$ObjectRef $isModifyContentsAllowed -> W2
    java.lang.String $userOrOwnerPassword -> T2
    java.lang.String $sourceFilePath -> S2
    kotlin.jvm.internal.Ref$ObjectRef $isOwnerPasswordProtected -> U2
    int label -> Q2
    android.app.Activity $context -> R2
com.deepanshuchaudhary.pdf_manipulator.PositionType -> k.n:
    com.deepanshuchaudhary.pdf_manipulator.PositionType BottomRight -> Y2
    com.deepanshuchaudhary.pdf_manipulator.PositionType Custom -> Z2
    com.deepanshuchaudhary.pdf_manipulator.PositionType BottomLeft -> W2
    com.deepanshuchaudhary.pdf_manipulator.PositionType BottomCenter -> X2
    com.deepanshuchaudhary.pdf_manipulator.PositionType Center -> U2
    com.deepanshuchaudhary.pdf_manipulator.PositionType CenterRight -> V2
    com.deepanshuchaudhary.pdf_manipulator.PositionType TopRight -> S2
    com.deepanshuchaudhary.pdf_manipulator.PositionType CenterLeft -> T2
    com.deepanshuchaudhary.pdf_manipulator.PositionType[] $VALUES -> a3
    com.deepanshuchaudhary.pdf_manipulator.PositionType TopLeft -> Q2
    com.deepanshuchaudhary.pdf_manipulator.PositionType TopCenter -> R2
    com.deepanshuchaudhary.pdf_manipulator.PositionType[] $values() -> a
com.deepanshuchaudhary.pdf_manipulator.RemovePdfPagesKt -> k.o:
    java.lang.Object getPDFPageDeleter(java.lang.String,java.util.List,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.RemovePdfPagesKt$getPDFPageDeleter$1 -> k.o$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.RemovePdfPagesKt$getPDFPageDeleter$2 -> k.o$b:
    java.lang.String $sourceFilePath -> S2
    kotlin.jvm.internal.Ref$ObjectRef $resultPDFPath -> U2
    int label -> Q2
    android.app.Activity $context -> R2
    java.util.List $pageNumbers -> T2
com.deepanshuchaudhary.pdf_manipulator.RemoveReorderRotatePdfPagesKt -> k.p:
    java.lang.Object getPDFPageRotatorDeleterReorder(java.lang.String,java.util.List,java.util.List,java.util.List,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.RemoveReorderRotatePdfPagesKt$getPDFPageRotatorDeleterReorder$1 -> k.p$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.RemoveReorderRotatePdfPagesKt$getPDFPageRotatorDeleterReorder$2 -> k.p$b:
    kotlin.jvm.internal.Ref$ObjectRef $resultPDFPath -> V2
    java.lang.String $sourceFilePath -> S2
    int label -> Q2
    android.app.Activity $context -> R2
    java.util.List $pageNumbersForReorder -> U2
    java.util.List $pagesRotationInfo -> T2
    java.util.List $pageNumbersForDeleter -> W2
com.deepanshuchaudhary.pdf_manipulator.ReorderPdfPagesKt -> k.q:
    java.lang.Object getPDFPageReorder(java.lang.String,java.util.List,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.ReorderPdfPagesKt$getPDFPageReorder$1 -> k.q$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.ReorderPdfPagesKt$getPDFPageReorder$2 -> k.q$b:
    java.lang.String $sourceFilePath -> S2
    kotlin.jvm.internal.Ref$ObjectRef $resultPDFPath -> U2
    int label -> Q2
    android.app.Activity $context -> R2
    java.util.List $pageNumbers -> T2
com.deepanshuchaudhary.pdf_manipulator.RotatePdfPagesKt -> k.r:
    java.lang.Object getPDFPageRotator(java.lang.String,java.util.List,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.RotatePdfPagesKt$getPDFPageRotator$1 -> k.r$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.RotatePdfPagesKt$getPDFPageRotator$2 -> k.r$b:
    java.lang.String $sourceFilePath -> S2
    kotlin.jvm.internal.Ref$ObjectRef $resultPDFPath -> U2
    int label -> Q2
    android.app.Activity $context -> R2
    java.util.List $pagesRotationInfo -> T2
com.deepanshuchaudhary.pdf_manipulator.Utils -> k.s:
    java.lang.String cleanupFileName(java.lang.String) -> a
    void copyDataFromSourceToDestDocument(android.net.Uri,android.net.Uri,android.content.ContentResolver) -> b
    void deleteTempFiles(java.util.List) -> c
    void finishSplitSuccessfullyWithListOfBoolean(java.util.List,io.flutter.plugin.common.MethodChannel$Result) -> d
    void finishSplitSuccessfullyWithListOfListOfDouble(java.util.List,io.flutter.plugin.common.MethodChannel$Result) -> e
    void finishSplitSuccessfullyWithListOfString(java.util.List,io.flutter.plugin.common.MethodChannel$Result) -> f
    void finishSuccessfullyWithString(java.lang.String,io.flutter.plugin.common.MethodChannel$Result) -> g
    void finishWithError(java.lang.String,java.lang.String,java.lang.String,io.flutter.plugin.common.MethodChannel$Result) -> h
    java.lang.String getFileNameFromPickedDocumentUri(android.net.Uri,android.app.Activity) -> i
    android.net.Uri getURI(java.lang.String) -> j
    void truncateDocumentToZeroSize(android.net.Uri,android.content.ContentResolver) -> k
com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer -> k.t:
    com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer OverContent -> R2
    com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer UnderContent -> Q2
    com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer[] $VALUES -> S2
    com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer[] $values() -> a
com.deepanshuchaudhary.pdf_manipulator.WatermarkPdfKt -> k.u:
    java.lang.Object getWatermarkedPDFPath(java.lang.String,java.lang.String,double,com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer,double,double,java.lang.String,com.deepanshuchaudhary.pdf_manipulator.PositionType,java.util.List,java.util.List,android.app.Activity,kotlin.coroutines.Continuation) -> a
com.deepanshuchaudhary.pdf_manipulator.WatermarkPdfKt$getWatermarkedPDFPath$1 -> k.u$a:
    int label -> S2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
com.deepanshuchaudhary.pdf_manipulator.WatermarkPdfKt$getWatermarkedPDFPath$2 -> k.u$b:
    java.util.List $customPositionXCoordinatesList -> Y2
    com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer $watermarkLayer -> a3
    java.util.List $customPositionYCoordinatesList -> Z2
    int label -> Q2
    double $fontSize -> V2
    java.lang.String $watermarkColor -> W2
    com.deepanshuchaudhary.pdf_manipulator.PositionType $positionType -> X2
    java.lang.String $text -> U2
    double $opacity -> b3
    java.lang.String $sourceFilePath -> S2
    double $rotationAngle -> c3
    kotlin.jvm.internal.Ref$ObjectRef $resultPDFPath -> T2
    android.app.Activity $context -> R2
    void invokeSuspend$watermark(java.lang.String,double,java.lang.String,com.deepanshuchaudhary.pdf_manipulator.PositionType,java.util.List,com.itextpdf.kernel.pdf.PdfDocument,java.util.List,com.deepanshuchaudhary.pdf_manipulator.WatermarkLayer,double,double) -> a
com.deepanshuchaudhary.pdf_manipulator.WatermarkPdfKt$getWatermarkedPDFPath$2$WhenMappings -> k.u$b$a:
    int[] $EnumSwitchMapping$0 -> a
com.github.barteksc.pdfviewer.AnimationManager -> com.github.barteksc.pdfviewer.a:
    com.github.barteksc.pdfviewer.PDFView pdfView -> a
    boolean pageFlinging -> e
    android.animation.ValueAnimator animation -> b
    android.widget.OverScroller scroller -> c
    boolean flinging -> d
    com.github.barteksc.pdfviewer.PDFView access$000(com.github.barteksc.pdfviewer.AnimationManager) -> a
    boolean access$102(com.github.barteksc.pdfviewer.AnimationManager,boolean) -> b
    void access$200(com.github.barteksc.pdfviewer.AnimationManager) -> c
    void computeFling() -> d
    void hideHandle() -> e
    boolean isFlinging() -> f
    void startFlingAnimation(int,int,int,int,int,int,int,int) -> g
    void startPageFlingAnimation(float) -> h
    void startXAnimation(float,float) -> i
    void startYAnimation(float,float) -> j
    void startZoomAnimation(float,float,float,float) -> k
    void stopAll() -> l
    void stopFling() -> m
com.github.barteksc.pdfviewer.AnimationManager$XAnimation -> com.github.barteksc.pdfviewer.a$a:
    com.github.barteksc.pdfviewer.AnimationManager this$0 -> a
com.github.barteksc.pdfviewer.AnimationManager$YAnimation -> com.github.barteksc.pdfviewer.a$b:
    com.github.barteksc.pdfviewer.AnimationManager this$0 -> a
com.github.barteksc.pdfviewer.AnimationManager$ZoomAnimation -> com.github.barteksc.pdfviewer.a$c:
    float centerY -> b
    float centerX -> a
    com.github.barteksc.pdfviewer.AnimationManager this$0 -> c
com.github.barteksc.pdfviewer.CacheManager -> com.github.barteksc.pdfviewer.b:
    java.util.PriorityQueue activeCache -> b
    java.lang.Object passiveActiveLock -> d
    java.util.PriorityQueue passiveCache -> a
    java.util.List thumbnails -> c
    com.github.barteksc.pdfviewer.CacheManager$PagePartComparator orderComparator -> e
    void addWithoutDuplicates(java.util.Collection,com.github.barteksc.pdfviewer.model.PagePart) -> a
    void cachePart(com.github.barteksc.pdfviewer.model.PagePart) -> b
    void cacheThumbnail(com.github.barteksc.pdfviewer.model.PagePart) -> c
    boolean containsThumbnail(int,android.graphics.RectF) -> d
    com.github.barteksc.pdfviewer.model.PagePart find(java.util.PriorityQueue,com.github.barteksc.pdfviewer.model.PagePart) -> e
    java.util.List getPageParts() -> f
    java.util.List getThumbnails() -> g
    void makeAFreeSpace() -> h
    void makeANewSet() -> i
    void recycle() -> j
    boolean upPartIfContained(int,android.graphics.RectF,int) -> k
com.github.barteksc.pdfviewer.CacheManager$PagePartComparator -> com.github.barteksc.pdfviewer.b$a:
    com.github.barteksc.pdfviewer.CacheManager this$0 -> a
    int compare(com.github.barteksc.pdfviewer.model.PagePart,com.github.barteksc.pdfviewer.model.PagePart) -> a
com.github.barteksc.pdfviewer.DecodingAsyncTask -> com.github.barteksc.pdfviewer.c:
    int[] userPages -> f
    com.github.barteksc.pdfviewer.source.DocumentSource docSource -> e
    com.shockwave.pdfium.PdfiumCore pdfiumCore -> c
    com.github.barteksc.pdfviewer.PdfFile pdfFile -> g
    java.lang.ref.WeakReference pdfViewReference -> b
    boolean cancelled -> a
    java.lang.String password -> d
    java.lang.Throwable doInBackground(java.lang.Void[]) -> a
    com.shockwave.pdfium.util.Size getViewSize(com.github.barteksc.pdfviewer.PDFView) -> b
    void onPostExecute(java.lang.Throwable) -> c
com.github.barteksc.pdfviewer.DragPinchManager -> com.github.barteksc.pdfviewer.d:
    com.github.barteksc.pdfviewer.PDFView pdfView -> a
    boolean scrolling -> e
    boolean scaling -> f
    android.view.GestureDetector gestureDetector -> c
    boolean enabled -> g
    android.view.ScaleGestureDetector scaleGestureDetector -> d
    com.github.barteksc.pdfviewer.AnimationManager animationManager -> b
    boolean checkDoPageFling(float,float) -> a
    boolean checkLinkTapped(float,float) -> b
    void disable() -> c
    void enable() -> d
    void hideHandle() -> e
    void onBoundedFling(float,float) -> f
    void onScrollEnd(android.view.MotionEvent) -> g
    void startPageFling(android.view.MotionEvent,android.view.MotionEvent,float,float) -> h
com.github.barteksc.pdfviewer.PDFView -> com.github.barteksc.pdfviewer.e:
    boolean recycled -> m
    float currentYOffset -> k
    boolean pageFling -> N
    com.github.barteksc.pdfviewer.CacheManager cacheManager -> e
    java.util.List onDrawPagesNums -> O
    boolean hasSize -> P
    boolean enableAntialiasing -> J
    android.graphics.Paint paint -> t
    float maxZoom -> c
    boolean fitEachPage -> w
    float minZoom -> a
    com.github.barteksc.pdfviewer.listener.Callbacks callbacks -> s
    com.github.barteksc.pdfviewer.RenderingHandler renderingHandler -> q
    boolean swipeVertical -> y
    com.github.barteksc.pdfviewer.util.FitPolicy pageFitPolicy -> v
    boolean bestQuality -> G
    boolean doubletapEnabled -> A
    boolean pageSnap -> C
    float zoom -> l
    boolean autoSpacing -> M
    float currentXOffset -> j
    com.github.barteksc.pdfviewer.scroll.ScrollHandle scrollHandle -> E
    int spacingPx -> L
    boolean renderDuringScale -> I
    android.os.HandlerThread renderingHandlerThread -> p
    android.graphics.Paint debugPaint -> u
    android.graphics.PaintFlagsDrawFilter antialiasFilter -> K
    int currentPage -> i
    float midZoom -> b
    com.github.barteksc.pdfviewer.DecodingAsyncTask decodingAsyncTask -> o
    com.shockwave.pdfium.PdfiumCore pdfiumCore -> D
    java.lang.String TAG -> R
    com.github.barteksc.pdfviewer.DragPinchManager dragPinchManager -> g
    com.github.barteksc.pdfviewer.AnimationManager animationManager -> f
    com.github.barteksc.pdfviewer.PDFView$ScrollDir scrollDir -> d
    boolean enableSwipe -> z
    int defaultPage -> x
    com.github.barteksc.pdfviewer.PDFView$Configurator waitingDocumentConfigurator -> Q
    boolean isScrollHandleInit -> F
    boolean annotationRendering -> H
    com.github.barteksc.pdfviewer.PagesLoader pagesLoader -> r
    boolean nightMode -> B
    com.github.barteksc.pdfviewer.PdfFile pdfFile -> h
    com.github.barteksc.pdfviewer.PDFView$State state -> n
    boolean isFitEachPage() -> A
    boolean isPageFlingEnabled() -> B
    boolean isSwipeEnabled() -> C
    boolean isSwipeVertical() -> D
    boolean isZooming() -> E
    void jumpTo(int) -> F
    void jumpTo(int,boolean) -> G
    void load(com.github.barteksc.pdfviewer.source.DocumentSource,java.lang.String) -> H
    void load(com.github.barteksc.pdfviewer.source.DocumentSource,java.lang.String,int[]) -> I
    void loadComplete(com.github.barteksc.pdfviewer.PdfFile) -> J
    void loadError(java.lang.Throwable) -> K
    void loadPageByOffset() -> L
    void loadPages() -> M
    void moveRelativeTo(float,float) -> N
    void moveTo(float,float) -> O
    void moveTo(float,float,boolean) -> P
    void onBitmapRendered(com.github.barteksc.pdfviewer.model.PagePart) -> Q
    void onPageError(com.github.barteksc.pdfviewer.exception.PageRenderingException) -> R
    boolean pageFillsScreen() -> S
    void performPageSnap() -> T
    void recycle() -> U
    void redraw() -> V
    void resetZoomWithAnimation() -> W
    void setPositionOffset(float,boolean) -> X
    void showPage(int) -> Y
    float snapOffsetForPage(int,com.github.barteksc.pdfviewer.util.SnapEdge) -> Z
    void access$1000(com.github.barteksc.pdfviewer.PDFView,boolean) -> a
    float toCurrentScale(float) -> a0
    void access$1100(com.github.barteksc.pdfviewer.PDFView,com.github.barteksc.pdfviewer.source.DocumentSource,java.lang.String,int[]) -> b
    void zoomCenteredRelativeTo(float,android.graphics.PointF) -> b0
    void access$1200(com.github.barteksc.pdfviewer.PDFView,com.github.barteksc.pdfviewer.source.DocumentSource,java.lang.String) -> c
    void zoomCenteredTo(float,android.graphics.PointF) -> c0
    boolean access$200(com.github.barteksc.pdfviewer.PDFView) -> d
    void zoomTo(float) -> d0
    com.github.barteksc.pdfviewer.PDFView$Configurator access$302(com.github.barteksc.pdfviewer.PDFView,com.github.barteksc.pdfviewer.PDFView$Configurator) -> e
    void zoomWithAnimation(float) -> e0
    void access$400(com.github.barteksc.pdfviewer.PDFView,int) -> f
    void zoomWithAnimation(float,float,float) -> f0
    void access$500(com.github.barteksc.pdfviewer.PDFView,boolean) -> g
    void access$600(com.github.barteksc.pdfviewer.PDFView,com.github.barteksc.pdfviewer.scroll.ScrollHandle) -> h
    void access$700(com.github.barteksc.pdfviewer.PDFView,int) -> i
    void access$800(com.github.barteksc.pdfviewer.PDFView,boolean) -> j
    void access$900(com.github.barteksc.pdfviewer.PDFView,com.github.barteksc.pdfviewer.util.FitPolicy) -> k
    boolean doRenderDuringScale() -> l
    boolean documentFitsView() -> m
    void drawPart(android.graphics.Canvas,com.github.barteksc.pdfviewer.model.PagePart) -> n
    void drawWithListener(android.graphics.Canvas,int,com.github.barteksc.pdfviewer.listener.OnDrawListener) -> o
    void enableAnnotationRendering(boolean) -> p
    void enableAntialiasing(boolean) -> q
    void enableDoubletap(boolean) -> r
    int findFocusPage(float,float) -> s
    com.github.barteksc.pdfviewer.util.SnapEdge findSnapEdge(int) -> t
    com.github.barteksc.pdfviewer.PDFView$Configurator fromBytes(byte[]) -> u
    com.github.barteksc.pdfviewer.PDFView$Configurator fromUri(android.net.Uri) -> v
    boolean isAnnotationRendering() -> w
    boolean isAutoSpacingEnabled() -> x
    boolean isBestQuality() -> y
    boolean isDoubletapEnabled() -> z
com.github.barteksc.pdfviewer.PDFView$1 -> com.github.barteksc.pdfviewer.e$a:
com.github.barteksc.pdfviewer.PDFView$Configurator -> com.github.barteksc.pdfviewer.e$b:
    boolean antialiasing -> u
    boolean autoSpacing -> w
    boolean swipeHorizontal -> q
    com.github.barteksc.pdfviewer.listener.OnDrawListener onDrawAllListener -> f
    com.github.barteksc.pdfviewer.listener.OnPageChangeListener onPageChangeListener -> i
    com.github.barteksc.pdfviewer.scroll.ScrollHandle scrollHandle -> t
    int[] pageNumbers -> b
    boolean fitEachPage -> y
    com.github.barteksc.pdfviewer.PDFView this$0 -> C
    com.github.barteksc.pdfviewer.util.FitPolicy pageFitPolicy -> x
    boolean pageSnap -> A
    boolean enableDoubletap -> d
    com.github.barteksc.pdfviewer.listener.OnPageScrollListener onPageScrollListener -> j
    com.github.barteksc.pdfviewer.listener.OnTapListener onTapListener -> l
    com.github.barteksc.pdfviewer.listener.OnRenderListener onRenderListener -> k
    com.github.barteksc.pdfviewer.link.LinkHandler linkHandler -> o
    java.lang.String password -> s
    boolean annotationRendering -> r
    com.github.barteksc.pdfviewer.listener.OnPageErrorListener onPageErrorListener -> n
    com.github.barteksc.pdfviewer.listener.OnLoadCompleteListener onLoadCompleteListener -> g
    com.github.barteksc.pdfviewer.listener.OnDrawListener onDrawListener -> e
    boolean pageFling -> z
    com.github.barteksc.pdfviewer.source.DocumentSource documentSource -> a
    int spacing -> v
    com.github.barteksc.pdfviewer.listener.OnLongPressListener onLongPressListener -> m
    com.github.barteksc.pdfviewer.listener.OnErrorListener onErrorListener -> h
    boolean nightMode -> B
    boolean enableSwipe -> c
    int defaultPage -> p
    com.github.barteksc.pdfviewer.PDFView$Configurator autoSpacing(boolean) -> a
    com.github.barteksc.pdfviewer.PDFView$Configurator defaultPage(int) -> b
    com.github.barteksc.pdfviewer.PDFView$Configurator enableAnnotationRendering(boolean) -> c
    com.github.barteksc.pdfviewer.PDFView$Configurator enableAntialiasing(boolean) -> d
    com.github.barteksc.pdfviewer.PDFView$Configurator enableDoubletap(boolean) -> e
    com.github.barteksc.pdfviewer.PDFView$Configurator enableSwipe(boolean) -> f
    com.github.barteksc.pdfviewer.PDFView$Configurator linkHandler(com.github.barteksc.pdfviewer.link.LinkHandler) -> g
    void load() -> h
    com.github.barteksc.pdfviewer.PDFView$Configurator nightMode(boolean) -> i
    com.github.barteksc.pdfviewer.PDFView$Configurator onError(com.github.barteksc.pdfviewer.listener.OnErrorListener) -> j
    com.github.barteksc.pdfviewer.PDFView$Configurator onPageChange(com.github.barteksc.pdfviewer.listener.OnPageChangeListener) -> k
    com.github.barteksc.pdfviewer.PDFView$Configurator onPageError(com.github.barteksc.pdfviewer.listener.OnPageErrorListener) -> l
    com.github.barteksc.pdfviewer.PDFView$Configurator onRender(com.github.barteksc.pdfviewer.listener.OnRenderListener) -> m
    com.github.barteksc.pdfviewer.PDFView$Configurator pageFitPolicy(com.github.barteksc.pdfviewer.util.FitPolicy) -> n
    com.github.barteksc.pdfviewer.PDFView$Configurator pageFling(boolean) -> o
    com.github.barteksc.pdfviewer.PDFView$Configurator pageSnap(boolean) -> p
    com.github.barteksc.pdfviewer.PDFView$Configurator password(java.lang.String) -> q
    com.github.barteksc.pdfviewer.PDFView$Configurator swipeHorizontal(boolean) -> r
com.github.barteksc.pdfviewer.PDFView$ScrollDir -> com.github.barteksc.pdfviewer.e$c:
    com.github.barteksc.pdfviewer.PDFView$ScrollDir NONE -> Q2
    com.github.barteksc.pdfviewer.PDFView$ScrollDir[] $VALUES -> T2
    com.github.barteksc.pdfviewer.PDFView$ScrollDir END -> S2
    com.github.barteksc.pdfviewer.PDFView$ScrollDir START -> R2
com.github.barteksc.pdfviewer.PDFView$State -> com.github.barteksc.pdfviewer.e$d:
    com.github.barteksc.pdfviewer.PDFView$State[] $VALUES -> U2
    com.github.barteksc.pdfviewer.PDFView$State LOADED -> R2
    com.github.barteksc.pdfviewer.PDFView$State DEFAULT -> Q2
    com.github.barteksc.pdfviewer.PDFView$State ERROR -> T2
    com.github.barteksc.pdfviewer.PDFView$State SHOWN -> S2
com.github.barteksc.pdfviewer.PagesLoader -> com.github.barteksc.pdfviewer.f:
    com.github.barteksc.pdfviewer.PDFView pdfView -> a
    float partRenderHeight -> h
    int preloadOffset -> j
    float partRenderWidth -> g
    float pageRelativePartHeight -> f
    float pageRelativePartWidth -> e
    float yOffset -> d
    float xOffset -> c
    android.graphics.RectF thumbnailRect -> i
    int cacheOrder -> b
    void calculatePartSize(com.github.barteksc.pdfviewer.PagesLoader$GridSize) -> a
    void getPageColsRows(com.github.barteksc.pdfviewer.PagesLoader$GridSize,int) -> b
    java.util.List getRenderRangeList(float,float,float,float) -> c
    boolean loadCell(int,int,int,float,float) -> d
    int loadPage(int,int,int,int,int,int) -> e
    void loadPages() -> f
    void loadThumbnail(int) -> g
    void loadVisible() -> h
com.github.barteksc.pdfviewer.PagesLoader$1 -> com.github.barteksc.pdfviewer.f$a:
com.github.barteksc.pdfviewer.PagesLoader$GridSize -> com.github.barteksc.pdfviewer.f$b:
    int cols -> b
    com.github.barteksc.pdfviewer.PagesLoader this$0 -> c
    int rows -> a
com.github.barteksc.pdfviewer.PagesLoader$Holder -> com.github.barteksc.pdfviewer.f$c:
    int col -> b
    com.github.barteksc.pdfviewer.PagesLoader this$0 -> c
    int row -> a
com.github.barteksc.pdfviewer.PagesLoader$RenderRange -> com.github.barteksc.pdfviewer.f$d:
    com.github.barteksc.pdfviewer.PagesLoader this$0 -> e
    com.github.barteksc.pdfviewer.PagesLoader$Holder rightBottom -> d
    com.github.barteksc.pdfviewer.PagesLoader$Holder leftTop -> c
    com.github.barteksc.pdfviewer.PagesLoader$GridSize gridSize -> b
    int page -> a
com.github.barteksc.pdfviewer.PdfFile -> com.github.barteksc.pdfviewer.g:
    boolean autoSpacing -> m
    com.shockwave.pdfium.PdfDocument pdfDocument -> a
    int spacingPx -> l
    java.util.List pageSpacing -> o
    com.shockwave.pdfium.util.Size originalMaxHeightPageSize -> h
    com.shockwave.pdfium.util.Size originalMaxWidthPageSize -> g
    int[] originalUserPages -> s
    boolean isVertical -> k
    com.shockwave.pdfium.PdfiumCore pdfiumCore -> b
    int pagesCount -> c
    boolean fitEachPage -> r
    java.util.List pageSizes -> e
    android.util.SparseBooleanArray openedPages -> f
    java.util.List originalPageSizes -> d
    com.shockwave.pdfium.util.SizeF maxWidthPageSize -> j
    java.lang.Object lock -> t
    com.shockwave.pdfium.util.SizeF maxHeightPageSize -> i
    com.github.barteksc.pdfviewer.util.FitPolicy pageFitPolicy -> q
    java.util.List pageOffsets -> n
    float documentLength -> p
    void setup(com.shockwave.pdfium.util.Size) -> A
    int determineValidPageNumberFrom(int) -> a
    void dispose() -> b
    int documentPage(int) -> c
    java.util.List getBookmarks() -> d
    float getDocLen(float) -> e
    float getMaxPageHeight() -> f
    com.shockwave.pdfium.util.SizeF getMaxPageSize() -> g
    float getMaxPageWidth() -> h
    com.shockwave.pdfium.PdfDocument$Meta getMetaData() -> i
    int getPageAtOffset(float,float) -> j
    float getPageLength(int,float) -> k
    java.util.List getPageLinks(int) -> l
    float getPageOffset(int,float) -> m
    com.shockwave.pdfium.util.SizeF getPageSize(int) -> n
    float getPageSpacing(int,float) -> o
    int getPagesCount() -> p
    com.shockwave.pdfium.util.SizeF getScaledPageSize(int,float) -> q
    float getSecondaryPageOffset(int,float) -> r
    android.graphics.RectF mapRectToDevice(int,int,int,int,int,android.graphics.RectF) -> s
    boolean openPage(int) -> t
    boolean pageHasError(int) -> u
    void prepareAutoSpacing(com.shockwave.pdfium.util.Size) -> v
    void prepareDocLen() -> w
    void preparePagesOffset() -> x
    void recalculatePageSizes(com.shockwave.pdfium.util.Size) -> y
    void renderPageBitmap(android.graphics.Bitmap,int,android.graphics.Rect,boolean) -> z
com.github.barteksc.pdfviewer.RenderingHandler -> com.github.barteksc.pdfviewer.h:
    java.lang.String TAG -> f
    android.graphics.RectF renderBounds -> b
    com.github.barteksc.pdfviewer.PDFView pdfView -> a
    android.graphics.Matrix renderMatrix -> d
    boolean running -> e
    android.graphics.Rect roundedRenderBounds -> c
    com.github.barteksc.pdfviewer.PDFView access$000(com.github.barteksc.pdfviewer.RenderingHandler) -> a
    void addRenderingTask(int,float,float,android.graphics.RectF,boolean,int,boolean,boolean) -> b
    void calculateBounds(int,int,android.graphics.RectF) -> c
    com.github.barteksc.pdfviewer.model.PagePart proceed(com.github.barteksc.pdfviewer.RenderingHandler$RenderingTask) -> d
    void start() -> e
    void stop() -> f
com.github.barteksc.pdfviewer.RenderingHandler$1 -> com.github.barteksc.pdfviewer.h$a:
    com.github.barteksc.pdfviewer.model.PagePart val$part -> Q2
    com.github.barteksc.pdfviewer.RenderingHandler this$0 -> R2
com.github.barteksc.pdfviewer.RenderingHandler$2 -> com.github.barteksc.pdfviewer.h$b:
    com.github.barteksc.pdfviewer.exception.PageRenderingException val$ex -> Q2
    com.github.barteksc.pdfviewer.RenderingHandler this$0 -> R2
com.github.barteksc.pdfviewer.RenderingHandler$RenderingTask -> com.github.barteksc.pdfviewer.h$c:
    android.graphics.RectF bounds -> c
    com.github.barteksc.pdfviewer.RenderingHandler this$0 -> i
    boolean thumbnail -> e
    int cacheOrder -> f
    float height -> b
    int page -> d
    boolean bestQuality -> g
    float width -> a
    boolean annotationRendering -> h
com.github.barteksc.pdfviewer.exception.PageRenderingException -> l.a:
    int page -> Q2
    int getPage() -> a
com.github.barteksc.pdfviewer.link.DefaultLinkHandler -> m.a:
    com.github.barteksc.pdfviewer.PDFView pdfView -> a
    java.lang.String TAG -> b
    void handleLinkEvent(com.github.barteksc.pdfviewer.model.LinkTapEvent) -> a
    void handlePage(int) -> b
    void handleUri(java.lang.String) -> c
com.github.barteksc.pdfviewer.link.LinkHandler -> m.b:
    void handleLinkEvent(com.github.barteksc.pdfviewer.model.LinkTapEvent) -> a
com.github.barteksc.pdfviewer.listener.Callbacks -> n.a:
    com.github.barteksc.pdfviewer.listener.OnPageErrorListener onPageErrorListener -> c
    com.github.barteksc.pdfviewer.listener.OnLoadCompleteListener onLoadCompleteListener -> a
    com.github.barteksc.pdfviewer.listener.OnPageChangeListener onPageChangeListener -> e
    com.github.barteksc.pdfviewer.listener.OnErrorListener onErrorListener -> b
    com.github.barteksc.pdfviewer.listener.OnLongPressListener onLongPressListener -> j
    com.github.barteksc.pdfviewer.listener.OnRenderListener onRenderListener -> d
    com.github.barteksc.pdfviewer.listener.OnTapListener onTapListener -> i
    com.github.barteksc.pdfviewer.link.LinkHandler linkHandler -> k
    com.github.barteksc.pdfviewer.listener.OnPageScrollListener onPageScrollListener -> f
    com.github.barteksc.pdfviewer.listener.OnDrawListener onDrawAllListener -> h
    com.github.barteksc.pdfviewer.listener.OnDrawListener onDrawListener -> g
    void callLinkHandler(com.github.barteksc.pdfviewer.model.LinkTapEvent) -> a
    void callOnLoadComplete(int) -> b
    void callOnLongPress(android.view.MotionEvent) -> c
    void callOnPageChange(int,int) -> d
    boolean callOnPageError(int,java.lang.Throwable) -> e
    void callOnPageScroll(int,float) -> f
    void callOnRender(int) -> g
    boolean callOnTap(android.view.MotionEvent) -> h
    com.github.barteksc.pdfviewer.listener.OnDrawListener getOnDraw() -> i
    com.github.barteksc.pdfviewer.listener.OnDrawListener getOnDrawAll() -> j
    com.github.barteksc.pdfviewer.listener.OnErrorListener getOnError() -> k
    void setLinkHandler(com.github.barteksc.pdfviewer.link.LinkHandler) -> l
    void setOnDraw(com.github.barteksc.pdfviewer.listener.OnDrawListener) -> m
    void setOnDrawAll(com.github.barteksc.pdfviewer.listener.OnDrawListener) -> n
    void setOnError(com.github.barteksc.pdfviewer.listener.OnErrorListener) -> o
    void setOnLoadComplete(com.github.barteksc.pdfviewer.listener.OnLoadCompleteListener) -> p
    void setOnLongPress(com.github.barteksc.pdfviewer.listener.OnLongPressListener) -> q
    void setOnPageChange(com.github.barteksc.pdfviewer.listener.OnPageChangeListener) -> r
    void setOnPageError(com.github.barteksc.pdfviewer.listener.OnPageErrorListener) -> s
    void setOnPageScroll(com.github.barteksc.pdfviewer.listener.OnPageScrollListener) -> t
    void setOnRender(com.github.barteksc.pdfviewer.listener.OnRenderListener) -> u
    void setOnTap(com.github.barteksc.pdfviewer.listener.OnTapListener) -> v
com.github.barteksc.pdfviewer.listener.OnDrawListener -> n.b:
    void onLayerDrawn(android.graphics.Canvas,float,float,int) -> a
com.github.barteksc.pdfviewer.listener.OnErrorListener -> n.c:
    void onError(java.lang.Throwable) -> a
com.github.barteksc.pdfviewer.listener.OnLoadCompleteListener -> n.d:
    void loadComplete(int) -> a
com.github.barteksc.pdfviewer.listener.OnLongPressListener -> n.e:
com.github.barteksc.pdfviewer.listener.OnPageChangeListener -> n.f:
    void onPageChanged(int,int) -> a
com.github.barteksc.pdfviewer.listener.OnPageErrorListener -> n.g:
    void onPageError(int,java.lang.Throwable) -> a
com.github.barteksc.pdfviewer.listener.OnPageScrollListener -> n.h:
    void onPageScrolled(int,float) -> a
com.github.barteksc.pdfviewer.listener.OnRenderListener -> n.i:
    void onInitiallyRendered(int) -> a
com.github.barteksc.pdfviewer.listener.OnTapListener -> n.j:
    boolean onTap(android.view.MotionEvent) -> a
com.github.barteksc.pdfviewer.model.LinkTapEvent -> o.a:
    android.graphics.RectF mappedLinkRect -> e
    com.shockwave.pdfium.PdfDocument$Link link -> f
    float documentY -> d
    float documentX -> c
    float originalY -> b
    float originalX -> a
    com.shockwave.pdfium.PdfDocument$Link getLink() -> a
com.github.barteksc.pdfviewer.model.PagePart -> o.b:
    android.graphics.Bitmap renderedBitmap -> b
    android.graphics.RectF pageRelativeBounds -> c
    int cacheOrder -> e
    int page -> a
    boolean thumbnail -> d
    int getCacheOrder() -> a
    int getPage() -> b
    android.graphics.RectF getPageRelativeBounds() -> c
    android.graphics.Bitmap getRenderedBitmap() -> d
    boolean isThumbnail() -> e
    void setCacheOrder(int) -> f
com.github.barteksc.pdfviewer.scroll.ScrollHandle -> p.a:
    void show() -> a
    void hide() -> b
    void setPageNum(int) -> c
    void setScroll(float) -> d
    void hideDelayed() -> e
    void destroyLayout() -> f
    void setupLayout(com.github.barteksc.pdfviewer.PDFView) -> g
    boolean shown() -> h
com.github.barteksc.pdfviewer.source.ByteArraySource -> q.a:
    byte[] data -> a
    com.shockwave.pdfium.PdfDocument createDocument(android.content.Context,com.shockwave.pdfium.PdfiumCore,java.lang.String) -> a
com.github.barteksc.pdfviewer.source.DocumentSource -> q.b:
    com.shockwave.pdfium.PdfDocument createDocument(android.content.Context,com.shockwave.pdfium.PdfiumCore,java.lang.String) -> a
com.github.barteksc.pdfviewer.source.UriSource -> q.c:
    android.net.Uri uri -> a
    com.shockwave.pdfium.PdfDocument createDocument(android.content.Context,com.shockwave.pdfium.PdfiumCore,java.lang.String) -> a
com.github.barteksc.pdfviewer.util.Constants -> r.a:
    float PART_SIZE -> c
    float THUMBNAIL_RATIO -> b
    int PRELOAD_OFFSET -> d
    boolean DEBUG_MODE -> a
com.github.barteksc.pdfviewer.util.Constants$Cache -> r.a$a:
    int THUMBNAILS_CACHE_SIZE -> b
    int CACHE_SIZE -> a
com.github.barteksc.pdfviewer.util.Constants$Pinch -> r.a$b:
    float MINIMUM_ZOOM -> b
    float MAXIMUM_ZOOM -> a
com.github.barteksc.pdfviewer.util.FitPolicy -> r.b:
    com.github.barteksc.pdfviewer.util.FitPolicy BOTH -> S2
    com.github.barteksc.pdfviewer.util.FitPolicy HEIGHT -> R2
    com.github.barteksc.pdfviewer.util.FitPolicy WIDTH -> Q2
    com.github.barteksc.pdfviewer.util.FitPolicy[] $VALUES -> T2
com.github.barteksc.pdfviewer.util.MathUtils -> r.c:
    int ceil(float) -> a
    int floor(float) -> b
    float limit(float,float,float) -> c
    float max(float,float) -> d
    float min(float,float) -> e
com.github.barteksc.pdfviewer.util.PageSizeCalculator -> r.d:
    float heightRatio -> h
    boolean fitEachPage -> i
    float widthRatio -> g
    com.github.barteksc.pdfviewer.util.FitPolicy fitPolicy -> a
    com.shockwave.pdfium.util.Size viewSize -> d
    com.shockwave.pdfium.util.Size originalMaxHeightPageSize -> c
    com.shockwave.pdfium.util.SizeF optimalMaxHeightPageSize -> f
    com.shockwave.pdfium.util.SizeF optimalMaxWidthPageSize -> e
    com.shockwave.pdfium.util.Size originalMaxWidthPageSize -> b
    com.shockwave.pdfium.util.SizeF calculate(com.shockwave.pdfium.util.Size) -> a
    void calculateMaxPages() -> b
    com.shockwave.pdfium.util.SizeF fitBoth(com.shockwave.pdfium.util.Size,float,float) -> c
    com.shockwave.pdfium.util.SizeF fitHeight(com.shockwave.pdfium.util.Size,float) -> d
    com.shockwave.pdfium.util.SizeF fitWidth(com.shockwave.pdfium.util.Size,float) -> e
    com.shockwave.pdfium.util.SizeF getOptimalMaxHeightPageSize() -> f
    com.shockwave.pdfium.util.SizeF getOptimalMaxWidthPageSize() -> g
com.github.barteksc.pdfviewer.util.PageSizeCalculator$1 -> r.d$a:
    int[] $SwitchMap$com$github$barteksc$pdfviewer$util$FitPolicy -> a
com.github.barteksc.pdfviewer.util.SnapEdge -> r.e:
    com.github.barteksc.pdfviewer.util.SnapEdge[] $VALUES -> U2
    com.github.barteksc.pdfviewer.util.SnapEdge START -> Q2
    com.github.barteksc.pdfviewer.util.SnapEdge CENTER -> R2
    com.github.barteksc.pdfviewer.util.SnapEdge END -> S2
    com.github.barteksc.pdfviewer.util.SnapEdge NONE -> T2
com.github.barteksc.pdfviewer.util.Util -> r.f:
    int getDP(android.content.Context,int) -> a
com.itextpdf.commons.actions.AbstractContextBasedEventHandler -> s.a:
    com.itextpdf.commons.actions.contexts.IContext defaultContext -> a
    void onEvent(com.itextpdf.commons.actions.IEvent) -> a
    void onAcceptedEvent(com.itextpdf.commons.actions.AbstractContextBasedITextEvent) -> b
com.itextpdf.commons.actions.AbstractContextBasedITextEvent -> s.b:
    com.itextpdf.commons.actions.contexts.IMetaInfo metaInfo -> c
    java.lang.Class getClassFromContext() -> d
    com.itextpdf.commons.actions.contexts.IMetaInfo getMetaInfo() -> e
com.itextpdf.commons.actions.AbstractEventWrapper -> s.c:
    com.itextpdf.commons.actions.AbstractProductProcessITextEvent event -> f
    java.lang.Class getClassFromContext() -> d
    java.lang.String getEventType() -> g
    com.itextpdf.commons.actions.AbstractProductProcessITextEvent getEvent() -> i
com.itextpdf.commons.actions.AbstractITextConfigurationEvent -> s.d:
    void addEvent(com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.AbstractProductProcessITextEvent) -> b
    void doAction() -> c
    com.itextpdf.commons.actions.processors.ITextProductEventProcessor getActiveProcessor(java.lang.String) -> d
    java.util.List getEvents(com.itextpdf.commons.actions.sequence.SequenceId) -> e
com.itextpdf.commons.actions.AbstractITextEvent -> s.e:
    java.util.Map INTERNAL_PACKAGES -> a
    void registerNamespace(java.lang.String) -> a
com.itextpdf.commons.actions.AbstractProductITextEvent -> s.f:
    com.itextpdf.commons.actions.data.ProductData productData -> b
    com.itextpdf.commons.actions.data.ProductData getProductData() -> b
    java.lang.String getProductName() -> c
com.itextpdf.commons.actions.AbstractProductProcessITextEvent -> s.g:
    java.lang.ref.WeakReference sequenceId -> d
    com.itextpdf.commons.actions.confirmations.EventConfirmationType confirmationType -> e
    com.itextpdf.commons.actions.confirmations.EventConfirmationType getConfirmationType() -> f
    java.lang.String getEventType() -> g
    com.itextpdf.commons.actions.sequence.SequenceId getSequenceId() -> h
com.itextpdf.commons.actions.AbstractStatisticsEvent -> s.h:
    org.slf4j.Logger LOGGER -> c
com.itextpdf.commons.actions.EventManager -> s.i:
    com.itextpdf.commons.actions.EventManager INSTANCE -> b
    java.util.Set handlers -> a
    com.itextpdf.commons.actions.EventManager getInstance() -> a
    void onEvent(com.itextpdf.commons.actions.IEvent) -> b
com.itextpdf.commons.actions.IEvent -> s.j:
com.itextpdf.commons.actions.IEventHandler -> s.k:
    void onEvent(com.itextpdf.commons.actions.IEvent) -> a
com.itextpdf.commons.actions.NamespaceConstant -> s.l:
    java.util.List ITEXT_CORE_NAMESPACES -> a
com.itextpdf.commons.actions.ProductEventHandler -> s.m:
    java.util.concurrent.ConcurrentHashMap processors -> b
    org.slf4j.Logger LOGGER -> e
    java.util.WeakHashMap events -> c
    com.itextpdf.commons.actions.ProductEventHandler INSTANCE -> d
    void onAcceptedEvent(com.itextpdf.commons.actions.AbstractContextBasedITextEvent) -> b
    void addEvent(com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.AbstractProductProcessITextEvent) -> c
    com.itextpdf.commons.actions.processors.ITextProductEventProcessor getActiveProcessor(java.lang.String) -> d
    java.util.List getEvents(com.itextpdf.commons.actions.sequence.SequenceId) -> e
    void tryProcessEvent(com.itextpdf.commons.actions.AbstractContextBasedITextEvent) -> f
    void wrapConfirmedEvent(com.itextpdf.commons.actions.confirmations.ConfirmEvent,com.itextpdf.commons.actions.processors.ITextProductEventProcessor) -> g
com.itextpdf.commons.actions.ProductNameConstant -> s.n:
    java.util.Set PRODUCT_NAMES -> a
com.itextpdf.commons.actions.ProductProcessorFactoryKeeper -> s.o:
    com.itextpdf.commons.actions.processors.IProductProcessorFactory productProcessorFactory -> b
    com.itextpdf.commons.actions.processors.IProductProcessorFactory DEFAULT_FACTORY -> a
    com.itextpdf.commons.actions.processors.IProductProcessorFactory getProductProcessorFactory() -> a
com.itextpdf.commons.actions.confirmations.ConfirmEvent -> t.a:
    com.itextpdf.commons.actions.AbstractProductProcessITextEvent getConfirmedEvent() -> j
com.itextpdf.commons.actions.confirmations.ConfirmedEventWrapper -> t.b:
    java.lang.String productUsageType -> g
    java.lang.String producerLine -> h
    java.lang.String getProducerLine() -> j
    java.lang.String getProductUsageType() -> k
com.itextpdf.commons.actions.confirmations.EventConfirmationType -> t.c:
    com.itextpdf.commons.actions.confirmations.EventConfirmationType[] $VALUES -> T2
    com.itextpdf.commons.actions.confirmations.EventConfirmationType UNCONFIRMABLE -> S2
    com.itextpdf.commons.actions.confirmations.EventConfirmationType ON_DEMAND -> Q2
    com.itextpdf.commons.actions.confirmations.EventConfirmationType ON_CLOSE -> R2
com.itextpdf.commons.actions.contexts.ContextManager -> u.a:
    com.itextpdf.commons.actions.contexts.ContextManager INSTANCE -> b
    java.util.SortedMap contextMappings -> a
    com.itextpdf.commons.actions.contexts.IContext getContext(java.lang.Class) -> a
    com.itextpdf.commons.actions.contexts.IContext getContext(java.lang.String) -> b
    com.itextpdf.commons.actions.contexts.ContextManager getInstance() -> c
    com.itextpdf.commons.actions.contexts.IContext getNamespaceMapping(java.lang.String) -> d
    java.lang.String getRecognisedNamespace(java.lang.String) -> e
    java.lang.String normalize(java.lang.String) -> f
    void registerGenericContext(java.util.Collection,java.util.Collection) -> g
com.itextpdf.commons.actions.contexts.ContextManager$1 -> u.a$a:
com.itextpdf.commons.actions.contexts.ContextManager$LengthComparator -> u.a$b:
    int compare(java.lang.String,java.lang.String) -> a
com.itextpdf.commons.actions.contexts.GenericContext -> u.b:
    java.util.Set supportedProducts -> a
    boolean isAllowed(com.itextpdf.commons.actions.AbstractContextBasedITextEvent) -> a
com.itextpdf.commons.actions.contexts.IContext -> u.c:
    boolean isAllowed(com.itextpdf.commons.actions.AbstractContextBasedITextEvent) -> a
com.itextpdf.commons.actions.contexts.IMetaInfo -> u.d:
com.itextpdf.commons.actions.contexts.UnknownContext -> u.e:
    com.itextpdf.commons.actions.contexts.IContext RESTRICTIVE -> b
    com.itextpdf.commons.actions.contexts.IContext PERMISSIVE -> c
    boolean allowEvents -> a
    boolean isAllowed(com.itextpdf.commons.actions.AbstractContextBasedITextEvent) -> a
com.itextpdf.commons.actions.data.ProductData -> v.a:
    int toCopyrightYear -> f
    java.lang.String publicProductName -> a
    int sinceCopyrightYear -> e
    java.lang.String version -> c
    java.lang.String productName -> b
    java.lang.String minimalCompatibleLicenseKeyVersion -> d
    java.lang.String getProductName() -> a
    java.lang.String getPublicProductName() -> b
    int getSinceCopyrightYear() -> c
    int getToCopyrightYear() -> d
    java.lang.String getVersion() -> e
com.itextpdf.commons.actions.processors.AbstractITextProductEventProcessor -> w.a:
    java.lang.String productName -> a
    java.lang.String getProducer() -> c
com.itextpdf.commons.actions.processors.DefaultITextProductEventProcessor -> w.b:
    java.util.concurrent.atomic.AtomicLong counter -> c
    int MAX_LVL -> i
    java.lang.Object lock -> b
    org.slf4j.Logger LOGGER -> g
    java.util.concurrent.atomic.AtomicLong repeatLevel -> e
    java.util.concurrent.atomic.AtomicLong level -> d
    long[] REPEAT -> h
    byte[] MESSAGE_FOR_LOGGING -> f
    java.lang.String getUsageType() -> a
    void onEvent(com.itextpdf.commons.actions.AbstractProductProcessITextEvent) -> b
    long acquireRepeatLevel(int) -> d
com.itextpdf.commons.actions.processors.DefaultProductProcessorFactory -> w.c:
    com.itextpdf.commons.actions.processors.ITextProductEventProcessor createProcessor(java.lang.String) -> a
com.itextpdf.commons.actions.processors.IProductProcessorFactory -> w.d:
    com.itextpdf.commons.actions.processors.ITextProductEventProcessor createProcessor(java.lang.String) -> a
com.itextpdf.commons.actions.processors.ITextProductEventProcessor -> w.e:
    java.lang.String getUsageType() -> a
    void onEvent(com.itextpdf.commons.actions.AbstractProductProcessITextEvent) -> b
    java.lang.String getProducer() -> c
com.itextpdf.commons.actions.producer.AbstractFormattedPlaceholderPopulator -> x.a:
    int attachQuotedString(int,java.lang.StringBuilder,char[]) -> b
    boolean isLetter(char) -> c
com.itextpdf.commons.actions.producer.CopyrightSincePlaceholderPopulator -> x.b:
    java.lang.String populate(java.util.List,java.lang.String) -> a
com.itextpdf.commons.actions.producer.CopyrightToPlaceholderPopulator -> x.c:
    java.lang.String populate(java.util.List,java.lang.String) -> a
com.itextpdf.commons.actions.producer.CurrentDatePlaceholderPopulator -> x.d:
    java.util.Set ALLOWED_PATTERNS -> a
    java.lang.String populate(java.util.List,java.lang.String) -> a
    java.lang.String formatDate(java.util.Date,java.lang.String) -> d
    int processDateComponent(int,java.util.Date,java.lang.StringBuilder,char[]) -> e
com.itextpdf.commons.actions.producer.IPlaceholderPopulator -> x.e:
    java.lang.String populate(java.util.List,java.lang.String) -> a
com.itextpdf.commons.actions.producer.ProducerBuilder -> x.f:
    org.slf4j.Logger LOGGER -> b
    java.util.regex.Pattern PATTERN -> d
    com.itextpdf.commons.actions.producer.ProducerBuilder INSTANCE -> c
    java.util.Map PLACEHOLDER_POPULATORS -> e
    void doAction() -> c
    java.lang.String buildProducer(java.util.List) -> f
    java.lang.String modifyProducer(java.util.List,java.lang.String) -> g
    java.lang.String populatePlaceholders(java.lang.String,java.util.List) -> h
com.itextpdf.commons.actions.producer.UsedProductsPlaceholderPopulator -> x.g:
    java.lang.String populate(java.util.List,java.lang.String) -> a
    java.lang.String formatLetter(char,com.itextpdf.commons.actions.producer.UsedProductsPlaceholderPopulator$ProductRepresentation) -> d
    java.lang.String formatProduct(com.itextpdf.commons.actions.producer.UsedProductsPlaceholderPopulator$ProductRepresentation,java.lang.String) -> e
com.itextpdf.commons.actions.producer.UsedProductsPlaceholderPopulator$ProductRepresentation -> x.g$a:
    java.util.Map PRODUCT_USAGE_TYPE_TO_HUMAN_READABLE_FORM -> d
    java.lang.String productName -> a
    java.lang.String version -> c
    java.lang.String productUsageType -> b
    java.lang.String getProductName() -> a
    java.lang.String getProductUsageType() -> b
    java.lang.String getVersion() -> c
com.itextpdf.commons.actions.sequence.AbstractIdentifiableElement -> y.a:
    com.itextpdf.commons.actions.sequence.SequenceId sequenceId -> Q2
    com.itextpdf.commons.actions.sequence.SequenceId getSequenceId() -> y
com.itextpdf.commons.actions.sequence.SequenceId -> y.b:
    java.util.concurrent.atomic.AtomicLong ID_GENERATOR -> b
    long id -> a
    long getId() -> a
com.itextpdf.commons.actions.sequence.SequenceIdManager -> y.c:
    com.itextpdf.commons.actions.sequence.SequenceId getSequenceId(com.itextpdf.commons.actions.sequence.AbstractIdentifiableElement) -> a
com.itextpdf.commons.exceptions.AggregatedException -> z.a:
    java.util.List aggregatedExceptions -> Q2
com.itextpdf.commons.exceptions.ITextException -> z.b:
com.itextpdf.commons.exceptions.UnknownProductException -> z.c:
com.itextpdf.commons.utils.Base64 -> a0.a:
    byte[] _STANDARD_DECODABET -> b
    byte[] _STANDARD_ALPHABET -> a
    byte[] _URL_SAFE_DECODABET -> d
    byte[] _URL_SAFE_ALPHABET -> c
    byte[] _ORDERED_DECODABET -> f
    byte[] _ORDERED_ALPHABET -> e
    byte[] decode(java.lang.String) -> a
    byte[] decode(java.lang.String,int) -> b
    byte[] decode(byte[],int,int,int) -> c
    int decode4to3(byte[],int,byte[],int,int) -> d
    byte[] getDecodabet(int) -> e
com.itextpdf.commons.utils.DateTimeUtil -> a0.b:
    java.lang.String format(java.util.Date,java.lang.String) -> a
    java.util.Date getCurrentTimeDate() -> b
    java.text.DateFormat initParserSDF(java.lang.String) -> c
com.itextpdf.commons.utils.EncodingUtil -> a0.c:
    byte[] convertToBytes(char[],java.lang.String) -> a
    java.lang.String convertToString(byte[],java.lang.String) -> b
com.itextpdf.commons.utils.FileUtil -> a0.d:
    java.io.PrintWriter createPrintWriter(java.io.OutputStream,java.lang.String) -> a
    java.io.OutputStream getBufferedOutputStream(java.lang.String) -> b
    java.io.OutputStream wrapWithBufferedOutputStream(java.io.OutputStream) -> c
com.itextpdf.commons.utils.MessageFormatUtil -> a0.e:
    java.lang.String format(java.lang.String,java.lang.Object[]) -> a
com.itextpdf.commons.utils.SystemUtil -> a0.f:
    long getFreeMemory() -> a
    long getTimeBasedSeed() -> b
com.itextpdf.io.codec.BitFile -> b0.a:
    java.io.OutputStream output -> a
    byte[] buffer -> b
    boolean blocks -> e
    int bitsLeft -> d
    int index -> c
    void flush() -> a
    void writeBits(int,int) -> b
com.itextpdf.io.codec.CCITTG4Encoder -> b0.b:
    byte[] zeroruns -> p
    byte[] oneruns -> q
    int offsetData -> h
    int sizeData -> i
    com.itextpdf.io.source.ByteBuffer outBuf -> f
    int data -> d
    int rowpixels -> b
    int bit -> c
    int rowbytes -> a
    int[][] vcodes -> n
    int[][] TIFFFaxBlackCodes -> k
    byte[] dataBp -> g
    int[][] TIFFFaxWhiteCodes -> j
    int[] msbmask -> o
    int[] horizcode -> l
    byte[] refline -> e
    int[] passcode -> m
    void Fax3Encode2DRow() -> a
    void Fax4PostEncode() -> b
    byte[] close() -> c
    byte[] compress(byte[],int,int) -> d
    void fax4Encode(byte[],int) -> e
    void fax4Encode(byte[],int,int) -> f
    int find0span(byte[],int,int,int) -> g
    int find1span(byte[],int,int,int) -> h
    int finddiff(byte[],int,int,int,int) -> i
    int finddiff2(byte[],int,int,int,int) -> j
    int pixel(byte[],int,int) -> k
    void putBits(int,int) -> l
    void putcode(int[]) -> m
    void putspan(int,int[][]) -> n
com.itextpdf.io.codec.Jbig2SegmentReader -> b0.c:
    java.util.Map segments -> a
    java.util.Map pages -> b
    java.util.Set globals -> c
    boolean sequential -> e
    boolean number_of_pages_known -> f
    int number_of_pages -> g
    boolean read -> h
    com.itextpdf.io.source.RandomAccessFileOrArray ra -> d
    byte[] copyByteArray(byte[]) -> a
    byte[] getGlobal(boolean) -> b
    com.itextpdf.io.codec.Jbig2SegmentReader$Jbig2Page getPage(int) -> c
    int numberOfPages() -> d
    void read() -> e
    void readFileHeader() -> f
    com.itextpdf.io.codec.Jbig2SegmentReader$Jbig2Segment readHeader() -> g
    void readSegment(com.itextpdf.io.codec.Jbig2SegmentReader$Jbig2Segment) -> h
com.itextpdf.io.codec.Jbig2SegmentReader$Jbig2Page -> b0.c$a:
    com.itextpdf.io.codec.Jbig2SegmentReader sr -> b
    java.util.Map segs -> c
    int pageBitmapWidth -> d
    int pageBitmapHeight -> e
    int page -> a
    void addSegment(com.itextpdf.io.codec.Jbig2SegmentReader$Jbig2Segment) -> a
    byte[] getData(boolean) -> b
com.itextpdf.io.codec.Jbig2SegmentReader$Jbig2Segment -> b0.c$b:
    int type -> V2
    boolean deferredNonRetain -> W2
    int page -> S2
    int countOfReferredToSegments -> X2
    long dataLength -> R2
    byte[] headerData -> Z2
    byte[] data -> Y2
    boolean page_association_size -> a3
    int segmentNumber -> Q2
    int page_association_offset -> b3
    int[] referredToSegmentNumbers -> T2
    boolean[] segmentRetentionFlags -> U2
    int compareTo(com.itextpdf.io.codec.Jbig2SegmentReader$Jbig2Segment) -> a
com.itextpdf.io.codec.LZWCompressor -> b0.d:
    short prefix_ -> f
    boolean tiffFudge_ -> i
    int numBits_ -> d
    com.itextpdf.io.codec.LZWStringTable lzss_ -> h
    int limit_ -> e
    int clearCode_ -> b
    com.itextpdf.io.codec.BitFile bf_ -> g
    int endOfInfo_ -> c
    int codeSize_ -> a
    void compress(byte[],int,int) -> a
    void flush() -> b
com.itextpdf.io.codec.LZWStringTable -> b0.e:
    byte[] strChr_ -> a
    int[] strLen_ -> e
    short[] strNxt_ -> b
    short[] strHsh_ -> c
    short numStrings_ -> d
    int AddCharString(short,byte) -> a
    void ClearTable(int) -> b
    short FindCharString(short,byte) -> c
    int Hash(short,byte) -> d
com.itextpdf.io.codec.PngWriter -> b0.f:
    java.io.OutputStream outp -> a
    byte[] PNG_SIGNTURE -> b
    int[] crc_table -> h
    byte[] iCCP -> g
    byte[] PLTE -> d
    byte[] IHDR -> c
    byte[] IEND -> f
    byte[] IDAT -> e
    void make_crc_table() -> a
    void outputInt(int) -> b
    void outputInt(int,java.io.OutputStream) -> c
    int update_crc(int,byte[],int,int) -> d
    void writeChunk(byte[],byte[]) -> e
    void writeData(byte[],int) -> f
    void writeEnd() -> g
    void writeHeader(int,int,int,int) -> h
    void writeIccProfile(byte[]) -> i
    void writePalette(byte[]) -> j
com.itextpdf.io.codec.TIFFDirectory -> b0.g:
    int[] sizeOfType -> g
    java.util.Map fieldIndex -> d
    long nextIFDOffset -> f
    long IFDOffset -> e
    boolean isBigEndian -> a
    int numEntries -> b
    com.itextpdf.io.codec.TIFFField[] fields -> c
    com.itextpdf.io.codec.TIFFField getField(int) -> a
    long getFieldAsLong(int) -> b
    long getFieldAsLong(int,int) -> c
    void initialize(com.itextpdf.io.source.RandomAccessFileOrArray) -> d
    boolean isTagPresent(int) -> e
    boolean isValidEndianTag(int) -> f
    double readDouble(com.itextpdf.io.source.RandomAccessFileOrArray) -> g
    float readFloat(com.itextpdf.io.source.RandomAccessFileOrArray) -> h
    int readInt(com.itextpdf.io.source.RandomAccessFileOrArray) -> i
    short readShort(com.itextpdf.io.source.RandomAccessFileOrArray) -> j
    long readUnsignedInt(com.itextpdf.io.source.RandomAccessFileOrArray) -> k
    int readUnsignedShort(com.itextpdf.io.source.RandomAccessFileOrArray) -> l
com.itextpdf.io.codec.TIFFFaxDecoder -> b0.h:
    int oneD -> n
    int uncompressedMode -> l
    boolean recoverFromImageError -> o
    byte[] flipTable -> r
    int fillBits -> m
    int lastChangingElement -> j
    int compression -> k
    int fillOrder -> f
    byte[] twoDCodes -> x
    int changingElemSize -> g
    int w -> d
    int h -> e
    int bytePointer -> b
    int bitPointer -> a
    short[] black -> w
    int[] prevChangingElems -> h
    int[] currChangingElems -> i
    int[] table1 -> p
    int[] table2 -> q
    short[] additionalMakeup -> t
    byte[] data -> c
    short[] white -> s
    short[] twoBitBlack -> v
    short[] initBlack -> u
    boolean advancePointer() -> a
    void decode1D(byte[],byte[],int,int) -> b
    void decode2D(byte[],byte[],int,int,long) -> c
    int decodeBlackCodeWord() -> d
    void decodeNextScanline(byte[],int,int) -> e
    void decodeT6(byte[],byte[],int,int,long) -> f
    int decodeWhiteCodeWord() -> g
    void getNextChangingElement(int,boolean,int[]) -> h
    int nextLesserThan8Bits(int) -> i
    int nextNBits(int) -> j
    int readEOL(boolean) -> k
    void reverseBits(byte[]) -> l
    void setRecoverFromImageError(boolean) -> m
    void setToBlack(byte[],int,int,int) -> n
    void updatePointer(int) -> o
com.itextpdf.io.codec.TIFFFaxDecompressor -> b0.i:
    int h -> n
    int[] table2 -> w
    int bitPointer -> j
    int[] currChangingElems -> s
    int oneD -> h
    int uncompressedMode -> f
    int t6Options -> d
    short[] initBlack -> A
    int compression -> b
    short[] black -> C
    short[] additionalMakeup -> z
    java.lang.Object lock -> u
    int changingElemSize -> q
    int[] table1 -> v
    int bitsPerScanline -> o
    int w -> m
    byte[] buffer -> l
    int[] prevChangingElems -> r
    int bytePointer -> k
    byte[] flipTable -> x
    int fillBits -> g
    short[] twoBitBlack -> B
    int fails -> e
    int t4Options -> c
    int fillOrder -> a
    short[] white -> y
    int lastChangingElement -> t
    byte[] data -> i
    byte[] twoDCodes -> D
    int lineBitNum -> p
    void SetOptions(int,int,int,int) -> a
    int decodeBlackCodeWord() -> b
    void decodeNextScanline() -> c
    void decodeRLE() -> d
    void decodeRaw(byte[],byte[],int,int) -> e
    void decodeT4() -> f
    void decodeT6() -> g
    int decodeWhiteCodeWord() -> h
    int findNextLine() -> i
    void getNextChangingElement(int,boolean,int[]) -> j
    int nextLesserThan8Bits(int) -> k
    int nextNBits(int) -> l
    void setToBlack(int,int) -> m
    void updatePointer(int) -> n
com.itextpdf.io.codec.TIFFField -> b0.j:
    int count -> S2
    int tag -> Q2
    int type -> R2
    java.lang.Object data -> T2
    long[] getAsRational(int) -> A
    int getTag() -> B
    int getType() -> C
    int compareTo(com.itextpdf.io.codec.TIFFField) -> a
    byte[] getAsBytes() -> c
    char[] getAsChars() -> d
    int getAsInt(int) -> k
    long getAsLong(int) -> n
    long[] getAsLongs() -> x
com.itextpdf.io.codec.TIFFLZWDecoder -> b0.k:
    int nextBits -> n
    int samplesPerPixel -> l
    int nextData -> m
    int h -> j
    int predictor -> k
    int dstIndex -> h
    int w -> i
    int bytePointer -> f
    int bitPointer -> g
    int tableIndex -> d
    int bitsToGet -> e
    byte[] data -> b
    int[] andTable -> o
    byte[][] stringTable -> a
    byte[] uncompData -> c
    void addStringToTable(byte[]) -> a
    void addStringToTable(byte[],byte) -> b
    byte[] composeString(byte[],byte) -> c
    byte[] decode(byte[],byte[],int) -> d
    int getNextCode() -> e
    void initializeStringTable() -> f
    void writeString(byte[]) -> g
com.itextpdf.io.codec.TiffWriter -> b0.l:
    java.util.TreeMap ifd -> a
    void addField(com.itextpdf.io.codec.TiffWriter$FieldBase) -> a
    void compressLZW(java.io.OutputStream,int,byte[],int,int,int) -> b
    int getIfdSize() -> c
    void writeFile(java.io.OutputStream) -> d
    void writeLong(int,java.io.OutputStream) -> e
    void writeShort(int,java.io.OutputStream) -> f
com.itextpdf.io.codec.TiffWriter$FieldAscii -> b0.l$a:
com.itextpdf.io.codec.TiffWriter$FieldBase -> b0.l$b:
    int offset -> e
    int fieldType -> b
    byte[] data -> d
    int count -> c
    int tag -> a
    int getTag() -> a
    int getValueSize() -> b
    void setOffset(int) -> c
    void writeField(java.io.OutputStream) -> d
    void writeValue(java.io.OutputStream) -> e
com.itextpdf.io.codec.TiffWriter$FieldImage -> b0.l$c:
com.itextpdf.io.codec.TiffWriter$FieldLong -> b0.l$d:
com.itextpdf.io.codec.TiffWriter$FieldRational -> b0.l$e:
com.itextpdf.io.codec.TiffWriter$FieldShort -> b0.l$f:
com.itextpdf.io.codec.TiffWriter$FieldUndefined -> b0.l$g:
com.itextpdf.io.codec.brotli.dec.BitReader -> c0.a:
    byte[] byteBuffer -> a
    com.itextpdf.io.codec.brotli.dec.IntReader intReader -> c
    int[] intBuffer -> b
    long accumulator -> f
    int intOffset -> h
    int tailBytes -> i
    boolean endOfStreamReached -> e
    int bitOffset -> g
    java.io.InputStream input -> d
    void checkHealth(com.itextpdf.io.codec.brotli.dec.BitReader,boolean) -> a
    void close(com.itextpdf.io.codec.brotli.dec.BitReader) -> b
    void copyBytes(com.itextpdf.io.codec.brotli.dec.BitReader,byte[],int,int) -> c
    void fillBitWindow(com.itextpdf.io.codec.brotli.dec.BitReader) -> d
    void init(com.itextpdf.io.codec.brotli.dec.BitReader,java.io.InputStream) -> e
    int intAvailable(com.itextpdf.io.codec.brotli.dec.BitReader) -> f
    void jumpToByteBoundary(com.itextpdf.io.codec.brotli.dec.BitReader) -> g
    void prepare(com.itextpdf.io.codec.brotli.dec.BitReader) -> h
    int readBits(com.itextpdf.io.codec.brotli.dec.BitReader,int) -> i
    void readMoreInput(com.itextpdf.io.codec.brotli.dec.BitReader) -> j
    void reload(com.itextpdf.io.codec.brotli.dec.BitReader) -> k
com.itextpdf.io.codec.brotli.dec.BrotliInputStream -> c0.b:
    byte[] buffer -> Q2
    int bufferOffset -> S2
    com.itextpdf.io.codec.brotli.dec.State state -> T2
    int remainingBufferBytes -> R2
com.itextpdf.io.codec.brotli.dec.BrotliRuntimeException -> c0.c:
com.itextpdf.io.codec.brotli.dec.Context -> c0.d:
    int[] LOOKUP_OFFSETS -> b
    int[] LOOKUP -> a
com.itextpdf.io.codec.brotli.dec.Decode -> c0.e:
    int[] DISTANCE_SHORT_CODE_INDEX_OFFSET -> b
    int[] DISTANCE_SHORT_CODE_VALUE_OFFSET -> c
    int[] FIXED_TABLE -> d
    int[] CODE_LENGTH_CODE_ORDER -> a
    void copyUncompressedData(com.itextpdf.io.codec.brotli.dec.State) -> a
    void decodeBlockTypeAndLength(com.itextpdf.io.codec.brotli.dec.State,int) -> b
    void decodeCommandBlockSwitch(com.itextpdf.io.codec.brotli.dec.State) -> c
    int decodeContextMap(int,byte[],com.itextpdf.io.codec.brotli.dec.BitReader) -> d
    void decodeDistanceBlockSwitch(com.itextpdf.io.codec.brotli.dec.State) -> e
    void decodeLiteralBlockSwitch(com.itextpdf.io.codec.brotli.dec.State) -> f
    void decodeMetaBlockLength(com.itextpdf.io.codec.brotli.dec.BitReader,com.itextpdf.io.codec.brotli.dec.State) -> g
    int decodeVarLenUnsignedByte(com.itextpdf.io.codec.brotli.dec.BitReader) -> h
    void decompress(com.itextpdf.io.codec.brotli.dec.State) -> i
    void inverseMoveToFrontTransform(byte[],int) -> j
    void maybeReallocateRingBuffer(com.itextpdf.io.codec.brotli.dec.State) -> k
    void moveToFront(int[],int) -> l
    int readBlockLength(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader) -> m
    void readHuffmanCode(int,int[],int,com.itextpdf.io.codec.brotli.dec.BitReader) -> n
    void readHuffmanCodeLengths(int[],int,int[],com.itextpdf.io.codec.brotli.dec.BitReader) -> o
    void readMetablockHuffmanCodesAndContextMaps(com.itextpdf.io.codec.brotli.dec.State) -> p
    void readMetablockInfo(com.itextpdf.io.codec.brotli.dec.State) -> q
    int readSymbol(int[],int,com.itextpdf.io.codec.brotli.dec.BitReader) -> r
    void setCustomDictionary(com.itextpdf.io.codec.brotli.dec.State,byte[]) -> s
    int translateShortCodes(int,int[],int) -> t
    boolean writeRingBuffer(com.itextpdf.io.codec.brotli.dec.State) -> u
com.itextpdf.io.codec.brotli.dec.Dictionary -> c0.f:
    int[] OFFSETS_BY_LENGTH -> b
    int[] SIZE_BITS_BY_LENGTH -> c
    java.nio.ByteBuffer data -> a
    java.nio.ByteBuffer getData() -> a
com.itextpdf.io.codec.brotli.dec.Dictionary$DataLoader -> c0.f$a:
    boolean OK -> a
com.itextpdf.io.codec.brotli.dec.Huffman -> c0.g:
    void buildHuffmanTable(int[],int,int,int[],int) -> a
    int getNextKey(int,int) -> b
    int nextTableBitSize(int[],int,int) -> c
    void replicateValue(int[],int,int,int,int) -> d
com.itextpdf.io.codec.brotli.dec.HuffmanTreeGroup -> c0.h:
    int[] codes -> b
    int[] trees -> c
    int alphabetSize -> a
    void decode(com.itextpdf.io.codec.brotli.dec.HuffmanTreeGroup,com.itextpdf.io.codec.brotli.dec.BitReader) -> a
    void init(com.itextpdf.io.codec.brotli.dec.HuffmanTreeGroup,int,int) -> b
com.itextpdf.io.codec.brotli.dec.IntReader -> c0.i:
    byte[] byteBuffer -> a
    int[] intBuffer -> b
    void convert(com.itextpdf.io.codec.brotli.dec.IntReader,int) -> a
    void init(com.itextpdf.io.codec.brotli.dec.IntReader,byte[],int[]) -> b
com.itextpdf.io.codec.brotli.dec.Prefix -> c0.j:
    int[] COPY_LENGTH_N_BITS -> f
    int[] INSERT_RANGE_LUT -> g
    int[] COPY_RANGE_LUT -> h
    int[] BLOCK_LENGTH_N_BITS -> b
    int[] INSERT_LENGTH_OFFSET -> c
    int[] INSERT_LENGTH_N_BITS -> d
    int[] COPY_LENGTH_OFFSET -> e
    int[] BLOCK_LENGTH_OFFSET -> a
com.itextpdf.io.codec.brotli.dec.State -> c0.k:
    int maxBackwardDistance -> O
    com.itextpdf.io.codec.brotli.dec.HuffmanTreeGroup hGroup2 -> m
    boolean isUncompressed -> i
    int distancePostfixBits -> K
    boolean trivialLiteralContext -> u
    int distanceCode -> G
    com.itextpdf.io.codec.brotli.dec.BitReader br -> c
    int distContextMapSlice -> C
    int[] blockLenTrees -> f
    int bytesWritten -> X
    int insertLength -> y
    int[] blockLength -> n
    int bytesToIgnore -> T
    boolean inputEnd -> h
    byte[] ringBuffer -> d
    int maxRingBufferSize -> P
    int distance -> L
    boolean isMetadata -> j
    byte[] contextModes -> z
    int contextLookupOffset1 -> D
    int runningState -> a
    int[] blockTypeTrees -> e
    int bytesToWrite -> Y
    int literalTreeIndex -> v
    byte[] distContextMap -> H
    int[] distRb -> q
    int outputOffset -> U
    int pos -> r
    int ringBufferSize -> Q
    com.itextpdf.io.codec.brotli.dec.HuffmanTreeGroup hGroup0 -> k
    int copyLength -> M
    int numDirectDistanceCodes -> I
    byte[] output -> Z
    int contextLookupOffset2 -> E
    int nextRunningState -> b
    byte[] contextMap -> A
    long expectedTotalSize -> R
    int outputLength -> V
    int literalTree -> w
    int[] blockTypeRb -> p
    int maxDistance -> s
    int copyDst -> N
    com.itextpdf.io.codec.brotli.dec.HuffmanTreeGroup hGroup1 -> l
    int distancePostfixMask -> J
    int treeCommandOffset -> F
    int metaBlockLength -> g
    int contextMapSlice -> B
    byte[] customDictionary -> S
    int j -> x
    int[] numBlockTypes -> o
    int outputUsed -> W
    int distRbIdx -> t
    void close(com.itextpdf.io.codec.brotli.dec.State) -> a
    int decodeWindowBits(com.itextpdf.io.codec.brotli.dec.BitReader) -> b
    void setInput(com.itextpdf.io.codec.brotli.dec.State,java.io.InputStream) -> c
com.itextpdf.io.codec.brotli.dec.Transform -> c0.l:
    byte[] prefix -> a
    int type -> b
    byte[] suffix -> c
    com.itextpdf.io.codec.brotli.dec.Transform[] TRANSFORMS -> d
    byte[] readUniBytes(java.lang.String) -> a
    int transformDictionaryWord(byte[],int,java.nio.ByteBuffer,int,int,com.itextpdf.io.codec.brotli.dec.Transform) -> b
com.itextpdf.io.codec.brotli.dec.Utils -> c0.m:
    byte[] BYTE_ZEROES -> a
    int[] INT_ZEROES -> b
    void fillWithZeroes(byte[],int,int) -> a
    void fillWithZeroes(int[],int,int) -> b
com.itextpdf.io.codec.brotli.dec.WordTransformType -> c0.n:
    int getOmitFirst(int) -> a
    int getOmitLast(int) -> b
com.itextpdf.io.colors.IccProfile -> d0.a:
    java.util.Map cstags -> c
    byte[] data -> a
    int numComponents -> b
    byte[] getData() -> a
    java.lang.String getIccColorSpaceName(byte[]) -> b
    java.lang.Integer getIccNumberOfComponents(byte[]) -> c
    com.itextpdf.io.colors.IccProfile getInstance(byte[]) -> d
    com.itextpdf.io.colors.IccProfile getInstance(byte[],int) -> e
    int getNumComponents() -> f
com.itextpdf.io.exceptions.FontCompressionException -> e0.a:
com.itextpdf.io.exceptions.IOException -> e0.b:
    java.util.List messageParams -> R2
    java.lang.Object obj -> Q2
    java.lang.Object[] getMessageParams() -> a
    com.itextpdf.io.exceptions.IOException setMessageParams(java.lang.Object[]) -> b
com.itextpdf.io.font.AdobeGlyphList -> f0.a:
    java.util.Map unicode2names -> a
    java.util.Map names2unicode -> b
    int nameToUnicode(java.lang.String) -> a
    java.lang.String unicodeToName(int) -> b
com.itextpdf.io.font.CFFFont -> f0.b:
    java.lang.Object[] args -> c
    int gsubrIndexOffset -> j
    int topdictIndexOffset -> h
    int stringIndexOffset -> i
    int offSize -> f
    int nameIndexOffset -> g
    int arg_count -> d
    com.itextpdf.io.font.CFFFont$Font[] fonts -> o
    com.itextpdf.io.source.RandomAccessSourceFactory rasFactory -> p
    com.itextpdf.io.source.RandomAccessFileOrArray buf -> e
    int nextIndexOffset -> a
    int[] gsubrOffsets -> n
    java.lang.String[] operatorNames -> q
    java.lang.String key -> b
    int[] nameOffsets -> k
    int[] topdictOffsets -> l
    int[] stringOffsets -> m
    java.lang.String[] standardStrings -> r
    char getCard16() -> a
    char getCard8() -> b
    void getDictItem() -> c
    com.itextpdf.io.font.CFFFont$RangeItem getEntireIndexRange(int) -> d
    int[] getIndex(int) -> e
    int getInt() -> f
    java.lang.String[] getNames() -> g
    int getOffset(int) -> h
    int getPosition() -> i
    short getShort() -> j
    java.lang.String getString(char) -> k
    boolean isCID() -> l
    boolean isCID(java.lang.String) -> m
    void seek(int) -> n
com.itextpdf.io.font.CFFFont$DictNumberItem -> f0.b$a:
    int value -> b
    int size -> c
    void emit(byte[]) -> a
    void increment(int[]) -> b
com.itextpdf.io.font.CFFFont$DictOffsetItem -> f0.b$b:
    int size -> c
    void emit(byte[]) -> a
    void increment(int[]) -> b
com.itextpdf.io.font.CFFFont$Font -> f0.b$c:
    int nglyphs -> n
    int[] PrivateSubrsOffset -> y
    int fdarrayOffset -> j
    int encodingOffset -> h
    int privateSubrs -> f
    int[][] PrivateSubrsOffsetsArray -> z
    int privateOffset -> d
    int[] SubrsOffsets -> A
    com.itextpdf.io.font.CFFFont this$0 -> C
    int FDArrayOffsize -> w
    java.lang.String name -> a
    int CharstringType -> u
    int FDSelectLength -> s
    int[] fdprivateOffsets -> l
    int nstrings -> o
    int[] FDArrayOffsets -> x
    int[] FDSelect -> r
    int fdselectOffset -> k
    int charsetOffset -> i
    int charstringsOffset -> g
    int privateLength -> e
    int[] gidToCid -> B
    int FDArrayCount -> v
    int FDSelectFormat -> t
    int[] charstringsOffsets -> q
    java.lang.String fullName -> b
    boolean isCID -> c
    int CharsetLength -> p
    int[] fdprivateLengths -> m
com.itextpdf.io.font.CFFFont$IndexBaseItem -> f0.b$d:
com.itextpdf.io.font.CFFFont$IndexMarkerItem -> f0.b$e:
    com.itextpdf.io.font.CFFFont$IndexBaseItem indexBase -> c
    com.itextpdf.io.font.CFFFont$OffsetItem offItem -> b
    void xref() -> c
com.itextpdf.io.font.CFFFont$IndexOffsetItem -> f0.b$f:
    int size -> c
    void emit(byte[]) -> a
    void increment(int[]) -> b
com.itextpdf.io.font.CFFFont$Item -> f0.b$g:
    int myOffset -> a
    void emit(byte[]) -> a
    void increment(int[]) -> b
    void xref() -> c
com.itextpdf.io.font.CFFFont$MarkerItem -> f0.b$h:
    com.itextpdf.io.font.CFFFont$OffsetItem p -> b
    void xref() -> c
com.itextpdf.io.font.CFFFont$OffsetItem -> f0.b$i:
    int value -> b
    void set(int) -> d
com.itextpdf.io.font.CFFFont$RangeItem -> f0.b$j:
    int offset -> b
    int length -> c
    com.itextpdf.io.source.RandomAccessFileOrArray buf -> d
    void emit(byte[]) -> a
    void increment(int[]) -> b
com.itextpdf.io.font.CFFFont$StringItem -> f0.b$k:
    java.lang.String s -> b
    void emit(byte[]) -> a
    void increment(int[]) -> b
com.itextpdf.io.font.CFFFont$SubrMarkerItem -> f0.b$l:
    com.itextpdf.io.font.CFFFont$IndexBaseItem indexBase -> c
    com.itextpdf.io.font.CFFFont$OffsetItem offItem -> b
    void xref() -> c
com.itextpdf.io.font.CFFFont$UInt16Item -> f0.b$m:
    char value -> b
    void emit(byte[]) -> a
    void increment(int[]) -> b
com.itextpdf.io.font.CFFFont$UInt24Item -> f0.b$n:
    int value -> b
    void emit(byte[]) -> a
    void increment(int[]) -> b
com.itextpdf.io.font.CFFFont$UInt32Item -> f0.b$o:
    int value -> b
    void emit(byte[]) -> a
    void increment(int[]) -> b
com.itextpdf.io.font.CFFFont$UInt8Item -> f0.b$p:
    char value -> b
    void emit(byte[]) -> a
    void increment(int[]) -> b
com.itextpdf.io.font.CFFFontSubset -> f0.c:
    java.util.Set hGSubrsUsed -> x
    java.util.Set hSubrsUsedNonCID -> z
    java.util.Set GlyphsUsed -> s
    java.util.List glyphsInList -> t
    java.util.Set FDArrayUsed -> u
    com.itextpdf.io.util.GenericArray hSubrsUsed -> v
    int NumOfHints -> H
    com.itextpdf.io.util.GenericArray lSubrsUsed -> w
    int GBias -> F
    java.util.List lGSubrsUsed -> y
    java.util.List lSubrsUsedNonCID -> A
    java.lang.String[] SubrsFunctions -> I
    java.lang.String[] SubrsEscapeFuncs -> J
    byte[][] NewLSubrsIndex -> B
    java.util.LinkedList OutputList -> G
    byte[] NewGSubrsIndex -> D
    byte[] NewSubrsIndexNonCID -> C
    byte[] NewCharStringsIndex -> E
    int CalcHints(int,int,int,int,int[]) -> A
    int CalcSubrOffsetSize(int,int) -> B
    void CopyHeader() -> C
    int CountCharset(int,int) -> D
    int CountRange(int,int) -> E
    void CreateCharset(com.itextpdf.io.font.CFFFont$OffsetItem,int) -> F
    void CreateFDArray(com.itextpdf.io.font.CFFFont$OffsetItem,com.itextpdf.io.font.CFFFont$OffsetItem,int) -> G
    void CreateFDSelect(com.itextpdf.io.font.CFFFont$OffsetItem,int) -> H
    void CreateKeys(com.itextpdf.io.font.CFFFont$OffsetItem,com.itextpdf.io.font.CFFFont$OffsetItem,com.itextpdf.io.font.CFFFont$OffsetItem,com.itextpdf.io.font.CFFFont$OffsetItem) -> I
    void CreateNewStringIndex(int) -> J
    void CreateNonCIDPrivate(int,com.itextpdf.io.font.CFFFont$OffsetItem) -> K
    void CreateNonCIDSubrs(int,com.itextpdf.io.font.CFFFont$IndexBaseItem,com.itextpdf.io.font.CFFFont$OffsetItem) -> L
    void EmptyStack() -> M
    void HandelStack() -> N
    void PopStack() -> O
    byte[] Process() -> P
    byte[] Process(java.lang.String) -> Q
    void PushStack() -> R
    void ReadASubr(int,int,int,int,java.util.Set,java.util.List,int[]) -> S
    void ReadCommand() -> T
    void ReadFDArray(int) -> U
    void Reconstruct(int) -> V
    void ReconstructFDArray(int,com.itextpdf.io.font.CFFFont$OffsetItem[]) -> W
    void ReconstructPrivateDict(int,com.itextpdf.io.font.CFFFont$OffsetItem[],com.itextpdf.io.font.CFFFont$IndexBaseItem[],com.itextpdf.io.font.CFFFont$OffsetItem[]) -> X
    void ReconstructPrivateSubrs(int,com.itextpdf.io.font.CFFFont$IndexBaseItem[],com.itextpdf.io.font.CFFFont$OffsetItem[]) -> Y
    int StackOpp() -> Z
    int getCidForGlyphId(int) -> a0
    int getCidForGlyphId(int,int) -> b0
    void initGlyphIdToCharacterIdArray(int,int,int) -> c0
    void readFDSelect(int) -> d0
    byte[] AssembleIndex(int[],byte[]) -> o
    void BuildFDArrayUsed(int) -> p
    void BuildFDSubrsOffsets(int,int) -> q
    void BuildGSubrsUsed(int) -> r
    void BuildIndexHeader(int,int,int) -> s
    void BuildNewCharString(int) -> t
    byte[] BuildNewFile(int) -> u
    byte[] BuildNewIndex(int[],java.util.Set,byte) -> v
    byte[] BuildNewIndexAndCopyAllGSubrs(int[],byte) -> w
    void BuildNewLGSubrs(int) -> x
    void BuildSubrUsed(int,int,int,int[],java.util.Set,java.util.List) -> y
    int CalcBias(int,int) -> z
com.itextpdf.io.font.CMapEncoding -> f0.d:
    com.itextpdf.io.util.IntHashtable code2Cid -> f
    com.itextpdf.io.font.cmap.CMapCidUni cid2Uni -> d
    com.itextpdf.io.font.cmap.CMapCidByte cid2Code -> e
    java.lang.String cmap -> a
    java.util.List IDENTITY_H_V_CODESPACE_RANGES -> h
    java.util.List codeSpaceRanges -> g
    java.lang.String uniMap -> b
    boolean isDirect -> c
    int fillCmapBytes(int,byte[],int) -> a
    int getCmapBytesLength(int) -> b
    java.lang.String getCmapName() -> c
    java.lang.String getOrdering() -> d
    java.lang.String getRegistry() -> e
    int getSupplement() -> f
    boolean isDirect() -> g
com.itextpdf.io.font.CidFont -> f0.e:
    java.lang.String fontName -> j
    int pdfFontFlags -> k
    java.util.Set compatibleCmaps -> l
    boolean compatibleWith(java.lang.String) -> B
    java.lang.String getCompatibleUniMap(java.lang.String) -> C
    void initializeCidFontNameAndStyle(java.lang.String) -> D
    void initializeCidFontProperties(java.util.Map) -> E
    int getPdfFontFlags() -> j
    boolean isFontSpecific() -> l
com.itextpdf.io.font.CidFontProperties -> f0.f:
    java.util.Map allFonts -> a
    java.util.Map registryNames -> b
    com.itextpdf.io.util.IntHashtable createMetric(java.lang.String) -> a
    java.util.Map getAllFonts() -> b
    java.util.Map getRegistryNames() -> c
    boolean isCidFont(java.lang.String,java.lang.String) -> d
    void loadRegistry() -> e
    java.util.Map readFontProperties(java.lang.String) -> f
com.itextpdf.io.font.FontCache -> f0.g:
    java.util.Map allCidFonts -> a
    java.util.Map registryNames -> b
    java.util.Map fontCache -> c
    com.itextpdf.io.util.IntHashtable createMetric(java.lang.String) -> a
    java.util.Map getAllPredefinedCidFonts() -> b
    com.itextpdf.io.font.cmap.CMapCidByte getCid2Byte(java.lang.String) -> c
    com.itextpdf.io.font.cmap.CMapCidUni getCid2UniCmap(java.lang.String) -> d
    java.util.Set getCompatibleCmaps(java.lang.String) -> e
    com.itextpdf.io.font.FontProgram getFont(com.itextpdf.io.font.FontCacheKey) -> f
    com.itextpdf.io.font.cmap.CMapUniCid getUni2CidCmap(java.lang.String) -> g
    boolean isPredefinedCidFont(java.lang.String) -> h
    void loadRegistry() -> i
    com.itextpdf.io.font.cmap.AbstractCMap parseCmap(java.lang.String,com.itextpdf.io.font.cmap.AbstractCMap) -> j
    java.util.Map readFontProperties(java.lang.String) -> k
    com.itextpdf.io.font.FontProgram saveFont(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.FontCacheKey) -> l
com.itextpdf.io.font.FontCacheKey -> f0.h:
    com.itextpdf.io.font.FontCacheKey create(java.lang.String) -> a
    com.itextpdf.io.font.FontCacheKey create(byte[]) -> b
com.itextpdf.io.font.FontCacheKey$FontCacheBytesKey -> f0.h$a:
    byte[] firstFontBytes -> a
    int fontLength -> b
    int hashcode -> c
    int calcHashCode() -> c
com.itextpdf.io.font.FontCacheKey$FontCacheStringKey -> f0.h$b:
    java.lang.String fontName -> a
com.itextpdf.io.font.FontEncoding -> f0.i:
    com.itextpdf.io.util.IntHashtable unicodeDifferences -> f
    com.itextpdf.io.util.IntHashtable unicodeToCode -> c
    int[] codeToUnicode -> d
    java.lang.String[] differences -> e
    byte[] emptyBytes -> g
    java.lang.String baseEncoding -> a
    boolean fontSpecific -> b
    boolean canDecode(int) -> a
    boolean canEncode(int) -> b
    int convertToByte(int) -> c
    com.itextpdf.io.font.FontEncoding createFontEncoding(java.lang.String) -> d
    com.itextpdf.io.font.FontEncoding createFontSpecificEncoding() -> e
    void fillCustomEncoding() -> f
    void fillNamedEncoding() -> g
    void fillStandardEncoding() -> h
    java.lang.String getBaseEncoding() -> i
    java.lang.String getDifference(int) -> j
    int getUnicode(int) -> k
    int getUnicodeDifference(int) -> l
    boolean hasDifferences() -> m
    boolean isFontSpecific() -> n
    java.lang.String normalizeEncoding(java.lang.String) -> o
    void setDifference(int,java.lang.String) -> p
com.itextpdf.io.font.FontIdentification -> f0.j:
    java.lang.String ttfVersion -> a
    java.lang.String panose -> b
    java.lang.String getPanose() -> a
    void setPanose(java.lang.String) -> b
    void setPanose(byte[]) -> c
    void setTtfVersion(java.lang.String) -> d
com.itextpdf.io.font.FontMetrics -> f0.k:
    int winAscender -> n
    int descender -> l
    float italicAngle -> i
    int xHeight -> h
    int typoDescender -> f
    float normalizationCoef -> a
    int unitsPerEm -> b
    int[] glyphWidths -> d
    int stemV -> y
    int superscriptSize -> w
    int subscriptSize -> u
    int[] bbox -> j
    boolean isFixedPitch -> A
    int strikeoutPosition -> s
    int underlinePosition -> q
    int winDescender -> o
    int lineGap -> m
    int ascender -> k
    int capHeight -> g
    int typoAscender -> e
    int numOfGlyphs -> c
    int stemH -> z
    int superscriptOffset -> x
    int subscriptOffset -> v
    int strikeoutSize -> t
    int underlineThickness -> r
    int advanceWidthMax -> p
    void setStrikeoutSize(int) -> A
    void setSubscriptOffset(int) -> B
    void setSubscriptSize(int) -> C
    void setSuperscriptOffset(int) -> D
    void setSuperscriptSize(int) -> E
    void setTypoAscender(int) -> F
    void setTypoDescender(int) -> G
    void setUnderlinePosition(int) -> H
    void setUnderlineThickness(int) -> I
    void setUnitsPerEm(int) -> J
    void setWinAscender(int) -> K
    void setWinDescender(int) -> L
    void setXHeight(int) -> M
    void updateBbox(float,float,float,float) -> N
    int[] getBbox() -> a
    int getCapHeight() -> b
    float getItalicAngle() -> c
    int getNumberOfGlyphs() -> d
    int getStemH() -> e
    int getStemV() -> f
    int getTypoAscender() -> g
    int getTypoDescender() -> h
    int getUnitsPerEm() -> i
    int getWinAscender() -> j
    int getWinDescender() -> k
    int getXHeight() -> l
    boolean isFixedPitch() -> m
    void setAdvanceWidthMax(int) -> n
    void setAscender(int) -> o
    void setBbox(int,int,int,int) -> p
    void setCapHeight(int) -> q
    void setDescender(int) -> r
    void setGlyphWidths(int[]) -> s
    void setIsFixedPitch(boolean) -> t
    void setItalicAngle(float) -> u
    void setLineGap(int) -> v
    void setNumberOfGlyphs(int) -> w
    void setStemH(int) -> x
    void setStemV(int) -> y
    void setStrikeoutPosition(int) -> z
com.itextpdf.io.font.FontNames -> f0.l:
    java.util.Map allNames -> a
    java.lang.String cidFontName -> g
    java.lang.String style -> f
    java.lang.String fontStretch -> i
    int macStyle -> j
    int weight -> h
    boolean allowEmbedding -> k
    java.lang.String[][] subfamily -> d
    java.lang.String[][] fullName -> b
    java.lang.String[][] familyName -> c
    java.lang.String fontName -> e
    boolean allowEmbedding() -> a
    java.lang.String[][] getFamilyName() -> b
    java.lang.String getFontName() -> c
    int getFontWeight() -> d
    java.lang.String[][] getFullName() -> e
    int getMacStyle() -> f
    java.lang.String[][] getNames(int) -> g
    java.lang.String getStyle() -> h
    boolean isBold() -> i
    boolean isItalic() -> j
    java.lang.String[][] listToArray(java.util.List) -> k
    void setAllNames(java.util.Map) -> l
    void setAllowEmbedding(boolean) -> m
    void setCidFontName(java.lang.String) -> n
    void setFamilyName(java.lang.String) -> o
    void setFamilyName(java.lang.String[][]) -> p
    void setFontName(java.lang.String) -> q
    void setFontStretch(java.lang.String) -> r
    void setFontWeight(int) -> s
    void setFullName(java.lang.String) -> t
    void setFullName(java.lang.String[][]) -> u
    void setMacStyle(int) -> v
    void setStyle(java.lang.String) -> w
    void setSubfamily(java.lang.String[][]) -> x
com.itextpdf.io.font.FontProgram -> f0.m:
    java.util.Map codeToGlyph -> a
    java.util.Map unicodeToGlyph -> b
    java.lang.String registry -> i
    com.itextpdf.io.font.FontMetrics fontMetrics -> e
    java.lang.String encodingScheme -> h
    int avgWidth -> g
    com.itextpdf.io.font.FontNames fontNames -> d
    com.itextpdf.io.font.FontIdentification fontIdentification -> f
    boolean isFontSpecific -> c
    java.lang.String trimFontStyle(java.lang.String) -> A
    void fixSpaceIssue() -> d
    com.itextpdf.io.font.FontIdentification getFontIdentification() -> e
    com.itextpdf.io.font.FontMetrics getFontMetrics() -> f
    com.itextpdf.io.font.FontNames getFontNames() -> g
    com.itextpdf.io.font.otf.Glyph getGlyph(int) -> h
    com.itextpdf.io.font.otf.Glyph getGlyphByCode(int) -> i
    int getPdfFontFlags() -> j
    java.lang.String getRegistry() -> k
    boolean isFontSpecific() -> l
    void setBbox(int[]) -> m
    void setBold(boolean) -> n
    void setCapHeight(int) -> o
    void setFixedPitch(boolean) -> p
    void setFontFamily(java.lang.String) -> q
    void setFontName(java.lang.String) -> r
    void setFontStretch(java.lang.String) -> s
    void setFontWeight(int) -> t
    void setItalicAngle(int) -> u
    void setStemH(int) -> v
    void setStemV(int) -> w
    void setTypoAscender(int) -> x
    void setTypoDescender(int) -> y
    void setXHeight(int) -> z
com.itextpdf.io.font.FontProgramDescriptor -> f0.n:
com.itextpdf.io.font.FontProgramFactory -> f0.o:
    com.itextpdf.io.font.FontRegisterProvider fontRegisterProvider -> b
    boolean DEFAULT_CACHED -> a
    com.itextpdf.io.font.FontProgram createFont(java.lang.String) -> a
    com.itextpdf.io.font.FontProgram createFont(java.lang.String,boolean) -> b
    com.itextpdf.io.font.FontProgram createFont(java.lang.String,byte[],boolean) -> c
    com.itextpdf.io.font.FontProgram createFont(byte[],boolean) -> d
    com.itextpdf.io.font.FontCacheKey createFontCacheKey(java.lang.String,byte[]) -> e
    byte[] readFontBytesFromPath(java.lang.String) -> f
com.itextpdf.io.font.FontRegisterProvider -> f0.p:
    java.util.Map fontNames -> a
    java.util.Map fontFamilies -> b
    org.slf4j.Logger LOGGER -> c
    void registerStandardFontFamilies() -> a
    void registerStandardFonts() -> b
com.itextpdf.io.font.GidAwareGlyph -> f0.q:
    int gid -> n
    int getGid() -> v
    void setGid(int) -> w
com.itextpdf.io.font.IExtraEncoding -> f0.r:
    java.lang.String byteToChar(byte[],java.lang.String) -> a
    byte[] charToByte(java.lang.String,java.lang.String) -> b
com.itextpdf.io.font.OpenTypeParser -> f0.s:
    com.itextpdf.io.font.OpenTypeParser$HeaderTable head -> a3
    com.itextpdf.io.font.OpenTypeParser$WindowsMetrics os_2 -> c3
    java.util.Map tables -> f3
    int[] glyphWidthsByIndex -> Z2
    com.itextpdf.io.font.OpenTypeParser$CmapTable cmaps -> e3
    java.util.Map allNameEntries -> V2
    boolean cff -> W2
    com.itextpdf.io.source.RandomAccessFileOrArray raf -> R2
    int ttcIndex -> S2
    int directoryOffset -> T2
    int cffLength -> Y2
    com.itextpdf.io.font.OpenTypeParser$HorizontalHeader hhea -> b3
    java.lang.String fontName -> U2
    int cffOffset -> X2
    java.lang.String fileName -> Q2
    com.itextpdf.io.font.OpenTypeParser$PostTable post -> d3
    void readHheaTable() -> A
    com.itextpdf.io.util.IntHashtable readKerning(int) -> B
    void readNameTable() -> C
    int readNumGlyphs() -> D
    void readOs_2Table() -> E
    void readPostTable() -> F
    java.lang.String readStandardString(int) -> G
    java.lang.String readUnicodeString(int) -> H
    void checkCff() -> a
    java.util.Map getAllNameEntries() -> b
    com.itextpdf.io.font.OpenTypeParser$CmapTable getCmapTable() -> c
    com.itextpdf.io.font.FontNames getFontNames() -> d
    byte[] getFullFont() -> e
    int getGlyphWidth(int) -> f
    int[] getGlyphWidthsByIndex() -> g
    com.itextpdf.io.font.OpenTypeParser$HeaderTable getHeadTable() -> h
    com.itextpdf.io.font.OpenTypeParser$HorizontalHeader getHheaTable() -> i
    com.itextpdf.io.font.OpenTypeParser$WindowsMetrics getOs_2Table() -> j
    com.itextpdf.io.font.OpenTypeParser$PostTable getPostTable() -> k
    java.lang.String getPsFontName() -> l
    byte[] getSubset(java.util.Set,boolean) -> m
    java.lang.String getTTCName(java.lang.String) -> n
    void initializeSfntTables() -> o
    boolean isCff() -> p
    void loadTables(boolean) -> q
    int[][] readBbox(int) -> r
    byte[] readCffFont() -> s
    void readCmapTable() -> t
    java.util.Map readFormat0() -> u
    java.util.Map readFormat12() -> v
    java.util.Map readFormat4(boolean) -> w
    java.util.Map readFormat6() -> x
    void readGlyphWidths() -> y
    void readHeadTable() -> z
com.itextpdf.io.font.OpenTypeParser$CmapTable -> f0.s$a:
    java.util.Map cmap10 -> a
    java.util.Map cmap31 -> b
    java.util.Map cmapExt -> c
    boolean fontSpecific -> d
com.itextpdf.io.font.OpenTypeParser$HeaderTable -> f0.s$b:
    short xMax -> e
    short yMax -> f
    int macStyle -> g
    int unitsPerEm -> b
    short xMin -> c
    short yMin -> d
    int flags -> a
com.itextpdf.io.font.OpenTypeParser$HorizontalHeader -> f0.s$c:
    short xMaxExtent -> g
    short caretSlopeRise -> h
    short minLeftSideBearing -> e
    short minRightSideBearing -> f
    int numberOfHMetrics -> j
    short caretSlopeRun -> i
    int advanceWidthMax -> d
    short LineGap -> c
    short Ascender -> a
    short Descender -> b
com.itextpdf.io.font.OpenTypeParser$PostTable -> f0.s$d:
    float italicAngle -> a
    int underlinePosition -> b
    int underlineThickness -> c
    boolean isFixedPitch -> d
com.itextpdf.io.font.OpenTypeParser$WindowsMetrics -> f0.s$e:
    byte[] achVendID -> q
    short sTypoDescender -> v
    short yStrikeoutPosition -> n
    int usWeightClass -> b
    int sCapHeight -> C
    int ulCodePageRange2 -> A
    short ySubscriptYOffset -> h
    short ySubscriptYSize -> f
    short ySuperscriptYOffset -> l
    short ySuperscriptYSize -> j
    int usWinDescent -> y
    short fsType -> d
    int usFirstCharIndex -> s
    byte[] panose -> p
    short sTypoLineGap -> w
    short sTypoAscender -> u
    short sFamilyClass -> o
    short yStrikeoutSize -> m
    int sxHeight -> B
    int usWidthClass -> c
    short ySubscriptXOffset -> g
    short ySubscriptXSize -> e
    short ySuperscriptXOffset -> k
    int ulCodePageRange1 -> z
    short ySuperscriptXSize -> i
    int usWinAscent -> x
    int usLastCharIndex -> t
    int fsSelection -> r
    short xAvgCharWidth -> a
com.itextpdf.io.font.PdfEncodings -> f0.t:
    char[] winansiByteToChar -> a
    char[] pdfEncodingByteToChar -> b
    com.itextpdf.io.util.IntHashtable pdfEncoding -> e
    int[] standardEncoding -> c
    com.itextpdf.io.util.IntHashtable winansi -> d
    java.util.Map extraEncodings -> f
    void addExtraEncoding(java.lang.String,com.itextpdf.io.font.IExtraEncoding) -> a
    byte[] convertToBytes(char,java.lang.String) -> b
    byte[] convertToBytes(java.lang.String,java.lang.String) -> c
    java.lang.String convertToString(byte[],java.lang.String) -> d
    boolean isPdfDocEncoding(java.lang.String) -> e
com.itextpdf.io.font.PdfEncodings$1 -> f0.t$a:
com.itextpdf.io.font.PdfEncodings$Cp437Conversion -> f0.t$b:
    char[] table -> b
    com.itextpdf.io.util.IntHashtable c2b -> a
    java.lang.String byteToChar(byte[],java.lang.String) -> a
    byte[] charToByte(java.lang.String,java.lang.String) -> b
com.itextpdf.io.font.PdfEncodings$SymbolConversion -> f0.t$c:
    char[] byteToChar -> b
    char[] table1 -> e
    char[] table2 -> f
    com.itextpdf.io.util.IntHashtable t1 -> c
    com.itextpdf.io.util.IntHashtable t2 -> d
    com.itextpdf.io.util.IntHashtable translation -> a
    java.lang.String byteToChar(byte[],java.lang.String) -> a
    byte[] charToByte(java.lang.String,java.lang.String) -> b
com.itextpdf.io.font.PdfEncodings$SymbolTTConversion -> f0.t$d:
    java.lang.String byteToChar(byte[],java.lang.String) -> a
    byte[] charToByte(java.lang.String,java.lang.String) -> b
com.itextpdf.io.font.PdfEncodings$WingdingsConversion -> f0.t$e:
    byte[] table -> a
    java.lang.String byteToChar(byte[],java.lang.String) -> a
    byte[] charToByte(java.lang.String,java.lang.String) -> b
com.itextpdf.io.font.Pfm2afm -> f0.u:
    byte defchar -> y
    short maxwidth -> v
    int[] Win2PSStd -> R
    int res2 -> K
    java.io.PrintWriter output -> b
    int res1 -> I
    short ascender -> O
    short weight -> p
    int psext -> G
    int h_len -> d
    short capheight -> M
    int bitoff -> E
    int face -> C
    short pixwidth -> r
    short verres -> h
    short type -> f
    short extleading -> l
    byte italic -> m
    short ascent -> j
    byte overs -> o
    byte charset -> q
    int firstchar -> w
    java.lang.String copyright -> e
    short widthby -> A
    java.lang.String[] WinChars -> S
    byte brkchar -> z
    short avgwidth -> u
    int fontname -> L
    int kernpairs -> J
    int chartab -> H
    short descender -> P
    int bits -> D
    short xheight -> N
    short pixheight -> s
    int device -> B
    boolean isMono -> Q
    short points -> g
    com.itextpdf.io.source.RandomAccessFileOrArray input -> a
    short extlen -> F
    short intleading -> k
    byte uline -> n
    short horres -> i
    int lastchar -> x
    byte kind -> t
    short vers -> c
    void convert(com.itextpdf.io.source.RandomAccessFileOrArray,java.io.OutputStream) -> a
    void openpfm() -> b
    void outchar(int,int,java.lang.String) -> c
    void outval(int) -> d
    void putchartab() -> e
    void putheader() -> f
    void putkerntab() -> g
    void puttrailer() -> h
    java.lang.String readString() -> i
    java.lang.String readString(int) -> j
com.itextpdf.io.font.TrueTypeFont -> f0.w:
    byte[] fontStreamBytes -> q
    com.itextpdf.io.font.otf.GlyphSubstitutionTableReader gsubTable -> m
    boolean isVertical -> l
    com.itextpdf.io.font.otf.OpenTypeGdefTableReader gdefTable -> o
    int[][] bBoxes -> k
    com.itextpdf.io.font.OpenTypeParser fontParser -> j
    com.itextpdf.io.util.IntHashtable kerning -> p
    com.itextpdf.io.font.otf.GlyphPositioningTableReader gposTable -> n
    java.lang.Integer $r8$lambda$l-TVF3vnQbQI7ik6X-G32oeViS8(com.itextpdf.io.font.TrueTypeFont,java.lang.Integer) -> B
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.Map getActiveCmap() -> C
    int getDirectoryOffset() -> D
    byte[] getFontStreamBytes() -> E
    byte[] getSubset(java.util.Set,boolean) -> F
    void initializeFontProperties() -> G
    boolean isCff() -> H
    java.lang.Integer lambda$mapGlyphsCidsToGids$0(java.lang.Integer) -> I
    java.util.Set mapGlyphsCidsToGids(java.util.Set) -> J
    void readGdefTable() -> K
    void readGposTable() -> L
    void readGsubTable() -> M
    int[] toCompactRange(java.util.List) -> N
    void updateUsedGlyphs(java.util.SortedSet,boolean,java.util.List) -> O
    int getPdfFontFlags() -> j
com.itextpdf.io.font.TrueTypeFontSubset -> f0.x:
    int fontPtr -> o
    int glyfTableRealSize -> l
    int locaTableRealSize -> m
    byte[] newGlyfTable -> k
    int tableGlyphOffset -> h
    byte[] outFont -> n
    int[] entrySelectors -> t
    java.util.Map tableDirectory -> a
    com.itextpdf.io.source.RandomAccessFileOrArray rf -> b
    int[] newLocaTable -> i
    int[] locaTable -> e
    java.util.Set glyphsUsed -> f
    byte[] newLocaTableOut -> j
    java.util.List glyphsInList -> g
    java.lang.String fileName -> c
    java.lang.String[] tableNames -> q
    int directoryOffset -> p
    java.lang.String[] TABLE_NAMES -> s
    boolean locaShortTable -> d
    java.lang.String[] TABLE_NAMES_SUBSET -> r
    void assembleFont() -> a
    int calculateChecksum(byte[]) -> b
    void checkGlyphComposite(int) -> c
    void createNewGlyphTables() -> d
    void createTableDirectory() -> e
    void flatGlyphs() -> f
    void locaToBytes() -> g
    byte[] process() -> h
    void readLoca() -> i
    java.lang.String readStandardString(int) -> j
    void writeFontInt(int) -> k
    void writeFontShort(int) -> l
    void writeFontString(java.lang.String) -> m
com.itextpdf.io.font.Type1Font -> f0.y:
    java.lang.String characterSet -> k
    com.itextpdf.io.font.Type1Parser fontParser -> j
    byte[] fontStreamBytes -> m
    int[] fontStreamLengths -> n
    int[] PFB_TYPES -> o
    java.util.Map kernPairs -> l
    byte[] getFontStreamBytes() -> B
    int[] getFontStreamLengths() -> C
    boolean isBuiltInFont() -> D
    void process() -> E
    int getPdfFontFlags() -> j
com.itextpdf.io.font.Type1Parser -> f0.z:
    com.itextpdf.io.source.RandomAccessSourceFactory sourceFactory -> f
    boolean isBuiltInFont -> e
    java.lang.String afmPath -> a
    byte[] afmData -> d
    java.lang.String pfbPath -> b
    byte[] pfbData -> c
    java.lang.String getAfmPath() -> a
    com.itextpdf.io.source.RandomAccessFileOrArray getMetricsFile() -> b
    com.itextpdf.io.source.RandomAccessFileOrArray getPostscriptBinary() -> c
    boolean isAfmFile(com.itextpdf.io.source.RandomAccessFileOrArray) -> d
    boolean isBuiltInFont() -> e
com.itextpdf.io.font.WoffConverter -> f0.a0:
    long bytesToUInt(byte[],int) -> a
    int bytesToUShort(byte[],int) -> b
    byte[] convert(byte[]) -> c
    boolean isWoffFont(byte[]) -> d
com.itextpdf.io.font.WoffConverter$1 -> f0.a0$a:
com.itextpdf.io.font.WoffConverter$TableDirectory -> f0.a0$b:
    byte[] tag -> a
    long origLengthVal -> e
    long offset -> b
    int outOffset -> g
    long compLength -> c
    byte[] origLength -> d
    byte[] origChecksum -> f
com.itextpdf.io.font.cmap.AbstractCMap -> g0.a:
    java.lang.String cmapName -> a
    int supplement -> d
    java.lang.String ordering -> c
    java.lang.String registry -> b
    void addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject) -> a
    void addCodeSpaceRange(byte[],byte[]) -> b
    void addRange(java.lang.String,java.lang.String,com.itextpdf.io.font.cmap.CMapObject) -> c
    int byteArrayToInt(byte[]) -> d
    byte[] decodeStringToByte(java.lang.String) -> e
    java.lang.String getOrdering() -> f
    java.lang.String getRegistry() -> g
    int getSupplement() -> h
    void intToByteArray(int,byte[]) -> i
    void setName(java.lang.String) -> j
    void setOrdering(java.lang.String) -> k
    void setRegistry(java.lang.String) -> l
    void setSupplement(int) -> m
    java.lang.String toUnicodeString(java.lang.String,boolean) -> n
com.itextpdf.io.font.cmap.CMapCidByte -> g0.b:
    java.util.List codeSpaceRanges -> g
    java.util.Map map -> e
    byte[] EMPTY -> f
    void addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject) -> a
    void addCodeSpaceRange(byte[],byte[]) -> b
    java.util.List getCodeSpaceRanges() -> o
    com.itextpdf.io.util.IntHashtable getReversMap() -> p
    byte[] lookup(int) -> q
com.itextpdf.io.font.cmap.CMapCidUni -> g0.c:
    com.itextpdf.io.util.IntHashtable map -> e
    void addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject) -> a
    int[] getCids() -> o
    int lookup(int) -> p
com.itextpdf.io.font.cmap.CMapContentParser -> g0.d:
    com.itextpdf.io.source.PdfTokenizer tokeniser -> a
    java.lang.String decodeName(byte[]) -> a
    boolean nextValidToken() -> b
    void parse(java.util.List) -> c
    com.itextpdf.io.font.cmap.CMapObject readArray() -> d
    com.itextpdf.io.font.cmap.CMapObject readDictionary() -> e
    com.itextpdf.io.font.cmap.CMapObject readObject() -> f
    java.lang.String toHex(int) -> g
    java.lang.String toHex4(int) -> h
com.itextpdf.io.font.cmap.CMapContentParser$1 -> g0.d$a:
    int[] $SwitchMap$com$itextpdf$io$source$PdfTokenizer$TokenType -> a
com.itextpdf.io.font.cmap.CMapLocationFromBytes -> g0.e:
    byte[] data -> a
    com.itextpdf.io.source.PdfTokenizer getLocation(java.lang.String) -> a
com.itextpdf.io.font.cmap.CMapLocationResource -> g0.f:
    com.itextpdf.io.source.PdfTokenizer getLocation(java.lang.String) -> a
com.itextpdf.io.font.cmap.CMapObject -> g0.g:
    java.lang.Object value -> b
    int type -> a
    java.lang.Object getValue() -> a
    boolean isArray() -> b
    boolean isHexString() -> c
    boolean isLiteral() -> d
    boolean isName() -> e
    boolean isNumber() -> f
    boolean isString() -> g
    boolean isToken() -> h
    void setValue(java.lang.Object) -> i
    byte[] toHexByteArray() -> j
com.itextpdf.io.font.cmap.CMapParser -> g0.h:
    void parseCid(java.lang.String,com.itextpdf.io.font.cmap.AbstractCMap,com.itextpdf.io.font.cmap.ICMapLocation) -> a
    void parseCid(java.lang.String,com.itextpdf.io.font.cmap.AbstractCMap,com.itextpdf.io.font.cmap.ICMapLocation,int) -> b
com.itextpdf.io.font.cmap.CMapToUnicode -> g0.i:
    com.itextpdf.io.font.cmap.CMapToUnicode EmptyCMapToUnicodeMap -> f
    java.util.Map byteMappings -> e
    void addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject) -> a
    void addChar(int,char[]) -> o
    int convertToInt(char[]) -> p
    char[] createCharsFromDoubleBytes(byte[]) -> q
    com.itextpdf.io.util.IntHashtable createDirectMapping() -> r
    java.util.Map createReverseMapping() -> s
    java.util.Set getCodes() -> t
    com.itextpdf.io.font.cmap.CMapToUnicode getIdentity() -> u
    char[] lookup(int) -> v
com.itextpdf.io.font.cmap.CMapUniCid -> g0.j:
    com.itextpdf.io.util.IntHashtable map -> e
    void addChar(java.lang.String,com.itextpdf.io.font.cmap.CMapObject) -> a
    com.itextpdf.io.font.cmap.CMapToUnicode exportToUnicode() -> o
    int lookup(int) -> p
com.itextpdf.io.font.cmap.ICMapLocation -> g0.k:
    com.itextpdf.io.source.PdfTokenizer getLocation(java.lang.String) -> a
com.itextpdf.io.font.constants.FontDescriptorFlags -> h0.a:
    int Nonsymbolic -> b
    int Symbolic -> a
com.itextpdf.io.font.constants.FontStretches -> h0.b:
    java.lang.String fromOpenTypeWidthClass(int) -> a
com.itextpdf.io.font.constants.FontWeights -> h0.c:
    int fromType1FontWeight(java.lang.String) -> a
    int normalizeFontWeight(int) -> b
com.itextpdf.io.font.constants.StandardFonts -> h0.d:
    java.util.Set BUILTIN_FONTS -> a
    boolean isStandardFont(java.lang.String) -> a
com.itextpdf.io.font.otf.ActualTextIterator -> i0.a:
    com.itextpdf.io.font.otf.GlyphLine glyphLine -> Q2
    int pos -> R2
    boolean glyphLinePartNeedsActualText(com.itextpdf.io.font.otf.GlyphLine$GlyphLinePart) -> a
    com.itextpdf.io.font.otf.GlyphLine$GlyphLinePart next() -> b
    com.itextpdf.io.font.otf.GlyphLine$GlyphLinePart nextGlyphLinePart(int) -> c
com.itextpdf.io.font.otf.ChainingContextualTable -> i0.b:
com.itextpdf.io.font.otf.ContextualPositionRule -> i0.c:
com.itextpdf.io.font.otf.ContextualRule -> i0.d:
com.itextpdf.io.font.otf.ContextualSubstRule -> i0.e:
com.itextpdf.io.font.otf.ContextualTable -> i0.f:
    com.itextpdf.io.font.otf.OpenTypeFontTableReader openReader -> a
    int lookupFlag -> b
com.itextpdf.io.font.otf.FeatureRecord -> i0.g:
    int[] lookups -> b
    java.lang.String tag -> a
com.itextpdf.io.font.otf.FontReadingException -> i0.h:
com.itextpdf.io.font.otf.Glyph -> i0.i:
    char[] chars -> e
    java.lang.String REPLACEMENT_CHARACTER_STRING -> m
    int unicode -> d
    int width -> b
    int code -> a
    short xPlacement -> g
    short yPlacement -> h
    short anchorDelta -> k
    int[] bbox -> c
    short xAdvance -> i
    short yAdvance -> j
    boolean isMark -> f
    char[] REPLACEMENT_CHARACTERS -> l
    int codePoint(char[]) -> a
    short getAnchorDelta() -> b
    int[] getBbox() -> c
    char[] getChars() -> d
    char[] getChars(int) -> e
    int getCode() -> f
    int getUnicode() -> g
    char[] getUnicodeChars() -> h
    int getWidth() -> i
    short getXAdvance() -> j
    short getXPlacement() -> k
    short getYAdvance() -> l
    short getYPlacement() -> m
    boolean hasAdvance() -> n
    boolean hasOffsets() -> o
    boolean hasPlacement() -> p
    boolean hasValidUnicode() -> q
    boolean isMark() -> r
    void setChars(char[]) -> s
    void setXAdvance(short) -> t
    java.lang.String toHex(int) -> u
com.itextpdf.io.font.otf.GlyphLine -> i0.j:
    java.util.List actualText -> e
    java.util.List glyphs -> d
    int end -> b
    int idx -> c
    int start -> a
    com.itextpdf.io.font.otf.GlyphLine filter(com.itextpdf.io.font.otf.GlyphLine$IGlyphLineFilter) -> a
    com.itextpdf.io.font.otf.Glyph get(int) -> b
    com.itextpdf.io.font.otf.Glyph set(int,com.itextpdf.io.font.otf.Glyph) -> c
    void setActualText(int,int,java.lang.String) -> d
    void setGlyphs(java.util.List) -> e
    int size() -> f
    java.lang.String toUnicodeString(int,int) -> g
com.itextpdf.io.font.otf.GlyphLine$ActualText -> i0.j$a:
    java.lang.String value -> a
com.itextpdf.io.font.otf.GlyphLine$GlyphLinePart -> i0.j$b:
    int end -> b
    java.lang.String actualText -> c
    int start -> a
    boolean reversed -> d
    com.itextpdf.io.font.otf.GlyphLine$GlyphLinePart setReversed(boolean) -> a
com.itextpdf.io.font.otf.GlyphLine$IGlyphLineFilter -> i0.j$c:
    boolean accept(com.itextpdf.io.font.otf.Glyph) -> a
com.itextpdf.io.font.otf.GlyphPositioningTableReader -> i0.k:
    com.itextpdf.io.font.otf.OpenTableLookup readLookupTable(int,int,int[]) -> f
com.itextpdf.io.font.otf.GlyphSubstitutionTableReader -> i0.l:
    com.itextpdf.io.font.otf.OpenTableLookup readLookupTable(int,int,int[]) -> f
com.itextpdf.io.font.otf.GposAnchor -> i0.m:
    int YCoordinate -> b
    int XCoordinate -> a
com.itextpdf.io.font.otf.GposLookupType1 -> i0.n:
    java.util.Map valueRecordMap -> d
    void readSubTable(int) -> a
com.itextpdf.io.font.otf.GposLookupType2 -> i0.o:
    java.util.List listRules -> d
    void readSubTable(int) -> a
com.itextpdf.io.font.otf.GposLookupType2$1 -> i0.o$a:
com.itextpdf.io.font.otf.GposLookupType2$PairPosAdjustmentFormat1 -> i0.o$b:
    java.util.Map gposMap -> d
    void readSubTable(int) -> a
    void readFormat(int) -> c
com.itextpdf.io.font.otf.GposLookupType2$PairPosAdjustmentFormat2 -> i0.o$c:
    com.itextpdf.io.font.otf.OtfClass classDef2 -> e
    com.itextpdf.io.font.otf.OtfClass classDef1 -> d
    java.util.HashSet coverageSet -> f
    java.util.Map posSubs -> g
    void readSubTable(int) -> a
    void readFormat(int) -> c
com.itextpdf.io.font.otf.GposLookupType2$PairValueFormat -> i0.o$d:
    com.itextpdf.io.font.otf.GposValueRecord second -> b
    com.itextpdf.io.font.otf.GposValueRecord first -> a
com.itextpdf.io.font.otf.GposLookupType4 -> i0.p:
    java.util.List marksbases -> d
    void readSubTable(int) -> a
com.itextpdf.io.font.otf.GposLookupType4$MarkToBase -> i0.p$a:
    java.util.Map marks -> a
    java.util.Map bases -> b
com.itextpdf.io.font.otf.GposLookupType5 -> i0.q:
    java.util.List marksligatures -> d
    void readSubTable(int) -> a
com.itextpdf.io.font.otf.GposLookupType5$MarkToLigature -> i0.q$a:
    java.util.Map marks -> a
    java.util.Map ligatures -> b
com.itextpdf.io.font.otf.GposLookupType6 -> i0.r:
    java.util.List marksbases -> d
    void readSubTable(int) -> a
com.itextpdf.io.font.otf.GposLookupType6$1 -> i0.r$a:
com.itextpdf.io.font.otf.GposLookupType6$MarkToBaseMark -> i0.r$b:
    java.util.Map marks -> a
    java.util.Map baseMarks -> b
com.itextpdf.io.font.otf.GposLookupType7 -> i0.s:
    java.util.List subTables -> d
    org.slf4j.Logger LOGGER -> e
    void readSubTable(int) -> a
    void readSubTableFormat2(int) -> c
com.itextpdf.io.font.otf.GposLookupType8 -> i0.t:
    void readSubTable(int) -> a
    void readSubTableFormat2(int) -> c
    void readSubTableFormat1(int) -> d
    void readSubTableFormat3(int) -> e
com.itextpdf.io.font.otf.GposValueRecord -> i0.u:
    int YAdvance -> d
    int YPlacement -> b
    int XAdvance -> c
    int XPlacement -> a
com.itextpdf.io.font.otf.GsubLookupType1 -> i0.v:
    com.itextpdf.io.util.IntHashtable substMap -> d
    void readSubTable(int) -> a
com.itextpdf.io.font.otf.GsubLookupType2 -> i0.w:
    java.util.Map substMap -> d
    void readSubTable(int) -> a
com.itextpdf.io.font.otf.GsubLookupType3 -> i0.x:
    java.util.Map substMap -> d
    void readSubTable(int) -> a
com.itextpdf.io.font.otf.GsubLookupType4 -> i0.y:
    java.util.Map ligatures -> d
    void readSubTable(int) -> a
com.itextpdf.io.font.otf.GsubLookupType5 -> i0.z:
    java.util.List subTables -> d
    void readSubTable(int) -> a
    void readSubTableFormat1(int) -> c
    void readSubTableFormat2(int) -> d
    void readSubTableFormat3(int) -> e
com.itextpdf.io.font.otf.GsubLookupType6 -> i0.a0:
    void readSubTableFormat1(int) -> c
    void readSubTableFormat2(int) -> d
    void readSubTableFormat3(int) -> e
com.itextpdf.io.font.otf.LanguageRecord -> i0.b0:
    int[] features -> c
    java.lang.String tag -> a
    int featureRequired -> b
com.itextpdf.io.font.otf.OpenTableLookup -> i0.c0:
    int[] subTableLocations -> b
    com.itextpdf.io.font.otf.OpenTypeFontTableReader openReader -> c
    int lookupFlag -> a
    void readSubTable(int) -> a
    void readSubTables() -> b
com.itextpdf.io.font.otf.OpenTypeFeature -> i0.d0:
    java.util.List records -> b
    com.itextpdf.io.font.otf.OpenTypeFontTableReader openTypeReader -> a
com.itextpdf.io.font.otf.OpenTypeFontTableReader -> i0.e0:
    com.itextpdf.io.source.RandomAccessFileOrArray rf -> a
    com.itextpdf.io.font.otf.OpenTypeFeature featuresType -> e
    int unitsPerEm -> h
    java.util.List lookupList -> c
    com.itextpdf.io.font.otf.OpenTypeScript scriptsType -> d
    int tableLocation -> b
    java.util.Map indexGlyphMap -> f
    com.itextpdf.io.font.otf.OpenTypeGdefTableReader gdef -> g
    int getUnitsPerEm() -> a
    com.itextpdf.io.font.otf.OtfClass readClassDefinition(int) -> b
    java.util.List readCoverageFormat(int) -> c
    void readCoverages(int[],java.util.List) -> d
    void readLookupListTable(int) -> e
    com.itextpdf.io.font.otf.OpenTableLookup readLookupTable(int,int,int[]) -> f
    void readLookupTable(int) -> g
    com.itextpdf.io.font.otf.PosLookupRecord[] readPosLookupRecords(int) -> h
    com.itextpdf.io.font.otf.SubstLookupRecord[] readSubstLookupRecords(int) -> i
    com.itextpdf.io.font.otf.TagAndLocation[] readTagAndLocations(int) -> j
    int[] readUShortArray(int) -> k
    int[] readUShortArray(int,int) -> l
    void startReadingTable() -> m
com.itextpdf.io.font.otf.OpenTypeGdefTableReader -> i0.f0:
    com.itextpdf.io.source.RandomAccessFileOrArray rf -> b
    com.itextpdf.io.font.otf.OtfClass glyphClass -> c
    com.itextpdf.io.font.otf.OtfClass markAttachmentClass -> d
    int tableLocation -> a
    void readTable() -> a
com.itextpdf.io.font.otf.OpenTypeScript -> i0.g0:
    java.util.List records -> b
    com.itextpdf.io.font.otf.OpenTypeFontTableReader openTypeReader -> a
    com.itextpdf.io.font.otf.LanguageRecord readLanguageRecord(com.itextpdf.io.font.otf.TagAndLocation) -> a
    void readScriptRecord(com.itextpdf.io.font.otf.TagAndLocation) -> b
com.itextpdf.io.font.otf.OtfClass -> i0.h0:
    com.itextpdf.io.util.IntHashtable mapClass -> a
    com.itextpdf.io.font.otf.OtfClass create(com.itextpdf.io.source.RandomAccessFileOrArray,int) -> a
com.itextpdf.io.font.otf.OtfMarkRecord -> i0.i0:
    com.itextpdf.io.font.otf.GposAnchor anchor -> b
    int markClass -> a
com.itextpdf.io.font.otf.OtfReadCommon -> i0.j0:
    com.itextpdf.io.font.otf.GposAnchor[] readAnchorArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int[],int,int) -> a
    java.util.List readBaseArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int) -> b
    java.util.List readCoverageFormat(com.itextpdf.io.source.RandomAccessFileOrArray,int) -> c
    void readCoverages(com.itextpdf.io.source.RandomAccessFileOrArray,int[],java.util.List) -> d
    com.itextpdf.io.font.otf.GposAnchor readGposAnchor(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int) -> e
    com.itextpdf.io.font.otf.GposValueRecord readGposValueRecord(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int) -> f
    java.util.List readLigatureArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int,int) -> g
    java.util.List readMarkArray(com.itextpdf.io.font.otf.OpenTypeFontTableReader,int) -> h
    com.itextpdf.io.font.otf.PosLookupRecord[] readPosLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int) -> i
    void readRangeRecord(com.itextpdf.io.source.RandomAccessFileOrArray,java.util.List) -> j
    com.itextpdf.io.font.otf.SubstLookupRecord[] readSubstLookupRecords(com.itextpdf.io.source.RandomAccessFileOrArray,int) -> k
    int[] readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int) -> l
    int[] readUShortArray(com.itextpdf.io.source.RandomAccessFileOrArray,int,int) -> m
com.itextpdf.io.font.otf.PosLookupRecord -> i0.k0:
    int lookupListIndex -> b
    int sequenceIndex -> a
com.itextpdf.io.font.otf.ScriptRecord -> i0.l0:
    com.itextpdf.io.font.otf.LanguageRecord[] languages -> c
    com.itextpdf.io.font.otf.LanguageRecord defaultLanguage -> b
    java.lang.String tag -> a
com.itextpdf.io.font.otf.SubstLookupRecord -> i0.m0:
    int lookupListIndex -> b
    int sequenceIndex -> a
com.itextpdf.io.font.otf.TagAndLocation -> i0.n0:
    java.lang.String tag -> a
    int location -> b
com.itextpdf.io.font.otf.lookuptype5.SubTableLookup5Format1 -> j0.a:
    java.util.Map substMap -> c
com.itextpdf.io.font.otf.lookuptype5.SubTableLookup5Format1$SubstRuleFormat1 -> j0.a$a:
    com.itextpdf.io.font.otf.SubstLookupRecord[] substLookupRecords -> b
    int[] inputGlyphIds -> a
com.itextpdf.io.font.otf.lookuptype5.SubTableLookup5Format2 -> j0.b:
    com.itextpdf.io.font.otf.OtfClass classDefinition -> e
    java.util.Set substCoverageGlyphIds -> c
    java.util.List subClassSets -> d
    com.itextpdf.io.font.otf.OtfClass access$000(com.itextpdf.io.font.otf.lookuptype5.SubTableLookup5Format2) -> a
    void setSubClassSets(java.util.List) -> b
com.itextpdf.io.font.otf.lookuptype5.SubTableLookup5Format2$SubstRuleFormat2 -> j0.b$a:
    com.itextpdf.io.font.otf.OtfClass classDefinition -> c
    com.itextpdf.io.font.otf.SubstLookupRecord[] substLookupRecords -> b
    int[] inputClassIds -> a
com.itextpdf.io.font.otf.lookuptype5.SubTableLookup5Format3 -> j0.c:
    com.itextpdf.io.font.otf.ContextualSubstRule substitutionRule -> c
com.itextpdf.io.font.otf.lookuptype5.SubTableLookup5Format3$SubstRuleFormat3 -> j0.c$a:
    java.util.List coverages -> a
    com.itextpdf.io.font.otf.SubstLookupRecord[] substLookupRecords -> b
com.itextpdf.io.font.otf.lookuptype6.SubTableLookup6Format1 -> k0.a:
    java.util.Map substMap -> c
com.itextpdf.io.font.otf.lookuptype6.SubTableLookup6Format1$SubstRuleFormat1 -> k0.a$a:
    int[] backtrackGlyphIds -> b
    int[] lookAheadGlyphIds -> c
    com.itextpdf.io.font.otf.SubstLookupRecord[] substLookupRecords -> d
    int[] inputGlyphIds -> a
com.itextpdf.io.font.otf.lookuptype6.SubTableLookup6Format2 -> k0.b:
    com.itextpdf.io.font.otf.OtfClass lookaheadClassDefinition -> g
    com.itextpdf.io.font.otf.OtfClass backtrackClassDefinition -> e
    com.itextpdf.io.font.otf.OtfClass inputClassDefinition -> f
    java.util.Set substCoverageGlyphIds -> c
    java.util.List subClassSets -> d
    void setSubClassSets(java.util.List) -> a
com.itextpdf.io.font.otf.lookuptype6.SubTableLookup6Format2$SubstRuleFormat2 -> k0.b$a:
    int[] inputClassIds -> b
    int[] lookAheadClassIds -> c
    com.itextpdf.io.font.otf.SubstLookupRecord[] substLookupRecords -> d
    int[] backtrackClassIds -> a
    com.itextpdf.io.font.otf.lookuptype6.SubTableLookup6Format2 subTable -> e
com.itextpdf.io.font.otf.lookuptype6.SubTableLookup6Format3 -> k0.c:
    com.itextpdf.io.font.otf.ContextualSubstRule substitutionRule -> c
com.itextpdf.io.font.otf.lookuptype6.SubTableLookup6Format3$SubstRuleFormat3 -> k0.c$a:
    java.util.List inputCoverages -> b
    java.util.List backtrackCoverages -> a
    java.util.List lookaheadCoverages -> c
    com.itextpdf.io.font.otf.SubstLookupRecord[] substLookupRecords -> d
com.itextpdf.io.font.otf.lookuptype7.PosTableLookup7Format2 -> l0.a:
    com.itextpdf.io.font.otf.OtfClass classDefinition -> e
    java.util.Set posCoverageGlyphIds -> c
    java.util.List subClassSets -> d
    com.itextpdf.io.font.otf.OtfClass access$000(com.itextpdf.io.font.otf.lookuptype7.PosTableLookup7Format2) -> a
    void setPosClassSets(java.util.List) -> b
com.itextpdf.io.font.otf.lookuptype7.PosTableLookup7Format2$PosRuleFormat2 -> l0.a$a:
    com.itextpdf.io.font.otf.PosLookupRecord[] posLookupRecords -> b
    com.itextpdf.io.font.otf.OtfClass classDefinition -> c
    int[] inputClassIds -> a
com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format1 -> m0.a:
    java.util.Map posMap -> c
com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format1$PosRuleFormat1 -> m0.a$a:
    int[] backtrackGlyphIds -> b
    int[] lookAheadGlyphIds -> c
    com.itextpdf.io.font.otf.PosLookupRecord[] posLookupRecords -> d
    int[] inputGlyphIds -> a
com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format2 -> m0.b:
    com.itextpdf.io.font.otf.OtfClass lookaheadClassDefinition -> g
    com.itextpdf.io.font.otf.OtfClass backtrackClassDefinition -> e
    com.itextpdf.io.font.otf.OtfClass inputClassDefinition -> f
    java.util.Set posCoverageGlyphIds -> c
    java.util.List posClassSets -> d
    void addPosClassSet(java.util.List) -> a
com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format2$PosRuleFormat2 -> m0.b$a:
    com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format2 posTable -> e
    int[] inputClassIds -> b
    int[] lookAheadClassIds -> c
    com.itextpdf.io.font.otf.PosLookupRecord[] posLookupRecords -> d
    int[] backtrackClassIds -> a
    com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format2 getPosTable() -> a
com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format3 -> m0.c:
    com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format3$PosRuleFormat3 posRule -> c
com.itextpdf.io.font.otf.lookuptype8.PosTableLookup8Format3$PosRuleFormat3 -> m0.c$a:
    java.util.List backtrackCoverages -> b
    java.util.List inputCoverages -> a
    com.itextpdf.io.font.otf.PosLookupRecord[] posLookupRecords -> d
    java.util.List lookaheadCoverages -> c
com.itextpdf.io.font.woff2.Buffer -> n0.a:
    byte[] data -> a
    int length -> d
    int offset -> b
    int initial_offset -> c
    int getInitialOffset() -> a
    int getLength() -> b
    int getOffset() -> c
    void read(byte[],int,int) -> d
    int readAsNumber(int) -> e
    byte readByte() -> f
    int readInt() -> g
    short readShort() -> h
    void skip(int) -> i
com.itextpdf.io.font.woff2.JavaUnsignedUtil -> n0.b:
    int asU16(short) -> a
    int asU8(byte) -> b
    int compareAsUnsigned(int,int) -> c
    short toU16(int) -> d
    byte toU8(int) -> e
com.itextpdf.io.font.woff2.Round -> n0.c:
    int round4(int) -> a
com.itextpdf.io.font.woff2.StoreBytes -> n0.d:
    int storeU16(byte[],int,int) -> a
    int storeU32(byte[],int,int) -> b
com.itextpdf.io.font.woff2.TableTags -> n0.e:
    int[] kKnownTags -> a
    int tag(char,char,char,char) -> a
com.itextpdf.io.font.woff2.VariableLength -> n0.f:
    int read255UShort(com.itextpdf.io.font.woff2.Buffer) -> a
    int readBase128(com.itextpdf.io.font.woff2.Buffer) -> b
com.itextpdf.io.font.woff2.Woff2Common -> n0.g:
    int collectionHeaderSize(int,int) -> a
    int computeULongSum(byte[],int,int) -> b
com.itextpdf.io.font.woff2.Woff2Common$Point -> n0.g$a:
    int y -> b
    boolean on_curve -> c
    int x -> a
com.itextpdf.io.font.woff2.Woff2Common$Table -> n0.g$b:
    int transform_length -> U2
    int dst_offset -> V2
    int src_offset -> S2
    int src_length -> T2
    int dst_length -> W2
    int tag -> Q2
    int flags -> R2
    int compareTo(com.itextpdf.io.font.woff2.Woff2Common$Table) -> a
com.itextpdf.io.font.woff2.Woff2Converter -> n0.h:
    byte[] convert(byte[]) -> a
    boolean isWoff2Font(byte[]) -> b
com.itextpdf.io.font.woff2.Woff2Dec -> n0.i:
    void computeBbox(int,com.itextpdf.io.font.woff2.Woff2Common$Point[],byte[]) -> a
    int computeOffsetToFirstTable(com.itextpdf.io.font.woff2.Woff2Dec$Woff2Header) -> b
    int computeWoff2FinalSize(byte[],int) -> c
    void convertWoff2ToTtf(byte[],int,com.itextpdf.io.font.woff2.Woff2Out) -> d
    com.itextpdf.io.font.woff2.Woff2Common$Table findTable(java.util.ArrayList,int) -> e
    void pad4(com.itextpdf.io.font.woff2.Woff2Out) -> f
    short readNumHMetrics(byte[],int,int) -> g
    void readTableDirectory(com.itextpdf.io.font.woff2.Buffer,com.itextpdf.io.font.woff2.Woff2Common$Table[],int) -> h
    void readWoff2Header(byte[],int,com.itextpdf.io.font.woff2.Woff2Dec$Woff2Header) -> i
    void reconstructFont(byte[],int,int,com.itextpdf.io.font.woff2.Woff2Dec$RebuildMetadata,com.itextpdf.io.font.woff2.Woff2Dec$Woff2Header,int,com.itextpdf.io.font.woff2.Woff2Out) -> j
    com.itextpdf.io.font.woff2.Woff2Dec$Checksums reconstructGlyf(byte[],int,com.itextpdf.io.font.woff2.Woff2Common$Table,int,com.itextpdf.io.font.woff2.Woff2Common$Table,int,com.itextpdf.io.font.woff2.Woff2Dec$Woff2FontInfo,com.itextpdf.io.font.woff2.Woff2Out) -> k
    int reconstructTransformedHmtx(byte[],int,int,int,int,short[],com.itextpdf.io.font.woff2.Woff2Out) -> l
    com.itextpdf.io.font.woff2.Woff2Dec$CompositeGlyphInfo sizeOfComposite(com.itextpdf.io.font.woff2.Buffer) -> m
    int storeLoca(int[],int,com.itextpdf.io.font.woff2.Woff2Out) -> n
    int storeOffsetTable(byte[],int,int,int) -> o
    int storePoints(int,com.itextpdf.io.font.woff2.Woff2Common$Point[],int,int,byte[],int) -> p
    int storeTableEntry(byte[],int,int) -> q
    java.util.ArrayList tables(com.itextpdf.io.font.woff2.Woff2Dec$Woff2Header,int) -> r
    int tripletDecode(byte[],int,int,int,int,com.itextpdf.io.font.woff2.Woff2Common$Point[]) -> s
    int withSign(int,int) -> t
    void woff2Uncompress(byte[],int,int,byte[],int,int) -> u
    void writeHeaders(byte[],int,com.itextpdf.io.font.woff2.Woff2Dec$RebuildMetadata,com.itextpdf.io.font.woff2.Woff2Dec$Woff2Header,com.itextpdf.io.font.woff2.Woff2Out) -> v
com.itextpdf.io.font.woff2.Woff2Dec$1 -> n0.i$a:
com.itextpdf.io.font.woff2.Woff2Dec$Checksums -> n0.i$b:
    int glyph_checksum -> b
    int loca_checksum -> a
com.itextpdf.io.font.woff2.Woff2Dec$CompositeGlyphInfo -> n0.i$c:
    boolean have_instructions -> b
    int size -> a
com.itextpdf.io.font.woff2.Woff2Dec$RebuildMetadata -> n0.i$d:
    com.itextpdf.io.font.woff2.Woff2Dec$Woff2FontInfo[] font_infos -> b
    java.util.Map checksums -> c
    int header_checksum -> a
com.itextpdf.io.font.woff2.Woff2Dec$StreamInfo -> n0.i$e:
    int length -> b
    int offset -> a
com.itextpdf.io.font.woff2.Woff2Dec$TableChecksumInfo -> n0.i$f:
    int offset -> b
    int tag -> a
com.itextpdf.io.font.woff2.Woff2Dec$TtcFont -> n0.i$g:
    int dst_offset -> b
    short[] table_indices -> d
    int header_checksum -> c
    int flavor -> a
com.itextpdf.io.font.woff2.Woff2Dec$Woff2FontInfo -> n0.i$h:
    short num_hmetrics -> c
    short[] x_mins -> d
    java.util.Map table_entry_by_tag -> e
    short num_glyphs -> a
    short index_format -> b
com.itextpdf.io.font.woff2.Woff2Dec$Woff2Header -> n0.i$i:
    com.itextpdf.io.font.woff2.Woff2Common$Table[] tables -> g
    int uncompressed_size -> f
    int compressed_offset -> d
    int compressed_length -> e
    int header_version -> b
    short num_tables -> c
    com.itextpdf.io.font.woff2.Woff2Dec$TtcFont[] ttc_fonts -> h
    int flavor -> a
com.itextpdf.io.font.woff2.Woff2MemoryOut -> n0.j:
    byte[] buf_ -> a
    int buf_size_ -> b
    int offset_ -> c
    void write(byte[],int,int) -> a
    void write(byte[],int,int,int) -> b
com.itextpdf.io.font.woff2.Woff2Out -> n0.k:
    void write(byte[],int,int) -> a
    void write(byte[],int,int,int) -> b
com.itextpdf.io.image.BmpImageData -> o0.a:
    boolean noHeader -> C
    boolean isNoHeader() -> S
com.itextpdf.io.image.BmpImageHelper -> o0.b:
    byte[] decodeRLE(boolean,byte[],com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> a
    int findMask(int) -> b
    int findShift(int) -> c
    boolean getImage(com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> d
    byte[] getPalette(int,com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> e
    void indexedModel(byte[],int,int,com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> f
    void process(com.itextpdf.io.image.BmpImageHelper$BmpParameters,java.io.InputStream) -> g
    void processImage(com.itextpdf.io.image.ImageData) -> h
    void read1632Bit(boolean,com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> i
    void read1Bit(int,com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> j
    void read24Bit(byte[],com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> k
    void read4Bit(int,com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> l
    void read8Bit(int,com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> m
    long readDWord(java.io.InputStream) -> n
    int readInt(java.io.InputStream) -> o
    int readLong(java.io.InputStream) -> p
    void readPalette(int,com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> q
    void readRLE4(com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> r
    void readRLE8(com.itextpdf.io.image.BmpImageHelper$BmpParameters) -> s
    int readUnsignedByte(java.io.InputStream) -> t
    long readUnsignedInt(java.io.InputStream) -> u
    int readUnsignedShort(java.io.InputStream) -> v
    int readWord(java.io.InputStream) -> w
com.itextpdf.io.image.BmpImageHelper$BmpParameters -> o0.b$a:
    boolean isBottomUp -> m
    int bitsPerPixel -> n
    long imageSize -> i
    int redMask -> o
    int numBands -> l
    java.util.Map properties -> s
    long bitmapFileSize -> f
    int imageType -> k
    long compression -> h
    long bitmapOffset -> g
    int width -> b
    int height -> c
    com.itextpdf.io.image.BmpImageData image -> a
    java.util.Map additional -> d
    long yPelsPerMeter -> u
    java.io.InputStream inputStream -> e
    byte[] palette -> j
    long xPelsPerMeter -> t
    int alphaMask -> r
    int greenMask -> p
    int blueMask -> q
com.itextpdf.io.image.GifImageData -> o0.c:
    java.util.List frames -> c
    java.net.URL url -> e
    float logicalWidth -> b
    float logicalHeight -> a
    byte[] data -> d
    void addFrame(com.itextpdf.io.image.ImageData) -> a
    byte[] getData() -> b
    java.util.List getFrames() -> c
    void loadData() -> d
    void setLogicalHeight(float) -> e
    void setLogicalWidth(float) -> f
com.itextpdf.io.image.GifImageHelper -> o0.d:
    boolean decodeImageData(com.itextpdf.io.image.GifImageHelper$GifParameters) -> a
    int newBpc(int) -> b
    void process(java.io.InputStream,com.itextpdf.io.image.GifImageHelper$GifParameters,int) -> c
    void processImage(com.itextpdf.io.image.GifImageData,int) -> d
    int readBlock(com.itextpdf.io.image.GifImageHelper$GifParameters) -> e
    byte[] readColorTable(int,com.itextpdf.io.image.GifImageHelper$GifParameters) -> f
    void readContents(com.itextpdf.io.image.GifImageHelper$GifParameters,int) -> g
    void readFrame(com.itextpdf.io.image.GifImageHelper$GifParameters) -> h
    void readGraphicControlExt(com.itextpdf.io.image.GifImageHelper$GifParameters) -> i
    void readHeader(com.itextpdf.io.image.GifImageHelper$GifParameters) -> j
    void readLSD(com.itextpdf.io.image.GifImageHelper$GifParameters) -> k
    int readShort(com.itextpdf.io.image.GifImageHelper$GifParameters) -> l
    void setPixel(int,int,int,com.itextpdf.io.image.GifImageHelper$GifParameters) -> m
    void skip(com.itextpdf.io.image.GifImageHelper$GifParameters) -> n
com.itextpdf.io.image.GifImageHelper$GifParameters -> o0.d$a:
    int dispose -> n
    boolean transparency -> o
    int iw -> j
    int ix -> h
    int pixelAspect -> d
    byte[] m_curr_table -> y
    byte[] suffix -> s
    byte[] m_out -> u
    int currentFrame -> A
    boolean interlace -> f
    int m_gbpc -> w
    short[] prefix -> r
    boolean gctFlag -> b
    int transIndex -> q
    int blockSize -> m
    byte[] block -> l
    int ih -> k
    int iy -> i
    byte[] m_global_table -> x
    int lctSize -> g
    byte[] pixelStack -> t
    int bgIndex -> c
    int m_line_stride -> z
    com.itextpdf.io.image.GifImageData image -> B
    boolean lctFlag -> e
    int m_bpc -> v
    java.io.InputStream input -> a
    int delay -> p
com.itextpdf.io.image.ImageData -> o0.e:
    com.itextpdf.io.colors.IccProfile profile -> n
    java.net.URL url -> a
    float[] decode -> j
    int bpc -> h
    float height -> e
    boolean interpolation -> u
    com.itextpdf.io.image.ImageType originalType -> c
    boolean mask -> s
    int[] transparency -> b
    com.itextpdf.io.image.ImageData imageMask -> t
    java.util.Map decodeParms -> k
    java.lang.Object staticLock -> A
    byte[] data -> f
    float rotation -> m
    int colorTransform -> q
    int dpiX -> o
    int colorEncodingComponentsNumber -> i
    boolean inverted -> l
    float width -> d
    int imageSize -> g
    boolean deflated -> r
    java.util.Map imageAttributes -> x
    java.lang.String filter -> w
    long serialId -> z
    java.lang.Long mySerialId -> y
    float XYRatio -> v
    int dpiY -> p
    void makeMask() -> A
    void setBpc(int) -> B
    void setColorEncodingComponentsNumber(int) -> C
    void setColorTransform(int) -> D
    void setDeflated(boolean) -> E
    void setDpi(int,int) -> F
    void setFilter(java.lang.String) -> G
    void setHeight(float) -> H
    void setImageAttributes(java.util.Map) -> I
    void setImageMask(com.itextpdf.io.image.ImageData) -> J
    void setInverted(boolean) -> K
    void setProfile(com.itextpdf.io.colors.IccProfile) -> L
    void setRotation(float) -> M
    void setTransparency(int[]) -> N
    void setWidth(float) -> O
    void setXYRatio(float) -> P
    boolean canBeMask() -> a
    int getBpc() -> b
    int getColorEncodingComponentsNumber() -> c
    int getColorTransform() -> d
    byte[] getData() -> e
    float[] getDecode() -> f
    java.util.Map getDecodeParms() -> g
    int getDpiX() -> h
    int getDpiY() -> i
    java.lang.String getFilter() -> j
    float getHeight() -> k
    java.util.Map getImageAttributes() -> l
    com.itextpdf.io.image.ImageData getImageMask() -> m
    com.itextpdf.io.image.ImageType getOriginalType() -> n
    com.itextpdf.io.colors.IccProfile getProfile() -> o
    java.lang.Long getSerialId() -> p
    int[] getTransparency() -> q
    java.net.URL getUrl() -> r
    float getWidth() -> s
    boolean isDeflated() -> t
    boolean isInterpolation() -> u
    boolean isInverted() -> v
    boolean isMask() -> w
    boolean isRawImage() -> x
    boolean isSoftMask() -> y
    void loadData() -> z
com.itextpdf.io.image.ImageDataFactory -> o0.f:
    com.itextpdf.io.image.ImageData create(java.lang.String) -> a
    com.itextpdf.io.image.ImageData create(java.lang.String,boolean) -> b
    com.itextpdf.io.image.ImageData create(java.net.URL,boolean) -> c
    com.itextpdf.io.image.ImageData createImageInstance(java.net.URL,boolean) -> d
    com.itextpdf.io.image.ImageData createRawImage(byte[]) -> e
com.itextpdf.io.image.ImageDataFactory$1 -> o0.f$a:
    int[] $SwitchMap$com$itextpdf$io$image$ImageType -> a
com.itextpdf.io.image.ImageType -> o0.g:
    com.itextpdf.io.image.ImageType JBIG2 -> Y2
    com.itextpdf.io.image.ImageType RAW -> Z2
    com.itextpdf.io.image.ImageType PS -> W2
    com.itextpdf.io.image.ImageType JPEG2000 -> X2
    com.itextpdf.io.image.ImageType TIFF -> U2
    com.itextpdf.io.image.ImageType[] $VALUES -> b3
    com.itextpdf.io.image.ImageType WMF -> V2
    com.itextpdf.io.image.ImageType GIF -> S2
    com.itextpdf.io.image.ImageType BMP -> T2
    com.itextpdf.io.image.ImageType JPEG -> Q2
    com.itextpdf.io.image.ImageType PNG -> R2
    com.itextpdf.io.image.ImageType NONE -> a3
com.itextpdf.io.image.ImageTypeDetector -> o0.h:
    byte[] jpeg -> b
    byte[] gif -> a
    byte[] tiff_1 -> h
    byte[] bmp -> g
    byte[] jbig2 -> j
    byte[] tiff_2 -> i
    byte[] jpeg2000_2 -> d
    byte[] jpeg2000_1 -> c
    byte[] wmf -> f
    byte[] png -> e
    com.itextpdf.io.image.ImageType detectImageType(java.net.URL) -> a
    com.itextpdf.io.image.ImageType detectImageTypeByHeader(byte[]) -> b
    boolean imageTypeIs(byte[],byte[]) -> c
    byte[] readImageType(java.io.InputStream) -> d
    byte[] readImageType(java.net.URL) -> e
com.itextpdf.io.image.Jbig2ImageData -> o0.i:
    int page -> B
    int getPage() -> Q
com.itextpdf.io.image.Jbig2ImageHelper -> o0.j:
    void processImage(com.itextpdf.io.image.ImageData) -> a
com.itextpdf.io.image.Jpeg2000ImageData -> o0.k:
    com.itextpdf.io.image.Jpeg2000ImageData$Parameters parameters -> B
com.itextpdf.io.image.Jpeg2000ImageData$ColorSpecBox -> o0.k$a:
    byte[] colorProfile -> Q2
    int getMeth() -> a
    void setColorProfile(byte[]) -> b
com.itextpdf.io.image.Jpeg2000ImageData$Parameters -> o0.k$b:
    java.util.List colorSpecBoxes -> b
    boolean isJp2 -> c
    int numOfComps -> a
    boolean isJpxBaseline -> d
    byte[] bpcBoxData -> e
com.itextpdf.io.image.Jpeg2000ImageHelper -> o0.l:
    int cio_read(int,java.io.InputStream) -> a
    void jp2_read_boxhdr(com.itextpdf.io.image.Jpeg2000ImageHelper$Jpeg2000Box,java.io.InputStream) -> b
    com.itextpdf.io.image.Jpeg2000ImageData$ColorSpecBox jp2_read_colr(com.itextpdf.io.image.Jpeg2000ImageHelper$Jpeg2000Box,java.io.InputStream) -> c
    void processImage(com.itextpdf.io.image.ImageData) -> d
    void processParameters(com.itextpdf.io.image.Jpeg2000ImageData) -> e
com.itextpdf.io.image.Jpeg2000ImageHelper$1 -> o0.l$a:
com.itextpdf.io.image.Jpeg2000ImageHelper$Jpeg2000Box -> o0.l$b:
    int type -> b
    int length -> a
com.itextpdf.io.image.Jpeg2000ImageHelper$ZeroBoxSizeException -> o0.l$c:
com.itextpdf.io.image.JpegImageData -> o0.m:
com.itextpdf.io.image.JpegImageHelper -> o0.n:
    org.slf4j.Logger LOGGER -> a
    int[] VALID_MARKERS -> b
    int[] UNSUPPORTED_MARKERS -> c
    int[] NOPARAM_MARKERS -> d
    byte[] PS_8BIM_RESO -> f
    byte[] JFIF_ID -> e
    void attemptToSetIccProfileToImage(byte[][],com.itextpdf.io.image.ImageData) -> a
    int getShort(java.io.InputStream) -> b
    int marker(int) -> c
    void processImage(com.itextpdf.io.image.ImageData) -> d
    void processParameters(java.io.InputStream,java.lang.String,com.itextpdf.io.image.ImageData) -> e
    void updateAttributes(com.itextpdf.io.image.ImageData) -> f
com.itextpdf.io.image.PngChromaticities -> o0.o:
    float yB -> h
    float xB -> g
    float yG -> f
    float xG -> e
    float yR -> d
    float xR -> c
    float yW -> b
    float xW -> a
    float getXB() -> a
    float getXG() -> b
    float getXR() -> c
    float getXW() -> d
    float getYB() -> e
    float getYG() -> f
    float getYR() -> g
    float getYW() -> h
com.itextpdf.io.image.PngImageData -> o0.p:
    com.itextpdf.io.image.PngChromaticities pngChromaticities -> F
    float gamma -> E
    int colorType -> D
    byte[] colorPalette -> C
    byte[] getColorPalette() -> S
    int getColorType() -> T
    float getGamma() -> U
    com.itextpdf.io.image.PngChromaticities getPngChromaticities() -> V
    boolean isGrayscaleImage() -> W
    boolean isHasCHRM() -> X
    boolean isIndexed() -> Y
    void setColorPalette(byte[]) -> Z
    void setColorType(int) -> a0
    void setGamma(float) -> b0
    void setPngChromaticities(com.itextpdf.io.image.PngChromaticities) -> c0
com.itextpdf.io.image.PngImageHelper -> o0.q:
    int[] PNGID -> a
    java.lang.String[] intents -> b
    boolean checkMarker(java.lang.String) -> a
    void decodeAverageFilter(byte[],byte[],int,int) -> b
    void decodeIdat(com.itextpdf.io.image.PngImageHelper$PngParameters) -> c
    void decodePaethFilter(byte[],byte[],int,int) -> d
    void decodePass(int,int,int,int,int,int,com.itextpdf.io.image.PngImageHelper$PngParameters) -> e
    void decodeSubFilter(byte[],int,int) -> f
    void decodeUpFilter(byte[],byte[],int) -> g
    int getExpectedNumberOfColorComponents(com.itextpdf.io.image.PngImageHelper$PngParameters) -> h
    int getInt(java.io.InputStream) -> i
    int[] getPixel(byte[],com.itextpdf.io.image.PngImageHelper$PngParameters) -> j
    java.lang.String getString(java.io.InputStream) -> k
    int getWord(java.io.InputStream) -> l
    int paethPredictor(int,int,int) -> m
    void processImage(com.itextpdf.io.image.ImageData) -> n
    void processPixels(byte[],int,int,int,int,com.itextpdf.io.image.PngImageHelper$PngParameters) -> o
    void processPng(java.io.InputStream,com.itextpdf.io.image.PngImageHelper$PngParameters) -> p
    void readPng(java.io.InputStream,com.itextpdf.io.image.PngImageHelper$PngParameters) -> q
    void setPixel(byte[],int[],int,int,int,int,int,int) -> r
com.itextpdf.io.image.PngImageHelper$PngParameters -> o0.q$a:
    int dpiX -> n
    byte[] smask -> k
    int interlaceMethod -> h
    int compressionMethod -> f
    int height -> d
    boolean genBWMask -> q
    java.lang.String intent -> x
    java.util.Map additional -> i
    int bytesPerPixel -> w
    byte[] imageData -> j
    int transBlue -> u
    java.io.InputStream dataStream -> b
    int transRedGray -> s
    com.itextpdf.io.source.ByteArrayOutputStream idat -> m
    int dpiY -> o
    byte[] trans -> l
    int filterMethod -> g
    int bitDepth -> e
    int width -> c
    boolean palShades -> r
    com.itextpdf.io.colors.IccProfile iccProfile -> y
    com.itextpdf.io.image.PngImageData image -> a
    int inputBands -> v
    int transGreen -> t
    float XYRatio -> p
com.itextpdf.io.image.RawImageData -> o0.r:
    int typeCcitt -> B
    int getTypeCcitt() -> Q
    void setTypeCcitt(int) -> R
    boolean isRawImage() -> x
com.itextpdf.io.image.RawImageHelper -> o0.s:
    void updateCcittImageParameters(com.itextpdf.io.image.RawImageData,int,int,boolean,int,int,byte[]) -> a
    void updateImageAttributes(com.itextpdf.io.image.RawImageData,java.util.Map) -> b
    void updateRawImageParameters(com.itextpdf.io.image.RawImageData,int,int,int,int,byte[]) -> c
    void updateRawImageParameters(com.itextpdf.io.image.RawImageData,int,int,int,int,byte[],int[]) -> d
    void updateRawImageParameters(com.itextpdf.io.image.RawImageData,int,int,boolean,int,int,byte[],int[]) -> e
com.itextpdf.io.image.TiffImageData -> o0.t:
    boolean direct -> E
    int page -> D
    boolean recoverFromImageError -> C
    int getPage() -> S
    boolean isDirect() -> T
    boolean isRecoverFromImageError() -> U
    void setOriginalType(com.itextpdf.io.image.ImageType) -> V
com.itextpdf.io.image.TiffImageHelper -> o0.u:
    void applyPredictor(byte[],int,int,int,int) -> a
    void decodePackbits(byte[],byte[]) -> b
    long[] getArrayLongShort(com.itextpdf.io.codec.TIFFDirectory,int) -> c
    int getDpi(com.itextpdf.io.codec.TIFFField,int) -> d
    void processExtraSamples(com.itextpdf.io.source.DeflaterOutputStream,com.itextpdf.io.source.DeflaterOutputStream,byte[],int,int,int,int) -> e
    void processImage(com.itextpdf.io.image.ImageData) -> f
    void processTiffImage(com.itextpdf.io.source.RandomAccessFileOrArray,com.itextpdf.io.image.TiffImageHelper$TiffParameters) -> g
    void processTiffImageColor(com.itextpdf.io.codec.TIFFDirectory,com.itextpdf.io.source.RandomAccessFileOrArray,com.itextpdf.io.image.TiffImageHelper$TiffParameters) -> h
com.itextpdf.io.image.TiffImageHelper$TiffParameters -> o0.u$a:
    java.util.Map additional -> c
    boolean jpegProcessing -> b
    com.itextpdf.io.image.TiffImageData image -> a
com.itextpdf.io.source.ArrayRandomAccessSource -> p0.a:
    byte[] array -> a
    int get(long) -> a
    int get(long,byte[],int,int) -> b
com.itextpdf.io.source.BufferCleaner -> p0.b:
    java.lang.Object theUnsafe -> c
    java.lang.Class unmappableBufferClass -> a
    java.lang.reflect.Method method -> b
    void freeBuffer(java.lang.String,java.nio.ByteBuffer) -> a
    java.lang.Object unmapHackImpl() -> b
com.itextpdf.io.source.BufferCleaner$1 -> p0.b$a:
    com.itextpdf.io.source.BufferCleaner this$0 -> b
    java.nio.ByteBuffer val$buffer -> a
    java.lang.Throwable run() -> a
com.itextpdf.io.source.ByteArrayOutputStream -> p0.c:
    com.itextpdf.io.source.ByteArrayOutputStream assignBytes(byte[],int) -> a
com.itextpdf.io.source.ByteBuffer -> p0.d:
    byte[] buffer -> b
    byte[] bytes -> c
    int count -> a
    com.itextpdf.io.source.ByteBuffer append(byte) -> a
    com.itextpdf.io.source.ByteBuffer append(int) -> b
    com.itextpdf.io.source.ByteBuffer append(java.lang.String) -> c
    com.itextpdf.io.source.ByteBuffer append(byte[]) -> d
    com.itextpdf.io.source.ByteBuffer append(byte[],int,int) -> e
    com.itextpdf.io.source.ByteBuffer appendHex(byte) -> f
    int capacity() -> g
    byte get(int) -> h
    int getHex(int) -> i
    byte[] getInternalBuffer() -> j
    boolean isEmpty() -> k
    com.itextpdf.io.source.ByteBuffer prepend(byte) -> l
    com.itextpdf.io.source.ByteBuffer prepend(byte[]) -> m
    com.itextpdf.io.source.ByteBuffer reset() -> n
    int size() -> o
    boolean startsWith(byte[]) -> p
    byte[] toByteArray() -> q
    byte[] toByteArray(int,int) -> r
com.itextpdf.io.source.ByteBufferRandomAccessSource -> p0.g:
    java.nio.ByteBuffer byteBuffer -> a
    boolean allowUnmapping -> b
    boolean UNMAP_SUPPORTED -> c
    com.itextpdf.io.source.BufferCleaner CLEANER -> d
    int get(long) -> a
    int get(long,byte[],int,int) -> b
    java.lang.Boolean $r8$lambda$HTbjSt4k-RykECpizDq-tr7ETGQ(java.nio.ByteBuffer) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    boolean clean(java.nio.ByteBuffer) -> d
    boolean cleanByUnmapping(java.nio.ByteBuffer) -> e
    java.lang.Boolean lambda$clean$0(java.nio.ByteBuffer) -> f
com.itextpdf.io.source.ByteUtils -> p0.h:
    byte[] bytes -> b
    boolean HighPrecision -> a
    byte[] one -> d
    byte[] zero -> c
    byte[] negOne -> e
    byte[] getIsoBytes(double) -> a
    byte[] getIsoBytes(double,com.itextpdf.io.source.ByteBuffer) -> b
    byte[] getIsoBytes(double,com.itextpdf.io.source.ByteBuffer,boolean) -> c
    byte[] getIsoBytes(int) -> d
    byte[] getIsoBytes(int,com.itextpdf.io.source.ByteBuffer) -> e
    byte[] getIsoBytes(java.lang.String) -> f
    int intSize(int) -> g
    int longSize(long) -> h
com.itextpdf.io.source.DeflaterOutputStream -> p0.i:
com.itextpdf.io.source.FileChannelRandomAccessSource -> p0.j:
    com.itextpdf.io.source.MappedChannelRandomAccessSource source -> b
    java.nio.channels.FileChannel channel -> a
    int get(long) -> a
    int get(long,byte[],int,int) -> b
com.itextpdf.io.source.GetBufferedRandomAccessSource -> p0.k:
    byte[] getBuffer -> b
    com.itextpdf.io.source.IRandomAccessSource source -> a
    long getBufferEnd -> d
    long getBufferStart -> c
    int get(long) -> a
    int get(long,byte[],int,int) -> b
com.itextpdf.io.source.GroupedRandomAccessSource -> p0.l:
    com.itextpdf.io.source.GroupedRandomAccessSource$SourceEntry[] sources -> a
    com.itextpdf.io.source.GroupedRandomAccessSource$SourceEntry currentSourceEntry -> b
    long size -> c
    int get(long) -> a
    int get(long,byte[],int,int) -> b
    com.itextpdf.io.source.GroupedRandomAccessSource$SourceEntry getSourceEntryForOffset(long) -> c
    int getStartingSourceIndex(long) -> d
    void sourceInUse(com.itextpdf.io.source.IRandomAccessSource) -> e
    void sourceReleased(com.itextpdf.io.source.IRandomAccessSource) -> f
com.itextpdf.io.source.GroupedRandomAccessSource$SourceEntry -> p0.l$a:
    com.itextpdf.io.source.IRandomAccessSource source -> a
    long firstByte -> b
    int index -> d
    long lastByte -> c
    long offsetN(long) -> a
com.itextpdf.io.source.IRandomAccessSource -> p0.m:
    int get(long) -> a
    int get(long,byte[],int,int) -> b
com.itextpdf.io.source.IndependentRandomAccessSource -> p0.n:
    com.itextpdf.io.source.IRandomAccessSource source -> a
    int get(long) -> a
    int get(long,byte[],int,int) -> b
com.itextpdf.io.source.MappedChannelRandomAccessSource -> p0.o:
    com.itextpdf.io.source.ByteBufferRandomAccessSource source -> d
    long offset -> b
    long length -> c
    java.nio.channels.FileChannel channel -> a
    int get(long) -> a
    int get(long,byte[],int,int) -> b
    void open() -> c
com.itextpdf.io.source.OutputStream -> p0.p:
    java.io.OutputStream outputStream -> S2
    boolean closeStream -> U2
    java.lang.Boolean localHighPrecision -> R2
    long currentPos -> T2
    com.itextpdf.io.source.ByteBuffer numBuffer -> Q2
    void assignBytes(byte[],int) -> a
    long getCurrentPos() -> b
    java.io.OutputStream getOutputStream() -> c
    void reset() -> d
    java.io.OutputStream writeByte(int) -> e
    void writeByte(byte) -> f
    java.io.OutputStream writeBytes(byte[]) -> g
    java.io.OutputStream writeDouble(double) -> h
    java.io.OutputStream writeDouble(double,boolean) -> i
    java.io.OutputStream writeFloat(float) -> j
    java.io.OutputStream writeFloat(float,boolean) -> k
    java.io.OutputStream writeFloats(float[]) -> l
    java.io.OutputStream writeInteger(int) -> m
    java.io.OutputStream writeLong(long) -> n
    java.io.OutputStream writeNewLine() -> o
    java.io.OutputStream writeSpace() -> p
    java.io.OutputStream writeString(java.lang.String) -> q
com.itextpdf.io.source.PagedChannelRandomAccessSource -> p0.q:
    java.nio.channels.FileChannel channel -> e
    int bufferSize -> d
    com.itextpdf.io.source.PagedChannelRandomAccessSource$MRU mru -> f
    int getStartingSourceIndex(long) -> d
    void sourceInUse(com.itextpdf.io.source.IRandomAccessSource) -> e
    void sourceReleased(com.itextpdf.io.source.IRandomAccessSource) -> f
    com.itextpdf.io.source.IRandomAccessSource[] buildSources(java.nio.channels.FileChannel,int) -> g
com.itextpdf.io.source.PagedChannelRandomAccessSource$MRU -> p0.q$a:
    java.util.LinkedList queue -> b
    int limit -> a
    java.lang.Object enqueue(java.lang.Object) -> a
com.itextpdf.io.source.PdfTokenizer -> p0.r:
    byte[] Trailer -> d3
    byte[] Stream -> c3
    boolean[] delims -> X2
    byte[] Startxref -> b3
    byte[] Xref -> a3
    byte[] True -> h3
    byte[] Null -> g3
    byte[] F -> f3
    com.itextpdf.io.source.ByteBuffer outBuf -> U2
    byte[] N -> e3
    byte[] R -> Z2
    byte[] Obj -> Y2
    int reference -> R2
    boolean closeStream -> W2
    int generation -> S2
    boolean hexString -> T2
    com.itextpdf.io.source.RandomAccessFileOrArray file -> V2
    byte[] False -> i3
    com.itextpdf.io.source.PdfTokenizer$TokenType type -> Q2
    void throwError(java.lang.String,java.lang.Object[]) -> A
    boolean tokenValueEqualsTo(byte[]) -> B
    void backOnePosition(int) -> a
    int[] checkObjectStart(com.itextpdf.io.source.PdfTokenizer) -> b
    java.lang.String checkPdfHeader() -> c
    boolean checkTrailer(com.itextpdf.io.source.ByteBuffer) -> d
    byte[] decodeStringContent(byte[],int,int,boolean) -> e
    byte[] decodeStringContent(byte[],boolean) -> f
    byte[] getByteContent() -> g
    int getGenNr() -> h
    int getHeaderOffset() -> i
    int getIntValue() -> j
    long getLongValue() -> k
    int getObjNr() -> l
    long getPosition() -> m
    com.itextpdf.io.source.RandomAccessFileOrArray getSafeFile() -> n
    long getStartxref() -> o
    java.lang.String getStringValue() -> p
    com.itextpdf.io.source.PdfTokenizer$TokenType getTokenType() -> q
    boolean isHexString() -> r
    boolean isWhitespace(int) -> s
    boolean isWhitespace(int,boolean) -> t
    long length() -> u
    boolean nextToken() -> v
    void nextValidToken() -> w
    boolean readLineSegment(com.itextpdf.io.source.ByteBuffer,boolean) -> x
    java.lang.String readString(int) -> y
    void seek(long) -> z
com.itextpdf.io.source.PdfTokenizer$TokenType -> p0.r$a:
    com.itextpdf.io.source.PdfTokenizer$TokenType[] $VALUES -> d3
    com.itextpdf.io.source.PdfTokenizer$TokenType EndOfFile -> c3
    com.itextpdf.io.source.PdfTokenizer$TokenType Other -> b3
    com.itextpdf.io.source.PdfTokenizer$TokenType EndObj -> a3
    com.itextpdf.io.source.PdfTokenizer$TokenType Obj -> Z2
    com.itextpdf.io.source.PdfTokenizer$TokenType Ref -> Y2
    com.itextpdf.io.source.PdfTokenizer$TokenType EndDic -> X2
    com.itextpdf.io.source.PdfTokenizer$TokenType StartDic -> W2
    com.itextpdf.io.source.PdfTokenizer$TokenType EndArray -> V2
    com.itextpdf.io.source.PdfTokenizer$TokenType StartArray -> U2
    com.itextpdf.io.source.PdfTokenizer$TokenType Comment -> T2
    com.itextpdf.io.source.PdfTokenizer$TokenType Name -> S2
    com.itextpdf.io.source.PdfTokenizer$TokenType String -> R2
    com.itextpdf.io.source.PdfTokenizer$TokenType Number -> Q2
com.itextpdf.io.source.RAFRandomAccessSource -> p0.s:
    java.io.RandomAccessFile raf -> a
    long length -> b
    int get(long) -> a
    int get(long,byte[],int,int) -> b
com.itextpdf.io.source.RASInputStream -> p0.t:
    com.itextpdf.io.source.IRandomAccessSource source -> Q2
    long position -> R2
    com.itextpdf.io.source.IRandomAccessSource getSource() -> a
com.itextpdf.io.source.RandomAccessFileOrArray -> p0.u:
    com.itextpdf.io.source.IRandomAccessSource byteSource -> Q2
    byte back -> S2
    boolean isBack -> T2
    long byteSourcePosition -> R2
    com.itextpdf.io.source.RandomAccessFileOrArray createView() -> a
    void ensureByteSourceIsThreadSafe() -> b
    long getPosition() -> c
    long length() -> d
    void pushBack(byte) -> e
    double readDoubleLE() -> f
    float readFloatLE() -> g
    int readIntLE() -> h
    long readLongLE() -> i
    short readShortLE() -> j
    java.lang.String readString(int,java.lang.String) -> k
    long readUnsignedInt() -> l
    long readUnsignedIntLE() -> m
    int readUnsignedShortLE() -> n
    void seek(long) -> o
com.itextpdf.io.source.RandomAccessSourceFactory -> p0.v:
    boolean forceRead -> a
    boolean usePlainRandomAccess -> b
    boolean exclusivelyLockFile -> c
    boolean forceReadDefaultValue -> d
    com.itextpdf.io.source.IRandomAccessSource createBestSource(java.lang.String) -> a
    com.itextpdf.io.source.IRandomAccessSource createBestSource(java.nio.channels.FileChannel) -> b
    com.itextpdf.io.source.IRandomAccessSource createByReadingToMemory(java.io.InputStream) -> c
    com.itextpdf.io.source.IRandomAccessSource createByReadingToMemory(java.lang.String) -> d
    com.itextpdf.io.source.IRandomAccessSource createSource(java.io.InputStream) -> e
    com.itextpdf.io.source.IRandomAccessSource createSource(java.net.URL) -> f
    com.itextpdf.io.source.IRandomAccessSource createSource(byte[]) -> g
    boolean exceptionIsMapFailureException(java.io.IOException) -> h
    com.itextpdf.io.source.IRandomAccessSource extractOrCreateSource(java.io.InputStream) -> i
    com.itextpdf.io.source.RandomAccessSourceFactory setForceRead(boolean) -> j
com.itextpdf.io.source.ThreadSafeRandomAccessSource -> p0.w:
    com.itextpdf.io.source.IRandomAccessSource source -> a
    java.lang.Object lockObj -> b
    int get(long) -> a
    int get(long,byte[],int,int) -> b
com.itextpdf.io.source.WindowRandomAccessSource -> p0.x:
    com.itextpdf.io.source.IRandomAccessSource source -> a
    long offset -> b
    long length -> c
    int get(long) -> a
    int get(long,byte[],int,int) -> b
com.itextpdf.io.util.ArrayUtil -> q0.a:
    int[] cloneArray(int[]) -> a
    int[] fillWithValue(int[],int) -> b
    byte[] shortenArray(byte[],int) -> c
    int[] toIntArray(java.util.Collection) -> d
com.itextpdf.io.util.DecimalFormatUtil -> q0.b:
    java.text.DecimalFormatSymbols dfs -> a
    java.lang.String formatNumber(double,java.lang.String) -> a
com.itextpdf.io.util.EnumUtil -> q0.c:
    java.lang.Enum throwIfNull(java.lang.Enum) -> a
com.itextpdf.io.util.FilterUtil -> q0.d:
    org.slf4j.Logger LOGGER -> a
    byte[] flateDecode(byte[],boolean) -> a
    java.io.InputStream getInflaterInputStream(java.io.InputStream) -> b
    void inflateData(byte[],byte[]) -> c
com.itextpdf.io.util.GenericArray -> q0.e:
    java.util.List array -> a
    java.lang.Object get(int) -> a
    java.lang.Object set(int,java.lang.Object) -> b
com.itextpdf.io.util.HashCode -> q0.f:
    int hashCode -> a
    com.itextpdf.io.util.HashCode append(double) -> a
    com.itextpdf.io.util.HashCode append(int) -> b
    int combine(int,double) -> c
    int combine(int,int) -> d
    int combine(int,long) -> e
com.itextpdf.io.util.IntHashtable -> q0.g:
    int threshold -> S2
    com.itextpdf.io.util.IntHashtable$Entry[] table -> R2
    int count -> Q2
    float loadFactor -> T2
    boolean containsKey(int) -> a
    int get(int) -> b
    int[] getKeys() -> c
    int put(int,int) -> d
    void rehash() -> e
    int[] toOrderedKeys() -> f
com.itextpdf.io.util.IntHashtable$Entry -> q0.g$a:
    com.itextpdf.io.util.IntHashtable$Entry next -> c
    int value -> b
    int key -> a
com.itextpdf.io.util.NumberUtil -> q0.h:
    java.lang.Float asFloat(java.lang.Object) -> a
    java.lang.Integer asInteger(java.lang.Object) -> b
com.itextpdf.io.util.ResourceUtil -> q0.i:
    java.io.InputStream getResourceStream(java.lang.String) -> a
    java.io.InputStream getResourceStream(java.lang.String,java.lang.ClassLoader) -> b
com.itextpdf.io.util.StreamUtil -> q0.j:
    byte[] escN -> b
    byte[] escR -> a
    byte[] escB -> d
    byte[] escT -> c
    byte[] escF -> e
    com.itextpdf.io.source.ByteBuffer createBufferedEscapedString(byte[]) -> a
    com.itextpdf.io.source.ByteBuffer createBufferedHexedString(byte[]) -> b
    byte[] createEscapedString(byte[]) -> c
    byte[] inputStreamToArray(java.io.InputStream) -> d
    void readFully(java.io.InputStream,byte[],int,int) -> e
    void skip(java.io.InputStream,long) -> f
    void transferBytes(java.io.InputStream,java.io.OutputStream) -> g
    void transferBytes(com.itextpdf.io.source.RandomAccessFileOrArray,java.io.OutputStream) -> h
    void writeEscapedString(java.io.OutputStream,byte[]) -> i
    void writeHexedString(java.io.OutputStream,byte[]) -> j
com.itextpdf.io.util.TextUtil -> q0.k:
    char[] convertFromUtf32(int) -> a
    int convertToUtf32(java.lang.String,int) -> b
    boolean isCarriageReturnFollowedByLineFeed(com.itextpdf.io.font.otf.GlyphLine,int) -> c
    boolean isNewLine(int) -> d
    boolean isNewLine(com.itextpdf.io.font.otf.Glyph) -> e
    boolean isNonBreakingHyphen(com.itextpdf.io.font.otf.Glyph) -> f
    boolean isNonPrintable(int) -> g
    boolean isSpaceOrWhitespace(com.itextpdf.io.font.otf.Glyph) -> h
    boolean isSurrogateHigh(char) -> i
    boolean isSurrogateLow(char) -> j
    boolean isSurrogatePair(java.lang.String,int) -> k
    boolean isUni0020(com.itextpdf.io.font.otf.Glyph) -> l
    boolean isWhitespace(com.itextpdf.io.font.otf.Glyph) -> m
    boolean isWhitespaceOrNonPrintable(int) -> n
com.itextpdf.io.util.UrlUtil -> q0.l:
    java.io.InputStream openStream(java.net.URL) -> a
    java.net.URL toURL(java.lang.String) -> b
com.itextpdf.io.util.XmlUtil -> q0.m:
    javax.xml.parsers.DocumentBuilderFactory getDocumentBuilderFactory() -> a
com.itextpdf.kernel.actions.data.ITextCoreProductData -> r0.a:
    com.itextpdf.commons.actions.data.ProductData ITEXT_PRODUCT_DATA -> a
    com.itextpdf.commons.actions.data.ProductData getInstance() -> a
com.itextpdf.kernel.actions.events.FlushPdfDocumentEvent -> s0.a:
    org.slf4j.Logger LOGGER -> c
    java.lang.ref.WeakReference document -> b
    void doAction() -> c
    java.util.List getConfirmedEvents(com.itextpdf.commons.actions.sequence.SequenceId) -> f
com.itextpdf.kernel.actions.events.ITextCoreProductEvent -> s0.b:
    java.lang.String eventType -> f
    java.lang.String getEventType() -> g
    com.itextpdf.kernel.actions.events.ITextCoreProductEvent createProcessPdfEvent(com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.contexts.IMetaInfo,com.itextpdf.commons.actions.confirmations.EventConfirmationType) -> i
com.itextpdf.kernel.actions.events.LinkDocumentIdEvent -> s0.c:
    java.lang.ref.WeakReference sequenceId -> c
    java.lang.ref.WeakReference document -> b
    void doAction() -> c
com.itextpdf.kernel.colors.CalGray -> t0.a:
com.itextpdf.kernel.colors.CalRgb -> t0.b:
com.itextpdf.kernel.colors.Color -> t0.c:
    com.itextpdf.kernel.pdf.colorspace.PdfColorSpace colorSpace -> a
    float[] colorValue -> b
    com.itextpdf.kernel.pdf.colorspace.PdfColorSpace getColorSpace() -> a
    float[] getColorValue() -> b
    com.itextpdf.kernel.colors.Color makeColor(com.itextpdf.kernel.pdf.colorspace.PdfColorSpace,float[]) -> c
com.itextpdf.kernel.colors.ColorConstants -> t0.d:
    com.itextpdf.kernel.colors.Color BLACK -> a
    com.itextpdf.kernel.colors.Color LIGHT_GRAY -> g
    com.itextpdf.kernel.colors.Color GREEN -> f
    com.itextpdf.kernel.colors.Color ORANGE -> i
    com.itextpdf.kernel.colors.Color MAGENTA -> h
    com.itextpdf.kernel.colors.Color CYAN -> c
    com.itextpdf.kernel.colors.Color BLUE -> b
    com.itextpdf.kernel.colors.Color GRAY -> e
    com.itextpdf.kernel.colors.Color DARK_GRAY -> d
    com.itextpdf.kernel.colors.Color RED -> k
    com.itextpdf.kernel.colors.Color PINK -> j
    com.itextpdf.kernel.colors.Color YELLOW -> m
    com.itextpdf.kernel.colors.Color WHITE -> l
com.itextpdf.kernel.colors.DeviceCmyk -> t0.e:
    com.itextpdf.kernel.colors.DeviceCmyk YELLOW -> e
    com.itextpdf.kernel.colors.DeviceCmyk BLACK -> f
    com.itextpdf.kernel.colors.DeviceCmyk CYAN -> c
    com.itextpdf.kernel.colors.DeviceCmyk MAGENTA -> d
com.itextpdf.kernel.colors.DeviceGray -> t0.f:
    com.itextpdf.kernel.colors.DeviceGray WHITE -> c
    com.itextpdf.kernel.colors.DeviceGray GRAY -> d
    com.itextpdf.kernel.colors.DeviceGray BLACK -> e
com.itextpdf.kernel.colors.DeviceN -> t0.g:
    float[] getDefaultColorants(int) -> d
com.itextpdf.kernel.colors.DeviceRgb -> t0.h:
    com.itextpdf.kernel.colors.Color BLUE -> g
    com.itextpdf.kernel.colors.Color GREEN -> f
    com.itextpdf.kernel.colors.Color BLACK -> c
    com.itextpdf.kernel.colors.Color RED -> e
    com.itextpdf.kernel.colors.Color WHITE -> d
com.itextpdf.kernel.colors.IccBased -> t0.i:
com.itextpdf.kernel.colors.Indexed -> t0.j:
com.itextpdf.kernel.colors.Lab -> t0.k:
com.itextpdf.kernel.colors.PatternColor -> t0.l:
    com.itextpdf.kernel.colors.Color underlyingColor -> d
    com.itextpdf.kernel.pdf.colorspace.PdfPattern pattern -> c
    com.itextpdf.kernel.pdf.colorspace.PdfColorSpace ensureNotPatternCs(com.itextpdf.kernel.pdf.colorspace.PdfColorSpace) -> d
    com.itextpdf.kernel.pdf.colorspace.PdfPattern getPattern() -> e
com.itextpdf.kernel.colors.Separation -> t0.m:
com.itextpdf.kernel.colors.gradients.AbstractLinearGradientBuilder -> u0.a:
com.itextpdf.kernel.crypto.AESCipher -> v0.a:
    org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher bp -> a
    byte[] doFinal() -> a
    byte[] update(byte[],int,int) -> b
com.itextpdf.kernel.crypto.AESCipherCBCnoPad -> v0.b:
    org.bouncycastle.crypto.BlockCipher cbc -> a
    byte[] processBlock(byte[],int,int) -> a
com.itextpdf.kernel.crypto.ARCFOUREncryption -> v0.c:
    byte[] state -> a
    int x -> b
    int y -> c
    void encryptARCFOUR(byte[]) -> a
    void encryptARCFOUR(byte[],int,int) -> b
    void encryptARCFOUR(byte[],int,int,byte[],int) -> c
    void encryptARCFOUR(byte[],byte[]) -> d
    void prepareARCFOURKey(byte[]) -> e
    void prepareARCFOURKey(byte[],int,int) -> f
com.itextpdf.kernel.crypto.AesDecryptor -> v0.d:
    byte[] key -> b
    com.itextpdf.kernel.crypto.AESCipher cipher -> a
    int ivptr -> e
    byte[] iv -> d
    boolean initiated -> c
    byte[] update(byte[],int,int) -> a
    byte[] finish() -> b
com.itextpdf.kernel.crypto.CryptoUtil -> v0.e:
    org.bouncycastle.asn1.ASN1OutputStream createAsn1OutputStream(java.io.OutputStream,java.lang.String) -> a
com.itextpdf.kernel.crypto.IDecryptor -> v0.f:
    byte[] update(byte[],int,int) -> a
    byte[] finish() -> b
com.itextpdf.kernel.crypto.IVGenerator -> v0.g:
    com.itextpdf.kernel.crypto.ARCFOUREncryption arcfour -> a
    byte[] getIV() -> a
    byte[] getIV(int) -> b
com.itextpdf.kernel.crypto.OutputStreamAesEncryption -> v0.h:
    boolean finished -> T2
    com.itextpdf.kernel.crypto.AESCipher cipher -> S2
    void finish() -> a
com.itextpdf.kernel.crypto.OutputStreamEncryption -> v0.i:
    byte[] sb -> R2
    java.io.OutputStream out -> Q2
    void finish() -> a
com.itextpdf.kernel.crypto.OutputStreamStandardEncryption -> v0.j:
    com.itextpdf.kernel.crypto.ARCFOUREncryption arcfour -> S2
    void finish() -> a
com.itextpdf.kernel.crypto.StandardDecryptor -> v0.k:
    com.itextpdf.kernel.crypto.ARCFOUREncryption arcfour -> a
    byte[] update(byte[],int,int) -> a
    byte[] finish() -> b
com.itextpdf.kernel.crypto.securityhandler.EncryptionUtils -> w0.a:
    com.itextpdf.kernel.crypto.securityhandler.EncryptionUtils$DERForRecipientParams calculateDERForRecipientParams(byte[]) -> a
    byte[] cipherBytes(java.security.cert.X509Certificate,byte[],org.bouncycastle.asn1.x509.AlgorithmIdentifier) -> b
    byte[] fetchEnvelopedData(java.security.Key,java.security.cert.Certificate,java.lang.String,com.itextpdf.kernel.security.IExternalDecryptionProcess,com.itextpdf.kernel.pdf.PdfArray) -> c
    byte[] generateSeed(int) -> d
com.itextpdf.kernel.crypto.securityhandler.EncryptionUtils$DERForRecipientParams -> w0.a$a:
    byte[] abyte1 -> b
    org.bouncycastle.asn1.x509.AlgorithmIdentifier algorithmIdentifier -> c
    byte[] abyte0 -> a
com.itextpdf.kernel.crypto.securityhandler.PubKeySecurityHandler -> w0.b:
    java.util.List recipients -> f
    byte[] seed -> g
    void addAllRecipients(java.security.cert.Certificate[],int[]) -> e
    void addRecipient(java.security.cert.Certificate,int) -> f
    byte[] computeGlobalKey(java.lang.String,boolean) -> g
    byte[] computeGlobalKeyOnReading(com.itextpdf.kernel.pdf.PdfDictionary,java.security.PrivateKey,java.security.cert.Certificate,java.lang.String,com.itextpdf.kernel.security.IExternalDecryptionProcess,boolean,java.lang.String) -> h
    org.bouncycastle.asn1.cms.KeyTransRecipientInfo computeRecipientInfo(java.security.cert.X509Certificate,byte[]) -> i
    org.bouncycastle.asn1.ASN1Primitive createDERForRecipient(byte[],java.security.cert.X509Certificate) -> j
    com.itextpdf.kernel.pdf.PdfArray createRecipientsArray() -> k
    java.lang.String getDigestAlgorithm() -> l
    byte[] getEncodedRecipient(int) -> m
    com.itextpdf.kernel.pdf.PdfArray getEncodedRecipients() -> n
    int getRecipientsSize() -> o
    byte[] getSeed() -> p
    void initKey(byte[],int) -> q
    void initKeyAndFillDictionary(com.itextpdf.kernel.pdf.PdfDictionary,java.security.cert.Certificate[],int[],boolean,boolean) -> r
    void initKeyAndReadDictionary(com.itextpdf.kernel.pdf.PdfDictionary,java.security.Key,java.security.cert.Certificate,java.lang.String,com.itextpdf.kernel.security.IExternalDecryptionProcess,boolean) -> s
    void setPubSecSpecificHandlerDicEntries(com.itextpdf.kernel.pdf.PdfDictionary,boolean,boolean) -> t
com.itextpdf.kernel.crypto.securityhandler.PubSecHandlerUsingAes128 -> w0.c:
    byte[] salt -> h
    com.itextpdf.kernel.crypto.IDecryptor getDecryptor() -> a
    com.itextpdf.kernel.crypto.OutputStreamEncryption getEncryptionStream(java.io.OutputStream) -> b
    void setHashKeyForNextObject(int,int) -> d
    java.lang.String getDigestAlgorithm() -> l
    void initKey(byte[],int) -> q
    void setPubSecSpecificHandlerDicEntries(com.itextpdf.kernel.pdf.PdfDictionary,boolean,boolean) -> t
com.itextpdf.kernel.crypto.securityhandler.PubSecHandlerUsingAes256 -> w0.d:
    void setHashKeyForNextObject(int,int) -> d
    java.lang.String getDigestAlgorithm() -> l
    void initKey(byte[],int) -> q
    void setPubSecSpecificHandlerDicEntries(com.itextpdf.kernel.pdf.PdfDictionary,boolean,boolean) -> t
com.itextpdf.kernel.crypto.securityhandler.PubSecHandlerUsingStandard128 -> w0.e:
    void setPubSecSpecificHandlerDicEntries(com.itextpdf.kernel.pdf.PdfDictionary,boolean,boolean) -> t
com.itextpdf.kernel.crypto.securityhandler.PubSecHandlerUsingStandard40 -> w0.f:
    com.itextpdf.kernel.crypto.IDecryptor getDecryptor() -> a
    com.itextpdf.kernel.crypto.OutputStreamEncryption getEncryptionStream(java.io.OutputStream) -> b
    java.lang.String getDigestAlgorithm() -> l
    void initKey(byte[],int) -> q
    void setPubSecSpecificHandlerDicEntries(com.itextpdf.kernel.pdf.PdfDictionary,boolean,boolean) -> t
com.itextpdf.kernel.crypto.securityhandler.PublicKeyRecipient -> w0.g:
    java.security.cert.Certificate certificate -> a
    int permission -> b
    byte[] cms -> c
    java.security.cert.Certificate getCertificate() -> a
    byte[] getCms() -> b
    int getPermission() -> c
    void setCms(byte[]) -> d
com.itextpdf.kernel.crypto.securityhandler.SecurityHandler -> w0.h:
    byte[] nextObjectKey -> b
    byte[] mkey -> a
    java.security.MessageDigest md5 -> d
    int nextObjectKeySize -> c
    byte[] extra -> e
    com.itextpdf.kernel.crypto.IDecryptor getDecryptor() -> a
    com.itextpdf.kernel.crypto.OutputStreamEncryption getEncryptionStream(java.io.OutputStream) -> b
    void safeInitMessageDigest() -> c
    void setHashKeyForNextObject(int,int) -> d
com.itextpdf.kernel.crypto.securityhandler.StandardHandlerUsingAes128 -> w0.i:
    byte[] salt -> m
    com.itextpdf.kernel.crypto.IDecryptor getDecryptor() -> a
    com.itextpdf.kernel.crypto.OutputStreamEncryption getEncryptionStream(java.io.OutputStream) -> b
    void setHashKeyForNextObject(int,int) -> d
    void setSpecificHandlerDicEntries(com.itextpdf.kernel.pdf.PdfDictionary,boolean,boolean) -> u
com.itextpdf.kernel.crypto.securityhandler.StandardHandlerUsingAes256 -> w0.j:
    boolean encryptMetadata -> i
    boolean isPdf2 -> h
    com.itextpdf.kernel.crypto.IDecryptor getDecryptor() -> a
    com.itextpdf.kernel.crypto.OutputStreamEncryption getEncryptionStream(java.io.OutputStream) -> b
    void setHashKeyForNextObject(int,int) -> d
    boolean compareArray(byte[],byte[],int) -> k
    byte[] computeHash(byte[],byte[],int,int) -> l
    byte[] computeHash(byte[],byte[],int,int,byte[]) -> m
    void initKeyAndFillDictionary(com.itextpdf.kernel.pdf.PdfDictionary,byte[],byte[],int,boolean,boolean) -> n
    void initKeyAndReadDictionary(com.itextpdf.kernel.pdf.PdfDictionary,byte[]) -> o
    boolean isEncryptMetadata() -> p
    void setAES256DicEntries(com.itextpdf.kernel.pdf.PdfDictionary,byte[],byte[],byte[],boolean,boolean) -> q
com.itextpdf.kernel.crypto.securityhandler.StandardHandlerUsingStandard128 -> w0.k:
    void calculatePermissions(int) -> k
    void computeGlobalEncryptionKey(byte[],byte[],boolean) -> m
    byte[] computeOwnerKey(byte[],byte[]) -> n
    byte[] computeUserKey() -> o
    boolean isValidPassword(byte[],byte[]) -> s
    void setSpecificHandlerDicEntries(com.itextpdf.kernel.pdf.PdfDictionary,boolean,boolean) -> u
com.itextpdf.kernel.crypto.securityhandler.StandardHandlerUsingStandard40 -> w0.l:
    byte[] metadataPad -> l
    byte[] pad -> k
    int keyLength -> i
    byte[] documentId -> h
    com.itextpdf.kernel.crypto.ARCFOUREncryption arcfour -> j
    com.itextpdf.kernel.crypto.IDecryptor getDecryptor() -> a
    com.itextpdf.kernel.crypto.OutputStreamEncryption getEncryptionStream(java.io.OutputStream) -> b
    void calculatePermissions(int) -> k
    void checkPassword(boolean,byte[],byte[],byte[]) -> l
    void computeGlobalEncryptionKey(byte[],byte[],boolean) -> m
    byte[] computeOwnerKey(byte[],byte[]) -> n
    byte[] computeUserKey() -> o
    int getKeyLength(com.itextpdf.kernel.pdf.PdfDictionary) -> p
    void initKeyAndFillDictionary(com.itextpdf.kernel.pdf.PdfDictionary,byte[],byte[],int,boolean,boolean,byte[]) -> q
    void initKeyAndReadDictionary(com.itextpdf.kernel.pdf.PdfDictionary,byte[],byte[],boolean) -> r
    boolean isValidPassword(byte[],byte[]) -> s
    byte[] padPassword(byte[]) -> t
    void setSpecificHandlerDicEntries(com.itextpdf.kernel.pdf.PdfDictionary,boolean,boolean) -> u
com.itextpdf.kernel.crypto.securityhandler.StandardSecurityHandler -> w0.m:
    long permissions -> f
    boolean usedOwnerPassword -> g
    boolean equalsArray(byte[],byte[],int) -> e
    byte[] generateOwnerPasswordIfNullOrEmpty(byte[]) -> f
    byte[] getIsoBytes(com.itextpdf.kernel.pdf.PdfString) -> g
    long getPermissions() -> h
    boolean isUsedOwnerPassword() -> i
    void setStandardHandlerDicEntries(com.itextpdf.kernel.pdf.PdfDictionary,byte[],byte[]) -> j
com.itextpdf.kernel.crypto.securityhandler.UnsupportedSecurityHandlerException -> w0.n:
com.itextpdf.kernel.events.Event -> x0.a:
    java.lang.String type -> a
    java.lang.String getType() -> a
com.itextpdf.kernel.events.EventDispatcher -> x0.b:
    java.util.Map eventHandlers -> a
    void dispatchEvent(com.itextpdf.kernel.events.Event) -> a
    void dispatchEvent(com.itextpdf.kernel.events.Event,boolean) -> b
    void removeAllHandlers() -> c
com.itextpdf.kernel.events.IEventHandler -> x0.c:
    void handleEvent(com.itextpdf.kernel.events.Event) -> a
com.itextpdf.kernel.events.PdfDocumentEvent -> x0.d:
    com.itextpdf.kernel.pdf.PdfDocument document -> c
    com.itextpdf.kernel.pdf.PdfPage page -> b
com.itextpdf.kernel.exceptions.BadPasswordException -> y0.a:
com.itextpdf.kernel.exceptions.InvalidXRefPrevException -> y0.b:
com.itextpdf.kernel.exceptions.MemoryLimitsAwareException -> y0.c:
com.itextpdf.kernel.exceptions.PdfException -> y0.d:
    java.util.List messageParams -> R2
    java.lang.Object object -> Q2
    java.lang.Object[] getMessageParams() -> a
    com.itextpdf.kernel.exceptions.PdfException setMessageParams(java.lang.Object[]) -> b
com.itextpdf.kernel.exceptions.XrefCycledReferencesException -> y0.e:
com.itextpdf.kernel.font.DocFontEncoding -> z0.a:
    com.itextpdf.io.font.FontEncoding createDocFontEncoding(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.io.font.cmap.CMapToUnicode) -> q
    void fillBaseEncoding(com.itextpdf.kernel.font.DocFontEncoding,com.itextpdf.kernel.pdf.PdfName) -> r
    void fillDifferences(com.itextpdf.kernel.font.DocFontEncoding,com.itextpdf.kernel.pdf.PdfArray,com.itextpdf.io.font.cmap.CMapToUnicode) -> s
    void fillDifferences(com.itextpdf.kernel.font.DocFontEncoding,com.itextpdf.io.font.cmap.CMapToUnicode) -> t
com.itextpdf.kernel.font.DocTrueTypeFont -> z0.b:
    com.itextpdf.kernel.pdf.PdfStream fontFile -> r
    int missingWidth -> u
    com.itextpdf.kernel.pdf.PdfName fontFileName -> s
    com.itextpdf.kernel.pdf.PdfName subtype -> t
    com.itextpdf.io.font.TrueTypeFont createFontProgram(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.io.font.FontEncoding,com.itextpdf.io.font.cmap.CMapToUnicode) -> P
    com.itextpdf.io.font.TrueTypeFont createFontProgram(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.io.font.cmap.CMapToUnicode) -> Q
    void fillFontDescriptor(com.itextpdf.kernel.font.DocTrueTypeFont,com.itextpdf.kernel.pdf.PdfDictionary) -> R
    int getMissingWidth() -> S
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> a
    com.itextpdf.kernel.pdf.PdfStream getFontFile() -> b
    com.itextpdf.kernel.pdf.PdfName getFontFileName() -> c
com.itextpdf.kernel.font.DocType1Font -> z0.c:
    com.itextpdf.kernel.pdf.PdfStream fontFile -> p
    com.itextpdf.kernel.pdf.PdfName fontFileName -> q
    com.itextpdf.kernel.pdf.PdfName subtype -> r
    int missingWidth -> s
    com.itextpdf.io.font.Type1Font createFontProgram(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.io.font.FontEncoding,com.itextpdf.io.font.cmap.CMapToUnicode) -> F
    void fillFontDescriptor(com.itextpdf.kernel.font.DocType1Font,com.itextpdf.kernel.pdf.PdfDictionary) -> G
    int getMissingWidth() -> H
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> a
    com.itextpdf.kernel.pdf.PdfStream getFontFile() -> b
    com.itextpdf.kernel.pdf.PdfName getFontFileName() -> c
com.itextpdf.kernel.font.FontUtil -> z0.d:
    java.util.HashMap uniMaps -> a
    java.lang.String addRandomSubsetPrefixForFontName(java.lang.String) -> a
    com.itextpdf.io.util.IntHashtable convertCompositeWidthsArray(com.itextpdf.kernel.pdf.PdfArray) -> b
    int[] convertSimpleWidthsArray(com.itextpdf.kernel.pdf.PdfArray,int,int) -> c
    java.lang.String createRandomFontName() -> d
    com.itextpdf.io.font.cmap.CMapToUnicode getToUnicodeFromUniMap(java.lang.String) -> e
    com.itextpdf.io.font.cmap.CMapToUnicode processToUnicode(com.itextpdf.kernel.pdf.PdfObject) -> f
com.itextpdf.kernel.font.IDocFontProgram -> z0.e:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> a
    com.itextpdf.kernel.pdf.PdfStream getFontFile() -> b
    com.itextpdf.kernel.pdf.PdfName getFontFileName() -> c
com.itextpdf.kernel.font.PdfFont -> z0.f:
    com.itextpdf.io.font.FontProgram fontProgram -> b
    java.util.Map notdefGlyphs -> c
    boolean embedded -> e
    byte[] EMPTY_BYTES -> h
    boolean subset -> f
    java.util.List subsetRanges -> g
    boolean newFont -> d
    boolean makeObjectIndirect(com.itextpdf.kernel.pdf.PdfObject) -> A
    java.lang.String updateSubsetPrefix(java.lang.String,boolean,boolean) -> B
    void writeText(com.itextpdf.io.font.otf.GlyphLine,int,int,com.itextpdf.kernel.pdf.PdfOutputStream) -> C
    void flush() -> h
    boolean isWrappedObjectMustBeIndirect() -> k
    int appendAnyGlyph(java.lang.String,int,java.util.List) -> r
    int appendGlyphs(java.lang.String,int,int,java.util.List) -> s
    boolean containsGlyph(int) -> t
    com.itextpdf.io.font.otf.GlyphLine createGlyphLine(java.lang.String) -> u
    com.itextpdf.io.font.FontProgram getFontProgram() -> v
    com.itextpdf.io.font.otf.Glyph getGlyph(int) -> w
    com.itextpdf.kernel.pdf.PdfStream getPdfFontStream(byte[],int[]) -> x
    boolean isEmbedded() -> y
    boolean isSubset() -> z
com.itextpdf.kernel.font.PdfFontFactory -> z0.g:
    com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy DEFAULT_EMBEDDING -> a
    com.itextpdf.kernel.font.PdfFont createFont() -> a
    com.itextpdf.kernel.font.PdfFont createFont(com.itextpdf.kernel.pdf.PdfDictionary) -> b
    com.itextpdf.kernel.font.PdfFont createFont(com.itextpdf.io.font.FontProgram,java.lang.String,com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy) -> c
    com.itextpdf.kernel.font.PdfFont createFont(java.lang.String) -> d
    com.itextpdf.kernel.font.PdfFont createFont(java.lang.String,java.lang.String) -> e
    com.itextpdf.kernel.font.PdfFont createFont(java.lang.String,java.lang.String,com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy) -> f
    com.itextpdf.kernel.font.PdfFont createFont(java.lang.String,java.lang.String,com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy,boolean) -> g
    com.itextpdf.kernel.font.PdfType1Font createFontFromType1FontProgram(com.itextpdf.io.font.Type1Font,java.lang.String,com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy) -> h
    com.itextpdf.kernel.font.PdfTrueTypeFont createTrueTypeFontFromTrueTypeFontProgram(com.itextpdf.io.font.TrueTypeFont,java.lang.String,com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy) -> i
    com.itextpdf.kernel.font.PdfType0Font createType0FontFromCidFontProgram(com.itextpdf.io.font.CidFont,java.lang.String,com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy) -> j
    com.itextpdf.kernel.font.PdfType0Font createType0FontFromTrueTypeFontProgram(com.itextpdf.io.font.TrueTypeFont,java.lang.String,com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy) -> k
com.itextpdf.kernel.font.PdfFontFactory$1 -> z0.g$a:
    int[] $SwitchMap$com$itextpdf$kernel$font$PdfFontFactory$EmbeddingStrategy -> a
com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy -> z0.g$b:
    com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy PREFER_NOT_EMBEDDED -> T2
    com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy FORCE_NOT_EMBEDDED -> R2
    com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy[] $VALUES -> U2
    com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy PREFER_EMBEDDED -> S2
    com.itextpdf.kernel.font.PdfFontFactory$EmbeddingStrategy FORCE_EMBEDDED -> Q2
com.itextpdf.kernel.font.PdfSimpleFont -> z0.h:
    boolean forceWidthsOutput -> j
    byte[] usedGlyphs -> k
    com.itextpdf.io.font.cmap.CMapToUnicode toUnicode -> l
    com.itextpdf.io.font.FontEncoding fontEncoding -> i
    void writeText(com.itextpdf.io.font.otf.GlyphLine,int,int,com.itextpdf.kernel.pdf.PdfOutputStream) -> C
    void addFontStream(com.itextpdf.kernel.pdf.PdfDictionary) -> D
    com.itextpdf.kernel.pdf.PdfArray buildWidthsArray(int,int) -> E
    void flushFontData(java.lang.String,com.itextpdf.kernel.pdf.PdfName) -> F
    com.itextpdf.kernel.pdf.PdfDictionary getFontDescriptor(java.lang.String) -> G
    com.itextpdf.io.font.FontEncoding getFontEncoding() -> H
    com.itextpdf.io.font.cmap.CMapToUnicode getToUnicode() -> I
    boolean isAppendableGlyph(com.itextpdf.io.font.otf.Glyph) -> J
    boolean isBuiltInFont() -> K
    boolean isForceWidthsOutput() -> L
    void setFontProgram(com.itextpdf.io.font.FontProgram) -> M
    int appendAnyGlyph(java.lang.String,int,java.util.List) -> r
    int appendGlyphs(java.lang.String,int,int,java.util.List) -> s
    com.itextpdf.io.font.otf.GlyphLine createGlyphLine(java.lang.String) -> u
com.itextpdf.kernel.font.PdfTrueTypeFont -> z0.i:
    void addFontStream(com.itextpdf.kernel.pdf.PdfDictionary) -> D
    boolean isBuiltInFont() -> K
    void flush() -> h
    boolean containsGlyph(int) -> t
    com.itextpdf.io.font.otf.Glyph getGlyph(int) -> w
com.itextpdf.kernel.font.PdfType0Font -> z0.j:
    int cidFontType -> l
    boolean vertical -> i
    byte[] rotbits -> n
    com.itextpdf.io.font.CMapEncoding cmapEncoding -> j
    java.util.Set usedGlyphs -> k
    char[] specificUnicodeDifferences -> m
    void writeText(com.itextpdf.io.font.otf.GlyphLine,int,int,com.itextpdf.kernel.pdf.PdfOutputStream) -> C
    int appendUniGlyphs(java.lang.String,int,int,java.util.List) -> D
    byte[] convertToBytes(com.itextpdf.io.font.otf.GlyphLine) -> E
    com.itextpdf.io.font.CMapEncoding createCMap(com.itextpdf.kernel.pdf.PdfObject,java.lang.String) -> F
    void flushFontData() -> G
    com.itextpdf.kernel.pdf.PdfObject generateWidthsArray() -> H
    com.itextpdf.kernel.pdf.PdfDictionary getCidFont(com.itextpdf.kernel.pdf.PdfDictionary,java.lang.String,boolean) -> I
    java.lang.String getCompatibleUniMap(java.lang.String) -> J
    com.itextpdf.kernel.pdf.PdfDictionary getFontDescriptor(java.lang.String) -> K
    java.lang.String getOrdering(com.itextpdf.kernel.pdf.PdfDictionary) -> L
    com.itextpdf.kernel.pdf.PdfStream getToUnicode() -> M
    java.lang.String getUniMapFromOrdering(java.lang.String,boolean) -> N
    boolean isAppendableGlyph(com.itextpdf.io.font.otf.Glyph) -> O
    java.lang.String toHex4(char) -> P
    int writeBfrange(com.itextpdf.io.source.OutputStream,java.util.List) -> Q
    void flush() -> h
    int appendAnyGlyph(java.lang.String,int,java.util.List) -> r
    int appendGlyphs(java.lang.String,int,int,java.util.List) -> s
    boolean containsGlyph(int) -> t
    com.itextpdf.io.font.otf.GlyphLine createGlyphLine(java.lang.String) -> u
    com.itextpdf.io.font.otf.Glyph getGlyph(int) -> w
com.itextpdf.kernel.font.PdfType1Font -> z0.k:
    void addFontStream(com.itextpdf.kernel.pdf.PdfDictionary) -> D
    boolean isBuiltInFont() -> K
    void flush() -> h
    boolean containsGlyph(int) -> t
    com.itextpdf.io.font.otf.Glyph getGlyph(int) -> w
    boolean isSubset() -> z
com.itextpdf.kernel.font.PdfType3Font -> z0.l:
    double[] fontMatrix -> m
    double[] DEFAULT_FONT_MATRIX -> o
    double glyphSpaceNormalizationFactor -> n
    void addFontStream(com.itextpdf.kernel.pdf.PdfDictionary) -> D
    com.itextpdf.kernel.pdf.PdfArray buildWidthsArray(int,int) -> E
    com.itextpdf.kernel.pdf.PdfDictionary getFontDescriptor(java.lang.String) -> G
    void addGlyphsFromCharProcs(com.itextpdf.kernel.pdf.PdfDictionary,int[]) -> N
    void addGlyphsFromDifferences(com.itextpdf.kernel.pdf.PdfArray,com.itextpdf.kernel.pdf.PdfDictionary,int[]) -> O
    void fillFontDescriptor(com.itextpdf.kernel.pdf.PdfDictionary) -> P
    void flushFontData() -> Q
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> R
    double[] getFontMatrix() -> S
    double getGlyphSpaceNormalizationFactor() -> T
    com.itextpdf.kernel.font.Type3Glyph getType3Glyph(int) -> U
    void initializeFontBBox(double[]) -> V
    void initializeTypoAscenderDescender(double[]) -> W
    int initializeUsedGlyphs(com.itextpdf.kernel.pdf.PdfDictionary) -> X
    double normalize1000UnitsToGlyphSpaceUnits(double) -> Y
    void normalize1000UnitsToGlyphSpaceUnits(double[]) -> Z
    int normalizeFirstLastChar(com.itextpdf.kernel.pdf.PdfNumber,int) -> a0
    double normalizeGlyphSpaceUnitsTo1000Units(double) -> b0
    void normalizeGlyphSpaceUnitsTo1000Units(double[]) -> c0
    double[] readFontBBox() -> d0
    double[] readFontMatrix() -> e0
    double[] readWidths(com.itextpdf.kernel.pdf.PdfDictionary) -> f0
    void setCapHeight(int) -> g0
    void flush() -> h
    void setFontFamily(java.lang.String) -> h0
    void setFontName(java.lang.String) -> i0
    void setFontStretch(java.lang.String) -> j0
    void setFontWeight(int) -> k0
    void setGlyphSpaceNormalizationFactor(double) -> l0
    void setItalicAngle(int) -> m0
    boolean containsGlyph(int) -> t
    com.itextpdf.io.font.otf.Glyph getGlyph(int) -> w
    boolean isEmbedded() -> y
    boolean isSubset() -> z
com.itextpdf.kernel.font.Type3Font -> z0.m:
    int flags -> m
    boolean colorized -> l
    java.util.Map type3Glyphs -> j
    java.util.Map type3GlyphsWithoutUnicode -> k
    void addGlyph(int,int,int,int[],com.itextpdf.kernel.font.Type3Glyph) -> B
    int getNumberOfGlyphs() -> C
    com.itextpdf.kernel.font.Type3Glyph getType3Glyph(int) -> D
    com.itextpdf.kernel.font.Type3Glyph getType3GlyphByCode(int) -> E
    void recalculateAverageWidth() -> F
    void removeGlyphFromMappings(int) -> G
    int getPdfFontFlags() -> j
    boolean isFontSpecific() -> l
    void setCapHeight(int) -> o
    void setFontFamily(java.lang.String) -> q
    void setFontName(java.lang.String) -> r
    void setFontStretch(java.lang.String) -> s
    void setFontWeight(int) -> t
    void setItalicAngle(int) -> u
    void setTypoAscender(int) -> x
    void setTypoDescender(int) -> y
com.itextpdf.kernel.font.Type3Glyph -> z0.n:
    float llx -> w0
    float wx -> v0
    float urx -> y0
    float lly -> x0
    boolean isColor -> A0
    byte[] d1 -> C0
    float ury -> z0
    byte[] d0 -> B0
    void fillBBFromBytes(byte[]) -> i0
com.itextpdf.kernel.geom.AffineTransform -> a1.a:
    int type -> W2
    double m00 -> Q2
    double m10 -> R2
    double m01 -> S2
    double m11 -> T2
    double m02 -> U2
    double m12 -> V2
    com.itextpdf.kernel.geom.AffineTransform clone() -> a
    void concatenate(com.itextpdf.kernel.geom.AffineTransform) -> b
    com.itextpdf.kernel.geom.AffineTransform createInverse() -> c
    double getDeterminant() -> d
    void getMatrix(double[]) -> e
    void getMatrix(float[]) -> f
    com.itextpdf.kernel.geom.AffineTransform getRotateInstance(double) -> g
    com.itextpdf.kernel.geom.AffineTransform getScaleInstance(double,double) -> h
    com.itextpdf.kernel.geom.AffineTransform getTranslateInstance(double,double) -> i
    double getTranslateX() -> j
    double getTranslateY() -> k
    com.itextpdf.kernel.geom.AffineTransform multiply(com.itextpdf.kernel.geom.AffineTransform,com.itextpdf.kernel.geom.AffineTransform) -> l
    void preConcatenate(com.itextpdf.kernel.geom.AffineTransform) -> m
    void rotate(double) -> n
    void scale(double,double) -> o
    void setToRotation(double) -> p
    void setToScale(double,double) -> r
    void setToTranslation(double,double) -> s
    void setTransform(double,double,double,double,double,double) -> t
    void setTransform(com.itextpdf.kernel.geom.AffineTransform) -> u
    com.itextpdf.kernel.geom.Point transform(com.itextpdf.kernel.geom.Point,com.itextpdf.kernel.geom.Point) -> w
    void translate(double,double) -> x
com.itextpdf.kernel.geom.Matrix -> a1.b:
    float[] vals -> a
    float get(int) -> a
    com.itextpdf.kernel.geom.Matrix multiply(com.itextpdf.kernel.geom.Matrix) -> b
com.itextpdf.kernel.geom.NoninvertibleTransformException -> a1.c:
com.itextpdf.kernel.geom.PageSize -> a1.d:
    com.itextpdf.kernel.geom.PageSize B7 -> n3
    com.itextpdf.kernel.geom.PageSize B6 -> m3
    com.itextpdf.kernel.geom.PageSize B9 -> p3
    com.itextpdf.kernel.geom.PageSize B8 -> o3
    com.itextpdf.kernel.geom.PageSize DEFAULT -> r3
    com.itextpdf.kernel.geom.PageSize B10 -> q3
    com.itextpdf.kernel.geom.PageSize LEDGER -> t3
    com.itextpdf.kernel.geom.PageSize EXECUTIVE -> s3
    com.itextpdf.kernel.geom.PageSize LETTER -> v3
    com.itextpdf.kernel.geom.PageSize LEGAL -> u3
    com.itextpdf.kernel.geom.PageSize A0 -> V2
    com.itextpdf.kernel.geom.PageSize A1 -> W2
    com.itextpdf.kernel.geom.PageSize TABLOID -> w3
    com.itextpdf.kernel.geom.PageSize A2 -> X2
    com.itextpdf.kernel.geom.PageSize A3 -> Y2
    com.itextpdf.kernel.geom.PageSize A4 -> Z2
    com.itextpdf.kernel.geom.PageSize A5 -> a3
    com.itextpdf.kernel.geom.PageSize A6 -> b3
    com.itextpdf.kernel.geom.PageSize A7 -> c3
    com.itextpdf.kernel.geom.PageSize A8 -> d3
    com.itextpdf.kernel.geom.PageSize A9 -> e3
    com.itextpdf.kernel.geom.PageSize A10 -> f3
    com.itextpdf.kernel.geom.PageSize B0 -> g3
    com.itextpdf.kernel.geom.PageSize B1 -> h3
    com.itextpdf.kernel.geom.PageSize B2 -> i3
    com.itextpdf.kernel.geom.PageSize B3 -> j3
    com.itextpdf.kernel.geom.PageSize B5 -> l3
    com.itextpdf.kernel.geom.PageSize B4 -> k3
    com.itextpdf.kernel.geom.PageSize rotate() -> D
    com.itextpdf.kernel.geom.Rectangle clone() -> c
com.itextpdf.kernel.geom.Point -> a1.e:
    double x -> Q2
    double y -> R2
    double getX() -> a
    double getY() -> b
    void setLocation(double,double) -> c
    void setLocation(int,int) -> d
com.itextpdf.kernel.geom.Rectangle -> a1.f:
    float x -> Q2
    float width -> S2
    float y -> R2
    float EPS -> U2
    float height -> T2
    com.itextpdf.kernel.geom.Rectangle setX(float) -> A
    com.itextpdf.kernel.geom.Rectangle setY(float) -> B
    com.itextpdf.kernel.geom.Point[] toPointsArray() -> C
    com.itextpdf.kernel.geom.Rectangle applyMargins(float,float,float,float,boolean) -> a
    com.itextpdf.kernel.geom.Rectangle calculateBBox(java.util.List) -> b
    com.itextpdf.kernel.geom.Rectangle clone() -> c
    com.itextpdf.kernel.geom.Rectangle decreaseHeight(float) -> d
    boolean equalsWithEpsilon(com.itextpdf.kernel.geom.Rectangle) -> e
    boolean equalsWithEpsilon(com.itextpdf.kernel.geom.Rectangle,float) -> f
    float getBottom() -> g
    com.itextpdf.kernel.geom.Rectangle getCommonRectangle(com.itextpdf.kernel.geom.Rectangle[]) -> h
    float getHeight() -> i
    float getLeft() -> j
    float getRight() -> k
    float getTop() -> l
    float getWidth() -> m
    float getX() -> n
    float getY() -> o
    com.itextpdf.kernel.geom.Rectangle increaseHeight(float) -> p
    com.itextpdf.kernel.geom.Rectangle increaseWidth(float) -> r
    com.itextpdf.kernel.geom.Rectangle moveDown(float) -> s
    com.itextpdf.kernel.geom.Rectangle moveLeft(float) -> t
    com.itextpdf.kernel.geom.Rectangle moveRight(float) -> u
    com.itextpdf.kernel.geom.Rectangle moveUp(float) -> w
    com.itextpdf.kernel.geom.Rectangle setHeight(float) -> x
    com.itextpdf.kernel.geom.Rectangle setWidth(float) -> y
com.itextpdf.kernel.pdf.CountOutputStream -> b1.a:
    java.io.OutputStream outputStream -> Q2
    long amountOfWrittenBytes -> R2
    long getAmountOfWrittenBytes() -> a
com.itextpdf.kernel.pdf.DestinationResolverCopyFilter -> b1.h:
    com.itextpdf.kernel.pdf.PdfDocument targetDocument -> a
    com.itextpdf.kernel.pdf.PdfDocument fromDocument -> b
    java.util.List EXCLUDE_KEYS_ACTIONCOPY -> c
    boolean shouldProcess(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> a
    void $r8$lambda$A1SqNGlp3siyrQQ2xPffst9r83c(com.itextpdf.kernel.pdf.navigation.PdfDestination) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$AfHgwwvmFyye48_OofGXp6MShQc(com.itextpdf.kernel.pdf.DestinationResolverCopyFilter,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.navigation.PdfDestination) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$Wnk34dqRajVNo4Wy1HKPklFZ9f8(com.itextpdf.kernel.pdf.DestinationResolverCopyFilter,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.navigation.PdfDestination) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$c0fEr9xVMfn7vGQPCqfv9Vj58pE(com.itextpdf.kernel.pdf.DestinationResolverCopyFilter,com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.navigation.PdfDestination) -> e
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$scXueOI_2-3Agu1Lk3NNhf_wqIM(com.itextpdf.kernel.pdf.navigation.PdfDestination) -> f
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$tWU3M2k3lyAIXxJKpPY-S9PwZRQ(com.itextpdf.kernel.pdf.navigation.PdfDestination) -> g
      # {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.PdfObject getDirectPdfObject(com.itextpdf.kernel.pdf.PdfObject) -> h
    void lambda$processAction$4(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.navigation.PdfDestination) -> i
    void lambda$processAction$5(com.itextpdf.kernel.pdf.navigation.PdfDestination) -> j
    void lambda$processLinkAnnotion$0(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.navigation.PdfDestination) -> k
    void lambda$processLinkAnnotion$1(com.itextpdf.kernel.pdf.navigation.PdfDestination) -> l
    void lambda$processLinkAnnotion$2(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.navigation.PdfDestination) -> m
    void lambda$processLinkAnnotion$3(com.itextpdf.kernel.pdf.navigation.PdfDestination) -> n
    void processAction(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfDictionary) -> o
    boolean processLinkAnnotion(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> p
com.itextpdf.kernel.pdf.DocumentProperties -> b1.i:
    com.itextpdf.commons.actions.contexts.IMetaInfo metaInfo -> a
    com.itextpdf.kernel.pdf.DocumentProperties setEventCountingMetaInfo(com.itextpdf.commons.actions.contexts.IMetaInfo) -> a
com.itextpdf.kernel.pdf.EncryptedEmbeddedStreamsHandler -> b1.j:
    com.itextpdf.kernel.pdf.PdfDocument document -> a
    java.util.Set embeddedStreams -> b
    com.itextpdf.kernel.pdf.PdfStream getEmbeddedFileStreamFromDictionary(com.itextpdf.kernel.pdf.PdfDictionary) -> a
    boolean isStreamStoredAsEmbedded(com.itextpdf.kernel.pdf.PdfStream) -> b
    void storeAllEmbeddedStreams() -> c
    void storeEmbeddedStream(com.itextpdf.kernel.pdf.PdfStream) -> d
com.itextpdf.kernel.pdf.EncryptionProperties -> b1.k:
    int[] publicKeyEncryptPermissions -> f
    byte[] userPassword -> b
    int standardEncryptPermissions -> d
    java.security.cert.Certificate[] publicCertificates -> e
    byte[] ownerPassword -> c
    int encryptionAlgorithm -> a
    void clearEncryption() -> a
    boolean isPublicKeyEncryptionUsed() -> b
    boolean isStandardEncryptionUsed() -> c
    void randomBytes(byte[]) -> d
    com.itextpdf.kernel.pdf.EncryptionProperties setStandardEncryption(byte[],byte[],int,int) -> e
com.itextpdf.kernel.pdf.FingerPrint -> b1.l:
    java.util.Set productDataSet -> a
    java.util.Collection getProducts() -> a
    boolean registerProduct(com.itextpdf.commons.actions.data.ProductData) -> b
com.itextpdf.kernel.pdf.IPdfPageExtraCopier -> b1.m:
    void copy(com.itextpdf.kernel.pdf.PdfPage,com.itextpdf.kernel.pdf.PdfPage) -> a
com.itextpdf.kernel.pdf.IPdfPageFactory -> b1.n:
    com.itextpdf.kernel.pdf.PdfPage createPdfPage(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.geom.PageSize) -> a
    com.itextpdf.kernel.pdf.PdfPage createPdfPage(com.itextpdf.kernel.pdf.PdfDictionary) -> b
com.itextpdf.kernel.pdf.IndirectFilterUtils -> b1.o:
    void logFilterWasAlreadyFlushed(org.slf4j.Logger,com.itextpdf.kernel.pdf.PdfStream) -> a
    void throwFlushedFilterException(com.itextpdf.kernel.pdf.PdfStream) -> b
com.itextpdf.kernel.pdf.IsoKey -> b1.p:
    com.itextpdf.kernel.pdf.IsoKey STROKE_COLOR -> X2
    com.itextpdf.kernel.pdf.IsoKey TAG_STRUCTURE_ELEMENT -> Y2
    com.itextpdf.kernel.pdf.IsoKey FONT_GLYPHS -> Z2
    com.itextpdf.kernel.pdf.IsoKey INLINE_IMAGE -> T2
    com.itextpdf.kernel.pdf.IsoKey[] $VALUES -> c3
    com.itextpdf.kernel.pdf.IsoKey PAGE -> U2
    com.itextpdf.kernel.pdf.IsoKey PDF_OBJECT -> V2
    com.itextpdf.kernel.pdf.IsoKey RENDERING_INTENT -> W2
    com.itextpdf.kernel.pdf.IsoKey CANVAS_STACK -> Q2
    com.itextpdf.kernel.pdf.IsoKey FILL_COLOR -> R2
    com.itextpdf.kernel.pdf.IsoKey EXTENDED_GRAPHICS_STATE -> S2
    com.itextpdf.kernel.pdf.IsoKey XREF_TABLE -> a3
    com.itextpdf.kernel.pdf.IsoKey SIGNATURE -> b3
com.itextpdf.kernel.pdf.MemoryLimitsAwareFilter -> b1.q:
    java.io.ByteArrayOutputStream enableMemoryLimitsAwareHandler(com.itextpdf.kernel.pdf.PdfDictionary) -> b
com.itextpdf.kernel.pdf.MemoryLimitsAwareHandler -> b1.r:
    long memoryUsedForCurrentPdfStreamDecompression -> e
    long maxSizeOfDecompressedPdfStreamsSum -> b
    boolean considerCurrentPdfStream -> f
    long allMemoryUsedForDecompression -> d
    int maxNumberOfElementsInXrefStructure -> c
    int maxSizeOfSingleDecompressedPdfStream -> a
    com.itextpdf.kernel.pdf.MemoryLimitsAwareHandler beginDecompressedPdfStreamProcessing() -> a
    long calculateDefaultParameter(long,int,long) -> b
    void checkIfXrefStructureExceedsTheLimit(int) -> c
    com.itextpdf.kernel.pdf.MemoryLimitsAwareHandler considerBytesOccupiedByDecompressedPdfStream(long) -> d
    com.itextpdf.kernel.pdf.MemoryLimitsAwareHandler endDecompressedPdfStreamProcessing() -> e
    void ensureCurrentStreamIsReset() -> f
    int getMaxNumberOfElementsInXrefStructure() -> g
    int getMaxSizeOfSingleDecompressedPdfStream() -> h
    boolean isMemoryLimitsAwarenessRequiredOnDecompression(com.itextpdf.kernel.pdf.PdfArray) -> i
com.itextpdf.kernel.pdf.MemoryLimitsAwareOutputStream -> b1.s:
    int maxStreamSize -> Q2
    com.itextpdf.kernel.pdf.MemoryLimitsAwareOutputStream setMaxStreamSize(int) -> a
com.itextpdf.kernel.pdf.OcgPropertiesCopier -> b1.t:
    org.slf4j.Logger LOGGER -> a
    void attemptToAddObjectToArray(java.util.Set,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfArray,com.itextpdf.kernel.pdf.PdfDocument) -> a
    void copyDArrayField(com.itextpdf.kernel.pdf.PdfName,java.util.Set,com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDocument) -> b
    void copyDDictionary(java.util.Set,com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDocument) -> c
    void copyOCGProperties(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.PdfDocument,java.util.Map) -> d
    void copyOCGs(java.util.Set,com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDocument) -> e
    java.util.Set getAllUsedNonFlushedOCGs(java.util.Map,com.itextpdf.kernel.pdf.PdfDictionary) -> f
    void getUsedNonFlushedOCGsFromOcDict(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfObject,java.util.Set,com.itextpdf.kernel.pdf.PdfDictionary) -> g
    void getUsedNonFlushedOCGsFromResources(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDictionary,java.util.Set,com.itextpdf.kernel.pdf.PdfDictionary,java.util.Set) -> h
    void getUsedNonFlushedOCGsFromXObject(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDictionary,java.util.Set,com.itextpdf.kernel.pdf.PdfDictionary,java.util.Set) -> i
    boolean ocgAlreadyInOCGs(com.itextpdf.kernel.pdf.PdfIndirectReference,com.itextpdf.kernel.pdf.PdfDictionary) -> j
    boolean orderBranchContainsSetElements(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfArray,int,java.util.Set,com.itextpdf.kernel.pdf.PdfArray,com.itextpdf.kernel.pdf.PdfDocument) -> k
com.itextpdf.kernel.pdf.PdfAConformanceLevel -> b1.u:
    com.itextpdf.kernel.pdf.PdfAConformanceLevel PDF_A_2U -> g
    com.itextpdf.kernel.pdf.PdfAConformanceLevel PDF_A_3A -> h
    com.itextpdf.kernel.pdf.PdfAConformanceLevel PDF_A_3B -> i
    com.itextpdf.kernel.pdf.PdfAConformanceLevel PDF_A_3U -> j
    com.itextpdf.kernel.pdf.PdfAConformanceLevel PDF_A_1A -> c
    com.itextpdf.kernel.pdf.PdfAConformanceLevel PDF_A_1B -> d
    java.lang.String conformance -> a
    com.itextpdf.kernel.pdf.PdfAConformanceLevel PDF_A_2A -> e
    com.itextpdf.kernel.pdf.PdfAConformanceLevel PDF_A_2B -> f
    java.lang.String part -> b
    com.itextpdf.kernel.pdf.PdfAConformanceLevel getConformanceLevel(java.lang.String,java.lang.String) -> a
    com.itextpdf.kernel.pdf.PdfAConformanceLevel getConformanceLevel(com.itextpdf.kernel.xmp.XMPMeta) -> b
com.itextpdf.kernel.pdf.PdfArray -> b1.v:
    java.util.List list -> S2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    byte getType() -> J
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    void add(int,com.itextpdf.kernel.pdf.PdfObject) -> d0
    void add(com.itextpdf.kernel.pdf.PdfObject) -> e0
    void addAll(com.itextpdf.kernel.pdf.PdfArray) -> f0
    void addAll(java.util.Collection) -> g0
    boolean contains(com.itextpdf.kernel.pdf.PdfObject) -> h0
    com.itextpdf.kernel.pdf.PdfObject get(int) -> i0
    com.itextpdf.kernel.pdf.PdfObject get(int,boolean) -> j0
    com.itextpdf.kernel.pdf.PdfArray getAsArray(int) -> k0
    com.itextpdf.kernel.pdf.PdfDictionary getAsDictionary(int) -> l0
    com.itextpdf.kernel.pdf.PdfName getAsName(int) -> m0
    com.itextpdf.kernel.pdf.PdfNumber getAsNumber(int) -> n0
    com.itextpdf.kernel.pdf.PdfStream getAsStream(int) -> o0
    com.itextpdf.kernel.pdf.PdfString getAsString(int) -> p0
    int indexOf(com.itextpdf.kernel.pdf.PdfObject) -> q0
    void releaseContent() -> r0
    void remove(int) -> s0
    void remove(com.itextpdf.kernel.pdf.PdfObject) -> t0
    com.itextpdf.kernel.pdf.PdfObject set(int,com.itextpdf.kernel.pdf.PdfObject) -> u0
    double[] toDoubleArray() -> v0
    float[] toFloatArray() -> w0
    int[] toIntArray() -> x0
    com.itextpdf.kernel.geom.Rectangle toRectangle() -> y0
com.itextpdf.kernel.pdf.PdfArrayDirectIterator -> b1.w:
    java.util.Iterator array -> Q2
    com.itextpdf.kernel.pdf.PdfObject next() -> a
com.itextpdf.kernel.pdf.PdfBoolean -> b1.x:
    com.itextpdf.kernel.pdf.PdfBoolean TRUE -> V2
    com.itextpdf.kernel.pdf.PdfBoolean FALSE -> W2
    boolean value -> U2
    byte[] False -> Y2
    byte[] True -> X2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    byte getType() -> J
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    void generateContent() -> d0
    boolean getValue() -> g0
    com.itextpdf.kernel.pdf.PdfBoolean valueOf(boolean) -> h0
com.itextpdf.kernel.pdf.PdfCatalog -> b1.y:
    com.itextpdf.kernel.pdf.PdfNumTree pageLabels -> d
    java.util.Map nameTrees -> c
    java.util.Set PAGE_MODES -> j
    com.itextpdf.kernel.pdf.layer.PdfOCProperties ocProperties -> e
    com.itextpdf.kernel.pdf.PdfPagesTree pageTree -> b
    com.itextpdf.kernel.pdf.PdfOutline outlines -> f
    org.slf4j.Logger LOGGER -> i
    boolean outlineMode -> h
    java.util.Set PAGE_LAYOUTS -> k
    java.util.Map pagesWithOutlines -> g
    com.itextpdf.kernel.pdf.PdfNameTree getNameTree(com.itextpdf.kernel.pdf.PdfName) -> A
    com.itextpdf.kernel.pdf.layer.PdfOCProperties getOCProperties(boolean) -> B
    com.itextpdf.kernel.pdf.PdfOutline getOutlines(boolean) -> C
    com.itextpdf.kernel.pdf.PdfPagesTree getPageTree() -> D
    java.util.Map getPagesWithOutlines() -> E
    boolean hasOutlines() -> F
    boolean isEqualSameNameDestExist(java.util.Map,com.itextpdf.kernel.pdf.PdfDocument,java.lang.String,com.itextpdf.kernel.pdf.PdfArray,com.itextpdf.kernel.pdf.PdfPage) -> G
    boolean isOCPropertiesMayHaveChanged() -> H
    boolean isOutlineMode() -> I
    com.itextpdf.kernel.pdf.PdfCatalog put(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> J
    com.itextpdf.kernel.pdf.PdfCatalog remove(com.itextpdf.kernel.pdf.PdfName) -> K
    void removeOutlines(com.itextpdf.kernel.pdf.PdfPage) -> L
    boolean isWrappedObjectMustBeIndirect() -> k
    void addNameToNameTree(java.lang.String,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName) -> r
    void addNamedDestination(java.lang.String,com.itextpdf.kernel.pdf.PdfObject) -> s
    void addOutlineToPage(com.itextpdf.kernel.pdf.PdfOutline,com.itextpdf.kernel.pdf.PdfDictionary,java.util.Map) -> t
    void addOutlineToPage(com.itextpdf.kernel.pdf.PdfOutline,java.util.Map) -> u
    void addRootOutline(com.itextpdf.kernel.pdf.PdfOutline) -> v
    void constructOutlines(com.itextpdf.kernel.pdf.PdfDictionary,java.util.Map) -> w
    com.itextpdf.kernel.pdf.navigation.PdfDestination copyDestination(com.itextpdf.kernel.pdf.PdfObject,java.util.Map,com.itextpdf.kernel.pdf.PdfDocument) -> x
    com.itextpdf.kernel.pdf.PdfDictionary fillAndGetOcPropertiesDictionary() -> y
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> z
com.itextpdf.kernel.pdf.PdfDate -> b1.z:
    int[] DATE_SPACE -> b
    boolean isWrappedObjectMustBeIndirect() -> k
    java.lang.String generateStringByCalendar(java.util.Calendar) -> r
    java.lang.String getW3CDate(java.lang.String) -> s
    java.lang.String setLength(int,int) -> t
com.itextpdf.kernel.pdf.PdfDictionary -> b1.a0:
    java.util.Map map -> S2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    java.util.Collection values() -> A0
    java.util.Collection values(boolean) -> B0
    byte getType() -> J
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    com.itextpdf.kernel.pdf.PdfDictionary clone(java.util.List) -> d0
    boolean containsKey(com.itextpdf.kernel.pdf.PdfName) -> e0
    com.itextpdf.kernel.pdf.PdfDictionary copyTo(com.itextpdf.kernel.pdf.PdfDocument,java.util.List,boolean) -> f0
    com.itextpdf.kernel.pdf.PdfDictionary copyTo(com.itextpdf.kernel.pdf.PdfDocument,java.util.List,boolean,com.itextpdf.kernel.utils.ICopyFilter) -> g0
    java.util.Set entrySet() -> h0
    com.itextpdf.kernel.pdf.PdfObject get(com.itextpdf.kernel.pdf.PdfName) -> i0
    com.itextpdf.kernel.pdf.PdfObject get(com.itextpdf.kernel.pdf.PdfName,boolean) -> j0
    com.itextpdf.kernel.pdf.PdfArray getAsArray(com.itextpdf.kernel.pdf.PdfName) -> k0
    java.lang.Boolean getAsBool(com.itextpdf.kernel.pdf.PdfName) -> l0
    com.itextpdf.kernel.pdf.PdfBoolean getAsBoolean(com.itextpdf.kernel.pdf.PdfName) -> m0
    com.itextpdf.kernel.pdf.PdfDictionary getAsDictionary(com.itextpdf.kernel.pdf.PdfName) -> n0
    java.lang.Float getAsFloat(com.itextpdf.kernel.pdf.PdfName) -> o0
    java.lang.Integer getAsInt(com.itextpdf.kernel.pdf.PdfName) -> p0
    com.itextpdf.kernel.pdf.PdfName getAsName(com.itextpdf.kernel.pdf.PdfName) -> q0
    com.itextpdf.kernel.pdf.PdfNumber getAsNumber(com.itextpdf.kernel.pdf.PdfName) -> r0
    com.itextpdf.kernel.geom.Rectangle getAsRectangle(com.itextpdf.kernel.pdf.PdfName) -> s0
    com.itextpdf.kernel.pdf.PdfStream getAsStream(com.itextpdf.kernel.pdf.PdfName) -> t0
    com.itextpdf.kernel.pdf.PdfString getAsString(com.itextpdf.kernel.pdf.PdfName) -> u0
    java.util.Set keySet() -> v0
    com.itextpdf.kernel.pdf.PdfObject put(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> w0
    void putAll(com.itextpdf.kernel.pdf.PdfDictionary) -> x0
    void releaseContent() -> y0
    com.itextpdf.kernel.pdf.PdfObject remove(com.itextpdf.kernel.pdf.PdfName) -> z0
com.itextpdf.kernel.pdf.PdfDictionaryEntrySet -> b1.b0:
    java.util.Set set -> Q2
com.itextpdf.kernel.pdf.PdfDictionaryEntrySet$DirectEntry -> b1.b0$a:
    java.util.Map$Entry entry -> Q2
    com.itextpdf.kernel.pdf.PdfName getKey() -> a
    com.itextpdf.kernel.pdf.PdfObject getValue() -> b
    com.itextpdf.kernel.pdf.PdfObject setValue(com.itextpdf.kernel.pdf.PdfObject) -> c
com.itextpdf.kernel.pdf.PdfDictionaryEntrySet$DirectIterator -> b1.b0$b:
    java.util.Iterator parentIterator -> Q2
    java.util.Map$Entry next() -> a
com.itextpdf.kernel.pdf.PdfDictionaryValues -> b1.c0:
    java.util.Collection collection -> Q2
    boolean add(com.itextpdf.kernel.pdf.PdfObject) -> a
com.itextpdf.kernel.pdf.PdfDictionaryValues$DirectIterator -> b1.c0$a:
    java.util.Iterator parentIterator -> Q2
    com.itextpdf.kernel.pdf.PdfObject next() -> a
com.itextpdf.kernel.pdf.PdfDocument -> b1.d0:
    int structParentIndex -> g3
    com.itextpdf.kernel.events.EventDispatcher eventDispatcher -> V2
    com.itextpdf.kernel.pdf.PdfReader reader -> X2
    com.itextpdf.kernel.pdf.PdfXrefTable xref -> R2
    byte[] xmpMetadata -> Y2
    com.itextpdf.kernel.pdf.FingerPrint fingerPrint -> d3
    com.itextpdf.kernel.xmp.options.SerializeOptions serializeOptions -> e3
    com.itextpdf.kernel.pdf.tagging.PdfStructTreeRoot structTreeRoot -> f3
    com.itextpdf.kernel.pdf.PdfCatalog catalog -> Z2
    com.itextpdf.kernel.pdf.PdfDocumentInfo info -> b3
    com.itextpdf.kernel.pdf.PdfVersion pdfVersion -> c3
    com.itextpdf.kernel.pdf.EncryptedEmbeddedStreamsHandler encryptedEmbeddedStreamsHandler -> t3
    com.itextpdf.kernel.pdf.MemoryLimitsAwareHandler memoryLimitsAwareHandler -> o3
    com.itextpdf.kernel.pdf.IPdfPageFactory pdfPageFactory -> u3
    com.itextpdf.kernel.pdf.PdfWriter writer -> W2
    boolean flushUnusedObjects -> l3
    boolean closed -> k3
    com.itextpdf.kernel.font.PdfFont defaultFont -> s3
    com.itextpdf.commons.actions.sequence.SequenceId documentId -> T2
    boolean closeReader -> h3
    boolean closeWriter -> i3
    boolean isClosing -> j3
    com.itextpdf.kernel.geom.PageSize defaultPageSize -> p3
    com.itextpdf.kernel.pdf.tagutils.TagStructureContext tagStructureContext -> m3
    java.util.List pendingDestinationMutations -> U2
    java.util.Map documentFonts -> S2
    com.itextpdf.kernel.pdf.PdfString modifiedDocumentId -> r3
    com.itextpdf.kernel.pdf.PdfString originalDocumentId -> q3
    com.itextpdf.kernel.pdf.StampingProperties properties -> Q2
    com.itextpdf.kernel.pdf.PdfDictionary trailer -> a3
    java.util.Map serializedObjectsCache -> n3
    void flushFonts() -> A
    void setXmpMetadata(com.itextpdf.kernel.xmp.XMPMeta,com.itextpdf.kernel.xmp.options.SerializeOptions) -> A0
    void flushObject(com.itextpdf.kernel.pdf.PdfObject,boolean) -> B
    void setXmpMetadata(byte[]) -> B0
    void getAllOutlinesToCopy(com.itextpdf.kernel.pdf.PdfOutline,java.util.Set) -> C
    void storeDestinationToReaddress(com.itextpdf.kernel.pdf.navigation.PdfDestination,java.util.function.Consumer,java.util.function.Consumer) -> C0
    com.itextpdf.kernel.pdf.PdfCatalog getCatalog() -> D
    void tryFlushTagStructure(boolean) -> D0
    com.itextpdf.kernel.geom.PageSize getDefaultPageSize() -> E
    void tryInitTagStructure(com.itextpdf.kernel.pdf.PdfDictionary) -> E0
    java.util.Collection getDocumentFonts() -> F
    com.itextpdf.kernel.xmp.XMPMeta updateDefaultXmpMetadata() -> F0
    long getDocumentId() -> G
    void updatePdfVersionFromCatalog() -> G0
    com.itextpdf.commons.actions.sequence.SequenceId getDocumentIdWrapper() -> H
    void updateValueInMarkInfoDict(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> H0
    com.itextpdf.kernel.pdf.PdfDocumentInfo getDocumentInfo() -> I
    void updateXmpMetadata() -> I0
    com.itextpdf.kernel.pdf.FingerPrint getFingerPrint() -> J
    boolean writerHasEncryption() -> J0
    com.itextpdf.kernel.font.PdfFont getFont(com.itextpdf.kernel.pdf.PdfDictionary) -> K
    int getNextStructParentIndex() -> L
    int getNumberOfPages() -> M
    int getNumberOfPdfObjects() -> N
    com.itextpdf.kernel.pdf.PdfString getOriginalDocumentId() -> O
    com.itextpdf.kernel.pdf.PdfOutline getOutlines(boolean) -> P
    com.itextpdf.kernel.pdf.PdfPage getPage(int) -> Q
    com.itextpdf.kernel.pdf.IPdfPageFactory getPageFactory() -> R
    int getPageNumber(com.itextpdf.kernel.pdf.PdfPage) -> S
    com.itextpdf.kernel.pdf.PdfObject getPdfObject(int) -> T
    com.itextpdf.kernel.pdf.PdfVersion getPdfVersion() -> U
    com.itextpdf.kernel.pdf.PdfReader getReader() -> V
    com.itextpdf.kernel.pdf.tagging.PdfStructTreeRoot getStructTreeRoot() -> W
    com.itextpdf.kernel.pdf.tagutils.TagStructureContext getTagStructureContext() -> X
    com.itextpdf.kernel.pdf.PdfDictionary getTrailer() -> Y
    com.itextpdf.kernel.pdf.PdfWriter getWriter() -> Z
    void addCustomMetadataExtensions(com.itextpdf.kernel.xmp.XMPMeta) -> a
    byte[] getXmpMetadata() -> a0
    com.itextpdf.kernel.font.PdfFont addFont(com.itextpdf.kernel.font.PdfFont) -> b
    byte[] getXmpMetadata(boolean) -> b0
    void addNamedDestination(java.lang.String,com.itextpdf.kernel.pdf.PdfObject) -> c
    com.itextpdf.kernel.pdf.PdfXrefTable getXref() -> c0
    com.itextpdf.kernel.pdf.PdfPage addNewPage() -> d
    boolean hasAcroForm() -> d0
    com.itextpdf.kernel.pdf.PdfPage addNewPage(com.itextpdf.kernel.geom.PageSize) -> e
    boolean hasOutlines() -> e0
    com.itextpdf.kernel.pdf.PdfPage addPage(int,com.itextpdf.kernel.pdf.PdfPage) -> f
    void initTagStructureContext() -> f0
    com.itextpdf.kernel.pdf.PdfPage addPage(com.itextpdf.kernel.pdf.PdfPage) -> g
    void initializeOutlines() -> g0
    void checkAndAddPage(int,com.itextpdf.kernel.pdf.PdfPage) -> h
    boolean isAppendMode() -> h0
    void checkAndAddPage(com.itextpdf.kernel.pdf.PdfPage) -> i
    boolean isCloseReader() -> i0
    void checkClosingStatus() -> j
    boolean isCloseWriter() -> j0
    void checkIsoConformance() -> k
    boolean isClosed() -> k0
    void checkIsoConformance(java.lang.Object,com.itextpdf.kernel.pdf.IsoKey) -> l
    boolean isFlushUnusedObjects() -> l0
    void checkIsoConformance(java.lang.Object,com.itextpdf.kernel.pdf.IsoKey,com.itextpdf.kernel.pdf.PdfResources,com.itextpdf.kernel.pdf.PdfStream) -> m
    boolean isTagged() -> m0
    void cloneOutlines(java.util.Set,com.itextpdf.kernel.pdf.PdfOutline,com.itextpdf.kernel.pdf.PdfOutline,java.util.Map,com.itextpdf.kernel.pdf.PdfDocument) -> n
    boolean isXmpMetaHasProperty(com.itextpdf.kernel.xmp.XMPMeta,java.lang.String,java.lang.String) -> n0
    void copyOutlines(java.util.Set,com.itextpdf.kernel.pdf.PdfDocument,java.util.Map) -> o
    java.util.List listIndirectReferences() -> o0
    java.util.List copyPagesTo(int,int,com.itextpdf.kernel.pdf.PdfDocument) -> p
    void open(com.itextpdf.kernel.pdf.PdfVersion) -> p0
    java.util.List copyPagesTo(int,int,com.itextpdf.kernel.pdf.PdfDocument,int,com.itextpdf.kernel.pdf.IPdfPageExtraCopier) -> q
    void overrideFullCompressionInWriterProperties(com.itextpdf.kernel.pdf.WriterProperties,boolean) -> q0
    java.util.List copyPagesTo(int,int,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.IPdfPageExtraCopier) -> r
    void processReadingError(java.lang.String) -> r0
    java.util.List copyPagesTo(java.util.List,com.itextpdf.kernel.pdf.PdfDocument) -> s
    void readDocumentIds() -> s0
    java.util.List copyPagesTo(java.util.List,com.itextpdf.kernel.pdf.PdfDocument,int,com.itextpdf.kernel.pdf.IPdfPageExtraCopier) -> t
    void removeAllHandlers() -> t0
    java.util.List copyPagesTo(java.util.List,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.IPdfPageExtraCopier) -> u
    void removePage(int) -> u0
    com.itextpdf.kernel.pdf.PdfIndirectReference createNextIndirectReference() -> v
    void removeUnusedWidgetsFromFields(com.itextpdf.kernel.pdf.PdfPage) -> v0
    void dispatchEvent(com.itextpdf.kernel.events.Event) -> w
    void resolveDestinations(com.itextpdf.kernel.pdf.PdfDocument,java.util.Map) -> w0
    boolean doesStreamBelongToEmbeddedFile(com.itextpdf.kernel.pdf.PdfStream) -> x
    void setDefaultPageSize(com.itextpdf.kernel.geom.PageSize) -> x0
    void ensureTreeRootAddedToNames(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName) -> y
    com.itextpdf.kernel.pdf.PdfDocument setTagged() -> y0
    void flushCopiedObjects(com.itextpdf.kernel.pdf.PdfDocument) -> z
    void setXmpMetadata(com.itextpdf.kernel.xmp.XMPMeta) -> z0
com.itextpdf.kernel.pdf.PdfDocument$DestinationMutationInfo -> b1.d0$a:
    com.itextpdf.kernel.pdf.navigation.PdfDestination originalDestination -> a
    java.util.function.Consumer onDestinationNotAvailable -> c
    java.util.function.Consumer onDestinationAvailable -> b
    com.itextpdf.kernel.pdf.navigation.PdfDestination getOriginalDestination() -> a
    void handleDestinationAvailable(com.itextpdf.kernel.pdf.navigation.PdfDestination) -> b
    void handleDestinationUnavailable() -> c
com.itextpdf.kernel.pdf.PdfDocumentInfo -> b1.e0:
    com.itextpdf.kernel.pdf.PdfName[] PDF20_DEPRECATED_KEYS -> b
    com.itextpdf.kernel.pdf.PdfDictionary infoDictionary -> a
    com.itextpdf.kernel.pdf.PdfDocumentInfo addCreationDate() -> a
    com.itextpdf.kernel.pdf.PdfDocumentInfo addModDate() -> b
    com.itextpdf.kernel.pdf.PdfDictionary getPdfObject() -> c
    java.lang.String getProducer() -> d
    java.lang.String getStringValue(com.itextpdf.kernel.pdf.PdfName) -> e
    com.itextpdf.kernel.pdf.PdfDocumentInfo put(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> f
    com.itextpdf.kernel.pdf.PdfDocumentInfo setAuthor(java.lang.String) -> g
    com.itextpdf.kernel.pdf.PdfDocumentInfo setCreator(java.lang.String) -> h
    com.itextpdf.kernel.pdf.PdfDocumentInfo setKeywords(java.lang.String) -> i
    com.itextpdf.kernel.pdf.PdfDocumentInfo setProducer(java.lang.String) -> j
    com.itextpdf.kernel.pdf.PdfDocumentInfo setSubject(java.lang.String) -> k
    com.itextpdf.kernel.pdf.PdfDocumentInfo setTitle(java.lang.String) -> l
    com.itextpdf.kernel.pdf.PdfDocumentInfo setTrapped(com.itextpdf.kernel.pdf.PdfName) -> m
com.itextpdf.kernel.pdf.PdfEncryption -> b1.f0:
    com.itextpdf.kernel.crypto.securityhandler.SecurityHandler securityHandler -> g
    long seq -> h
    java.lang.Long permissions -> c
    boolean embeddedFilesOnly -> e
    int cryptoMode -> b
    byte[] documentId -> f
    boolean encryptMetadata -> d
    boolean isMetadataEncrypted() -> A
    boolean isOpenedWithFullPermission() -> B
    byte[] padByteArrayTo16(byte[]) -> C
    int readAndSetCryptoModeForPubSecHandler(com.itextpdf.kernel.pdf.PdfDictionary) -> D
    int readAndSetCryptoModeForStdHandler(com.itextpdf.kernel.pdf.PdfDictionary) -> E
    boolean readEmbeddedFilesOnlyFromEncryptDictionary(com.itextpdf.kernel.pdf.PdfDictionary) -> F
    int setCryptoMode(int) -> G
    int setCryptoMode(int,int) -> H
    void setHashKeyForNextObject(int,int) -> I
    void setKeyLength(int) -> J
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.PdfObject createInfoId(byte[],byte[]) -> r
    byte[] decryptByteArray(byte[]) -> s
    byte[] encryptByteArray(byte[]) -> t
    int fixAccessibilityPermissionPdf20(int) -> u
    byte[] generateNewDocumentId() -> v
    int getCryptoMode() -> w
    com.itextpdf.kernel.crypto.OutputStreamEncryption getEncryptionStream(java.io.OutputStream) -> x
    java.lang.Long getPermissions() -> y
    boolean isEmbeddedFilesOnly() -> z
com.itextpdf.kernel.pdf.PdfEncryptor -> b1.g0:
    byte[] getContent(org.bouncycastle.cms.RecipientInformation,java.security.PrivateKey,java.lang.String) -> a
    boolean isModifyContentsAllowed(int) -> b
    boolean isPrintingAllowed(int) -> c
com.itextpdf.kernel.pdf.PdfIndirectReference -> b1.h0:
    int objectStreamNumber -> V2
    int objNr -> S2
    int genNr -> T2
    long offsetOrIndex -> W2
    com.itextpdf.kernel.pdf.PdfObject refersTo -> U2
    com.itextpdf.kernel.pdf.PdfDocument pdfDocument -> X2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    byte getType() -> J
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    com.itextpdf.kernel.pdf.PdfObject setState(short) -> c0
    int comparePdfDocumentLinks(com.itextpdf.kernel.pdf.PdfIndirectReference) -> d0
    int compareTo(com.itextpdf.kernel.pdf.PdfIndirectReference) -> e0
    void fixOffset(long) -> f0
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> g0
    int getGenNumber() -> h0
    int getIndex() -> i0
    int getObjNumber() -> j0
    int getObjStreamNumber() -> k0
    long getOffset() -> l0
    com.itextpdf.kernel.pdf.PdfReader getReader() -> m0
    com.itextpdf.kernel.pdf.PdfObject getRefersTo() -> n0
    com.itextpdf.kernel.pdf.PdfObject getRefersTo(boolean) -> o0
    com.itextpdf.kernel.pdf.PdfWriter getWriter() -> p0
    boolean isFree() -> q0
    void setFree() -> r0
    void setIndex(long) -> s0
    void setObjStreamNumber(int) -> t0
    void setOffset(long) -> u0
    void setRefersTo(com.itextpdf.kernel.pdf.PdfObject) -> v0
com.itextpdf.kernel.pdf.PdfLiteral -> b1.i0:
    long position -> U2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    byte getType() -> J
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    void generateContent() -> d0
    void setPosition(long) -> g0
com.itextpdf.kernel.pdf.PdfName -> b1.j0:
    com.itextpdf.kernel.pdf.PdfName C1 -> k5
    com.itextpdf.kernel.pdf.PdfName DescendantFonts -> K6
    com.itextpdf.kernel.pdf.PdfName FullScreen -> m9
    com.itextpdf.kernel.pdf.PdfName LastPage -> Pa
    com.itextpdf.kernel.pdf.PdfName Page -> rd
    com.itextpdf.kernel.pdf.PdfName Redaction -> Re
    com.itextpdf.kernel.pdf.PdfName Title -> th
    com.itextpdf.kernel.pdf.PdfName WhitePoint -> Ti
    com.itextpdf.kernel.pdf.PdfName Adbe_pkcs7_s4 -> z3
    com.itextpdf.kernel.pdf.PdfName BorderColor -> Z4
    com.itextpdf.kernel.pdf.PdfName Movie -> ac
    com.itextpdf.kernel.pdf.PdfName Panose -> Ad
    com.itextpdf.kernel.pdf.PdfName SMask -> cg
    com.itextpdf.kernel.pdf.PdfName Top -> Ch
    com.itextpdf.kernel.pdf.PdfName Version -> Ci
    com.itextpdf.kernel.pdf.PdfName AF -> I3
    com.itextpdf.kernel.pdf.PdfName Count -> k6
    com.itextpdf.kernel.pdf.PdfName Encoding -> K7
    com.itextpdf.kernel.pdf.PdfName InlineAlign -> pa
    com.itextpdf.kernel.pdf.PdfName MediaClip -> Pb
    com.itextpdf.kernel.pdf.PdfName Private -> re
    com.itextpdf.kernel.pdf.PdfName Short -> Rf
    com.itextpdf.kernel.pdf.PdfName UseOC -> ti
    com.itextpdf.kernel.pdf.PdfName BaseEncoding -> z4
    com.itextpdf.kernel.pdf.PdfName Colorants -> Z5
    com.itextpdf.kernel.pdf.PdfName OPM -> ad
    com.itextpdf.kernel.pdf.PdfName Q -> Ae
    com.itextpdf.kernel.pdf.PdfName Tabs -> ch
    com.itextpdf.kernel.pdf.PdfName UCR -> ci
    com.itextpdf.kernel.pdf.PdfName _3DA -> i3
    com.itextpdf.kernel.pdf.PdfName BG -> I4
    com.itextpdf.kernel.pdf.PdfName Document -> k7
    com.itextpdf.kernel.pdf.PdfName FL -> K8
    com.itextpdf.kernel.pdf.PdfName Lock -> pb
    com.itextpdf.kernel.pdf.PdfName OE -> Pc
    com.itextpdf.kernel.pdf.PdfName Row -> rf
    com.itextpdf.kernel.pdf.PdfName Subtype -> Rg
    com.itextpdf.kernel.pdf.PdfName TU -> Rh
    com.itextpdf.kernel.pdf.PdfName Certs -> z5
    com.itextpdf.kernel.pdf.PdfName Differences -> Z6
    com.itextpdf.kernel.pdf.PdfName PO -> ae
    com.itextpdf.kernel.pdf.PdfName RV -> Af
    com.itextpdf.kernel.pdf.PdfName StemH -> Ag
    com.itextpdf.kernel.pdf.PdfName WT -> cj
    com.itextpdf.kernel.pdf.PdfName ApplicationPdf -> i4
    com.itextpdf.kernel.pdf.PdfName CIDToGIDMap -> I5
    com.itextpdf.kernel.pdf.PdfName F -> k8
    com.itextpdf.kernel.pdf.PdfName HardLight -> K9
    com.itextpdf.kernel.pdf.PdfName NextPage -> pc
    com.itextpdf.kernel.pdf.PdfName Pdf_Version_1_2 -> Pd
    com.itextpdf.kernel.pdf.PdfName StampImage -> rg
    com.itextpdf.kernel.pdf.PdfName TI -> rh
    com.itextpdf.kernel.pdf.PdfName Watermark -> Ri
    com.itextpdf.kernel.pdf.PdfName And -> X3
    com.itextpdf.kernel.pdf.PdfName Data -> z6
    com.itextpdf.kernel.pdf.PdfName Exclusion -> Z7
    com.itextpdf.kernel.pdf.PdfName Resume -> af
    com.itextpdf.kernel.pdf.PdfName ca -> m5
    com.itextpdf.kernel.pdf.PdfName Descent -> M6
    com.itextpdf.kernel.pdf.PdfName Functions -> o9
    com.itextpdf.kernel.pdf.PdfName Layout -> Ra
    byte[] rightParenthesis -> Y2
    com.itextpdf.kernel.pdf.PdfName PageLabels -> td
    com.itextpdf.kernel.pdf.PdfName Registry -> Te
    com.itextpdf.kernel.pdf.PdfName TrimBox -> vh
    com.itextpdf.kernel.pdf.PdfName Widths -> Vi
    com.itextpdf.kernel.pdf.PdfName MuLaw -> cc
    com.itextpdf.kernel.pdf.PdfName Params -> Cd
    com.itextpdf.kernel.pdf.PdfName SoftLight -> eg
    com.itextpdf.kernel.pdf.PdfName ToUnicode -> Eh
    com.itextpdf.kernel.pdf.PdfName After -> K3
    com.itextpdf.kernel.pdf.PdfName CRL -> m6
    com.itextpdf.kernel.pdf.PdfName EncryptMetadata -> M7
    com.itextpdf.kernel.pdf.PdfName InkList -> ra
    com.itextpdf.kernel.pdf.PdfName Middle -> Rb
    com.itextpdf.kernel.pdf.PdfName Producer -> te
    com.itextpdf.kernel.pdf.PdfName SigFieldLock -> Tf
    com.itextpdf.kernel.pdf.PdfName UseThumbs -> vi
    com.itextpdf.kernel.pdf.PdfName JBIG2Globals -> Aa
    com.itextpdf.kernel.pdf.PdfName Or -> cd
    com.itextpdf.kernel.pdf.PdfName QuadPoints -> Ce
    com.itextpdf.kernel.pdf.PdfName TD -> eh
    com.itextpdf.kernel.pdf.PdfName VerticesPerRow -> Ei
    com.itextpdf.kernel.pdf.PdfName _3DCrossSection -> k3
    com.itextpdf.kernel.pdf.PdfName BibEntry -> K4
    com.itextpdf.kernel.pdf.PdfName Domain -> m7
    com.itextpdf.kernel.pdf.PdfName FlateDecode -> M8
    com.itextpdf.kernel.pdf.PdfName Location -> rb
    com.itextpdf.kernel.pdf.PdfName ON -> Rc
    com.itextpdf.kernel.pdf.PdfName RowSpan -> tf
    com.itextpdf.kernel.pdf.PdfName Supplement -> Tg
    com.itextpdf.kernel.pdf.PdfName ICCBased -> aa
    com.itextpdf.kernel.pdf.PdfName Marked -> Ab
    com.itextpdf.kernel.pdf.PdfName PolyLine -> ce
    com.itextpdf.kernel.pdf.PdfName S -> Cf
    com.itextpdf.kernel.pdf.PdfName UCR2 -> ei
    com.itextpdf.kernel.pdf.PdfName Approved -> k4
    com.itextpdf.kernel.pdf.PdfName CL -> K5
    com.itextpdf.kernel.pdf.PdfName Ff -> m8
    com.itextpdf.kernel.pdf.PdfName Headers -> M9
    com.itextpdf.kernel.pdf.PdfName NonFullScreenPageMode -> rc
    com.itextpdf.kernel.pdf.PdfName Pdf_Version_1_4 -> Rd
    com.itextpdf.kernel.pdf.PdfName Standard -> tg
    com.itextpdf.kernel.pdf.PdfName TwoColumnRight -> Th
    com.itextpdf.kernel.pdf.PdfName Annots -> Z3
    com.itextpdf.kernel.pdf.PdfName Lighten -> ab
    com.itextpdf.kernel.pdf.PdfName NS -> Ac
    com.itextpdf.kernel.pdf.PdfName Requirements -> cf
    com.itextpdf.kernel.pdf.PdfName Stm -> Cg
    com.itextpdf.kernel.pdf.PdfName x_sampa -> ej
    com.itextpdf.kernel.pdf.PdfName CalRGB -> o5
    com.itextpdf.kernel.pdf.PdfName Dest -> O6
    com.itextpdf.kernel.pdf.PdfName Gamma -> q9
    com.itextpdf.kernel.pdf.PdfName LBody -> Ta
    com.itextpdf.kernel.pdf.PdfName PageMode -> vd
    com.itextpdf.kernel.pdf.PdfName RelativeColorimetric -> Ve
    com.itextpdf.kernel.pdf.PdfName TM -> xh
    com.itextpdf.kernel.pdf.PdfName Win -> Xi
    byte[] percent -> W2
    com.itextpdf.kernel.pdf.PdfName N -> ec
    com.itextpdf.kernel.pdf.PdfName ParentTree -> Ed
    com.itextpdf.kernel.pdf.PdfName Solid -> gg
    com.itextpdf.kernel.pdf.PdfName TR2 -> Gh
    com.itextpdf.kernel.pdf.PdfName AIS -> M3
    com.itextpdf.kernel.pdf.PdfName CreationDate -> o6
    com.itextpdf.kernel.pdf.PdfName End -> O7
    com.itextpdf.kernel.pdf.PdfName Interpolate -> ta
    com.itextpdf.kernel.pdf.PdfName Mix -> Tb
    com.itextpdf.kernel.pdf.PdfName Prop_Build -> ve
    com.itextpdf.kernel.pdf.PdfName Signed -> Vf
    com.itextpdf.kernel.pdf.PdfName UserProperties -> xi
    com.itextpdf.kernel.pdf.PdfName JS -> Ca
    com.itextpdf.kernel.pdf.PdfName Ordered -> ed
    com.itextpdf.kernel.pdf.PdfName R -> Ee
    com.itextpdf.kernel.pdf.PdfName Text -> gh
    com.itextpdf.kernel.pdf.PdfName ViewArea -> Gi
    com.itextpdf.kernel.pdf.PdfName _3DI -> m3
    com.itextpdf.kernel.pdf.PdfName BitsPerCoordinate -> M4
    com.itextpdf.kernel.pdf.PdfName Double -> o7
    com.itextpdf.kernel.pdf.PdfName Font -> O8
    com.itextpdf.kernel.pdf.PdfName LowerRoman -> tb
    com.itextpdf.kernel.pdf.PdfName OP -> Tc
    com.itextpdf.kernel.pdf.PdfName RT -> vf
    com.itextpdf.kernel.pdf.PdfName Symbol -> Vg
    com.itextpdf.kernel.pdf.PdfName IDS -> ca
    com.itextpdf.kernel.pdf.PdfName Markup -> Cb
    com.itextpdf.kernel.pdf.PdfName Predictor -> ee
    com.itextpdf.kernel.pdf.PdfName Saturation -> Ef
    com.itextpdf.kernel.pdf.PdfName UF -> gi
    com.itextpdf.kernel.pdf.PdfName ArtBox -> m4
    com.itextpdf.kernel.pdf.PdfName CMapName -> M5
    com.itextpdf.kernel.pdf.PdfName Fields -> o8
    com.itextpdf.kernel.pdf.PdfName Hide -> O9
    byte[] solidus -> f3
    com.itextpdf.kernel.pdf.PdfName NonStruct -> tc
    com.itextpdf.kernel.pdf.PdfName Pdf_Version_1_6 -> Td
    com.itextpdf.kernel.pdf.PdfName StartIndent -> vg
    com.itextpdf.kernel.pdf.PdfName TwoPageRight -> Vh
    com.itextpdf.kernel.pdf.PdfName Line -> cb
    com.itextpdf.kernel.pdf.PdfName NumCopies -> Cc
    com.itextpdf.kernel.pdf.PdfName ReversedChars -> ef
    com.itextpdf.kernel.pdf.PdfName StrF -> Eg
    com.itextpdf.kernel.pdf.PdfName XML -> gj
    com.itextpdf.kernel.pdf.PdfName GoTo -> s9
    com.itextpdf.kernel.pdf.PdfName Leading -> Va
    com.itextpdf.kernel.pdf.PdfName Pages -> xd
    com.itextpdf.kernel.pdf.PdfName Renditions -> Xe
    com.itextpdf.kernel.pdf.PdfName TOCI -> zh
    com.itextpdf.kernel.pdf.PdfName WritingMode -> Zi
    com.itextpdf.kernel.pdf.PdfName DigestLocation -> b7
    com.itextpdf.kernel.pdf.PdfName Experimental -> b8
    com.itextpdf.kernel.pdf.PdfName H -> B9
    com.itextpdf.kernel.pdf.PdfName Name -> gc
    com.itextpdf.kernel.pdf.PdfName Part -> Gd
    com.itextpdf.kernel.pdf.PdfName Sound -> ig
    com.itextpdf.kernel.pdf.PdfName TransformMethod -> Ih
    com.itextpdf.kernel.pdf.PdfName Cap -> q5
    com.itextpdf.kernel.pdf.PdfName Dests -> Q6
    com.itextpdf.kernel.pdf.PdfName EndOfBlock -> Q7
    com.itextpdf.kernel.pdf.PdfName IsMap -> va
    com.itextpdf.kernel.pdf.PdfName MK -> Vb
    com.itextpdf.kernel.pdf.PdfName PS -> xe
    com.itextpdf.kernel.pdf.PdfName Simplex -> Xf
    com.itextpdf.kernel.pdf.PdfName V -> zi
    com.itextpdf.kernel.pdf.PdfName ForComment -> b9
    com.itextpdf.kernel.pdf.PdfName K -> Ea
    com.itextpdf.kernel.pdf.PdfName Outlines -> gd
    com.itextpdf.kernel.pdf.PdfName Range -> Ge
    com.itextpdf.kernel.pdf.PdfName TextDecorationColor -> ih
    com.itextpdf.kernel.pdf.PdfName ViewClip -> Ii
    com.itextpdf.kernel.pdf.PdfName All -> O3
    com.itextpdf.kernel.pdf.PdfName CreatorInfo -> q6
    com.itextpdf.kernel.pdf.PdfName Dp -> q7
    com.itextpdf.kernel.pdf.PdfName FontDescriptor -> Q8
    com.itextpdf.kernel.pdf.PdfName LW -> vb
    com.itextpdf.kernel.pdf.PdfName Open -> Vc
    com.itextpdf.kernel.pdf.PdfName RubyAlign -> xf
    com.itextpdf.kernel.pdf.PdfName T -> Xg
    com.itextpdf.kernel.pdf.PdfName IdentityH -> ea
    com.itextpdf.kernel.pdf.PdfName MarkStyle -> Eb
    com.itextpdf.kernel.pdf.PdfName PreserveRB -> ge
    com.itextpdf.kernel.pdf.PdfName Scope -> Gf
    com.itextpdf.kernel.pdf.PdfName Unordered -> ii
    com.itextpdf.kernel.pdf.PdfName _3DView -> o3
    com.itextpdf.kernel.pdf.PdfName BitsPerSample -> O4
    byte[] leftCurlyBracket -> d3
    com.itextpdf.kernel.pdf.PdfName Code -> O5
    com.itextpdf.kernel.pdf.PdfName FileAttachment -> q8
    com.itextpdf.kernel.pdf.PdfName HideMenubar -> Q9
    com.itextpdf.kernel.pdf.PdfName Normal -> vc
    com.itextpdf.kernel.pdf.PdfName Pg -> Vd
    com.itextpdf.kernel.pdf.PdfName StateModel -> xg
    com.itextpdf.kernel.pdf.PdfName Type -> Xh
    com.itextpdf.kernel.pdf.PdfName LineHeight -> eb
    com.itextpdf.kernel.pdf.PdfName O -> Ec
    com.itextpdf.kernel.pdf.PdfName PhoneticAlphabet -> gf
    com.itextpdf.kernel.pdf.PdfName Strong -> Gg
    com.itextpdf.kernel.pdf.PdfName XHeight -> ij
    com.itextpdf.kernel.pdf.PdfName AS -> o4
    com.itextpdf.kernel.pdf.PdfName MacExpertEncoding -> yb
    com.itextpdf.kernel.pdf.PdfName Operation -> Yc
    com.itextpdf.kernel.pdf.PdfName Both -> c5
    com.itextpdf.kernel.pdf.PdfName Decode -> C6
    com.itextpdf.kernel.pdf.PdfName ForPublicRelease -> e9
    com.itextpdf.kernel.pdf.PdfName ImageMask -> ha
    com.itextpdf.kernel.pdf.PdfName max -> Hb
    com.itextpdf.kernel.pdf.PdfName PrevPage -> je
    com.itextpdf.kernel.pdf.PdfName Sect -> Jf
    com.itextpdf.kernel.pdf.PdfName UpperRoman -> li
    com.itextpdf.kernel.pdf.PdfName A85 -> r3
    com.itextpdf.kernel.pdf.PdfName BlackPoint -> R4
    com.itextpdf.kernel.pdf.PdfName Draft -> t7
    com.itextpdf.kernel.pdf.PdfName FontFile -> T8
    byte[] rightSquare -> c3
    com.itextpdf.kernel.pdf.PdfName Note -> yc
    com.itextpdf.kernel.pdf.PdfName Placement -> Yd
    com.itextpdf.kernel.pdf.PdfName Adbe_pkcs7_s5 -> A3
    com.itextpdf.kernel.pdf.PdfName ColorTransform -> c6
    com.itextpdf.kernel.pdf.PdfName EF -> C7
    com.itextpdf.kernel.pdf.PdfName Link -> hb
    com.itextpdf.kernel.pdf.PdfName ObjStm -> Hc
    com.itextpdf.kernel.pdf.PdfName RichMedia -> jf
    com.itextpdf.kernel.pdf.PdfName StructParents -> Jg
    com.itextpdf.kernel.pdf.PdfName XStep -> lj
    com.itextpdf.kernel.pdf.PdfName ASCIIHexDecode -> r4
    com.itextpdf.kernel.pdf.PdfName ColumnCount -> R5
    com.itextpdf.kernel.pdf.PdfName FFilter -> t8
    com.itextpdf.kernel.pdf.PdfName Highlight -> T9
    com.itextpdf.kernel.pdf.PdfName LE -> Wa
    com.itextpdf.kernel.pdf.PdfName Pagination -> yd
    com.itextpdf.kernel.pdf.PdfName Repeat -> Ye
    com.itextpdf.kernel.pdf.PdfName BaselineShift -> A4
    com.itextpdf.kernel.pdf.PdfName DigestMethod -> c7
    com.itextpdf.kernel.pdf.PdfName FitBH -> C8
    com.itextpdf.kernel.pdf.PdfName H1 -> C9
    com.itextpdf.kernel.pdf.PdfName Named -> hc
    com.itextpdf.kernel.pdf.PdfName Path -> Hd
    com.itextpdf.kernel.pdf.PdfName Source -> jg
    com.itextpdf.kernel.pdf.PdfName TransformParams -> Jh
    com.itextpdf.kernel.pdf.PdfName Caption -> r5
    com.itextpdf.kernel.pdf.PdfName DeviceCMY -> R6
    com.itextpdf.kernel.pdf.PdfName GoTo3DView -> t9
    com.itextpdf.kernel.pdf.PdfName ItalicAngle -> wa
    com.itextpdf.kernel.pdf.PdfName ML -> Wb
    com.itextpdf.kernel.pdf.PdfName Pushpin -> ye
    com.itextpdf.kernel.pdf.PdfName SinglePage -> Yf
    com.itextpdf.kernel.pdf.PdfName Annotation -> a4
    com.itextpdf.kernel.pdf.PdfName CF -> A5
    com.itextpdf.kernel.pdf.PdfName Expired -> c8
    com.itextpdf.kernel.pdf.PdfName Form -> c9
    com.itextpdf.kernel.pdf.PdfName Keywords -> Fa
    com.itextpdf.kernel.pdf.PdfName OutputCondition -> hd
    com.itextpdf.kernel.pdf.PdfName Raw -> He
    com.itextpdf.kernel.pdf.PdfName TextDecorationThickness -> jh
    com.itextpdf.kernel.pdf.PdfName ViewState -> Ji
    com.itextpdf.kernel.pdf.PdfName AllOff -> P3
    com.itextpdf.kernel.pdf.PdfName CropBox -> r6
    com.itextpdf.kernel.pdf.PdfName EndOfLine -> R7
    com.itextpdf.kernel.pdf.PdfName BS -> e5
    com.itextpdf.kernel.pdf.PdfName Default -> E6
    com.itextpdf.kernel.pdf.PdfName FreeText -> g9
    com.itextpdf.kernel.pdf.PdfName ipa -> ja
    com.itextpdf.kernel.pdf.PdfName MCD -> Jb
    com.itextpdf.kernel.pdf.PdfName PrintArea -> le
    com.itextpdf.kernel.pdf.PdfName SeparationColorNames -> Lf
    com.itextpdf.kernel.pdf.PdfName URL -> ni
    com.itextpdf.kernel.pdf.PdfName AbsoluteColorimetric -> t3
    com.itextpdf.kernel.pdf.PdfName Block -> T4
    com.itextpdf.kernel.pdf.PdfName DSS -> v7
    com.itextpdf.kernel.pdf.PdfName FontFile3 -> V8
    byte[] greaterThan -> a3
    com.itextpdf.kernel.pdf.PdfName Adbe_x509_rsa_sha1 -> C3
    com.itextpdf.kernel.pdf.PdfName Columns -> e6
    com.itextpdf.kernel.pdf.PdfName EFOpen -> E7
    com.itextpdf.kernel.pdf.PdfName ListMode -> jb
    com.itextpdf.kernel.pdf.PdfName OCG -> Jc
    com.itextpdf.kernel.pdf.PdfName RO -> lf
    com.itextpdf.kernel.pdf.PdfName Style -> Lg
    com.itextpdf.kernel.pdf.PdfName YStep -> nj
    com.itextpdf.kernel.pdf.PdfName AsIs -> t4
    com.itextpdf.kernel.pdf.PdfName ColumnWidths -> T5
    com.itextpdf.kernel.pdf.PdfName FENote -> v8
    com.itextpdf.kernel.pdf.PdfName HTO -> V9
    com.itextpdf.kernel.pdf.PdfName Length1 -> Ya
    com.itextpdf.kernel.pdf.PdfName BaseVersion -> C4
    com.itextpdf.kernel.pdf.PdfName Direction -> e7
    com.itextpdf.kernel.pdf.PdfName FitH -> E8
    com.itextpdf.kernel.pdf.PdfName Namespace -> jc
    com.itextpdf.kernel.pdf.PdfName PatternType -> Jd
    com.itextpdf.kernel.pdf.PdfName SpaceBefore -> lg
    com.itextpdf.kernel.pdf.PdfName TrapNet -> Lh
    com.itextpdf.kernel.pdf.PdfName Catalog -> t5
    com.itextpdf.kernel.pdf.PdfName DeviceGray -> T6
    com.itextpdf.kernel.pdf.PdfName GoToE -> v9
    com.itextpdf.kernel.pdf.PdfName JavaScript -> ya
    com.itextpdf.kernel.pdf.PdfName MN -> Yb
    com.itextpdf.kernel.pdf.PdfName AnyOff -> c4
    com.itextpdf.kernel.pdf.PdfName Ch -> C5
    com.itextpdf.kernel.pdf.PdfName ExportState -> e8
    com.itextpdf.kernel.pdf.PdfName H3 -> E9
    com.itextpdf.kernel.pdf.PdfName L2R -> Ha
    com.itextpdf.kernel.pdf.PdfName OutputIntent -> jd
    com.itextpdf.kernel.pdf.PdfName RBGroups -> Je
    com.itextpdf.kernel.pdf.PdfName TextIndent -> lh
    com.itextpdf.kernel.pdf.PdfName Volatile -> Li
    com.itextpdf.kernel.pdf.PdfName Alt -> R3
    com.itextpdf.kernel.pdf.PdfName CS -> t6
    com.itextpdf.kernel.pdf.PdfName EP -> T7
    com.itextpdf.kernel.pdf.PdfName Butt -> g5
    com.itextpdf.kernel.pdf.PdfName DefaultCryptFilter -> G6
    com.itextpdf.kernel.pdf.PdfName FreeTextTypeWriter -> i9
    com.itextpdf.kernel.pdf.PdfName Language -> La
    com.itextpdf.kernel.pdf.PdfName MCR -> Lb
    com.itextpdf.kernel.pdf.PdfName PrinterMark -> ne
    com.itextpdf.kernel.pdf.PdfName Shading -> Nf
    com.itextpdf.kernel.pdf.PdfName Usage -> pi
    com.itextpdf.kernel.pdf.PdfName Action -> v3
    com.itextpdf.kernel.pdf.PdfName BlockQuote -> V4
    com.itextpdf.kernel.pdf.PdfName DuplexFlipShortEdge -> x7
    com.itextpdf.kernel.pdf.PdfName FontName -> X8
    com.itextpdf.kernel.pdf.PdfName Adobe_PPKMS -> E3
    com.itextpdf.kernel.pdf.PdfName Confidential -> g6
    com.itextpdf.kernel.pdf.PdfName EmbeddedFile -> G7
    com.itextpdf.kernel.pdf.PdfName Index -> la
    com.itextpdf.kernel.pdf.PdfName LJ -> lb
    com.itextpdf.kernel.pdf.PdfName OCMD -> Lc
    com.itextpdf.kernel.pdf.PdfName RoleMapNS -> nf
    com.itextpdf.kernel.pdf.PdfName SubFilter -> Ng
    com.itextpdf.kernel.pdf.PdfName zh_Latn_pinyin -> pj
    com.itextpdf.kernel.pdf.PdfName Author -> v4
    com.itextpdf.kernel.pdf.PdfName CharProcs -> V5
    com.itextpdf.kernel.pdf.PdfName First -> x8
    com.itextpdf.kernel.pdf.PdfName Hue -> X9
    com.itextpdf.kernel.pdf.PdfName BBox -> E4
    com.itextpdf.kernel.pdf.PdfName DisplayDocTitle -> g7
    com.itextpdf.kernel.pdf.PdfName FitV -> G8
    com.itextpdf.kernel.pdf.PdfName NeedAppearances -> lc
    com.itextpdf.kernel.pdf.PdfName Perceptual -> Ld
    com.itextpdf.kernel.pdf.PdfName Square -> ng
    com.itextpdf.kernel.pdf.PdfName TrapRegions -> Nh
    com.itextpdf.kernel.pdf.PdfName CCITTFaxDecode -> v5
    com.itextpdf.kernel.pdf.PdfName DeviceRGB -> V6
    com.itextpdf.kernel.pdf.PdfName Graph -> x9
    com.itextpdf.kernel.pdf.PdfName AP -> e4
    com.itextpdf.kernel.pdf.PdfName CIDFontType0 -> E5
    com.itextpdf.kernel.pdf.PdfName Extends -> g8
    com.itextpdf.kernel.pdf.PdfName H5 -> G9
    com.itextpdf.kernel.pdf.PdfName Lab -> Ja
    com.itextpdf.kernel.pdf.PdfName Outset -> ld
    com.itextpdf.kernel.pdf.PdfName RClosedArrow -> Le
    com.itextpdf.kernel.pdf.PdfName TFoot -> nh
    com.itextpdf.kernel.pdf.PdfName VRI -> Ni
    com.itextpdf.kernel.pdf.PdfName Alternates -> T3
    com.itextpdf.kernel.pdf.PdfName D -> v6
    com.itextpdf.kernel.pdf.PdfName ETSI_CAdES_DETACHED -> V7
    com.itextpdf.kernel.pdf.PdfName Slash -> ag
    com.itextpdf.kernel.pdf.PdfName TP -> Ah
    com.itextpdf.kernel.pdf.PdfName C -> i5
    com.itextpdf.kernel.pdf.PdfName DefaultRGB -> I6
    com.itextpdf.kernel.pdf.PdfName Formula -> k9
    com.itextpdf.kernel.pdf.PdfName LastChar -> Na
    com.itextpdf.kernel.pdf.PdfName PA -> pd
    com.itextpdf.kernel.pdf.PdfName Rect -> Pe
    com.itextpdf.kernel.pdf.PdfName SetOCGState -> Pf
    com.itextpdf.kernel.pdf.PdfName UseBlackPtComp -> ri
    com.itextpdf.kernel.pdf.PdfName ADBE -> x3
    com.itextpdf.kernel.pdf.PdfName Book -> X4
    com.itextpdf.kernel.pdf.PdfName DV -> z7
    com.itextpdf.kernel.pdf.PdfName FontStretch -> Z8
    com.itextpdf.kernel.pdf.PdfName TA -> ah
    com.itextpdf.kernel.pdf.PdfName V2 -> Ai
    com.itextpdf.kernel.pdf.PdfName AESV2 -> G3
    com.itextpdf.kernel.pdf.PdfName Contents -> i6
    com.itextpdf.kernel.pdf.PdfName Encode -> I7
    com.itextpdf.kernel.pdf.PdfName Info -> na
    com.itextpdf.kernel.pdf.PdfName Measure -> Nb
    com.itextpdf.kernel.pdf.PdfName PrintScaling -> pe
    com.itextpdf.kernel.pdf.PdfName Root -> pf
    com.itextpdf.kernel.pdf.PdfName Subject -> Pg
    com.itextpdf.kernel.pdf.PdfName Zoom -> rj
    com.itextpdf.kernel.pdf.PdfName BackgroundColor -> x4
    com.itextpdf.kernel.pdf.PdfName ColorBurn -> X5
    com.itextpdf.kernel.pdf.PdfName FirstPage -> z8
    com.itextpdf.kernel.pdf.PdfName IC -> Z9
    com.itextpdf.kernel.pdf.PdfName Type3 -> ai
    com.itextpdf.kernel.pdf.PdfName Before -> G4
    com.itextpdf.kernel.pdf.PdfName DocOpen -> i7
    com.itextpdf.kernel.pdf.PdfName FixedPrint -> I8
    com.itextpdf.kernel.pdf.PdfName LLE -> nb
    com.itextpdf.kernel.pdf.PdfName OCSP -> Nc
    com.itextpdf.kernel.pdf.PdfName PC -> Nd
    com.itextpdf.kernel.pdf.PdfName St -> pg
    com.itextpdf.kernel.pdf.PdfName True -> Ph
    com.itextpdf.kernel.pdf.PdfName CenterWindow -> x5
    com.itextpdf.kernel.pdf.PdfName Diamond -> X6
    com.itextpdf.kernel.pdf.PdfName Groove -> z9
    com.itextpdf.kernel.pdf.PdfName WP -> aj
    com.itextpdf.kernel.pdf.PdfName AppDefault -> g4
    com.itextpdf.kernel.pdf.PdfName CIDSet -> G5
    com.itextpdf.kernel.pdf.PdfName ExtensionLevel -> i8
    com.itextpdf.kernel.pdf.PdfName HalftoneType -> I9
    com.itextpdf.kernel.pdf.PdfName NewWindow -> nc
    com.itextpdf.kernel.pdf.PdfName OverlayText -> nd
    com.itextpdf.kernel.pdf.PdfName Reason -> Ne
    com.itextpdf.kernel.pdf.PdfName THead -> ph
    com.itextpdf.kernel.pdf.PdfName W2 -> Pi
    com.itextpdf.kernel.pdf.PdfName Alternative -> V3
    com.itextpdf.kernel.pdf.PdfName Darken -> x6
    com.itextpdf.kernel.pdf.PdfName Event -> X7
    com.itextpdf.kernel.pdf.PdfName _3DB -> j3
    com.itextpdf.kernel.pdf.PdfName BG2 -> J4
    com.itextpdf.kernel.pdf.PdfName DocumentFragment -> l7
    com.itextpdf.kernel.pdf.PdfName Flags -> L8
    com.itextpdf.kernel.pdf.PdfName Locked -> qb
    com.itextpdf.kernel.pdf.PdfName OFF -> Qc
    com.itextpdf.kernel.pdf.PdfName Rows -> sf
    com.itextpdf.kernel.pdf.PdfName Subtype2 -> Sg
    com.itextpdf.kernel.pdf.PdfName Polygon -> be
    com.itextpdf.kernel.pdf.PdfName Stream -> Bf
    com.itextpdf.kernel.pdf.PdfName UR3 -> di
    com.itextpdf.kernel.pdf.PdfName X -> dj
    com.itextpdf.kernel.pdf.PdfName ApplicationXml -> j4
    com.itextpdf.kernel.pdf.PdfName Circle -> J5
    com.itextpdf.kernel.pdf.PdfName False -> l8
    com.itextpdf.kernel.pdf.PdfName Header -> L9
    com.itextpdf.kernel.pdf.PdfName NM -> qc
    com.itextpdf.kernel.pdf.PdfName Pdf_Version_1_3 -> Qd
    com.itextpdf.kernel.pdf.PdfName StampSnapshot -> sg
    com.itextpdf.kernel.pdf.PdfName TwoColumnLeft -> Sh
    com.itextpdf.kernel.pdf.PdfName WC -> Si
    com.itextpdf.kernel.pdf.PdfName Annot -> Y3
    com.itextpdf.kernel.pdf.PdfName Requirement -> bf
    com.itextpdf.kernel.pdf.PdfName Stop -> Bg
    com.itextpdf.kernel.pdf.PdfName Toggle -> Bh
    com.itextpdf.kernel.pdf.PdfName C0 -> j5
    com.itextpdf.kernel.pdf.PdfName Departmental -> J6
    com.itextpdf.kernel.pdf.PdfName FT -> l9
    byte[] lessThan -> Z2
    com.itextpdf.kernel.pdf.PdfName LastModified -> Oa
    com.itextpdf.kernel.pdf.PdfName Padding -> qd
    com.itextpdf.kernel.pdf.PdfName Redact -> Qe
    com.itextpdf.kernel.pdf.PdfName TilingType -> sh
    com.itextpdf.kernel.pdf.PdfName UseNone -> si
    com.itextpdf.kernel.pdf.PdfName Adbe_pkcs7_detached -> y3
    com.itextpdf.kernel.pdf.PdfName Border -> Y4
    com.itextpdf.kernel.pdf.PdfName SM -> bg
    com.itextpdf.kernel.pdf.PdfName Table -> bh
    com.itextpdf.kernel.pdf.PdfName VE -> Bi
    com.itextpdf.kernel.pdf.PdfName AESV3 -> H3
    com.itextpdf.kernel.pdf.PdfName Coords -> j6
    com.itextpdf.kernel.pdf.PdfName EncodedByteAlign -> J7
    com.itextpdf.kernel.pdf.PdfName Inline -> oa
    com.itextpdf.kernel.pdf.PdfName MediaBox -> Ob
    com.itextpdf.kernel.pdf.PdfName PrintState -> qe
    com.itextpdf.kernel.pdf.PdfName SetState -> Qf
    com.itextpdf.kernel.pdf.PdfName SubmitForm -> Qg
    com.itextpdf.kernel.pdf.PdfName BaseFont -> y4
    com.itextpdf.kernel.pdf.PdfName ColorDodge -> Y5
    com.itextpdf.kernel.pdf.PdfName _3DD -> l3
    com.itextpdf.kernel.pdf.PdfName BitsPerComponent -> L4
    com.itextpdf.kernel.pdf.PdfName Dotted -> n7
    com.itextpdf.kernel.pdf.PdfName Fo -> N8
    com.itextpdf.kernel.pdf.PdfName LowerAlpha -> sb
    com.itextpdf.kernel.pdf.PdfName OneColumn -> Sc
    com.itextpdf.kernel.pdf.PdfName RP -> uf
    com.itextpdf.kernel.pdf.PdfName Sy -> Ug
    com.itextpdf.kernel.pdf.PdfName ID -> ba
    com.itextpdf.kernel.pdf.PdfName MarkInfo -> Bb
    com.itextpdf.kernel.pdf.PdfName Popup -> de
    com.itextpdf.kernel.pdf.PdfName SA -> Df
    com.itextpdf.kernel.pdf.PdfName UE -> fi
    com.itextpdf.kernel.pdf.PdfName Art -> l4
    com.itextpdf.kernel.pdf.PdfName ClosedArrow -> L5
    com.itextpdf.kernel.pdf.PdfName FieldMDP -> n8
    com.itextpdf.kernel.pdf.PdfName Height -> N9
    com.itextpdf.kernel.pdf.PdfName None -> sc
    com.itextpdf.kernel.pdf.PdfName Pdf_Version_1_5 -> Sd
    com.itextpdf.kernel.pdf.PdfName Start -> ug
    com.itextpdf.kernel.pdf.PdfName TwoPageLeft -> Uh
    java.lang.String value -> U2
    com.itextpdf.kernel.pdf.PdfName Limits -> bb
    com.itextpdf.kernel.pdf.PdfName NSO -> Bc
    com.itextpdf.kernel.pdf.PdfName Resources -> df
    com.itextpdf.kernel.pdf.PdfName StmF -> Dg
    com.itextpdf.kernel.pdf.PdfName XFA -> fj
    com.itextpdf.kernel.pdf.PdfName CA -> l5
    com.itextpdf.kernel.pdf.PdfName Desc -> L6
    com.itextpdf.kernel.pdf.PdfName Function -> n9
    com.itextpdf.kernel.pdf.PdfName Launch -> Qa
    byte[] leftParenthesis -> X2
    com.itextpdf.kernel.pdf.PdfName PageElement -> sd
    com.itextpdf.kernel.pdf.PdfName Reference -> Se
    com.itextpdf.kernel.pdf.PdfName TPadding -> uh
    com.itextpdf.kernel.pdf.PdfName Width -> Ui
    com.itextpdf.kernel.pdf.PdfName MR -> bc
    com.itextpdf.kernel.pdf.PdfName Paperclip -> Bd
    com.itextpdf.kernel.pdf.PdfName SMaskInData -> dg
    com.itextpdf.kernel.pdf.PdfName TopSecret -> Dh
    com.itextpdf.kernel.pdf.PdfName AFRelationship -> J3
    com.itextpdf.kernel.pdf.PdfName CP -> l6
    com.itextpdf.kernel.pdf.PdfName Encrypt -> L7
    com.itextpdf.kernel.pdf.PdfName Ink -> qa
    com.itextpdf.kernel.pdf.PdfName Metadata -> Qb
    com.itextpdf.kernel.pdf.PdfName ProcSet -> se
    com.itextpdf.kernel.pdf.PdfName Sig -> Sf
    com.itextpdf.kernel.pdf.PdfName UseOutlines -> ui
    com.itextpdf.kernel.pdf.PdfName Opt -> bd
    com.itextpdf.kernel.pdf.PdfName Quote -> Be
    com.itextpdf.kernel.pdf.PdfName TBody -> dh
    com.itextpdf.kernel.pdf.PdfName Vertices -> Di
    com.itextpdf.kernel.pdf.PdfName BitsPerFlag -> N4
    com.itextpdf.kernel.pdf.PdfName DP -> p7
    com.itextpdf.kernel.pdf.PdfName FontBBox -> P8
    com.itextpdf.kernel.pdf.PdfName Luminosity -> ub
    com.itextpdf.kernel.pdf.PdfName op -> Uc
    com.itextpdf.kernel.pdf.PdfName Ruby -> wf
    com.itextpdf.kernel.pdf.PdfName Synchronous -> Wg
    com.itextpdf.kernel.pdf.PdfName Identity -> da
    com.itextpdf.kernel.pdf.PdfName Markup3D -> Db
    com.itextpdf.kernel.pdf.PdfName Preferred -> fe
    com.itextpdf.kernel.pdf.PdfName Schema -> Ff
    com.itextpdf.kernel.pdf.PdfName Underline -> hi
    com.itextpdf.kernel.pdf.PdfName _3DV -> n3
    com.itextpdf.kernel.pdf.PdfName Artifact -> n4
    com.itextpdf.kernel.pdf.PdfName CO -> N5
    com.itextpdf.kernel.pdf.PdfName Figure -> p8
    com.itextpdf.kernel.pdf.PdfName Hidden -> P9
    byte[] numberSign -> g3
    com.itextpdf.kernel.pdf.PdfName NoOp -> uc
    com.itextpdf.kernel.pdf.PdfName Pdf_Version_1_7 -> Ud
    com.itextpdf.kernel.pdf.PdfName State -> wg
    com.itextpdf.kernel.pdf.PdfName Tx -> Wh
    com.itextpdf.kernel.pdf.PdfName LineArrow -> db
    com.itextpdf.kernel.pdf.PdfName Nums -> Dc
    com.itextpdf.kernel.pdf.PdfName Phoneme -> ff
    com.itextpdf.kernel.pdf.PdfName StrikeOut -> Fg
    com.itextpdf.kernel.pdf.PdfName XObject -> hj
    com.itextpdf.kernel.pdf.PdfName CalGray -> n5
    com.itextpdf.kernel.pdf.PdfName Design -> N6
    com.itextpdf.kernel.pdf.PdfName FunctionType -> p9
    com.itextpdf.kernel.pdf.PdfName Lbl -> Sa
    com.itextpdf.kernel.pdf.PdfName PageLayout -> ud
    com.itextpdf.kernel.pdf.PdfName RegistryName -> Ue
    com.itextpdf.kernel.pdf.PdfName TK -> wh
    com.itextpdf.kernel.pdf.PdfName Widget -> Wi
    byte[] space -> V2
    com.itextpdf.kernel.pdf.PdfName Multiply -> dc
    com.itextpdf.kernel.pdf.PdfName Parent -> Dd
    com.itextpdf.kernel.pdf.PdfName Sold -> fg
    com.itextpdf.kernel.pdf.PdfName TR -> Fh
    com.itextpdf.kernel.pdf.PdfName AHx -> L3
    com.itextpdf.kernel.pdf.PdfName CRLs -> n6
    com.itextpdf.kernel.pdf.PdfName EncryptedPayload -> N7
    com.itextpdf.kernel.pdf.PdfName Intent -> sa
    com.itextpdf.kernel.pdf.PdfName min -> Sb
    com.itextpdf.kernel.pdf.PdfName PronunciationLexicon -> ue
    com.itextpdf.kernel.pdf.PdfName SigFlags -> Uf
    com.itextpdf.kernel.pdf.PdfName User -> wi
    com.itextpdf.kernel.pdf.PdfName JPXDecode -> Ba
    com.itextpdf.kernel.pdf.PdfName Order -> dd
    com.itextpdf.kernel.pdf.PdfName r -> De
    com.itextpdf.kernel.pdf.PdfName Templates -> fh
    com.itextpdf.kernel.pdf.PdfName View -> Fi
    com.itextpdf.kernel.pdf.PdfName FontFamily -> R8
    com.itextpdf.kernel.pdf.PdfName LZWDecode -> wb
    com.itextpdf.kernel.pdf.PdfName OpenAction -> Wc
    com.itextpdf.kernel.pdf.PdfName RubyPosition -> yf
    com.itextpdf.kernel.pdf.PdfName Tag -> Yg
    com.itextpdf.kernel.pdf.PdfName BorderStyle -> a5
    com.itextpdf.kernel.pdf.PdfName DCTDecode -> A6
    com.itextpdf.kernel.pdf.PdfName DW -> A7
    com.itextpdf.kernel.pdf.PdfName Inset -> fa
    com.itextpdf.kernel.pdf.PdfName Mask -> Fb
    com.itextpdf.kernel.pdf.PdfName PresSteps -> he
    com.itextpdf.kernel.pdf.PdfName Screen -> Hf
    com.itextpdf.kernel.pdf.PdfName Unspecified -> ji
    com.itextpdf.kernel.pdf.PdfName a -> p3
    com.itextpdf.kernel.pdf.PdfName Bl -> P4
    com.itextpdf.kernel.pdf.PdfName DPart -> r7
    com.itextpdf.kernel.pdf.PdfName Filespec -> r8
    com.itextpdf.kernel.pdf.PdfName HideToolbar -> R9
    com.itextpdf.kernel.pdf.PdfName Not -> wc
    byte[] rightCurlyBracket -> e3
    com.itextpdf.kernel.pdf.PdfName PI -> Wd
    com.itextpdf.kernel.pdf.PdfName StdCF -> yg
    java.util.Map staticNames -> sj
    com.itextpdf.kernel.pdf.PdfName Type0 -> Yh
    com.itextpdf.kernel.pdf.PdfName Colors -> a6
    com.itextpdf.kernel.pdf.PdfName Div -> a7
    com.itextpdf.kernel.pdf.PdfName Fit -> A8
    com.itextpdf.kernel.pdf.PdfName LineNum -> fb
    com.itextpdf.kernel.pdf.PdfName Obj -> Fc
    com.itextpdf.kernel.pdf.PdfName Ref -> hf
    com.itextpdf.kernel.pdf.PdfName StructElem -> Hg
    com.itextpdf.kernel.pdf.PdfName XRef -> jj
    com.itextpdf.kernel.pdf.PdfName Ascent -> p4
    com.itextpdf.kernel.pdf.PdfName Collection -> P5
    com.itextpdf.kernel.pdf.PdfName DestOutputProfile -> P6
    com.itextpdf.kernel.pdf.PdfName GlyphOrientationVertical -> r9
    com.itextpdf.kernel.pdf.PdfName LC -> Ua
    com.itextpdf.kernel.pdf.PdfName PageNum -> wd
    com.itextpdf.kernel.pdf.PdfName Rendition -> We
    com.itextpdf.kernel.pdf.PdfName TOC -> yh
    com.itextpdf.kernel.pdf.PdfName WinAnsiEncoding -> Yi
    com.itextpdf.kernel.pdf.PdfName ExData -> a8
    com.itextpdf.kernel.pdf.PdfName GTS_PDFA1 -> A9
    com.itextpdf.kernel.pdf.PdfName NA -> fc
    com.itextpdf.kernel.pdf.PdfName ParentTreeNextKey -> Fd
    com.itextpdf.kernel.pdf.PdfName Sort -> hg
    com.itextpdf.kernel.pdf.PdfName Trans -> Hh
    com.itextpdf.kernel.pdf.PdfName CapHeight -> p5
    com.itextpdf.kernel.pdf.PdfName Creator -> p6
    com.itextpdf.kernel.pdf.PdfName EndIndent -> P7
    com.itextpdf.kernel.pdf.PdfName IRT -> ua
    com.itextpdf.kernel.pdf.PdfName MissingWidth -> Ub
    com.itextpdf.kernel.pdf.PdfName Properties -> we
    com.itextpdf.kernel.pdf.PdfName SigRef -> Wf
    com.itextpdf.kernel.pdf.PdfName UserUnit -> yi
    com.itextpdf.kernel.pdf.PdfName Footer -> a9
    com.itextpdf.kernel.pdf.PdfName Justify -> Da
    com.itextpdf.kernel.pdf.PdfName Ordering -> fd
    com.itextpdf.kernel.pdf.PdfName R2L -> Fe
    com.itextpdf.kernel.pdf.PdfName TextAlign -> hh
    com.itextpdf.kernel.pdf.PdfName ViewerPreferences -> Hi
    com.itextpdf.kernel.pdf.PdfName Alaw -> N3
    com.itextpdf.kernel.pdf.PdfName Length -> Xa
    com.itextpdf.kernel.pdf.PdfName PaintType -> zd
    com.itextpdf.kernel.pdf.PdfName ResetForm -> Ze
    com.itextpdf.kernel.pdf.PdfName BaseState -> B4
    com.itextpdf.kernel.pdf.PdfName DigestValue -> d7
    com.itextpdf.kernel.pdf.PdfName FitBV -> D8
    com.itextpdf.kernel.pdf.PdfName Names -> ic
    com.itextpdf.kernel.pdf.PdfName Pattern -> Id
    com.itextpdf.kernel.pdf.PdfName Span -> kg
    com.itextpdf.kernel.pdf.PdfName Transparency -> Kh
    com.itextpdf.kernel.pdf.PdfName Caret -> s5
    com.itextpdf.kernel.pdf.PdfName DeviceCMYK -> S6
    com.itextpdf.kernel.pdf.PdfName GoToDp -> u9
    com.itextpdf.kernel.pdf.PdfName IT -> xa
    com.itextpdf.kernel.pdf.PdfName MMType1 -> Xb
    com.itextpdf.kernel.pdf.PdfName PV -> ze
    com.itextpdf.kernel.pdf.PdfName Size -> Zf
    com.itextpdf.kernel.pdf.PdfName AnnotStates -> b4
    com.itextpdf.kernel.pdf.PdfName CFM -> B5
    com.itextpdf.kernel.pdf.PdfName Export -> d8
    com.itextpdf.kernel.pdf.PdfName H2 -> D9
    com.itextpdf.kernel.pdf.PdfName Kids -> Ga
    com.itextpdf.kernel.pdf.PdfName OutputConditionIdentifier -> id
    com.itextpdf.kernel.pdf.PdfName RB -> Ie
    com.itextpdf.kernel.pdf.PdfName TextDecorationType -> kh
    com.itextpdf.kernel.pdf.PdfName VisiblePages -> Ki
    com.itextpdf.kernel.pdf.PdfName AllOn -> Q3
    com.itextpdf.kernel.pdf.PdfName Crypt -> s6
    com.itextpdf.kernel.pdf.PdfName Enforce -> S7
    com.itextpdf.kernel.pdf.PdfName M -> xb
    com.itextpdf.kernel.pdf.PdfName OpenArrow -> Xc
    com.itextpdf.kernel.pdf.PdfName RunLengthDecode -> zf
    com.itextpdf.kernel.pdf.PdfName TBorderStyle -> Zg
    com.itextpdf.kernel.pdf.PdfName BorderThickness -> b5
    com.itextpdf.kernel.pdf.PdfName Decimal -> B6
    com.itextpdf.kernel.pdf.PdfName FormData -> d9
    com.itextpdf.kernel.pdf.PdfName Image -> ga
    com.itextpdf.kernel.pdf.PdfName Matrix -> Gb
    com.itextpdf.kernel.pdf.PdfName Prev -> ie
    com.itextpdf.kernel.pdf.PdfName SD -> If
    com.itextpdf.kernel.pdf.PdfName UpperAlpha -> ki
    com.itextpdf.kernel.pdf.PdfName A -> q3
    com.itextpdf.kernel.pdf.PdfName BlackIs1 -> Q4
    com.itextpdf.kernel.pdf.PdfName DR -> s7
    com.itextpdf.kernel.pdf.PdfName FontFauxing -> S8
    com.itextpdf.kernel.pdf.PdfName HideWindowUI -> S9
    byte[] leftSquare -> b3
    com.itextpdf.kernel.pdf.PdfName NotApproved -> xc
    com.itextpdf.kernel.pdf.PdfName PickTrayByPDFSize -> Xd
    com.itextpdf.kernel.pdf.PdfName StemV -> zg
    com.itextpdf.kernel.pdf.PdfName Type1 -> Zh
    com.itextpdf.kernel.pdf.PdfName ColorSpace -> b6
    com.itextpdf.kernel.pdf.PdfName E -> B7
    com.itextpdf.kernel.pdf.PdfName FitB -> B8
    com.itextpdf.kernel.pdf.PdfName LineThrough -> gb
    com.itextpdf.kernel.pdf.PdfName OBJR -> Gc
    com.itextpdf.kernel.pdf.PdfName RI -> if
    com.itextpdf.kernel.pdf.PdfName StructParent -> Ig
    com.itextpdf.kernel.pdf.PdfName XRefStm -> kj
    com.itextpdf.kernel.pdf.PdfName ASCII85Decode -> q4
    com.itextpdf.kernel.pdf.PdfName ColSpan -> Q5
    com.itextpdf.kernel.pdf.PdfName Filter -> s8
    com.itextpdf.kernel.pdf.PdfName LI -> Za
    com.itextpdf.kernel.pdf.PdfName Bates -> D4
    com.itextpdf.kernel.pdf.PdfName Disc -> f7
    com.itextpdf.kernel.pdf.PdfName FitR -> F8
    com.itextpdf.kernel.pdf.PdfName Namespaces -> kc
    com.itextpdf.kernel.pdf.PdfName Pause -> Kd
    com.itextpdf.kernel.pdf.PdfName SpaceAfter -> mg
    com.itextpdf.kernel.pdf.PdfName Trapped -> Mh
    com.itextpdf.kernel.pdf.PdfName Category -> u5
    com.itextpdf.kernel.pdf.PdfName DeviceN -> U6
    com.itextpdf.kernel.pdf.PdfName GoToR -> w9
    com.itextpdf.kernel.pdf.PdfName JBIG2Decode -> za
    com.itextpdf.kernel.pdf.PdfName ModDate -> Zb
    com.itextpdf.kernel.pdf.PdfName AnyOn -> d4
    com.itextpdf.kernel.pdf.PdfName CI -> D5
    com.itextpdf.kernel.pdf.PdfName Extend -> f8
    com.itextpdf.kernel.pdf.PdfName H4 -> F9
    com.itextpdf.kernel.pdf.PdfName L -> Ia
    com.itextpdf.kernel.pdf.PdfName OutputIntents -> kd
    com.itextpdf.kernel.pdf.PdfName RC -> Ke
    com.itextpdf.kernel.pdf.PdfName TF -> mh
    com.itextpdf.kernel.pdf.PdfName Volume -> Mi
    com.itextpdf.kernel.pdf.PdfName Alternate -> S3
    com.itextpdf.kernel.pdf.PdfName CT -> u6
    com.itextpdf.kernel.pdf.PdfName ESIC -> U7
    com.itextpdf.kernel.pdf.PdfName MacRomanEncoding -> zb
    com.itextpdf.kernel.pdf.PdfName OPI -> Zc
    com.itextpdf.kernel.pdf.PdfName Bounds -> d5
    com.itextpdf.kernel.pdf.PdfName DecodeParms -> D6
    com.itextpdf.kernel.pdf.PdfName FormType -> f9
    com.itextpdf.kernel.pdf.PdfName ImportData -> ia
    com.itextpdf.kernel.pdf.PdfName MaxLen -> Ib
    com.itextpdf.kernel.pdf.PdfName Print -> ke
    com.itextpdf.kernel.pdf.PdfName Separation -> Kf
    com.itextpdf.kernel.pdf.PdfName URI -> mi
    com.itextpdf.kernel.pdf.PdfName AA -> s3
    com.itextpdf.kernel.pdf.PdfName BleedBox -> S4
    com.itextpdf.kernel.pdf.PdfName DS -> u7
    com.itextpdf.kernel.pdf.PdfName FontFile2 -> U8
    com.itextpdf.kernel.pdf.PdfName NotForPublicRelease -> zc
    com.itextpdf.kernel.pdf.PdfName Play -> Zd
    com.itextpdf.kernel.pdf.PdfName Adbe_pkcs7_sha1 -> B3
    com.itextpdf.kernel.pdf.PdfName Column -> d6
    com.itextpdf.kernel.pdf.PdfName EFF -> D7
    com.itextpdf.kernel.pdf.PdfName List -> ib
    com.itextpdf.kernel.pdf.PdfName OC -> Ic
    com.itextpdf.kernel.pdf.PdfName Ridge -> kf
    com.itextpdf.kernel.pdf.PdfName StructTreeRoot -> Kg
    com.itextpdf.kernel.pdf.PdfName XYZ -> mj
    com.itextpdf.kernel.pdf.PdfName Aside -> s4
    com.itextpdf.kernel.pdf.PdfName ColumnGap -> S5
    com.itextpdf.kernel.pdf.PdfName FDecodeParams -> u8
    com.itextpdf.kernel.pdf.PdfName HT -> U9
    com.itextpdf.kernel.pdf.PdfName BE -> F4
    com.itextpdf.kernel.pdf.PdfName DocMDP -> h7
    com.itextpdf.kernel.pdf.PdfName FitWindow -> H8
    com.itextpdf.kernel.pdf.PdfName LL -> mb
    com.itextpdf.kernel.pdf.PdfName NeedsRendering -> mc
    com.itextpdf.kernel.pdf.PdfName Perms -> Md
    com.itextpdf.kernel.pdf.PdfName Squiggly -> og
    com.itextpdf.kernel.pdf.PdfName TrapStyles -> Oh
    com.itextpdf.kernel.pdf.PdfName Center -> w5
    com.itextpdf.kernel.pdf.PdfName DeviceRGBK -> W6
    com.itextpdf.kernel.pdf.PdfName Group -> y9
    com.itextpdf.kernel.pdf.PdfName App -> f4
    com.itextpdf.kernel.pdf.PdfName CIDFontType2 -> F5
    com.itextpdf.kernel.pdf.PdfName Extensions -> h8
    com.itextpdf.kernel.pdf.PdfName H6 -> H9
    com.itextpdf.kernel.pdf.PdfName Lang -> Ka
    com.itextpdf.kernel.pdf.PdfName Overlay -> md
    com.itextpdf.kernel.pdf.PdfName RD -> Me
    com.itextpdf.kernel.pdf.PdfName TH -> oh
    com.itextpdf.kernel.pdf.PdfName W -> Oi
    com.itextpdf.kernel.pdf.PdfName AlternatePresentations -> U3
    com.itextpdf.kernel.pdf.PdfName DA -> w6
    com.itextpdf.kernel.pdf.PdfName ETSI_RFC3161 -> W7
    com.itextpdf.kernel.pdf.PdfName Btn -> f5
    com.itextpdf.kernel.pdf.PdfName DefaultCMYK -> F6
    com.itextpdf.kernel.pdf.PdfName FreeTextCallout -> h9
    com.itextpdf.kernel.pdf.PdfName Include -> ka
    com.itextpdf.kernel.pdf.PdfName MCID -> Kb
    com.itextpdf.kernel.pdf.PdfName PrintClip -> me
    com.itextpdf.kernel.pdf.PdfName SeparationInfo -> Mf
    com.itextpdf.kernel.pdf.PdfName URLS -> oi
    com.itextpdf.kernel.pdf.PdfName AcroForm -> u3
    com.itextpdf.kernel.pdf.PdfName BlockAlign -> U4
    com.itextpdf.kernel.pdf.PdfName Duplex -> w7
    com.itextpdf.kernel.pdf.PdfName FontMatrix -> W8
    com.itextpdf.kernel.pdf.PdfName Adobe_PPKLite -> D3
    com.itextpdf.kernel.pdf.PdfName Compatible -> f6
    com.itextpdf.kernel.pdf.PdfName Em -> F7
    com.itextpdf.kernel.pdf.PdfName ListNumbering -> kb
    com.itextpdf.kernel.pdf.PdfName OCGs -> Kc
    com.itextpdf.kernel.pdf.PdfName RoleMap -> mf
    com.itextpdf.kernel.pdf.PdfName Sub -> Mg
    com.itextpdf.kernel.pdf.PdfName ZapfDingbats -> oj
    com.itextpdf.kernel.pdf.PdfName AuthEvent -> u4
    com.itextpdf.kernel.pdf.PdfName ContactInfo -> U5
    com.itextpdf.kernel.pdf.PdfName Final -> w8
    com.itextpdf.kernel.pdf.PdfName HTP -> W9
    com.itextpdf.kernel.pdf.PdfName U -> bi
    com.itextpdf.kernel.pdf.PdfName _3D -> h3
    com.itextpdf.kernel.pdf.PdfName BC -> H4
    com.itextpdf.kernel.pdf.PdfName DocTimeStamp -> j7
    com.itextpdf.kernel.pdf.PdfName Fl -> J8
    com.itextpdf.kernel.pdf.PdfName LLO -> ob
    com.itextpdf.kernel.pdf.PdfName OCSPs -> Oc
    com.itextpdf.kernel.pdf.PdfName Rotate -> qf
    com.itextpdf.kernel.pdf.PdfName Stamp -> qg
    com.itextpdf.kernel.pdf.PdfName TrueType -> Qh
    com.itextpdf.kernel.pdf.PdfName Cert -> y5
    com.itextpdf.kernel.pdf.PdfName Difference -> Y6
    com.itextpdf.kernel.pdf.PdfName WS -> bj
    com.itextpdf.kernel.pdf.PdfName ApplicationOctetStream -> h4
    com.itextpdf.kernel.pdf.PdfName CIDSystemInfo -> H5
    com.itextpdf.kernel.pdf.PdfName ExtGState -> j8
    com.itextpdf.kernel.pdf.PdfName HalftoneName -> J9
    com.itextpdf.kernel.pdf.PdfName Next -> oc
    com.itextpdf.kernel.pdf.PdfName PCM -> Od
    com.itextpdf.kernel.pdf.PdfName Recipients -> Oe
    com.itextpdf.kernel.pdf.PdfName Thumb -> qh
    com.itextpdf.kernel.pdf.PdfName Warichu -> Qi
    com.itextpdf.kernel.pdf.PdfName AN -> W3
    com.itextpdf.kernel.pdf.PdfName Dashed -> y6
    com.itextpdf.kernel.pdf.PdfName Exclude -> Y7
    com.itextpdf.kernel.pdf.PdfName ByteRange -> h5
    com.itextpdf.kernel.pdf.PdfName DefaultGray -> H6
    com.itextpdf.kernel.pdf.PdfName FS -> j9
    com.itextpdf.kernel.pdf.PdfName Last -> Ma
    com.itextpdf.kernel.pdf.PdfName P -> od
    com.itextpdf.kernel.pdf.PdfName PrintPageRange -> oe
    com.itextpdf.kernel.pdf.PdfName ShadingType -> Of
    com.itextpdf.kernel.pdf.PdfName UseAttachments -> qi
    com.itextpdf.kernel.pdf.PdfName ActualText -> w3
    com.itextpdf.kernel.pdf.PdfName BM -> W4
    com.itextpdf.kernel.pdf.PdfName DuplexFlipLongEdge -> y7
    com.itextpdf.kernel.pdf.PdfName FontWeight -> Y8
    com.itextpdf.kernel.pdf.PdfName Adobe_PubSec -> F3
    com.itextpdf.kernel.pdf.PdfName Configs -> h6
    com.itextpdf.kernel.pdf.PdfName EmbeddedFiles -> H7
    com.itextpdf.kernel.pdf.PdfName Indexed -> ma
    com.itextpdf.kernel.pdf.PdfName MD5 -> Mb
    com.itextpdf.kernel.pdf.PdfName OCProperties -> Mc
    com.itextpdf.kernel.pdf.PdfName ROpenArrow -> of
    com.itextpdf.kernel.pdf.PdfName Subj -> Og
    com.itextpdf.kernel.pdf.PdfName zh_Latn_wadegile -> qj
    com.itextpdf.kernel.pdf.PdfName B -> w4
    com.itextpdf.kernel.pdf.PdfName Color -> W5
    com.itextpdf.kernel.pdf.PdfName FirstChar -> y8
    com.itextpdf.kernel.pdf.PdfName I -> Y9
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    byte getType() -> J
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    void generateContent() -> d0
    int compareTo(com.itextpdf.kernel.pdf.PdfName) -> g0
    com.itextpdf.kernel.pdf.PdfName createDirectName(java.lang.String) -> h0
    void generateValue() -> i0
    java.lang.String getValue() -> j0
com.itextpdf.kernel.pdf.PdfNameLoader -> b1.k0:
    java.util.Map loadNames() -> a
com.itextpdf.kernel.pdf.PdfNameTree -> b1.l0:
    java.util.Map items -> b
    com.itextpdf.kernel.pdf.PdfCatalog catalog -> a
    com.itextpdf.kernel.pdf.PdfName treeType -> c
    boolean modified -> d
    void addEntry(java.lang.String,com.itextpdf.kernel.pdf.PdfObject) -> a
    com.itextpdf.kernel.pdf.PdfDictionary buildTree() -> b
    com.itextpdf.kernel.pdf.PdfArray getDestArray(com.itextpdf.kernel.pdf.PdfObject) -> c
    java.util.Map getNames() -> d
    boolean isModified() -> e
    com.itextpdf.kernel.pdf.PdfString iterateItems(com.itextpdf.kernel.pdf.PdfDictionary,java.util.Map,com.itextpdf.kernel.pdf.PdfString) -> f
    java.util.Map readTree(com.itextpdf.kernel.pdf.PdfDictionary) -> g
com.itextpdf.kernel.pdf.PdfNull -> b1.m0:
    byte[] NullContent -> V2
    com.itextpdf.kernel.pdf.PdfNull PDF_NULL -> U2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    byte getType() -> J
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    void generateContent() -> d0
com.itextpdf.kernel.pdf.PdfNumTree -> b1.n0:
    java.util.Map items -> b
    com.itextpdf.kernel.pdf.PdfCatalog catalog -> a
    com.itextpdf.kernel.pdf.PdfName treeType -> c
    void addEntry(int,com.itextpdf.kernel.pdf.PdfObject) -> a
    com.itextpdf.kernel.pdf.PdfDictionary buildTree() -> b
    java.util.Map getNumbers() -> c
    com.itextpdf.kernel.pdf.PdfNumber iterateItems(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfNumber) -> d
    void readTree(com.itextpdf.kernel.pdf.PdfDictionary) -> e
com.itextpdf.kernel.pdf.PdfNumber -> b1.o0:
    boolean isDouble -> V2
    double value -> U2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    byte getType() -> J
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    void generateContent() -> d0
    void decrement() -> g0
    double doubleValue() -> h0
    float floatValue() -> i0
    void generateValue() -> j0
    double getValue() -> k0
    void increment() -> l0
    int intValue() -> m0
    boolean isDoubleNumber() -> n0
    long longValue() -> o0
    void setValue(double) -> p0
    void setValue(int) -> q0
com.itextpdf.kernel.pdf.PdfObject -> b1.p0:
    com.itextpdf.kernel.pdf.PdfIndirectReference indirectReference -> Q2
    short state -> R2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    com.itextpdf.kernel.pdf.PdfObject copyTo(com.itextpdf.kernel.pdf.PdfDocument) -> B
    com.itextpdf.kernel.pdf.PdfObject copyTo(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> C
    com.itextpdf.kernel.pdf.PdfObject copyTo(com.itextpdf.kernel.pdf.PdfDocument,boolean) -> D
    com.itextpdf.kernel.pdf.PdfObject copyTo(com.itextpdf.kernel.pdf.PdfDocument,boolean,com.itextpdf.kernel.utils.ICopyFilter) -> E
    boolean equalContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfObject) -> F
    void flush() -> G
    void flush(boolean) -> H
    com.itextpdf.kernel.pdf.PdfIndirectReference getIndirectReference() -> I
    byte getType() -> J
    boolean isArray() -> K
    boolean isDictionary() -> L
    boolean isFlushed() -> M
    boolean isIndirect() -> N
    boolean isIndirectReference() -> O
    boolean isModified() -> P
    boolean isName() -> Q
    boolean isNumber() -> R
    boolean isReleaseForbidden() -> S
    boolean isStream() -> T
    boolean isString() -> U
    com.itextpdf.kernel.pdf.PdfObject makeIndirect(com.itextpdf.kernel.pdf.PdfDocument) -> V
    com.itextpdf.kernel.pdf.PdfObject makeIndirect(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.PdfIndirectReference) -> W
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    com.itextpdf.kernel.pdf.PdfObject processCopying(com.itextpdf.kernel.pdf.PdfDocument,boolean,com.itextpdf.kernel.utils.ICopyFilter) -> Y
    void release() -> Z
    boolean checkState(short) -> a
    com.itextpdf.kernel.pdf.PdfObject setIndirectReference(com.itextpdf.kernel.pdf.PdfIndirectReference) -> a0
    com.itextpdf.kernel.pdf.PdfObject setModified() -> b0
    com.itextpdf.kernel.pdf.PdfObject setState(short) -> c0
    com.itextpdf.kernel.pdf.PdfObject clearState(short) -> k
    com.itextpdf.kernel.pdf.PdfObject clone() -> n
    com.itextpdf.kernel.pdf.PdfObject clone(com.itextpdf.kernel.utils.ICopyFilter) -> x
com.itextpdf.kernel.pdf.PdfObjectStream -> b1.q0:
    com.itextpdf.kernel.pdf.PdfNumber size -> Y2
    com.itextpdf.kernel.pdf.PdfOutputStream indexStream -> Z2
    void addObject(com.itextpdf.kernel.pdf.PdfObject) -> N0
    com.itextpdf.kernel.pdf.PdfOutputStream getIndexStream() -> O0
    int getSize() -> P0
    void releaseContent(boolean) -> Q0
    void releaseContent() -> y0
com.itextpdf.kernel.pdf.PdfObjectWrapper -> b1.r0:
    com.itextpdf.kernel.pdf.PdfObject pdfObject -> a
    void ensureObjectIsAddedToDocument(com.itextpdf.kernel.pdf.PdfObject) -> f
    void ensureUnderlyingObjectHasIndirectReference() -> g
    void flush() -> h
    com.itextpdf.kernel.pdf.PdfObject getPdfObject() -> i
    boolean isFlushed() -> j
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.PdfObjectWrapper makeIndirect(com.itextpdf.kernel.pdf.PdfDocument) -> l
    com.itextpdf.kernel.pdf.PdfObjectWrapper makeIndirect(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.PdfIndirectReference) -> m
    void markObjectAsIndirect(com.itextpdf.kernel.pdf.PdfObject) -> n
    void setForbidRelease() -> o
    com.itextpdf.kernel.pdf.PdfObjectWrapper setModified() -> p
    void setPdfObject(com.itextpdf.kernel.pdf.PdfObject) -> q
com.itextpdf.kernel.pdf.PdfOutline -> b1.s0:
    java.util.List children -> a
    com.itextpdf.kernel.pdf.navigation.PdfDestination destination -> d
    int FLAG_BOLD -> h
    com.itextpdf.kernel.pdf.PdfDictionary content -> c
    com.itextpdf.kernel.pdf.PdfOutline parent -> e
    int FLAG_ITALIC -> g
    com.itextpdf.kernel.pdf.PdfDocument pdfDoc -> f
    java.lang.String title -> b
    void addDestination(com.itextpdf.kernel.pdf.navigation.PdfDestination) -> a
    com.itextpdf.kernel.pdf.PdfOutline addOutline(java.lang.String) -> b
    com.itextpdf.kernel.pdf.PdfOutline addOutline(java.lang.String,int) -> c
    void clear() -> d
    java.util.List getAllChildren() -> e
    com.itextpdf.kernel.colors.Color getColor() -> f
    com.itextpdf.kernel.pdf.PdfDictionary getContent() -> g
    com.itextpdf.kernel.pdf.navigation.PdfDestination getDestination() -> h
    com.itextpdf.kernel.pdf.PdfDictionary getOutlineRoot() -> i
    com.itextpdf.kernel.pdf.PdfOutline getParent() -> j
    java.lang.Integer getStyle() -> k
    java.lang.String getTitle() -> l
    boolean isOpen() -> m
    boolean isOutlineRoot() -> n
    void removeOutline() -> o
    void setColor(com.itextpdf.kernel.colors.Color) -> p
    void setDestination(com.itextpdf.kernel.pdf.navigation.PdfDestination) -> q
    void setOpen(boolean) -> r
    void setStyle(int) -> s
    void setTitle(java.lang.String) -> t
com.itextpdf.kernel.pdf.PdfOutputStream -> b1.t0:
    byte[] endIndirectWithZeroGenNr -> c3
    org.slf4j.Logger LOGGER -> d3
    byte[] endIndirect -> b3
    byte[] closeDict -> a3
    byte[] openDict -> Z2
    com.itextpdf.kernel.pdf.PdfEncryption crypto -> W2
    byte[] endstream -> Y2
    byte[] stream -> X2
    com.itextpdf.kernel.pdf.PdfDocument document -> V2
    void write(int,int) -> A
    void write(long,int) -> B
    void write(com.itextpdf.kernel.pdf.PdfArray) -> C
    void write(com.itextpdf.kernel.pdf.PdfDictionary) -> D
    void write(com.itextpdf.kernel.pdf.PdfIndirectReference) -> E
    void write(com.itextpdf.kernel.pdf.PdfLiteral) -> F
    void write(com.itextpdf.kernel.pdf.PdfName) -> G
    void write(com.itextpdf.kernel.pdf.PdfNumber) -> H
    void write(com.itextpdf.kernel.pdf.PdfPrimitiveObject) -> I
    void write(com.itextpdf.kernel.pdf.PdfStream) -> J
    void write(com.itextpdf.kernel.pdf.PdfString) -> K
    boolean checkEncryption(com.itextpdf.kernel.pdf.PdfStream) -> r
    boolean containsFlateFilter(com.itextpdf.kernel.pdf.PdfStream) -> s
    byte[] decodeFlateBytes(com.itextpdf.kernel.pdf.PdfStream,byte[]) -> t
    boolean decodeParamsArrayNotFlushed(com.itextpdf.kernel.pdf.PdfStream) -> u
    boolean isFlushed(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfName) -> v
    boolean isNotMetadataPdfStream(com.itextpdf.kernel.pdf.PdfStream) -> w
    boolean isXRefStream(com.itextpdf.kernel.pdf.PdfStream) -> x
    void updateCompressionFilter(com.itextpdf.kernel.pdf.PdfStream) -> y
    com.itextpdf.kernel.pdf.PdfOutputStream write(com.itextpdf.kernel.pdf.PdfObject) -> z
com.itextpdf.kernel.pdf.PdfPage -> b1.u0:
    com.itextpdf.kernel.pdf.PdfPages parentPages -> d
    boolean ignorePageRotationForContent -> e
    boolean pageRotationInverseMatrixWritten -> f
    java.util.List XOBJECT_EXCLUDED_KEYS -> h
    java.util.List PAGE_EXCLUDED_KEYS -> g
    com.itextpdf.kernel.pdf.PdfResources resources -> b
    int mcid -> c
    void flushResourcesContentStreams(com.itextpdf.kernel.pdf.PdfDictionary) -> A
    void flushWithResources(com.itextpdf.kernel.pdf.PdfDictionary) -> B
    java.util.List getAnnotations() -> C
    com.itextpdf.kernel.pdf.PdfArray getAnnots(boolean) -> D
    com.itextpdf.kernel.pdf.PdfStream getContentStream(int) -> E
    int getContentStreamCount() -> F
    com.itextpdf.kernel.geom.Rectangle getCropBox() -> G
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> H
    com.itextpdf.kernel.pdf.PdfObject getInheritedValue(com.itextpdf.kernel.pdf.PdfName,int) -> I
    com.itextpdf.kernel.pdf.PdfObject getInheritedValue(com.itextpdf.kernel.pdf.PdfPages,com.itextpdf.kernel.pdf.PdfName) -> J
    com.itextpdf.kernel.pdf.PdfStream getLastContentStream() -> K
    com.itextpdf.kernel.geom.Rectangle getMediaBox() -> L
    int getNextMcid() -> M
    java.util.List getOutlines(boolean) -> N
    com.itextpdf.kernel.geom.Rectangle getPageSize() -> O
    com.itextpdf.kernel.geom.Rectangle getPageSizeWithRotation() -> P
    com.itextpdf.kernel.pdf.PdfResources getResources() -> Q
    com.itextpdf.kernel.pdf.PdfResources getResources(boolean) -> R
    int getRotation() -> S
    int getStructParentIndex() -> T
    com.itextpdf.kernel.pdf.PdfName getTabOrder() -> U
    com.itextpdf.kernel.geom.Rectangle getTrimBox() -> V
    com.itextpdf.kernel.pdf.PdfDictionary initResources(boolean) -> W
    boolean isIgnorePageRotationForContent() -> X
    boolean isPageRotationInverseMatrixWritten() -> Y
    com.itextpdf.kernel.pdf.PdfStream newContentStream(boolean) -> Z
    com.itextpdf.kernel.pdf.PdfStream newContentStreamAfter() -> a0
    com.itextpdf.kernel.pdf.PdfStream newContentStreamBefore() -> b0
    com.itextpdf.kernel.pdf.PdfPage put(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> c0
    void rebuildFormFieldParent(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDocument) -> d0
    void releaseInstanceFields() -> e0
    com.itextpdf.kernel.pdf.PdfPage setIgnorePageRotationForContent(boolean) -> f0
    com.itextpdf.kernel.pdf.PdfPage setMediaBox(com.itextpdf.kernel.geom.Rectangle) -> g0
    void flush() -> h
    void setPageRotationInverseMatrixWritten() -> h0
    com.itextpdf.kernel.pdf.PdfPage setRotation(int) -> i0
    com.itextpdf.kernel.pdf.PdfPage setTabOrder(com.itextpdf.kernel.pdf.PdfName) -> j0
    boolean isWrappedObjectMustBeIndirect() -> k
    void tryFlushPageTags() -> k0
    com.itextpdf.kernel.pdf.PdfPage addAnnotation(int,com.itextpdf.kernel.pdf.annot.PdfAnnotation,boolean) -> r
    com.itextpdf.kernel.pdf.PdfPage addAnnotation(com.itextpdf.kernel.pdf.annot.PdfAnnotation) -> s
    void copyAnnotations(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.PdfPage,com.itextpdf.kernel.utils.ICopyFilter) -> t
    void copyInheritedProperties(com.itextpdf.kernel.pdf.PdfPage,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> u
    com.itextpdf.kernel.pdf.PdfPage copyTo(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.IPdfPageExtraCopier) -> v
    void flush(boolean) -> w
    void flushAppearanceStreams(com.itextpdf.kernel.pdf.PdfDictionary) -> x
    void flushMustBeIndirectObject(com.itextpdf.kernel.pdf.PdfObject) -> y
    void flushResourcesContentStreams() -> z
com.itextpdf.kernel.pdf.PdfPageFactory -> b1.v0:
    com.itextpdf.kernel.pdf.PdfPage createPdfPage(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.geom.PageSize) -> a
    com.itextpdf.kernel.pdf.PdfPage createPdfPage(com.itextpdf.kernel.pdf.PdfDictionary) -> b
com.itextpdf.kernel.pdf.PdfPages -> b1.w0:
    com.itextpdf.kernel.pdf.PdfArray kids -> d
    com.itextpdf.kernel.pdf.PdfPages parent -> e
    int from -> b
    com.itextpdf.kernel.pdf.PdfNumber count -> c
    com.itextpdf.kernel.pdf.PdfPages getParent() -> A
    void incrementCount() -> B
    void removeFromParent() -> C
    boolean removePage(int) -> D
    boolean isWrappedObjectMustBeIndirect() -> k
    void addPage(com.itextpdf.kernel.pdf.PdfDictionary) -> r
    boolean addPage(int,com.itextpdf.kernel.pdf.PdfPage) -> s
    void addPages(com.itextpdf.kernel.pdf.PdfPages) -> t
    int compareTo(int) -> u
    void correctFrom(int) -> v
    void decrementCount() -> w
    int getCount() -> x
    int getFrom() -> y
    com.itextpdf.kernel.pdf.PdfArray getKids() -> z
com.itextpdf.kernel.pdf.PdfPagesTree -> b1.x0:
    java.util.List pageRefs -> b
    com.itextpdf.kernel.pdf.PdfDocument document -> e
    java.util.List pages -> d
    java.util.List parents -> c
    boolean generated -> f
    org.slf4j.Logger LOGGER -> h
    com.itextpdf.kernel.pdf.PdfPages root -> g
    int leafSize -> a
    void addPage(int,com.itextpdf.kernel.pdf.PdfPage) -> a
    void addPage(com.itextpdf.kernel.pdf.PdfPage) -> b
    void clearPageRefs() -> c
    void correctPdfPagesFromProperty(int,int) -> d
    int findPageParent(int) -> e
    com.itextpdf.kernel.pdf.PdfPages findPageParent(com.itextpdf.kernel.pdf.PdfPage) -> f
    com.itextpdf.kernel.pdf.PdfObject generateTree() -> g
    int getNumberOfPages() -> h
    com.itextpdf.kernel.pdf.PdfPage getPage(int) -> i
    int getPageNumber(com.itextpdf.kernel.pdf.PdfPage) -> j
    boolean internalRemovePage(int) -> k
    void loadPage(int) -> l
    void loadPage(int,java.util.Set) -> m
    com.itextpdf.kernel.pdf.PdfPage removePage(int) -> n
com.itextpdf.kernel.pdf.PdfPrimitiveObject -> b1.y0:
    byte[] content -> S2
    boolean directOnly -> T2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    com.itextpdf.kernel.pdf.PdfObject makeIndirect(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.PdfIndirectReference) -> W
    com.itextpdf.kernel.pdf.PdfObject setIndirectReference(com.itextpdf.kernel.pdf.PdfIndirectReference) -> a0
    void generateContent() -> d0
    byte[] getInternalContent() -> e0
    boolean hasContent() -> f0
com.itextpdf.kernel.pdf.PdfReader -> b1.z0:
    boolean fixedXref -> g3
    boolean xrefStm -> h3
    com.itextpdf.kernel.pdf.PdfVersion headerPdfVersion -> W2
    boolean encrypted -> d3
    com.itextpdf.io.source.PdfTokenizer tokens -> U2
    boolean rebuiltXref -> e3
    boolean hybridXref -> f3
    com.itextpdf.kernel.pdf.ReaderProperties properties -> c3
    com.itextpdf.kernel.pdf.PdfIndirectReference currentIndirectReference -> T2
    boolean memorySavingMode -> R2
    com.itextpdf.kernel.pdf.PdfDocument pdfDocument -> a3
    com.itextpdf.kernel.pdf.PdfReader$StrictnessLevel strictnessLevel -> S2
    long lastXref -> X2
    long eofPos -> Y2
    com.itextpdf.kernel.pdf.PdfAConformanceLevel pdfAConformanceLevel -> b3
    com.itextpdf.kernel.pdf.PdfEncryption decrypt -> V2
    byte[] endobj -> k3
    byte[] endstream -> j3
    boolean unethicalReading -> Q2
    com.itextpdf.kernel.pdf.PdfReader$StrictnessLevel DEFAULT_STRICTNESS_LEVEL -> i3
    boolean correctStreamLength -> l3
    com.itextpdf.kernel.pdf.PdfDictionary trailer -> Z2
    void readObjectStream(com.itextpdf.kernel.pdf.PdfStream) -> A
    void readPdf() -> B
    com.itextpdf.kernel.pdf.PdfName readPdfName(boolean) -> C
    com.itextpdf.kernel.pdf.PdfObject readReference(boolean) -> D
    byte[] readStreamBytes(com.itextpdf.kernel.pdf.PdfStream,boolean) -> E
    byte[] readStreamBytesRaw(com.itextpdf.kernel.pdf.PdfStream) -> F
    void readXref() -> G
    com.itextpdf.kernel.pdf.PdfDictionary readXrefSection() -> H
    boolean readXrefStream(long) -> I
    void rebuildXref() -> J
    com.itextpdf.kernel.pdf.PdfReader setMemorySavingMode(boolean) -> K
    com.itextpdf.kernel.pdf.PdfReader setUnethicalReading(boolean) -> L
    void checkPdfStreamLength(com.itextpdf.kernel.pdf.PdfStream) -> a
    com.itextpdf.kernel.pdf.PdfObject createPdfNullInstance(boolean) -> b
    byte[] decodeBytes(byte[],com.itextpdf.kernel.pdf.PdfDictionary) -> c
    byte[] decodeBytes(byte[],com.itextpdf.kernel.pdf.PdfDictionary,java.util.Map) -> d
    void fixXref() -> e
    long getLastXref() -> f
    com.itextpdf.io.source.PdfTokenizer getOffsetTokeniser(com.itextpdf.io.source.IRandomAccessSource,boolean) -> g
    byte[] getOriginalFileId() -> h
    com.itextpdf.kernel.pdf.PdfAConformanceLevel getPdfAConformanceLevel() -> i
    long getPermissions() -> j
    com.itextpdf.kernel.pdf.PdfReader$StrictnessLevel getStrictnessLevel() -> k
    com.itextpdf.kernel.pdf.PdfNumber getXrefPrev(com.itextpdf.kernel.pdf.PdfObject) -> l
    boolean hasFixedXref() -> m
    boolean hasRebuiltXref() -> n
    boolean hasXrefStm() -> o
    boolean isEncrypted() -> p
    boolean isMemorySavingMode() -> q
    boolean isOpenedWithFullPermission() -> r
    void processArrayReadError() -> s
    com.itextpdf.kernel.pdf.PdfArray readArray(boolean) -> t
    void readDecryptObj() -> u
    com.itextpdf.kernel.pdf.PdfDictionary readDictionary(boolean) -> v
    com.itextpdf.kernel.pdf.PdfObject readObject(com.itextpdf.kernel.pdf.PdfIndirectReference) -> w
    com.itextpdf.kernel.pdf.PdfObject readObject(com.itextpdf.kernel.pdf.PdfIndirectReference,boolean) -> x
    com.itextpdf.kernel.pdf.PdfObject readObject(boolean) -> y
    com.itextpdf.kernel.pdf.PdfObject readObject(boolean,boolean) -> z
com.itextpdf.kernel.pdf.PdfReader$1 -> b1.z0$a:
    int[] $SwitchMap$com$itextpdf$io$source$PdfTokenizer$TokenType -> a
com.itextpdf.kernel.pdf.PdfReader$ReusableRandomAccessSource -> b1.z0$b:
    com.itextpdf.io.source.ByteBuffer buffer -> a
    int get(long) -> a
    int get(long,byte[],int,int) -> b
com.itextpdf.kernel.pdf.PdfReader$StrictnessLevel -> b1.z0$c:
    com.itextpdf.kernel.pdf.PdfReader$StrictnessLevel[] $VALUES -> T2
    com.itextpdf.kernel.pdf.PdfReader$StrictnessLevel CONSERVATIVE -> R2
    com.itextpdf.kernel.pdf.PdfReader$StrictnessLevel LENIENT -> S2
    int levelValue -> Q2
    boolean isStricter(com.itextpdf.kernel.pdf.PdfReader$StrictnessLevel) -> a
com.itextpdf.kernel.pdf.PdfResources -> b1.a1:
    com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator imageNamesGen -> d
    java.util.Map resourceToName -> b
    com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator formNamesGen -> e
    com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator fontNamesGen -> c
    com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator csNamesGen -> h
    com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator patternNamesGen -> i
    com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator egsNamesGen -> f
    boolean readOnly -> k
    com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator propNamesGen -> g
    boolean isModified -> l
    com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator shadingNamesGen -> j
    com.itextpdf.kernel.pdf.PdfName addResource(com.itextpdf.kernel.pdf.PdfObjectWrapper,com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator) -> A
    void addResource(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfName) -> B
    void buildResources(com.itextpdf.kernel.pdf.PdfDictionary) -> C
    void checkAndResolveCircularReferences(com.itextpdf.kernel.pdf.PdfObject) -> D
    com.itextpdf.kernel.pdf.PdfName getResourceName(com.itextpdf.kernel.pdf.PdfObject) -> E
    boolean isModified() -> F
    boolean isReadOnly() -> G
    void setReadOnly(boolean) -> H
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.PdfObjectWrapper setModified() -> p
    com.itextpdf.kernel.pdf.PdfName addColorSpace(com.itextpdf.kernel.pdf.colorspace.PdfColorSpace) -> r
    com.itextpdf.kernel.pdf.PdfName addExtGState(com.itextpdf.kernel.pdf.extgstate.PdfExtGState) -> s
    com.itextpdf.kernel.pdf.PdfName addFont(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.font.PdfFont) -> t
    com.itextpdf.kernel.pdf.PdfName addForm(com.itextpdf.kernel.pdf.xobject.PdfFormXObject) -> u
    com.itextpdf.kernel.pdf.PdfName addImage(com.itextpdf.kernel.pdf.PdfStream) -> v
    com.itextpdf.kernel.pdf.PdfName addImage(com.itextpdf.kernel.pdf.xobject.PdfImageXObject) -> w
    com.itextpdf.kernel.pdf.PdfName addPattern(com.itextpdf.kernel.pdf.colorspace.PdfPattern) -> x
    com.itextpdf.kernel.pdf.PdfName addProperties(com.itextpdf.kernel.pdf.PdfDictionary) -> y
    com.itextpdf.kernel.pdf.PdfName addResource(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator) -> z
com.itextpdf.kernel.pdf.PdfResources$ResourceNameGenerator -> b1.a1$a:
    com.itextpdf.kernel.pdf.PdfName resourceType -> a
    int counter -> b
    java.lang.String prefix -> c
    com.itextpdf.kernel.pdf.PdfName generate(com.itextpdf.kernel.pdf.PdfResources) -> a
    com.itextpdf.kernel.pdf.PdfName getResourceType() -> b
com.itextpdf.kernel.pdf.PdfStream -> b1.b1:
    com.itextpdf.kernel.pdf.PdfOutputStream outputStream -> U2
    java.io.InputStream inputStream -> V2
    int compressionLevel -> T2
    long offset -> W2
    int length -> X2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    byte[] getBytes() -> C0
    byte[] getBytes(boolean) -> D0
    int getCompressionLevel() -> E0
    java.io.InputStream getInputStream() -> F0
    long getOffset() -> G0
    com.itextpdf.kernel.pdf.PdfOutputStream getOutputStream() -> H0
    void initOutputStream(java.io.OutputStream) -> I0
    byte getType() -> J
    void setCompressionLevel(int) -> J0
    void setData(byte[]) -> K0
    void setData(byte[],boolean) -> L0
    void updateLength(int) -> M0
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    int getLength() -> c
    void releaseContent() -> y0
com.itextpdf.kernel.pdf.PdfString -> b1.c1:
    boolean hexWriting -> W2
    int decryptInfoGen -> Y2
    java.lang.String encoding -> V2
    java.lang.String value -> U2
    int decryptInfoNum -> X2
    com.itextpdf.kernel.pdf.PdfEncryption decryption -> Z2
    void copyContent(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.ICopyFilter) -> A
    byte getType() -> J
    com.itextpdf.kernel.pdf.PdfObject newInstance() -> X
    void generateContent() -> d0
    byte[] decodeContent() -> g0
    byte[] encodeBytes(byte[]) -> h0
    boolean encrypt(com.itextpdf.kernel.pdf.PdfEncryption) -> i0
    void generateValue() -> j0
    java.lang.String getEncoding() -> k0
    java.lang.String getValue() -> l0
    byte[] getValueBytes() -> m0
    boolean isHexWriting() -> n0
    void setDecryption(int,int,com.itextpdf.kernel.pdf.PdfEncryption) -> o0
    com.itextpdf.kernel.pdf.PdfString setHexWriting(boolean) -> p0
    java.lang.String toUnicodeString() -> q0
com.itextpdf.kernel.pdf.PdfVersion -> b1.d1:
    com.itextpdf.kernel.pdf.PdfVersion PDF_1_0 -> T2
    com.itextpdf.kernel.pdf.PdfVersion PDF_1_1 -> U2
    java.util.List values -> S2
    com.itextpdf.kernel.pdf.PdfVersion PDF_1_2 -> V2
    com.itextpdf.kernel.pdf.PdfVersion PDF_1_3 -> W2
    com.itextpdf.kernel.pdf.PdfVersion PDF_1_4 -> X2
    com.itextpdf.kernel.pdf.PdfVersion PDF_1_5 -> Y2
    com.itextpdf.kernel.pdf.PdfVersion PDF_1_6 -> Z2
    int major -> Q2
    com.itextpdf.kernel.pdf.PdfVersion PDF_1_7 -> a3
    int minor -> R2
    com.itextpdf.kernel.pdf.PdfVersion PDF_2_0 -> b3
    int compareTo(com.itextpdf.kernel.pdf.PdfVersion) -> a
    com.itextpdf.kernel.pdf.PdfVersion createPdfVersion(int,int) -> c
    com.itextpdf.kernel.pdf.PdfVersion fromPdfName(com.itextpdf.kernel.pdf.PdfName) -> d
    com.itextpdf.kernel.pdf.PdfVersion fromString(java.lang.String) -> k
    com.itextpdf.kernel.pdf.PdfName toPdfName() -> n
com.itextpdf.kernel.pdf.PdfWriter -> b1.e1:
    com.itextpdf.kernel.pdf.WriterProperties properties -> e3
    boolean isUserWarnedAboutAcroFormCopying -> f3
    byte[] endobj -> k3
    byte[] obj -> j3
    java.util.Map copiedObjects -> h3
    com.itextpdf.kernel.pdf.PdfObjectStream objectStream -> g3
    com.itextpdf.kernel.pdf.SmartModePdfObjectsSerializer smartModeSerializer -> i3
    boolean checkTypeOfPdfDictionary(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName) -> L
    com.itextpdf.kernel.pdf.PdfObject copyObject(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDocument,boolean,com.itextpdf.kernel.utils.ICopyFilter) -> M
    void flushCopiedObjects(long) -> N
    void flushModifiedWaitingObjects(java.util.Set) -> O
    void flushObject(com.itextpdf.kernel.pdf.PdfObject,boolean) -> P
    void flushWaitingObjects(java.util.Set) -> Q
    int getCompressionLevel() -> R
    com.itextpdf.kernel.pdf.PdfObjectStream getObjectStream() -> S
    void initCryptoIfSpecified(com.itextpdf.kernel.pdf.PdfVersion) -> T
    boolean isFullCompression() -> U
    void markArrayContentToFlush(com.itextpdf.kernel.pdf.PdfArray) -> V
    void markDictionaryContentToFlush(com.itextpdf.kernel.pdf.PdfDictionary) -> W
    void markObjectToFlush(com.itextpdf.kernel.pdf.PdfObject) -> X
    com.itextpdf.kernel.pdf.PdfWriter setCompressionLevel(int) -> Y
    com.itextpdf.kernel.pdf.PdfWriter setSmartMode(boolean) -> Z
    void writeHeader() -> a0
    void writeToBody(com.itextpdf.kernel.pdf.PdfObject) -> b0
com.itextpdf.kernel.pdf.PdfXrefTable -> b1.f1:
    java.util.TreeMap freeReferencesLinkedList -> e
    com.itextpdf.kernel.pdf.PdfIndirectReference[] xref -> a
    com.itextpdf.kernel.pdf.MemoryLimitsAwareHandler memoryLimitsAwareHandler -> d
    byte[] inUseXRefEntry -> g
    int count -> b
    boolean readingCompleted -> c
    byte[] freeXRefEntry -> f
    com.itextpdf.kernel.pdf.PdfIndirectReference add(com.itextpdf.kernel.pdf.PdfIndirectReference) -> a
    void appendNewRefToFreeList(com.itextpdf.kernel.pdf.PdfIndirectReference) -> b
    void clear() -> c
    com.itextpdf.kernel.pdf.PdfIndirectReference createNewIndirectReference(com.itextpdf.kernel.pdf.PdfDocument) -> d
    com.itextpdf.kernel.pdf.PdfIndirectReference createNextIndirectReference(com.itextpdf.kernel.pdf.PdfDocument) -> e
    java.util.List createSections(com.itextpdf.kernel.pdf.PdfDocument,boolean) -> f
    void ensureCount(int) -> g
    void extendXref(int) -> h
    void freeReference(com.itextpdf.kernel.pdf.PdfIndirectReference) -> i
    com.itextpdf.kernel.pdf.PdfIndirectReference get(int) -> j
    int getOffsetSize(long) -> k
    void initFreeReferencesList(com.itextpdf.kernel.pdf.PdfDocument) -> l
    boolean isReadingCompleted() -> m
    void markReadingCompleted() -> n
    com.itextpdf.kernel.pdf.PdfIndirectReference removeFreeRefFromList(int) -> o
    void setCapacity(int) -> p
    void setMemoryLimitsAwareHandler(com.itextpdf.kernel.pdf.MemoryLimitsAwareHandler) -> q
    int size() -> r
    void writeKeyInfo(com.itextpdf.kernel.pdf.PdfDocument) -> s
    void writeXrefTableAndTrailer(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfObject) -> t
com.itextpdf.kernel.pdf.ReaderProperties -> b1.g1:
    java.security.cert.Certificate certificate -> c
    byte[] password -> a
    java.security.Key certificateKey -> b
    com.itextpdf.kernel.security.IExternalDecryptionProcess externalDecryptionProcess -> e
    com.itextpdf.kernel.pdf.MemoryLimitsAwareHandler memoryLimitsAwareHandler -> f
    java.lang.String certificateKeyProvider -> d
    void clearEncryptionParams() -> a
    com.itextpdf.kernel.pdf.ReaderProperties setPassword(byte[]) -> b
com.itextpdf.kernel.pdf.SerializedObjectContent -> b1.h1:
    byte[] serializedContent -> a
    int hash -> b
    int calculateHash(byte[]) -> a
com.itextpdf.kernel.pdf.SmartModePdfObjectsSerializer -> b1.i1:
    java.security.MessageDigest md5 -> a
    java.util.HashMap serializedContentToObj -> b
    com.itextpdf.kernel.pdf.PdfIndirectReference getSavedSerializedObject(com.itextpdf.kernel.pdf.SerializedObjectContent) -> a
    boolean isKeyRefersBack(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfName) -> b
    void saveSerializedObject(com.itextpdf.kernel.pdf.SerializedObjectContent,com.itextpdf.kernel.pdf.PdfIndirectReference) -> c
    void serArray(com.itextpdf.kernel.pdf.PdfArray,com.itextpdf.io.source.ByteBuffer,int,java.util.Map) -> d
    void serDic(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.io.source.ByteBuffer,int,java.util.Map) -> e
    void serObject(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.io.source.ByteBuffer,int,java.util.Map) -> f
    com.itextpdf.kernel.pdf.SerializedObjectContent serializeObject(com.itextpdf.kernel.pdf.PdfObject) -> g
com.itextpdf.kernel.pdf.SmartModePdfObjectsSerializer$1 -> b1.i1$a:
com.itextpdf.kernel.pdf.SmartModePdfObjectsSerializer$SelfReferenceException -> b1.i1$b:
com.itextpdf.kernel.pdf.StampingProperties -> b1.j1:
    boolean appendMode -> b
    boolean preserveEncryption -> c
com.itextpdf.kernel.pdf.VersionConforming -> b1.k1:
    org.slf4j.Logger logger -> a
    boolean validatePdfVersionForDeprecatedFeatureLogWarn(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.PdfVersion,java.lang.String) -> a
    boolean validatePdfVersionForDictEntry(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.pdf.PdfVersion,com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfName) -> b
com.itextpdf.kernel.pdf.WriterProperties -> b1.l1:
    com.itextpdf.kernel.pdf.PdfVersion pdfVersion -> f
    com.itextpdf.kernel.pdf.EncryptionProperties encryptionProperties -> g
    boolean addUAXmpMetadata -> e
    com.itextpdf.kernel.pdf.PdfString initialDocumentId -> h
    com.itextpdf.kernel.pdf.PdfString modifiedDocumentId -> i
    boolean smartMode -> c
    int compressionLevel -> a
    java.lang.Boolean isFullCompression -> b
    boolean addXmpMetadata -> d
    boolean isPublicKeyEncryptionUsed() -> a
    boolean isStandardEncryptionUsed() -> b
    com.itextpdf.kernel.pdf.WriterProperties setCompressionLevel(int) -> c
    com.itextpdf.kernel.pdf.WriterProperties setStandardEncryption(byte[],byte[],int,int) -> d
com.itextpdf.kernel.pdf.XmpMetaInfoConverter -> b1.m1:
    void appendArrayItemIfDoesNotExist(com.itextpdf.kernel.xmp.XMPMeta,java.lang.String,java.lang.String,java.lang.String,int) -> a
    void appendDocumentInfoToMetadata(com.itextpdf.kernel.pdf.PdfDocumentInfo,com.itextpdf.kernel.xmp.XMPMeta) -> b
    void appendMetadataToInfo(byte[],com.itextpdf.kernel.pdf.PdfDocumentInfo) -> c
    java.lang.String fetchArrayIntoString(com.itextpdf.kernel.xmp.XMPMeta,java.lang.String,java.lang.String) -> d
com.itextpdf.kernel.pdf.action.PdfAction -> c1.a:
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.action.PdfAction put(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> r
com.itextpdf.kernel.pdf.annot.Pdf3DAnnotation -> d1.a:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfAnnotation -> d1.b:
    com.itextpdf.kernel.pdf.PdfName HIGHLIGHT_TOGGLE -> g
    com.itextpdf.kernel.pdf.PdfString Completed -> r
    com.itextpdf.kernel.pdf.PdfName HIGHLIGHT_PUSH -> f
    com.itextpdf.kernel.pdf.PdfString None -> s
    com.itextpdf.kernel.pdf.PdfName STYLE_DASHED -> i
    com.itextpdf.kernel.pdf.PdfString Rejected -> p
    com.itextpdf.kernel.pdf.PdfName STYLE_SOLID -> h
    com.itextpdf.kernel.pdf.PdfString Canceled -> q
    com.itextpdf.kernel.pdf.PdfName STYLE_INSET -> k
    com.itextpdf.kernel.pdf.PdfString Unmarked -> n
    com.itextpdf.kernel.pdf.PdfName STYLE_BEVELED -> j
    com.itextpdf.kernel.pdf.PdfString Accepted -> o
    com.itextpdf.kernel.pdf.PdfName STYLE_UNDERLINE -> l
    com.itextpdf.kernel.pdf.PdfString Marked -> m
    com.itextpdf.kernel.pdf.PdfString MarkedModel -> t
    com.itextpdf.kernel.pdf.PdfString ReviewModel -> u
    com.itextpdf.kernel.pdf.PdfPage page -> b
    com.itextpdf.kernel.pdf.PdfName HIGHLIGHT_NONE -> c
    com.itextpdf.kernel.pdf.PdfName HIGHLIGHT_OUTLINE -> e
    com.itextpdf.kernel.pdf.PdfName HIGHLIGHT_INVERT -> d
    com.itextpdf.kernel.pdf.annot.PdfAnnotation setFlags(int) -> A
    com.itextpdf.kernel.pdf.annot.PdfAnnotation setPage(com.itextpdf.kernel.pdf.PdfPage) -> B
    com.itextpdf.kernel.pdf.annot.PdfAnnotation setRectangle(com.itextpdf.kernel.pdf.PdfArray) -> C
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.PdfDictionary getAppearanceDictionary() -> r
    com.itextpdf.kernel.pdf.PdfDictionary getAppearanceObject(com.itextpdf.kernel.pdf.PdfName) -> s
    com.itextpdf.kernel.pdf.PdfDictionary getDownAppearanceObject() -> t
    com.itextpdf.kernel.pdf.PdfDictionary getNormalAppearanceObject() -> u
    com.itextpdf.kernel.pdf.PdfDictionary getRolloverAppearanceObject() -> v
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
    com.itextpdf.kernel.pdf.annot.PdfAnnotation makeAnnotation(com.itextpdf.kernel.pdf.PdfObject) -> x
    com.itextpdf.kernel.pdf.annot.PdfAnnotation put(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> y
    com.itextpdf.kernel.pdf.annot.PdfAnnotation setBorder(com.itextpdf.kernel.pdf.PdfArray) -> z
com.itextpdf.kernel.pdf.annot.PdfAnnotation$PdfUnknownAnnotation -> d1.b$a:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfCaretAnnotation -> d1.c:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfCircleAnnotation -> d1.d:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfFileAttachmentAnnotation -> d1.e:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfFreeTextAnnotation -> d1.f:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfInkAnnotation -> d1.g:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfLineAnnotation -> d1.h:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfLinkAnnotation -> d1.i:
    com.itextpdf.kernel.pdf.PdfName None -> w
    com.itextpdf.kernel.pdf.PdfName Outline -> y
    com.itextpdf.kernel.pdf.PdfName Invert -> x
    com.itextpdf.kernel.pdf.PdfName Push -> z
    org.slf4j.Logger logger -> v
    com.itextpdf.kernel.pdf.PdfObject getDestinationObject() -> D
    com.itextpdf.kernel.pdf.annot.PdfLinkAnnotation removeDestination() -> E
    com.itextpdf.kernel.pdf.annot.PdfLinkAnnotation setAction(com.itextpdf.kernel.pdf.action.PdfAction) -> F
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfMarkupAnnotation -> d1.j:
    com.itextpdf.kernel.pdf.annot.PdfPopupAnnotation popup -> w
    com.itextpdf.kernel.pdf.annot.PdfAnnotation inReplyTo -> v
com.itextpdf.kernel.pdf.annot.PdfPolyGeomAnnotation -> d1.k:
com.itextpdf.kernel.pdf.annot.PdfPolygonAnnotation -> d1.l:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfPolylineAnnotation -> d1.m:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfPopupAnnotation -> d1.n:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfPrinterMarkAnnotation -> d1.o:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfRedactAnnotation -> d1.p:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfScreenAnnotation -> d1.q:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfSoundAnnotation -> d1.r:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfSquareAnnotation -> d1.s:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfStampAnnotation -> d1.t:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfTextAnnotation -> d1.u:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfTextMarkupAnnotation -> d1.v:
    com.itextpdf.kernel.pdf.PdfName MarkupUnderline -> y
    com.itextpdf.kernel.pdf.PdfName MarkupHighlight -> x
    com.itextpdf.kernel.pdf.PdfName MarkupStrikeout -> z
    com.itextpdf.kernel.pdf.PdfName MarkupSquiggly -> A
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfTrapNetworkAnnotation -> d1.w:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfWatermarkAnnotation -> d1.x:
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.annot.PdfWidgetAnnotation -> d1.y:
    void releaseFormFieldFromWidgetAnnotation() -> D
    com.itextpdf.kernel.pdf.PdfName getSubtype() -> w
com.itextpdf.kernel.pdf.canvas.CanvasArtifact -> e1.a:
com.itextpdf.kernel.pdf.canvas.CanvasGraphicsState -> e1.b:
    int lineCapStyle -> n
    float textRise -> k
    com.itextpdf.kernel.pdf.PdfObject softMask -> u
    float fontSize -> i
    int textRenderingMode -> j
    float leading -> g
    float wordSpacing -> e
    com.itextpdf.kernel.font.PdfFont font -> h
    com.itextpdf.kernel.pdf.PdfName renderingIntent -> r
    boolean automaticStrokeAdjustment -> s
    int overprintMode -> A
    com.itextpdf.kernel.geom.Matrix ctm -> a
    com.itextpdf.kernel.pdf.PdfObject underColorRemovalFunction2 -> E
    com.itextpdf.kernel.pdf.PdfObject blackGenerationFunction2 -> C
    com.itextpdf.kernel.colors.Color fillColor -> c
    boolean strokeOverprint -> y
    float fillAlpha -> w
    com.itextpdf.kernel.pdf.PdfObject transferFunction2 -> G
    com.itextpdf.kernel.pdf.PdfArray dashPattern -> q
    float lineWidth -> m
    com.itextpdf.kernel.pdf.PdfObject blendMode -> t
    int lineJoinStyle -> o
    float flatnessTolerance -> I
    float scale -> f
    boolean textKnockout -> l
    float charSpacing -> d
    boolean alphaIsShape -> x
    com.itextpdf.kernel.pdf.PdfObject htp -> K
    com.itextpdf.kernel.pdf.PdfObject underColorRemovalFunction -> D
    com.itextpdf.kernel.pdf.PdfObject blackGenerationFunction -> B
    com.itextpdf.kernel.pdf.PdfObject halftone -> H
    com.itextpdf.kernel.colors.Color strokeColor -> b
    boolean fillOverprint -> z
    float strokeAlpha -> v
    com.itextpdf.kernel.pdf.PdfObject transferFunction -> F
    java.lang.Float smoothnessTolerance -> J
    float miterLimit -> p
    void copyFrom(com.itextpdf.kernel.pdf.canvas.CanvasGraphicsState) -> a
    float getCharSpacing() -> b
    com.itextpdf.kernel.geom.Matrix getCtm() -> c
    com.itextpdf.kernel.colors.Color getFillColor() -> d
    com.itextpdf.kernel.font.PdfFont getFont() -> e
    float getFontSize() -> f
    float getHorizontalScaling() -> g
    int getLineCapStyle() -> h
    float getLineWidth() -> i
    com.itextpdf.kernel.colors.Color getStrokeColor() -> j
    int getTextRenderingMode() -> k
    float getWordSpacing() -> l
    void setCharSpacing(float) -> m
    void setFillColor(com.itextpdf.kernel.colors.Color) -> n
    void setFont(com.itextpdf.kernel.font.PdfFont) -> o
    void setFontSize(float) -> p
    void setHorizontalScaling(float) -> q
    void setLineCapStyle(int) -> r
    void setLineWidth(float) -> s
    void setStrokeColor(com.itextpdf.kernel.colors.Color) -> t
    void setTextRenderingMode(int) -> u
    void setTextRise(float) -> v
    void setWordSpacing(float) -> w
    void updateCtm(float,float,float,float,float,float) -> x
    void updateCtm(com.itextpdf.kernel.geom.Matrix) -> y
    void updateFromExtGState(com.itextpdf.kernel.pdf.extgstate.PdfExtGState,com.itextpdf.kernel.pdf.PdfDocument) -> z
com.itextpdf.kernel.pdf.canvas.CanvasTag -> e1.c:
    com.itextpdf.kernel.pdf.PdfName role -> a
    com.itextpdf.kernel.pdf.PdfDictionary properties -> b
    com.itextpdf.kernel.pdf.canvas.CanvasTag addProperty(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> a
    void ensurePropertiesInit() -> b
    com.itextpdf.kernel.pdf.PdfDictionary getProperties() -> c
    com.itextpdf.kernel.pdf.PdfName getRole() -> d
    com.itextpdf.kernel.pdf.canvas.CanvasTag setProperties(com.itextpdf.kernel.pdf.PdfDictionary) -> e
com.itextpdf.kernel.pdf.canvas.PdfCanvas -> e1.d:
    byte[] Q -> P
    byte[] cm -> q
    byte[] m -> L
    byte[] TJ -> d0
    byte[] BStar -> m
    byte[] TD -> b0
    byte[] SCN -> X
    byte[] f -> y
    byte[] ri -> T
    byte[] Do -> u
    com.itextpdf.kernel.pdf.colorspace.PdfSpecialCs$Pattern pattern -> u0
    byte[] B -> h
    byte[] j -> G
    byte[] gs -> C
    java.util.Stack gsStack -> b
    byte[] cs -> r
    byte[] re -> Q
    byte[] bStar -> n
    com.itextpdf.kernel.pdf.colorspace.PdfDeviceCs$Rgb rgb -> s0
    byte[] fStar -> z
    byte[] sh -> Y
    byte[] EI -> v
    com.itextpdf.kernel.pdf.PdfStream contentStream -> d
    byte[] S -> U
    byte[] WStar -> p0
    byte[] W -> n0
    byte[] J -> H
    byte[] Tr -> h0
    com.itextpdf.kernel.pdf.PdfDocument document -> f
    byte[] b -> i
    byte[] TL -> f0
    boolean defaultDeviceGrayBlackColorCheckRequired -> a
    byte[] h -> D
    byte[] Tz -> l0
    byte[] TStar -> j0
    byte[] Td -> a0
    byte[] BT -> o
    byte[] rg -> R
    byte[] Tj -> e0
    byte[] BI -> k
    byte[] n -> N
    byte[] Tf -> c0
    byte[] EMC -> w
    com.itextpdf.kernel.pdf.colorspace.PdfDeviceCs$Cmyk cmyk -> t0
    byte[] Tc -> Z
    byte[] CS -> s
    byte[] s -> V
    com.itextpdf.kernel.pdf.PdfResources resources -> e
    byte[] G -> A
    byte[] BDC -> j
    byte[] K -> I
    byte[] i -> E
    byte[] c -> p
    byte[] q -> O
    byte[] BMC -> l
    byte[] l -> K
    com.itextpdf.kernel.pdf.canvas.CanvasGraphicsState currentGs -> c
    byte[] ET -> x
    int mcDepth -> g
    byte[] scn -> W
    byte[] d -> t
    byte[] RG -> S
    byte[] y -> q0
    byte[] g -> B
    byte[] w -> o0
    byte[] Ts -> i0
    byte[] k -> J
    byte[] Tm -> g0
    byte[] v -> m0
    com.itextpdf.kernel.pdf.colorspace.PdfDeviceCs$Gray gray -> r0
    byte[] ID -> F
    byte[] Tw -> k0
    com.itextpdf.kernel.pdf.canvas.CanvasGraphicsState getGraphicsState() -> A
    com.itextpdf.kernel.pdf.PdfStream getPageStream(com.itextpdf.kernel.pdf.PdfPage) -> B
    float getSubrangeWidth(com.itextpdf.io.font.otf.GlyphLine,int,int) -> C
    float getSubrangeYDelta(com.itextpdf.io.font.otf.GlyphLine,int,int) -> D
    float getWordSpacingAddition(com.itextpdf.io.font.otf.Glyph) -> E
    boolean isIdentityMatrix(float,float,float,float,float,float) -> F
    java.util.List iteratorToList(java.util.Iterator) -> G
    com.itextpdf.kernel.pdf.canvas.PdfCanvas lineTo(double,double) -> H
    com.itextpdf.kernel.pdf.canvas.PdfCanvas moveText(double,double) -> I
    com.itextpdf.kernel.pdf.canvas.PdfCanvas moveTo(double,double) -> J
    com.itextpdf.kernel.pdf.canvas.PdfCanvas openTag(com.itextpdf.kernel.pdf.canvas.CanvasTag) -> K
    com.itextpdf.kernel.pdf.canvas.PdfCanvas openTag(com.itextpdf.kernel.pdf.tagutils.TagReference) -> L
    com.itextpdf.kernel.pdf.canvas.PdfCanvas rectangle(double,double,double,double) -> M
    com.itextpdf.kernel.pdf.canvas.PdfCanvas rectangle(com.itextpdf.kernel.geom.Rectangle) -> N
    com.itextpdf.kernel.pdf.canvas.PdfCanvas restoreState() -> O
    com.itextpdf.kernel.pdf.canvas.PdfCanvas saveState() -> P
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setCharacterSpacing(float) -> Q
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setColor(com.itextpdf.kernel.pdf.colorspace.PdfColorSpace,float[],com.itextpdf.kernel.pdf.colorspace.PdfPattern,boolean) -> R
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setColor(com.itextpdf.kernel.pdf.colorspace.PdfColorSpace,float[],boolean) -> S
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setColor(com.itextpdf.kernel.colors.Color,boolean) -> T
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setExtGState(com.itextpdf.kernel.pdf.extgstate.PdfExtGState) -> U
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setFillColor(com.itextpdf.kernel.colors.Color) -> V
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setFontAndSize(com.itextpdf.kernel.font.PdfFont,float) -> W
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setHorizontalScaling(float) -> X
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setLineCapStyle(int) -> Y
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setLineWidth(float) -> Z
    com.itextpdf.kernel.pdf.canvas.PdfCanvas addFormWithTransformationMatrix(com.itextpdf.kernel.pdf.xobject.PdfFormXObject,float,float,float,float,float,float,boolean) -> a
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setStrokeColor(com.itextpdf.kernel.colors.Color) -> a0
    com.itextpdf.kernel.pdf.canvas.PdfCanvas addImageWithTransformationMatrix(com.itextpdf.kernel.pdf.xobject.PdfXObject,float,float,float,float,float,float) -> b
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setTextMatrix(float,float,float,float,float,float) -> b0
    com.itextpdf.kernel.pdf.canvas.PdfCanvas addXObjectWithTransformationMatrix(com.itextpdf.kernel.pdf.xobject.PdfXObject,float,float,float,float,float,float) -> c
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setTextRenderingMode(int) -> c0
    void applyRotation(com.itextpdf.kernel.pdf.PdfPage) -> d
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setTextRise(float) -> d0
    com.itextpdf.kernel.pdf.canvas.PdfCanvas arc(double,double,double,double,double,double) -> e
    com.itextpdf.kernel.pdf.canvas.PdfCanvas setWordSpacing(float) -> e0
    com.itextpdf.kernel.pdf.canvas.PdfCanvas arcContinuous(double,double,double,double,double,double) -> f
    com.itextpdf.kernel.pdf.canvas.PdfCanvas showText(com.itextpdf.io.font.otf.GlyphLine) -> f0
    com.itextpdf.kernel.pdf.canvas.PdfCanvas beginMarkedContent(com.itextpdf.kernel.pdf.PdfName) -> g
    com.itextpdf.kernel.pdf.canvas.PdfCanvas showText(com.itextpdf.io.font.otf.GlyphLine,java.util.Iterator) -> g0
    com.itextpdf.kernel.pdf.canvas.PdfCanvas beginMarkedContent(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfDictionary) -> h
    com.itextpdf.kernel.pdf.canvas.PdfCanvas stroke() -> h0
    com.itextpdf.kernel.pdf.canvas.PdfCanvas beginText() -> i
    java.util.List bezierArc(double,double,double,double,double,double) -> j
    void checkDefaultDeviceGrayBlackColor(com.itextpdf.kernel.pdf.canvas.PdfCanvas$CheckColorMode) -> k
    com.itextpdf.kernel.pdf.canvas.PdfCanvas clip() -> l
    com.itextpdf.kernel.pdf.canvas.PdfCanvas closeTag() -> m
    com.itextpdf.kernel.pdf.canvas.PdfCanvas concatMatrix(double,double,double,double,double,double) -> n
    com.itextpdf.kernel.pdf.canvas.PdfCanvas concatMatrix(com.itextpdf.kernel.geom.AffineTransform) -> o
    com.itextpdf.kernel.colors.Color createColor(com.itextpdf.kernel.pdf.colorspace.PdfColorSpace,float[],com.itextpdf.kernel.pdf.colorspace.PdfPattern) -> p
    com.itextpdf.kernel.pdf.canvas.PdfCanvas curveTo(double,double,double,double,double,double) -> q
    com.itextpdf.kernel.pdf.canvas.PdfCanvas drawArc(double,double,double,double,double,double,boolean) -> r
    com.itextpdf.kernel.pdf.canvas.PdfCanvas endMarkedContent() -> s
    com.itextpdf.kernel.pdf.canvas.PdfCanvas endPath() -> t
    com.itextpdf.kernel.pdf.canvas.PdfCanvas endText() -> u
    com.itextpdf.kernel.pdf.PdfStream ensureStreamDataIsReadyToBeProcessed(com.itextpdf.kernel.pdf.PdfStream) -> v
    com.itextpdf.kernel.pdf.canvas.PdfCanvas fill() -> w
    com.itextpdf.kernel.pdf.canvas.PdfCanvas$CheckColorMode getColorKeyForText() -> x
    com.itextpdf.kernel.pdf.PdfStream getContentStream() -> y
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> z
com.itextpdf.kernel.pdf.canvas.PdfCanvas$CheckColorMode -> e1.d$a:
    com.itextpdf.kernel.pdf.canvas.PdfCanvas$CheckColorMode STROKE -> S2
    com.itextpdf.kernel.pdf.canvas.PdfCanvas$CheckColorMode FILL -> R2
    com.itextpdf.kernel.pdf.canvas.PdfCanvas$CheckColorMode NONE -> Q2
    com.itextpdf.kernel.pdf.canvas.PdfCanvas$CheckColorMode[] $VALUES -> U2
    com.itextpdf.kernel.pdf.canvas.PdfCanvas$CheckColorMode FILL_AND_STROKE -> T2
com.itextpdf.kernel.pdf.colorspace.PdfCieBasedCs -> f1.a:
    boolean isWrappedObjectMustBeIndirect() -> k
com.itextpdf.kernel.pdf.colorspace.PdfCieBasedCs$CalGray -> f1.a$a:
    int getNumberOfComponents() -> r
com.itextpdf.kernel.pdf.colorspace.PdfCieBasedCs$CalRgb -> f1.a$b:
    int getNumberOfComponents() -> r
com.itextpdf.kernel.pdf.colorspace.PdfCieBasedCs$IccBased -> f1.a$c:
    int getNumberOfComponents() -> r
    com.itextpdf.kernel.pdf.PdfStream getIccProfileStream(com.itextpdf.io.colors.IccProfile) -> t
com.itextpdf.kernel.pdf.colorspace.PdfCieBasedCs$Lab -> f1.a$d:
    int getNumberOfComponents() -> r
com.itextpdf.kernel.pdf.colorspace.PdfColorSpace -> f1.b:
    java.util.Set DIRECT_COLOR_SPACES -> b
    int getNumberOfComponents() -> r
    com.itextpdf.kernel.pdf.colorspace.PdfColorSpace makeColorSpace(com.itextpdf.kernel.pdf.PdfObject) -> s
com.itextpdf.kernel.pdf.colorspace.PdfDeviceCs -> f1.c:
    boolean isWrappedObjectMustBeIndirect() -> k
com.itextpdf.kernel.pdf.colorspace.PdfDeviceCs$Cmyk -> f1.c$a:
    int getNumberOfComponents() -> r
com.itextpdf.kernel.pdf.colorspace.PdfDeviceCs$Gray -> f1.c$b:
    int getNumberOfComponents() -> r
com.itextpdf.kernel.pdf.colorspace.PdfDeviceCs$Rgb -> f1.c$c:
    int getNumberOfComponents() -> r
com.itextpdf.kernel.pdf.colorspace.PdfPattern -> f1.d:
    boolean isWrappedObjectMustBeIndirect() -> k
com.itextpdf.kernel.pdf.colorspace.PdfPattern$Tiling -> f1.d$a:
com.itextpdf.kernel.pdf.colorspace.PdfSpecialCs -> f1.e:
    boolean isWrappedObjectMustBeIndirect() -> k
com.itextpdf.kernel.pdf.colorspace.PdfSpecialCs$DeviceN -> f1.e$a:
    int numOfComponents -> c
    int getNumberOfComponents() -> r
com.itextpdf.kernel.pdf.colorspace.PdfSpecialCs$Indexed -> f1.e$b:
    int getNumberOfComponents() -> r
    com.itextpdf.kernel.pdf.colorspace.PdfColorSpace getBaseCs() -> t
com.itextpdf.kernel.pdf.colorspace.PdfSpecialCs$NChannel -> f1.e$c:
com.itextpdf.kernel.pdf.colorspace.PdfSpecialCs$Pattern -> f1.e$d:
    boolean isWrappedObjectMustBeIndirect() -> k
    int getNumberOfComponents() -> r
com.itextpdf.kernel.pdf.colorspace.PdfSpecialCs$Separation -> f1.e$e:
    int getNumberOfComponents() -> r
    com.itextpdf.kernel.pdf.colorspace.PdfColorSpace getBaseCs() -> t
    com.itextpdf.kernel.pdf.function.IPdfFunction getTintTransformation() -> u
com.itextpdf.kernel.pdf.colorspace.PdfSpecialCs$UncoloredTilingPattern -> f1.e$f:
    boolean isWrappedObjectMustBeIndirect() -> k
    int getNumberOfComponents() -> r
    com.itextpdf.kernel.pdf.colorspace.PdfColorSpace getUnderlyingColorSpace() -> t
com.itextpdf.kernel.pdf.extgstate.PdfExtGState -> g1.a:
    com.itextpdf.kernel.pdf.PdfName BM_LIGHTEN -> g
    com.itextpdf.kernel.pdf.PdfName BM_DARKEN -> f
    com.itextpdf.kernel.pdf.PdfName BM_COLOR_BURN -> i
    com.itextpdf.kernel.pdf.PdfName BM_COLOR_DODGE -> h
    com.itextpdf.kernel.pdf.PdfName BM_SOFT_LIGHT -> k
    com.itextpdf.kernel.pdf.PdfName BM_HARD_LIGHT -> j
    com.itextpdf.kernel.pdf.PdfName BM_EXCLUSION -> m
    com.itextpdf.kernel.pdf.PdfName BM_DIFFERENCE -> l
    com.itextpdf.kernel.pdf.PdfName BM_SATURATION -> o
    com.itextpdf.kernel.pdf.PdfName BM_HUE -> n
    com.itextpdf.kernel.pdf.PdfName BM_LUMINOSITY -> q
    com.itextpdf.kernel.pdf.PdfName BM_COLOR -> p
    com.itextpdf.kernel.pdf.PdfName BM_MULTIPLY -> c
    com.itextpdf.kernel.pdf.PdfName BM_NORMAL -> b
    com.itextpdf.kernel.pdf.PdfName BM_OVERLAY -> e
    com.itextpdf.kernel.pdf.PdfName BM_SCREEN -> d
    com.itextpdf.kernel.pdf.PdfArray getFont() -> A
    com.itextpdf.kernel.pdf.PdfObject getHalftone() -> B
    java.lang.Integer getLineCapStyle() -> C
    java.lang.Integer getLineJoinStyle() -> D
    java.lang.Float getLineWidth() -> E
    java.lang.Float getMiterLimit() -> F
    java.lang.Integer getOverprintMode() -> G
    com.itextpdf.kernel.pdf.PdfName getRenderingIntent() -> H
    java.lang.Float getSmothnessTolerance() -> I
    com.itextpdf.kernel.pdf.PdfObject getSoftMask() -> J
    java.lang.Float getStrokeOpacity() -> K
    java.lang.Boolean getStrokeOverprintFlag() -> L
    java.lang.Boolean getTextKnockoutFlag() -> M
    com.itextpdf.kernel.pdf.PdfObject getTransferFunction() -> N
    com.itextpdf.kernel.pdf.PdfObject getTransferFunction2() -> O
    com.itextpdf.kernel.pdf.PdfObject getUndercolorRemovalFunction() -> P
    com.itextpdf.kernel.pdf.PdfObject getUndercolorRemovalFunction2() -> Q
    com.itextpdf.kernel.pdf.extgstate.PdfExtGState put(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> R
    com.itextpdf.kernel.pdf.extgstate.PdfExtGState setFillOpacity(float) -> S
    com.itextpdf.kernel.pdf.extgstate.PdfExtGState setStrokeOpacity(float) -> T
    boolean isWrappedObjectMustBeIndirect() -> k
    java.lang.Boolean getAlphaSourceFlag() -> r
    java.lang.Boolean getAutomaticStrokeAdjustmentFlag() -> s
    com.itextpdf.kernel.pdf.PdfObject getBlackGenerationFunction() -> t
    com.itextpdf.kernel.pdf.PdfObject getBlackGenerationFunction2() -> u
    com.itextpdf.kernel.pdf.PdfObject getBlendMode() -> v
    com.itextpdf.kernel.pdf.PdfArray getDashPattern() -> w
    java.lang.Float getFillOpacity() -> x
    java.lang.Boolean getFillOverprintFlag() -> y
    java.lang.Float getFlatnessTolerance() -> z
com.itextpdf.kernel.pdf.filters.ASCII85DecodeFilter -> h1.a:
    byte[] decode(byte[],com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> a
    byte[] ASCII85DecodeInternal(byte[],java.io.ByteArrayOutputStream) -> c
com.itextpdf.kernel.pdf.filters.ASCIIHexDecodeFilter -> h1.b:
    byte[] decode(byte[],com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> a
    byte[] ASCIIHexDecodeInternal(byte[],java.io.ByteArrayOutputStream) -> c
com.itextpdf.kernel.pdf.filters.CCITTFaxDecodeFilter -> h1.c:
    byte[] decode(byte[],com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> a
com.itextpdf.kernel.pdf.filters.DctDecodeFilter -> h1.d:
    org.slf4j.Logger LOGGER -> a
    byte[] decode(byte[],com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> a
com.itextpdf.kernel.pdf.filters.DoNothingFilter -> h1.e:
    com.itextpdf.kernel.pdf.PdfName lastFilterName -> a
    byte[] decode(byte[],com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> a
com.itextpdf.kernel.pdf.filters.FilterHandlers -> h1.f:
    java.util.Map defaults -> a
    java.util.Map getDefaultFilterHandlers() -> a
com.itextpdf.kernel.pdf.filters.FlateDecodeFilter -> h1.g:
    byte[] decode(byte[],com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> a
    byte[] decodePredictor(byte[],com.itextpdf.kernel.pdf.PdfObject) -> c
    byte[] flateDecode(byte[],boolean) -> d
    byte[] flateDecodeInternal(byte[],boolean,java.io.ByteArrayOutputStream) -> e
    int getNumberOrDefault(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfName,int) -> f
com.itextpdf.kernel.pdf.filters.IFilterHandler -> h1.h:
    byte[] decode(byte[],com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> a
com.itextpdf.kernel.pdf.filters.JpxDecodeFilter -> h1.i:
    org.slf4j.Logger LOGGER -> a
    byte[] decode(byte[],com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> a
com.itextpdf.kernel.pdf.filters.LZWDecodeFilter -> h1.j:
    byte[] decode(byte[],com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> a
    byte[] LZWDecodeInternal(byte[],java.io.ByteArrayOutputStream) -> c
com.itextpdf.kernel.pdf.filters.LZWDecoder -> h1.k:
    byte[] data -> b
    int nextData -> h
    java.io.OutputStream uncompData -> c
    int nextBits -> i
    int bytePointer -> f
    int bitPointer -> g
    byte[][] stringTable -> a
    int tableIndex -> d
    int bitsToGet -> e
    int[] andTable -> j
    void addStringToTable(byte[]) -> a
    void addStringToTable(byte[],byte) -> b
    byte[] composeString(byte[],byte) -> c
    void decode(byte[],java.io.OutputStream) -> d
    int getNextCode() -> e
    void initializeStringTable() -> f
    void writeString(byte[]) -> g
com.itextpdf.kernel.pdf.filters.RunLengthDecodeFilter -> h1.l:
    byte[] decode(byte[],com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary) -> a
com.itextpdf.kernel.pdf.function.AbstractPdfFunction -> i1.a:
    double[] domain -> c
    double[] range -> d
    int functionType -> b
    int getInputSize() -> b
    byte[] calculateFromByteArray(byte[],int,int,int,int) -> c
    int getOutputSize() -> d
    byte[] calculateFromByteArray(byte[],int,int,int,int,com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$IInputConversionFunction,com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$IOutputConversionFunction) -> r
    double[] clip(double[],double[]) -> s
    double[] clipInput(double[]) -> t
    double[] clipOutput(double[]) -> u
    double[] getDomain() -> v
    double[] getRange() -> w
    double[] normalize(double[],double[]) -> x
com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors -> i1.d:
    double[] $r8$lambda$Mu7sUg3s9xi22ECfy5SJd_JWGiA(int,double,byte[],int,int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    byte[] $r8$lambda$S94x-Vo5Pns3qXB1kOTFsdeuxzA(int,double,double[]) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$IInputConversionFunction getByteBasedInputConvertor(int,double) -> c
    com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$IOutputConversionFunction getByteBasedOutputConvertor(int,double) -> d
    com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$IInputConversionFunction getInputConvertor(int,double) -> e
    com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$IOutputConversionFunction getOutputConvertor(int,double) -> f
    double[] lambda$getByteBasedInputConvertor$0(int,double,byte[],int,int) -> g
    byte[] lambda$getByteBasedOutputConvertor$1(int,double,double[]) -> h
com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$IInputConversionFunction -> i1.d$a:
    double[] convert(byte[],int,int) -> a
com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$IOutputConversionFunction -> i1.d$b:
    byte[] convert(double[]) -> a
com.itextpdf.kernel.pdf.function.IPdfFunction -> i1.e:
    int getInputSize() -> b
    byte[] calculateFromByteArray(byte[],int,int,int,int) -> c
    int getOutputSize() -> d
    double[] calculate(double[]) -> e
com.itextpdf.kernel.pdf.function.IPdfFunctionFactory -> i1.f:
    com.itextpdf.kernel.pdf.function.IPdfFunction create(com.itextpdf.kernel.pdf.PdfObject) -> a
com.itextpdf.kernel.pdf.function.PdfFunctionFactory -> i1.g:
    com.itextpdf.kernel.pdf.function.IPdfFunction create(com.itextpdf.kernel.pdf.PdfObject) -> a
com.itextpdf.kernel.pdf.function.PdfType0Function -> i1.i:
    int[] encode -> g
    boolean isValidated -> n
    int outputDimension -> l
    com.itextpdf.kernel.pdf.function.utils.AbstractSampleExtractor sampleExtractor -> j
    byte[] samples -> k
    int[] size -> e
    int bitsPerSample -> i
    int order -> f
    java.lang.String errorMessage -> o
    double[][] derivatives -> p
    double[] decode -> h
    long decodeLimit -> m
    double calculateCubicSplineFormula(double,double,double,double,double) -> A
    double[] calculateCubicSplineFormula(double,int) -> B
    double calculateLinearInterpolationFormula(double,double,double) -> C
    void calculateSecondDerivatives() -> D
    double decode(long,int) -> E
    double encode(double,int,int) -> F
    int[] getDefaultEncoding() -> G
    int[] getFloor(double[],int[]) -> H
    double getFloorWeight(double,int,int) -> I
    double[] getFloorWeights(double[],int[]) -> J
    int[] getInputDimensionSteps() -> K
    int getSamplePosition(int[],int[]) -> L
    double getValue(int,int) -> M
    void initializeEncoding(com.itextpdf.kernel.pdf.PdfArray) -> N
    double[] interpolate(double[],int[]) -> O
    double[] interpolateByCubicSpline(double,int) -> P
    double interpolateOrder1(double[],int,int[],int,int) -> Q
    double interpolateOrder3(double[],int[],int,int[],int,int) -> R
    boolean isInvalid() -> S
    int lambda$isInvalid$0(int,int) -> T
    void setErrorMessage(java.lang.String) -> U
    double[] specialSweepMethod(double[]) -> V
    double[] calculate(double[]) -> e
    boolean isWrappedObjectMustBeIndirect() -> k
    int $r8$lambda$GRQ53dUpzOGWBmsG04kIYfqD0TU(int,int) -> y
      # {"id":"com.android.tools.r8.synthesized"}
    double calculateCubicInterpolationFormula(double,double,double,double,double) -> z
com.itextpdf.kernel.pdf.function.PdfType2Function -> i1.j:
    double[] c0 -> e
    double[] c1 -> f
    double n -> g
    int getOutputSize() -> d
    double[] calculate(double[]) -> e
    boolean isWrappedObjectMustBeIndirect() -> k
    double[] initializeCArray(com.itextpdf.kernel.pdf.PdfArray,com.itextpdf.kernel.pdf.PdfArray,com.itextpdf.kernel.pdf.PdfArray,double) -> y
com.itextpdf.kernel.pdf.function.PdfType3Function -> i1.l:
    com.itextpdf.kernel.pdf.function.IPdfFunctionFactory functionFactory -> e
    java.util.List functions -> f
    com.itextpdf.kernel.pdf.function.IPdfFunctionFactory DEFAULT_FUNCTION_FACTORY -> i
    double[] bounds -> g
    double[] encode -> h
    int calculateSubdomain(double) -> A
    double[] checkAndGetBounds(com.itextpdf.kernel.pdf.PdfArray) -> B
    double[] checkAndGetEncode(com.itextpdf.kernel.pdf.PdfArray) -> C
    java.util.List checkAndGetFunctions(com.itextpdf.kernel.pdf.PdfArray) -> D
    double[] getSubdomainBorders(int) -> E
    com.itextpdf.kernel.pdf.function.IPdfFunction lambda$static$0(com.itextpdf.kernel.pdf.PdfObject) -> F
    double mapValueFromActualRangeToExpected(double,double,double,double,double) -> G
    int getOutputSize() -> d
    double[] calculate(double[]) -> e
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.function.IPdfFunction $r8$lambda$bGuqcfMTAjPObVCNJ8oEli9wcY0(com.itextpdf.kernel.pdf.PdfObject) -> y
      # {"id":"com.android.tools.r8.synthesized"}
    boolean areThreeDoubleEqual(double,double,double) -> z
com.itextpdf.kernel.pdf.function.PdfType4Function -> i1.m:
    double[] calculate(double[]) -> e
    boolean isWrappedObjectMustBeIndirect() -> k
com.itextpdf.kernel.pdf.function.utils.AbstractSampleExtractor -> j1.a:
    com.itextpdf.kernel.pdf.function.utils.AbstractSampleExtractor createExtractor(int) -> a
    long extract(byte[],int) -> b
com.itextpdf.kernel.pdf.function.utils.AbstractSampleExtractor$1 -> j1.a$a:
com.itextpdf.kernel.pdf.function.utils.AbstractSampleExtractor$Sample12BitsExtractor -> j1.a$b:
    long extract(byte[],int) -> b
com.itextpdf.kernel.pdf.function.utils.AbstractSampleExtractor$SampleBitsExtractor -> j1.a$c:
    byte mask -> b
    int bitsPerSample -> a
    long extract(byte[],int) -> b
com.itextpdf.kernel.pdf.function.utils.AbstractSampleExtractor$SampleBytesExtractor -> j1.a$d:
    int bytesPerSample -> a
    long extract(byte[],int) -> b
com.itextpdf.kernel.pdf.layer.PdfLayer -> k1.a:
    boolean locked -> e
    com.itextpdf.kernel.pdf.layer.PdfLayer parent -> f
    java.util.List children -> g
    java.lang.String title -> b
    boolean on -> c
    boolean onPanel -> d
    boolean isWrappedObjectMustBeIndirect() -> k
    void addChild(com.itextpdf.kernel.pdf.layer.PdfLayer) -> r
    com.itextpdf.kernel.pdf.layer.PdfLayer createTitleSilent(java.lang.String,com.itextpdf.kernel.pdf.PdfDocument) -> s
    java.util.List getChildren() -> t
    com.itextpdf.kernel.pdf.PdfIndirectReference getIndirectReference() -> u
    com.itextpdf.kernel.pdf.layer.PdfLayer getParent() -> v
    java.lang.String getTitle() -> w
    boolean isLocked() -> x
    boolean isOn() -> y
    boolean isOnPanel() -> z
com.itextpdf.kernel.pdf.layer.PdfOCProperties -> k1.b:
    java.util.List layers -> b
    void flush() -> h
    boolean isWrappedObjectMustBeIndirect() -> k
    void addASEvent(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfName) -> r
    java.lang.String createUniqueName() -> s
    com.itextpdf.kernel.pdf.PdfObject fillDictionary() -> t
    com.itextpdf.kernel.pdf.PdfObject fillDictionary(boolean) -> u
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> v
    void getOCGOrder(com.itextpdf.kernel.pdf.PdfArray,com.itextpdf.kernel.pdf.layer.PdfLayer) -> w
    void readLayersFromDictionary() -> x
    void readOrderFromDictionary(com.itextpdf.kernel.pdf.layer.PdfLayer,com.itextpdf.kernel.pdf.PdfArray,java.util.Map) -> y
    void removeNotRegisteredOcgs() -> z
com.itextpdf.kernel.pdf.navigation.PdfDestination -> l1.a:
    com.itextpdf.kernel.pdf.PdfObject getDestinationPage(java.util.Map) -> r
    com.itextpdf.kernel.pdf.navigation.PdfDestination makeDestination(com.itextpdf.kernel.pdf.PdfObject) -> s
com.itextpdf.kernel.pdf.navigation.PdfExplicitDestination -> l1.b:
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.PdfObject getDestinationPage(java.util.Map) -> r
com.itextpdf.kernel.pdf.navigation.PdfExplicitRemoteGoToDestination -> l1.c:
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.PdfObject getDestinationPage(java.util.Map) -> r
com.itextpdf.kernel.pdf.navigation.PdfNamedDestination -> l1.d:
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.PdfObject getDestinationPage(java.util.Map) -> r
com.itextpdf.kernel.pdf.navigation.PdfStringDestination -> l1.e:
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.PdfObject getDestinationPage(java.util.Map) -> r
com.itextpdf.kernel.pdf.navigation.PdfStructureDestination -> l1.f:
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.PdfObject getDestinationPage(java.util.Map) -> r
com.itextpdf.kernel.pdf.statistics.NumberOfPagesStatisticsEvent -> m1.a:
    int numberOfPages -> d
com.itextpdf.kernel.pdf.statistics.SizeOfPdfStatisticsEvent -> m1.b:
    long amountOfBytes -> d
com.itextpdf.kernel.pdf.tagging.IStructureNode -> n1.a:
    java.util.List getKids() -> a
com.itextpdf.kernel.pdf.tagging.ParentTreeHandler -> n1.b:
    java.util.Map pageToPageMcrs -> c
    java.util.Map pageToStructParentsInd -> d
    com.itextpdf.kernel.pdf.tagging.PdfStructTreeRoot structTreeRoot -> a
    java.util.Map xObjectToStructParentsInd -> e
    com.itextpdf.kernel.pdf.PdfNumTree parentTree -> b
    com.itextpdf.kernel.pdf.PdfDictionary buildParentTree() -> a
    void createParentTreeEntryForPage(com.itextpdf.kernel.pdf.PdfPage) -> b
    int getNextMcidForPage(com.itextpdf.kernel.pdf.PdfPage) -> c
    int getOrCreatePageStructParentIndex(com.itextpdf.kernel.pdf.PdfPage) -> d
    com.itextpdf.kernel.pdf.tagging.ParentTreeHandler$PageMcrsContainer getPageMarkedContentReferences(com.itextpdf.kernel.pdf.PdfPage) -> e
    com.itextpdf.kernel.pdf.PdfObject getStm(com.itextpdf.kernel.pdf.tagging.PdfMcr) -> f
    void registerAllMcrs() -> g
    void registerMcr(com.itextpdf.kernel.pdf.tagging.PdfMcr) -> h
    void registerMcr(com.itextpdf.kernel.pdf.tagging.PdfMcr,boolean) -> i
    void savePageStructParentIndexIfNeeded(com.itextpdf.kernel.pdf.PdfPage) -> j
    void unregisterMcr(com.itextpdf.kernel.pdf.tagging.PdfMcr) -> k
    boolean updateStructParentTreeEntries(com.itextpdf.kernel.pdf.PdfPage,com.itextpdf.kernel.pdf.tagging.ParentTreeHandler$PageMcrsContainer) -> l
    boolean updateStructParentTreeForContentStreamEntries(java.util.Map,int) -> m
com.itextpdf.kernel.pdf.tagging.ParentTreeHandler$PageMcrsContainer -> n1.b$a:
    java.util.Map objRefs -> a
    java.util.NavigableMap pageContentStreams -> b
    java.util.Map pageResourceXObjects -> c
    java.util.Collection getAllMcrsAsCollection() -> a
    java.util.Map getObjRefs() -> b
    java.util.NavigableMap getPageContentStreamsMcrs() -> c
    java.util.Map getPageResourceXObjects() -> d
    void putObjectReferenceMcr(int,com.itextpdf.kernel.pdf.tagging.PdfMcr) -> e
    void putPageContentStreamMcr(int,com.itextpdf.kernel.pdf.tagging.PdfMcr) -> f
    void putXObjectMcr(com.itextpdf.kernel.pdf.PdfIndirectReference,com.itextpdf.kernel.pdf.tagging.PdfMcr) -> g
com.itextpdf.kernel.pdf.tagging.PdfMcr -> n1.c:
    com.itextpdf.kernel.pdf.tagging.PdfStructElem parent -> b
    java.util.List getKids() -> a
    boolean isWrappedObjectMustBeIndirect() -> k
    int getMcid() -> r
    com.itextpdf.kernel.pdf.PdfIndirectReference getPageIndirectReference() -> s
    com.itextpdf.kernel.pdf.PdfDictionary getPageObject() -> t
com.itextpdf.kernel.pdf.tagging.PdfMcrDictionary -> n1.d:
    int getMcid() -> r
    com.itextpdf.kernel.pdf.PdfDictionary getPageObject() -> t
com.itextpdf.kernel.pdf.tagging.PdfMcrNumber -> n1.e:
    int getMcid() -> r
    com.itextpdf.kernel.pdf.PdfDictionary getPageObject() -> t
com.itextpdf.kernel.pdf.tagging.PdfNamespace -> n1.f:
    boolean isWrappedObjectMustBeIndirect() -> k
    java.lang.String getNamespaceName() -> r
    com.itextpdf.kernel.pdf.PdfDictionary getNamespaceRoleMap() -> s
    com.itextpdf.kernel.pdf.PdfDictionary getNamespaceRoleMap(boolean) -> t
    com.itextpdf.kernel.pdf.tagging.PdfNamespace put(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> u
    com.itextpdf.kernel.pdf.tagging.PdfNamespace setNamespaceRoleMap(com.itextpdf.kernel.pdf.PdfDictionary) -> v
com.itextpdf.kernel.pdf.tagging.PdfObjRef -> n1.g:
    int getMcid() -> r
    com.itextpdf.kernel.pdf.PdfDictionary getPageObject() -> t
com.itextpdf.kernel.pdf.tagging.PdfStructElem -> n1.h:
    com.itextpdf.kernel.pdf.PdfObject getAttributes(boolean) -> A
    com.itextpdf.kernel.pdf.PdfDocument getDocEnsureIndirectForKids() -> B
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> C
    com.itextpdf.kernel.pdf.PdfString getE() -> D
    com.itextpdf.kernel.pdf.PdfObject getK() -> E
    com.itextpdf.kernel.pdf.PdfString getLang() -> F
    com.itextpdf.kernel.pdf.tagging.PdfNamespace getNamespace() -> G
    com.itextpdf.kernel.pdf.PdfString getPhoneme() -> H
    com.itextpdf.kernel.pdf.PdfName getPhoneticAlphabet() -> I
    java.util.List getRefsList() -> J
    com.itextpdf.kernel.pdf.PdfName getRole() -> K
    boolean isStructElem(com.itextpdf.kernel.pdf.PdfDictionary) -> L
    com.itextpdf.kernel.pdf.tagging.PdfStructElem put(com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> M
    int removeKid(com.itextpdf.kernel.pdf.tagging.IStructureNode) -> N
    com.itextpdf.kernel.pdf.tagging.IStructureNode removeKid(int,boolean) -> O
    int removeKidObject(com.itextpdf.kernel.pdf.PdfObject) -> P
    int removeObjectFromArray(com.itextpdf.kernel.pdf.PdfArray,com.itextpdf.kernel.pdf.PdfObject) -> Q
    void setActualText(com.itextpdf.kernel.pdf.PdfString) -> R
    void setAlt(com.itextpdf.kernel.pdf.PdfString) -> S
    void setAttributes(com.itextpdf.kernel.pdf.PdfObject) -> T
    void setE(com.itextpdf.kernel.pdf.PdfString) -> U
    void setLang(com.itextpdf.kernel.pdf.PdfString) -> V
    void setNamespace(com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> W
    void setPhoneme(com.itextpdf.kernel.pdf.PdfString) -> X
    void setPhoneticAlphabet(com.itextpdf.kernel.pdf.PdfName) -> Y
    void setRole(com.itextpdf.kernel.pdf.PdfName) -> Z
    java.util.List getKids() -> a
    void flush() -> h
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.tagging.PdfMcr addKid(int,com.itextpdf.kernel.pdf.tagging.PdfMcr) -> r
    com.itextpdf.kernel.pdf.tagging.PdfStructElem addKid(int,com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> s
    com.itextpdf.kernel.pdf.tagging.PdfStructElem addKid(com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> t
    void addKidObject(com.itextpdf.kernel.pdf.PdfDictionary,int,com.itextpdf.kernel.pdf.PdfObject) -> u
    void addKidObjectToStructElemList(com.itextpdf.kernel.pdf.PdfObject,java.util.List) -> v
    void addRef(com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> w
    com.itextpdf.kernel.pdf.tagging.IStructureNode convertPdfObjectToIPdfStructElem(com.itextpdf.kernel.pdf.PdfObject) -> x
    com.itextpdf.kernel.pdf.PdfString getActualText() -> y
    com.itextpdf.kernel.pdf.PdfString getAlt() -> z
com.itextpdf.kernel.pdf.tagging.PdfStructTreeRoot -> n1.i:
    com.itextpdf.kernel.pdf.tagging.ParentTreeHandler parentTreeHandler -> c
    java.util.Map staticRoleNames -> d
    com.itextpdf.kernel.pdf.PdfDocument document -> b
    com.itextpdf.kernel.pdf.PdfArray getKidsObject() -> A
    java.util.List getNamespaces() -> B
    com.itextpdf.kernel.pdf.PdfArray getNamespacesObject() -> C
    int getNextMcidForPage(com.itextpdf.kernel.pdf.PdfPage) -> D
    java.util.Collection getPageMarkedContentReferences(com.itextpdf.kernel.pdf.PdfPage) -> E
    com.itextpdf.kernel.pdf.tagging.ParentTreeHandler getParentTreeHandler() -> F
    int getParentTreeNextKey() -> G
    com.itextpdf.kernel.pdf.PdfDictionary getRoleMap() -> H
    void ifKidIsStructElementAddToList(com.itextpdf.kernel.pdf.PdfObject,java.util.List) -> I
    void savePageStructParentIndexIfNeeded(com.itextpdf.kernel.pdf.PdfPage) -> J
    java.util.List getKids() -> a
    void flush() -> h
    boolean isWrappedObjectMustBeIndirect() -> k
    com.itextpdf.kernel.pdf.tagging.PdfStructElem addKid(int,com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> r
    com.itextpdf.kernel.pdf.tagging.PdfStructElem addKid(com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> s
    void addKidObject(int,com.itextpdf.kernel.pdf.PdfDictionary) -> t
    com.itextpdf.kernel.pdf.PdfName convertRoleToPdfName(java.lang.String) -> u
    void copyTo(com.itextpdf.kernel.pdf.PdfDocument,int,java.util.Map) -> v
    void copyTo(com.itextpdf.kernel.pdf.PdfDocument,java.util.Map) -> w
    void createParentTreeEntryForPage(com.itextpdf.kernel.pdf.PdfPage) -> x
    void flushAllKids(com.itextpdf.kernel.pdf.tagging.IStructureNode) -> y
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> z
com.itextpdf.kernel.pdf.tagging.PdfStructureAttributes -> n1.j:
    boolean isWrappedObjectMustBeIndirect() -> k
com.itextpdf.kernel.pdf.tagging.StandardNamespaces -> n1.k:
    java.util.Set STD_STRUCT_NAMESPACE_1_7_TYPES -> a
    java.util.Set STD_STRUCT_NAMESPACE_2_0_TYPES -> b
    java.lang.String getDefault() -> a
    boolean isHnRole(java.lang.String) -> b
    boolean isKnownDomainSpecificNamespace(com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> c
    boolean roleBelongsToStandardNamespace(java.lang.String,java.lang.String) -> d
com.itextpdf.kernel.pdf.tagging.StructureTreeCopier -> n1.l:
    java.util.List ignoreKeysForClone -> b
    java.util.List ignoreKeysForCopy -> a
    com.itextpdf.kernel.pdf.PdfDictionary addAllParentsToSet(com.itextpdf.kernel.pdf.tagging.PdfMcr,java.util.Set) -> a
    void cloneParents(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.tagging.StructureTreeCopier$LastClonedAncestor,com.itextpdf.kernel.pdf.PdfDocument) -> b
    com.itextpdf.kernel.pdf.PdfDictionary copyNamespaceDict(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.tagging.StructureTreeCopier$StructElemCopyingParams) -> c
    com.itextpdf.kernel.pdf.PdfDictionary copyObject(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDictionary,boolean,com.itextpdf.kernel.pdf.tagging.StructureTreeCopier$StructElemCopyingParams) -> d
    com.itextpdf.kernel.pdf.PdfObject copyObjectKid(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDictionary,boolean,com.itextpdf.kernel.pdf.tagging.StructureTreeCopier$StructElemCopyingParams) -> e
    com.itextpdf.kernel.pdf.tagging.StructureTreeCopier$CopyStructureResult copyStructure(com.itextpdf.kernel.pdf.PdfDocument,java.util.Map,com.itextpdf.kernel.pdf.PdfDocument,boolean) -> f
    void copyTo(com.itextpdf.kernel.pdf.PdfDocument,int,java.util.Map,com.itextpdf.kernel.pdf.PdfDocument) -> g
    void copyTo(com.itextpdf.kernel.pdf.PdfDocument,int,java.util.Map,com.itextpdf.kernel.pdf.PdfDocument,boolean) -> h
    void copyTo(com.itextpdf.kernel.pdf.PdfDocument,java.util.Map,com.itextpdf.kernel.pdf.PdfDocument) -> i
    void copyTo(com.itextpdf.kernel.pdf.PdfDocument,java.util.Map,com.itextpdf.kernel.pdf.PdfDocument,boolean) -> j
    void copyTo(com.itextpdf.kernel.pdf.PdfDocument,java.util.Map,com.itextpdf.kernel.pdf.PdfDocument,boolean,int) -> k
    java.util.List retrieveParents(com.itextpdf.kernel.pdf.tagging.PdfMcr,boolean) -> l
    void separateKids(com.itextpdf.kernel.pdf.PdfDictionary,java.util.Set,com.itextpdf.kernel.pdf.tagging.StructureTreeCopier$LastClonedAncestor,com.itextpdf.kernel.pdf.PdfDocument) -> m
    int separateStructure(com.itextpdf.kernel.pdf.PdfDocument,int) -> n
    int separateStructure(com.itextpdf.kernel.pdf.PdfDocument,int,int,int) -> o
    boolean shouldTableElementBeCopied(com.itextpdf.kernel.pdf.PdfDictionary,com.itextpdf.kernel.pdf.PdfDictionary) -> p
com.itextpdf.kernel.pdf.tagging.StructureTreeCopier$CopyStructureResult -> n1.l$a:
    java.util.List topsList -> a
    java.util.Set copiedNamespaces -> b
    java.util.Set getCopiedNamespaces() -> a
    java.util.List getTopsList() -> b
com.itextpdf.kernel.pdf.tagging.StructureTreeCopier$LastClonedAncestor -> n1.l$b:
    com.itextpdf.kernel.pdf.PdfDictionary ancestor -> a
    com.itextpdf.kernel.pdf.PdfDictionary clone -> b
com.itextpdf.kernel.pdf.tagging.StructureTreeCopier$StructElemCopyingParams -> n1.l$c:
    java.util.Map page2page -> c
    com.itextpdf.kernel.pdf.PdfDocument toDocument -> b
    java.util.Set copiedNamespaces -> e
    java.util.Set objectsToCopy -> a
    boolean copyFromDestDocument -> d
    void addCopiedNamespace(com.itextpdf.kernel.pdf.PdfDictionary) -> a
    java.util.Set getCopiedNamespaces() -> b
    java.util.Set getObjectsToCopy() -> c
    java.util.Map getPage2page() -> d
    com.itextpdf.kernel.pdf.PdfDocument getToDocument() -> e
    boolean isCopyFromDestDocument() -> f
com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties -> o1.a:
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties addAttributes(int,com.itextpdf.kernel.pdf.tagging.PdfStructureAttributes) -> a
    java.lang.String getActualText() -> b
    java.lang.String getAlternateDescription() -> c
    java.util.List getAttributesList() -> d
    java.lang.String getExpansion() -> e
    java.lang.String getLanguage() -> f
    com.itextpdf.kernel.pdf.tagging.PdfNamespace getNamespace() -> g
    java.lang.String getPhoneme() -> h
    java.lang.String getPhoneticAlphabet() -> i
    java.util.List getRefsList() -> j
    java.lang.String getRole() -> k
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties setNamespace(com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> l
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties setRole(java.lang.String) -> m
com.itextpdf.kernel.pdf.tagutils.AccessibilityPropertiesToStructElem -> o1.b:
    void addNewAttributesToAttributesArray(int,java.util.List,com.itextpdf.kernel.pdf.PdfNumber,com.itextpdf.kernel.pdf.PdfArray) -> a
    void apply(com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties,com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> b
    com.itextpdf.kernel.pdf.PdfObject combineAttributesList(com.itextpdf.kernel.pdf.PdfObject,int,java.util.List,com.itextpdf.kernel.pdf.PdfNumber) -> c
com.itextpdf.kernel.pdf.tagutils.BackedAccessibilityProperties -> o1.c:
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer pointerToBackingElem -> a
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties addAttributes(int,com.itextpdf.kernel.pdf.tagging.PdfStructureAttributes) -> a
    java.lang.String getActualText() -> b
    java.lang.String getAlternateDescription() -> c
    java.util.List getAttributesList() -> d
    java.lang.String getExpansion() -> e
    java.lang.String getLanguage() -> f
    com.itextpdf.kernel.pdf.tagging.PdfNamespace getNamespace() -> g
    java.lang.String getPhoneme() -> h
    java.lang.String getPhoneticAlphabet() -> i
    java.util.List getRefsList() -> j
    java.lang.String getRole() -> k
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties setNamespace(com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> l
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties setRole(java.lang.String) -> m
    com.itextpdf.kernel.pdf.tagging.PdfStructElem getBackingElem() -> n
    java.lang.String toUnicodeString(com.itextpdf.kernel.pdf.PdfString) -> o
com.itextpdf.kernel.pdf.tagutils.DefaultAccessibilityProperties -> o1.d:
    java.lang.String phoneme -> g
    java.lang.String phoneticAlphabet -> h
    java.util.List attributesList -> f
    com.itextpdf.kernel.pdf.tagging.PdfNamespace namespace -> i
    java.util.List refs -> j
    java.lang.String role -> a
    java.lang.String actualText -> c
    java.lang.String language -> b
    java.lang.String expansion -> e
    java.lang.String alternateDescription -> d
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties addAttributes(int,com.itextpdf.kernel.pdf.tagging.PdfStructureAttributes) -> a
    java.lang.String getActualText() -> b
    java.lang.String getAlternateDescription() -> c
    java.util.List getAttributesList() -> d
    java.lang.String getExpansion() -> e
    java.lang.String getLanguage() -> f
    com.itextpdf.kernel.pdf.tagging.PdfNamespace getNamespace() -> g
    java.lang.String getPhoneme() -> h
    java.lang.String getPhoneticAlphabet() -> i
    java.util.List getRefsList() -> j
    java.lang.String getRole() -> k
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties setNamespace(com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> l
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties setRole(java.lang.String) -> m
com.itextpdf.kernel.pdf.tagutils.IRoleMappingResolver -> o1.e:
    boolean resolveNextMapping() -> a
    com.itextpdf.kernel.pdf.tagging.PdfNamespace getNamespace() -> b
    java.lang.String getRole() -> c
    boolean currentRoleIsStandard() -> d
    boolean currentRoleShallBeMappedToStandard() -> e
com.itextpdf.kernel.pdf.tagutils.RoleMappingResolver -> o1.f:
    com.itextpdf.kernel.pdf.PdfName currRole -> a
    com.itextpdf.kernel.pdf.PdfDictionary roleMap -> b
    boolean resolveNextMapping() -> a
    com.itextpdf.kernel.pdf.tagging.PdfNamespace getNamespace() -> b
    java.lang.String getRole() -> c
    boolean currentRoleIsStandard() -> d
    boolean currentRoleShallBeMappedToStandard() -> e
com.itextpdf.kernel.pdf.tagutils.RoleMappingResolverPdf2 -> o1.g:
    com.itextpdf.kernel.pdf.tagging.PdfNamespace defaultNamespace -> c
    com.itextpdf.kernel.pdf.PdfName currRole -> a
    com.itextpdf.kernel.pdf.tagging.PdfNamespace currNamespace -> b
    boolean resolveNextMapping() -> a
    com.itextpdf.kernel.pdf.tagging.PdfNamespace getNamespace() -> b
    java.lang.String getRole() -> c
    boolean currentRoleIsStandard() -> d
    boolean currentRoleShallBeMappedToStandard() -> e
com.itextpdf.kernel.pdf.tagutils.RootTagNormalizer -> o1.h:
    com.itextpdf.kernel.pdf.tagging.PdfStructElem rootTagElement -> b
    com.itextpdf.kernel.pdf.tagutils.TagStructureContext context -> a
    com.itextpdf.kernel.pdf.PdfDocument document -> c
    void addStructTreeRootKidsToTheRootTag(java.util.List) -> a
    void createNewRootTag() -> b
    void ensureExistingRootTagIsDocument() -> c
    void logCreatedRootTagHasMappingIssue(com.itextpdf.kernel.pdf.tagging.PdfNamespace,com.itextpdf.kernel.pdf.tagutils.IRoleMappingResolver) -> d
    com.itextpdf.kernel.pdf.tagging.PdfStructElem makeSingleStandardRootTag(java.util.List) -> e
    void removeOldRoot(com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> f
    void wrapAllKidsInTag(com.itextpdf.kernel.pdf.tagging.PdfStructElem,com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> g
com.itextpdf.kernel.pdf.tagutils.TagReference -> o1.i:
    com.itextpdf.kernel.pdf.tagging.PdfStructElem referencedTag -> c
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer tagPointer -> a
    int insertIndex -> b
    com.itextpdf.kernel.pdf.PdfDictionary properties -> e
    com.itextpdf.kernel.pdf.PdfName role -> d
    int createNextMcid() -> a
    com.itextpdf.kernel.pdf.PdfDictionary getProperties() -> b
    com.itextpdf.kernel.pdf.PdfName getRole() -> c
com.itextpdf.kernel.pdf.tagutils.TagStructureContext -> o1.j:
    java.util.Set namespaces -> g
    com.itextpdf.kernel.pdf.PdfDocument document -> a
    com.itextpdf.kernel.pdf.tagging.PdfStructElem rootTagElement -> b
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer autoTaggingPointer -> c
    java.util.Set ALLOWED_ROOT_TAG_ROLES -> j
    com.itextpdf.kernel.pdf.PdfVersion tagStructureTargetVersion -> d
    com.itextpdf.kernel.pdf.tagging.PdfNamespace documentDefaultNamespace -> i
    boolean forbidUnknownRoles -> e
    com.itextpdf.kernel.pdf.tagutils.WaitingTagsManager waitingTagsManager -> f
    java.util.Map nameToNamespace -> h
    void throwExceptionIfRoleIsInvalid(java.lang.String,com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> A
    void throwExceptionIfRoleIsInvalid(com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties,com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> B
    void actualizeNamespacesInStructTreeRoot() -> a
    boolean checkIfRoleShallBeMappedToStandardRole(java.lang.String,com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> b
    java.lang.String composeExceptionBasedOnNamespacePresence(java.lang.String,com.itextpdf.kernel.pdf.tagging.PdfNamespace,java.lang.String,java.lang.String) -> c
    java.lang.String composeInvalidRoleException(java.lang.String,com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> d
    java.lang.String composeTooMuchTransitiveMappingsException(java.lang.String,com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> e
    void ensureNamespaceRegistered(com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> f
    com.itextpdf.kernel.pdf.tagging.PdfNamespace fetchNamespace(java.lang.String) -> g
    com.itextpdf.kernel.pdf.tagutils.TagStructureContext flushPageTags(com.itextpdf.kernel.pdf.PdfPage) -> h
    void flushParentIfBelongsToPage(com.itextpdf.kernel.pdf.tagging.PdfStructElem,com.itextpdf.kernel.pdf.PdfPage) -> i
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer getAutoTaggingPointer() -> j
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> k
    com.itextpdf.kernel.pdf.tagging.PdfNamespace getDocumentDefaultNamespace() -> l
    com.itextpdf.kernel.pdf.tagging.PdfStructElem getPointerStructElem(com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> m
    com.itextpdf.kernel.pdf.tagutils.IRoleMappingResolver getRoleMappingResolver(java.lang.String,com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> n
    com.itextpdf.kernel.pdf.tagging.PdfStructElem getRootTag() -> o
    com.itextpdf.kernel.pdf.PdfVersion getTagStructureTargetVersion() -> p
    com.itextpdf.kernel.pdf.tagutils.WaitingTagsManager getWaitingTagsManager() -> q
    void initRegisteredNamespaces() -> r
    boolean isRoleAllowedToBeRoot(java.lang.String) -> s
    void normalizeDocumentRootTag() -> t
    void prepareToDocumentClosing() -> u
    void removePageTagFromParent(com.itextpdf.kernel.pdf.tagging.IStructureNode,com.itextpdf.kernel.pdf.tagging.IStructureNode) -> v
    com.itextpdf.kernel.pdf.tagutils.TagStructureContext removePageTags(com.itextpdf.kernel.pdf.PdfPage) -> w
    com.itextpdf.kernel.pdf.tagutils.IRoleMappingResolver resolveMappingToStandardOrDomainSpecificRole(java.lang.String,com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> x
    void setNamespaceForNewTagsBasedOnExistingRoot() -> y
    boolean targetTagStructureVersionIs2() -> z
com.itextpdf.kernel.pdf.tagutils.TagTreePointer -> o1.k:
    com.itextpdf.kernel.pdf.tagging.PdfStructElem currentStructElem -> b
    com.itextpdf.kernel.pdf.tagutils.TagStructureContext tagStructureContext -> a
    com.itextpdf.kernel.pdf.tagging.PdfNamespace currentNamespace -> e
    com.itextpdf.kernel.pdf.PdfPage currentPage -> c
    int nextNewKidIndex -> f
    com.itextpdf.kernel.pdf.PdfStream contentStream -> d
    com.itextpdf.kernel.pdf.tagging.PdfMcr prepareMcrForMovingToNewParent(com.itextpdf.kernel.pdf.tagging.PdfMcr,com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> A
    void processKidNamespace(com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> B
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer relocate(com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> C
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer relocateKid(int,com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> D
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer removeTag() -> E
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer setContentStreamForTagging(com.itextpdf.kernel.pdf.PdfStream) -> F
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer setCurrentStructElem(com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> G
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer setNamespaceForNewTags(com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> H
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer setNextNewKidIndex(int) -> I
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer setPageForTagging(com.itextpdf.kernel.pdf.PdfPage) -> J
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer setRole(java.lang.String) -> K
    void throwExceptionIfCurrentPageIsNotInited() -> L
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer addAnnotationTag(com.itextpdf.kernel.pdf.annot.PdfAnnotation) -> a
    com.itextpdf.kernel.pdf.tagging.PdfMcr addNewKid(com.itextpdf.kernel.pdf.tagging.PdfMcr) -> b
    com.itextpdf.kernel.pdf.tagging.PdfStructElem addNewKid(java.lang.String) -> c
    com.itextpdf.kernel.pdf.tagging.PdfStructElem addNewKid(com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> d
    com.itextpdf.kernel.pdf.tagging.PdfStructElem addNewKid(com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties) -> e
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer addTag(int,java.lang.String) -> f
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer addTag(int,com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties) -> g
    int createNextMcidForStructElem(com.itextpdf.kernel.pdf.tagging.PdfStructElem,int) -> h
    boolean ensureElementPageEqualsKidPage(com.itextpdf.kernel.pdf.tagging.PdfStructElem,com.itextpdf.kernel.pdf.PdfDictionary) -> i
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer flushParentsIfAllKidsFlushed() -> j
    com.itextpdf.kernel.pdf.tagutils.TagStructureContext getContext() -> k
    com.itextpdf.kernel.pdf.tagging.PdfStructElem getCurrentElemEnsureIndirect() -> l
    com.itextpdf.kernel.pdf.PdfPage getCurrentPage() -> m
    com.itextpdf.kernel.pdf.tagging.PdfStructElem getCurrentStructElem() -> n
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> o
    int getIndexInParentKidsList() -> p
    int getNextNewKidPosition() -> q
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties getProperties() -> r
    java.lang.String getRole() -> s
    com.itextpdf.kernel.pdf.tagutils.TagReference getTagReference() -> t
    com.itextpdf.kernel.pdf.tagutils.TagReference getTagReference(int) -> u
    boolean isPointingToSameTag(com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> v
    boolean markedContentNotInPageStream() -> w
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer moveToParent() -> x
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer moveToPointer(com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> y
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer moveToRoot() -> z
com.itextpdf.kernel.pdf.tagutils.WaitingTagsManager -> o1.l:
    java.util.Map associatedObjToWaitingTag -> a
    java.util.Map waitingTagToAssociatedObj -> b
    java.lang.Object assignWaitingState(com.itextpdf.kernel.pdf.tagutils.TagTreePointer,java.lang.Object) -> a
    void flushStructElementAndItKids(com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> b
    java.lang.Object getObjForStructDict(com.itextpdf.kernel.pdf.PdfDictionary) -> c
    boolean isObjectAssociatedWithWaitingTag(java.lang.Object) -> d
    void removeAllWaitingStates() -> e
    boolean removeWaitingState(java.lang.Object) -> f
    void removeWaitingStateAndFlushIfParentFlushed(com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> g
    java.lang.Object saveAssociatedObjectForWaitingTag(java.lang.Object,com.itextpdf.kernel.pdf.tagging.PdfStructElem) -> h
    boolean tryMovePointerToWaitingTag(com.itextpdf.kernel.pdf.tagutils.TagTreePointer,java.lang.Object) -> i
com.itextpdf.kernel.pdf.xobject.ImagePdfBytesInfo -> p1.a:
    com.itextpdf.kernel.pdf.PdfObject colorspace -> d
    int stride -> j
    java.lang.String TIFFTAG_SOFTWARE_VALUE -> k
    com.itextpdf.kernel.pdf.PdfArray decode -> e
    int pngColorType -> f
    byte[] palette -> h
    int pngBitDepth -> g
    byte[] icc -> i
    int width -> b
    int height -> c
    int bpc -> a
    byte[] decodeTiffAndPngBytes(byte[]) -> a
    void findColorspace(com.itextpdf.kernel.pdf.PdfObject,boolean) -> b
    int getPngColorType() -> c
    byte[] processPng(byte[],int,int) -> d
    byte[] processSeperationColor(byte[],com.itextpdf.kernel.pdf.PdfArray) -> e
com.itextpdf.kernel.pdf.xobject.PdfFormXObject -> p1.b:
    com.itextpdf.kernel.pdf.PdfResources resources -> b
    void flush() -> h
    float getHeight() -> r
    float getWidth() -> s
    com.itextpdf.kernel.pdf.PdfArray getBBox() -> t
com.itextpdf.kernel.pdf.xobject.PdfImageXObject -> p1.c:
    boolean softMask -> e
    float height -> c
    float width -> b
    boolean mask -> d
    com.itextpdf.io.image.ImageType identifyImageType() -> A
    float initHeightField() -> B
    float initWidthField() -> C
    void flush() -> h
    float getHeight() -> r
    float getWidth() -> s
    com.itextpdf.io.image.ImageData checkImageType(com.itextpdf.io.image.ImageData) -> t
    com.itextpdf.kernel.pdf.PdfArray createArray(com.itextpdf.kernel.pdf.PdfStream,java.lang.Object[]) -> u
    com.itextpdf.kernel.pdf.PdfDictionary createDictionaryFromMap(com.itextpdf.kernel.pdf.PdfStream,java.util.Map) -> v
    com.itextpdf.kernel.pdf.PdfStream createPdfStream(com.itextpdf.io.image.ImageData,com.itextpdf.kernel.pdf.xobject.PdfImageXObject) -> w
    com.itextpdf.kernel.pdf.PdfObject getColorSpaceInfo(com.itextpdf.io.image.PngImageData) -> x
    byte[] getImageBytes() -> y
    byte[] getImageBytes(boolean) -> z
com.itextpdf.kernel.pdf.xobject.PdfImageXObject$1 -> p1.c$a:
com.itextpdf.kernel.pdf.xobject.PdfImageXObject$PngChromaticitiesHelper -> p1.c$b:
    float[] matrix -> a
    float[] wp -> b
    void constructMatrix(com.itextpdf.io.image.PngImageData) -> a
com.itextpdf.kernel.pdf.xobject.PdfXObject -> p1.d:
    boolean isWrappedObjectMustBeIndirect() -> k
    float getHeight() -> r
    float getWidth() -> s
com.itextpdf.kernel.security.IExternalDecryptionProcess -> q1.a:
    org.bouncycastle.cms.Recipient getCmsRecipient() -> a
    org.bouncycastle.cms.RecipientId getCmsRecipientId() -> b
com.itextpdf.kernel.utils.DefaultSafeXmlParserFactory -> r1.a:
    org.slf4j.Logger LOGGER -> a
    javax.xml.parsers.DocumentBuilder createDocumentBuilderInstance(boolean,boolean) -> a
    void configureSafeDocumentBuilderFactory(javax.xml.parsers.DocumentBuilderFactory) -> b
    javax.xml.parsers.DocumentBuilderFactory createDocumentBuilderFactory() -> c
    void tryToSetFeature(javax.xml.parsers.DocumentBuilderFactory,java.lang.String,boolean) -> d
com.itextpdf.kernel.utils.DefaultSafeXmlParserFactory$SafeEmptyEntityResolver -> r1.a$a:
    org.xml.sax.InputSource resolveEntity(java.lang.String,java.lang.String) -> f
com.itextpdf.kernel.utils.ICopyFilter -> r1.b:
    boolean shouldProcess(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> a
com.itextpdf.kernel.utils.IXmlParserFactory -> r1.c:
    javax.xml.parsers.DocumentBuilder createDocumentBuilderInstance(boolean,boolean) -> a
com.itextpdf.kernel.utils.IdleOutputStream -> r1.d:
com.itextpdf.kernel.utils.NullCopyFilter -> r1.e:
    com.itextpdf.kernel.utils.NullCopyFilter INSTANCE -> a
    boolean shouldProcess(com.itextpdf.kernel.pdf.PdfObject,com.itextpdf.kernel.pdf.PdfName,com.itextpdf.kernel.pdf.PdfObject) -> a
    com.itextpdf.kernel.utils.NullCopyFilter getInstance() -> b
com.itextpdf.kernel.utils.PageRange -> r1.f:
    java.util.List sequences -> a
    java.util.regex.Pattern SINGLE_PAGE_PATTERN -> c
    java.util.regex.Pattern SEQUENCE_PATTERN -> b
    com.itextpdf.kernel.utils.PageRange addPageRangePart(com.itextpdf.kernel.utils.PageRange$IPageRangePart) -> a
    com.itextpdf.kernel.utils.PageRange addPageSequence(int,int) -> b
    java.util.List getQualifyingPageNums(int) -> c
    com.itextpdf.kernel.utils.PageRange$IPageRangePart getRangeObject(java.lang.String) -> d
com.itextpdf.kernel.utils.PageRange$IPageRangePart -> r1.f$a:
    java.util.List getAllPagesInRange(int) -> a
com.itextpdf.kernel.utils.PageRange$PageRangePartAfter -> r1.f$b:
    int start -> a
    java.util.List getAllPagesInRange(int) -> a
com.itextpdf.kernel.utils.PageRange$PageRangePartAnd -> r1.f$c:
    java.util.List conditions -> a
    java.util.List getAllPagesInRange(int) -> a
com.itextpdf.kernel.utils.PageRange$PageRangePartOddEven -> r1.f$d:
    com.itextpdf.kernel.utils.PageRange$PageRangePartOddEven EVEN -> d
    com.itextpdf.kernel.utils.PageRange$PageRangePartOddEven ODD -> c
    boolean isOdd -> a
    int mod -> b
    java.util.List getAllPagesInRange(int) -> a
com.itextpdf.kernel.utils.PageRange$PageRangePartSequence -> r1.f$e:
    int end -> b
    int start -> a
    java.util.List getAllPagesInRange(int) -> a
com.itextpdf.kernel.utils.PageRange$PageRangePartSingle -> r1.f$f:
    int page -> a
    java.util.List getAllPagesInRange(int) -> a
com.itextpdf.kernel.utils.PdfMerger -> r1.g:
    com.itextpdf.kernel.pdf.PdfDocument pdfDocument -> a
    boolean closeSrcDocuments -> b
    boolean mergeTags -> c
    boolean mergeOutlines -> d
    com.itextpdf.kernel.utils.PdfMerger merge(com.itextpdf.kernel.pdf.PdfDocument,int,int) -> a
    com.itextpdf.kernel.utils.PdfMerger merge(com.itextpdf.kernel.pdf.PdfDocument,java.util.List) -> b
com.itextpdf.kernel.utils.PdfResourceCounter -> r1.h:
    java.util.Map resources -> a
    long getLength(java.util.Map) -> a
    java.util.Map getResources() -> b
    void loopOver(com.itextpdf.kernel.pdf.PdfObject) -> c
    void process(com.itextpdf.kernel.pdf.PdfObject) -> d
com.itextpdf.kernel.utils.PdfSplitter -> r1.i:
    com.itextpdf.kernel.pdf.PdfDocument pdfDocument -> a
    com.itextpdf.commons.actions.contexts.IMetaInfo metaInfo -> d
    boolean preserveTagged -> b
    boolean preserveOutlines -> c
    com.itextpdf.kernel.pdf.PdfDocument createPdfDocument(com.itextpdf.kernel.utils.PageRange) -> a
    com.itextpdf.kernel.pdf.PdfDocument extractPageRange(com.itextpdf.kernel.utils.PageRange) -> b
    java.util.List extractPageRanges(java.util.List) -> c
    com.itextpdf.kernel.pdf.PdfWriter getNextPdfWriter(com.itextpdf.kernel.utils.PageRange) -> d
    com.itextpdf.kernel.utils.PageRange getNextRange(int,int,long) -> e
    void splitByPageCount(int,com.itextpdf.kernel.utils.PdfSplitter$IDocumentReadyListener) -> f
    void splitByPageNumbers(java.util.List,com.itextpdf.kernel.utils.PdfSplitter$IDocumentReadyListener) -> g
    java.util.List splitBySize(long) -> h
    long xrefLength(int) -> i
com.itextpdf.kernel.utils.PdfSplitter$IDocumentReadyListener -> r1.i$a:
    void documentReady(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.PageRange) -> a
com.itextpdf.kernel.utils.XmlProcessorCreator -> r1.j:
    com.itextpdf.kernel.utils.IXmlParserFactory xmlParserFactory -> a
    javax.xml.parsers.DocumentBuilder createSafeDocumentBuilder(boolean,boolean) -> a
com.itextpdf.kernel.xmp.XMPDateTime -> s1.a:
    int getMinute() -> b
    boolean hasTime() -> e
    void setDay(int) -> f
    void setSecond(int) -> g
    int getSecond() -> h
    void setNanoSecond(int) -> i
    int getYear() -> j
    int getMonth() -> l
    void setHour(int) -> m
    void setMinute(int) -> o
    int getNanoSecond() -> p
    void setMonth(int) -> q
    int getDay() -> r
    void setTimeZone(java.util.TimeZone) -> s
    boolean hasTimeZone() -> t
    void setYear(int) -> u
    java.util.Calendar getCalendar() -> v
    boolean hasDate() -> w
    int getHour() -> y
    java.util.TimeZone getTimeZone() -> z
com.itextpdf.kernel.xmp.XMPDateTimeFactory -> s1.b:
    java.util.TimeZone UTC -> a
    com.itextpdf.kernel.xmp.XMPDateTime createFromCalendar(java.util.Calendar) -> a
com.itextpdf.kernel.xmp.XMPException -> s1.c:
    int errorCode -> Q2
    int getErrorCode() -> a
com.itextpdf.kernel.xmp.XMPMeta -> s1.d:
    void setLocalizedText(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,com.itextpdf.kernel.xmp.options.PropertyOptions) -> L
    void setPropertyInteger(java.lang.String,java.lang.String,int,com.itextpdf.kernel.xmp.options.PropertyOptions) -> M
    void setObjectName(java.lang.String) -> V
    void appendArrayItem(java.lang.String,java.lang.String,com.itextpdf.kernel.xmp.options.PropertyOptions,java.lang.String,com.itextpdf.kernel.xmp.options.PropertyOptions) -> b0
    int countArrayItems(java.lang.String,java.lang.String) -> c0
    void setLocalizedText(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> g0
    com.itextpdf.kernel.xmp.properties.XMPProperty getProperty(java.lang.String,java.lang.String) -> q
    com.itextpdf.kernel.xmp.properties.XMPProperty getLocalizedText(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> v
    void setProperty(java.lang.String,java.lang.String,java.lang.Object) -> x0
    com.itextpdf.kernel.xmp.properties.XMPProperty getArrayItem(java.lang.String,java.lang.String,int) -> z
com.itextpdf.kernel.xmp.XMPMetaFactory -> s1.e:
    com.itextpdf.kernel.xmp.XMPSchemaRegistry schema -> b
    com.itextpdf.kernel.xmp.XMPVersionInfo versionInfo -> c
    java.lang.Object staticLock -> a
    void assertImplementation(com.itextpdf.kernel.xmp.XMPMeta) -> a
    com.itextpdf.kernel.xmp.XMPMeta create() -> b
    com.itextpdf.kernel.xmp.XMPSchemaRegistry getSchemaRegistry() -> c
    com.itextpdf.kernel.xmp.XMPVersionInfo getVersionInfo() -> d
    com.itextpdf.kernel.xmp.XMPMeta parseFromBuffer(byte[]) -> e
    com.itextpdf.kernel.xmp.XMPMeta parseFromBuffer(byte[],com.itextpdf.kernel.xmp.options.ParseOptions) -> f
    byte[] serializeToBuffer(com.itextpdf.kernel.xmp.XMPMeta,com.itextpdf.kernel.xmp.options.SerializeOptions) -> g
com.itextpdf.kernel.xmp.XMPMetaFactory$XMPVersionInfoImpl -> s1.e$a:
    java.lang.String message -> f
    boolean debug -> e
    int engBuild -> d
    int minor -> b
    int micro -> c
    int major -> a
    java.lang.String getMessage() -> a
com.itextpdf.kernel.xmp.XMPPathFactory -> s1.f:
    java.lang.String composeArrayItemPath(java.lang.String,int) -> a
com.itextpdf.kernel.xmp.XMPSchemaRegistry -> s1.g:
    java.lang.String registerNamespace(java.lang.String,java.lang.String) -> a
    com.itextpdf.kernel.xmp.properties.XMPAliasInfo findAlias(java.lang.String) -> b
    java.lang.String getNamespacePrefix(java.lang.String) -> c
    java.lang.String getNamespaceURI(java.lang.String) -> d
com.itextpdf.kernel.xmp.XMPUtils -> s1.h:
    java.lang.String convertFromBoolean(boolean) -> a
    java.lang.String convertFromDate(com.itextpdf.kernel.xmp.XMPDateTime) -> b
    java.lang.String convertFromDouble(double) -> c
    java.lang.String convertFromInteger(int) -> d
    java.lang.String convertFromLong(long) -> e
    boolean convertToBoolean(java.lang.String) -> f
    com.itextpdf.kernel.xmp.XMPDateTime convertToDate(java.lang.String) -> g
    double convertToDouble(java.lang.String) -> h
    int convertToInteger(java.lang.String) -> i
    long convertToLong(java.lang.String) -> j
    byte[] decodeBase64(java.lang.String) -> k
    java.lang.String encodeBase64(byte[]) -> l
com.itextpdf.kernel.xmp.XMPVersionInfo -> s1.i:
    java.lang.String getMessage() -> a
com.itextpdf.kernel.xmp.impl.Base64 -> t1.a:
    byte[] ascii -> b
    byte[] base64 -> a
    byte[] decode(byte[]) -> a
    byte[] encode(byte[]) -> b
    byte[] encode(byte[],int) -> c
com.itextpdf.kernel.xmp.impl.ByteBuffer -> t1.b:
    byte[] buffer -> a
    int length -> b
    java.lang.String encoding -> c
    void append(byte) -> a
    void append(byte[]) -> b
    void append(byte[],int,int) -> c
    int charAt(int) -> d
    void ensureCapacity(int) -> e
    java.io.InputStream getByteStream() -> f
    java.lang.String getEncoding() -> g
    int length() -> h
com.itextpdf.kernel.xmp.impl.CountOutputStream -> t1.c:
    java.io.OutputStream output -> Q2
    int bytesWritten -> R2
    int getBytesWritten() -> a
com.itextpdf.kernel.xmp.impl.FixASCIIControlsReader -> t1.d:
    int digits -> S2
    int state -> Q2
    int control -> R2
    char processChar(char) -> a
com.itextpdf.kernel.xmp.impl.ISO8601Converter -> t1.e:
    com.itextpdf.kernel.xmp.XMPDateTime parse(java.lang.String) -> a
    com.itextpdf.kernel.xmp.XMPDateTime parse(java.lang.String,com.itextpdf.kernel.xmp.XMPDateTime) -> b
    java.lang.String render(com.itextpdf.kernel.xmp.XMPDateTime) -> c
com.itextpdf.kernel.xmp.impl.Latin1Converter -> t1.f:
    com.itextpdf.kernel.xmp.impl.ByteBuffer convert(com.itextpdf.kernel.xmp.impl.ByteBuffer) -> a
    byte[] convertToUTF8(byte) -> b
com.itextpdf.kernel.xmp.impl.ParameterAsserts -> t1.g:
    void assertArrayName(java.lang.String) -> a
    void assertNotNull(java.lang.Object) -> b
    void assertPrefix(java.lang.String) -> c
    void assertPropName(java.lang.String) -> d
    void assertSchemaNS(java.lang.String) -> e
    void assertSpecificLang(java.lang.String) -> f
com.itextpdf.kernel.xmp.impl.ParseRDF -> t1.h:
    com.itextpdf.kernel.xmp.impl.XMPNode addChildNode(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.impl.XMPNode,org.w3c.dom.Node,java.lang.String,boolean) -> a
    com.itextpdf.kernel.xmp.impl.XMPNode addQualifierNode(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String,java.lang.String) -> b
    void fixupQualifiedNode(com.itextpdf.kernel.xmp.impl.XMPNode) -> c
    int getRDFTermKind(org.w3c.dom.Node) -> d
    boolean isCoreSyntaxTerm(int) -> e
    boolean isOldTerm(int) -> f
    boolean isPropertyElementName(int) -> g
    boolean isWhitespaceNode(org.w3c.dom.Node) -> h
    com.itextpdf.kernel.xmp.impl.XMPMetaImpl parse(org.w3c.dom.Node) -> i
    void rdf_EmptyPropertyElement(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.impl.XMPNode,org.w3c.dom.Node,boolean) -> j
    void rdf_LiteralPropertyElement(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.impl.XMPNode,org.w3c.dom.Node,boolean) -> k
    void rdf_NodeElement(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.impl.XMPNode,org.w3c.dom.Node,boolean) -> l
    void rdf_NodeElementAttrs(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.impl.XMPNode,org.w3c.dom.Node,boolean) -> m
    void rdf_NodeElementList(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.impl.XMPNode,org.w3c.dom.Node) -> n
    void rdf_ParseTypeCollectionPropertyElement() -> o
    void rdf_ParseTypeLiteralPropertyElement() -> p
    void rdf_ParseTypeOtherPropertyElement() -> q
    void rdf_ParseTypeResourcePropertyElement(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.impl.XMPNode,org.w3c.dom.Node,boolean) -> r
    void rdf_PropertyElement(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.impl.XMPNode,org.w3c.dom.Node,boolean) -> s
    void rdf_PropertyElementList(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.impl.XMPNode,org.w3c.dom.Node,boolean) -> t
    void rdf_RDF(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,org.w3c.dom.Node) -> u
    void rdf_ResourcePropertyElement(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.impl.XMPNode,org.w3c.dom.Node,boolean) -> v
com.itextpdf.kernel.xmp.impl.ParseState -> t1.i:
    java.lang.String str -> a
    int pos -> b
    char ch() -> a
    char ch(int) -> b
    int gatherInt(java.lang.String,int) -> c
    boolean hasNext() -> d
    int pos() -> e
    void skip() -> f
com.itextpdf.kernel.xmp.impl.QName -> t1.j:
    java.lang.String prefix -> a
    java.lang.String localName -> b
    java.lang.String getPrefix() -> a
    boolean hasPrefix() -> b
com.itextpdf.kernel.xmp.impl.Utils -> t1.k:
    boolean[] xmlNameStartChars -> a
    boolean[] xmlNameChars -> b
    boolean checkUUIDFormat(java.lang.String) -> a
    java.lang.String escapeXML(java.lang.String,boolean,boolean) -> b
    void initCharTables() -> c
    boolean isControlChar(char) -> d
    boolean isNameChar(char) -> e
    boolean isNameStartChar(char) -> f
    boolean isXMLName(java.lang.String) -> g
    boolean isXMLNameNS(java.lang.String) -> h
    java.lang.String normalizeLangValue(java.lang.String) -> i
    java.lang.String removeControlChars(java.lang.String) -> j
    java.lang.String[] splitNameAndValue(java.lang.String) -> k
com.itextpdf.kernel.xmp.impl.XMPDateTimeImpl -> t1.l:
    int minute -> U2
    int second -> V2
    int day -> S2
    int hour -> T2
    boolean hasDate -> Y2
    int nanoSeconds -> X2
    boolean hasTimeZone -> a3
    int year -> Q2
    boolean hasTime -> Z2
    int month -> R2
    java.util.TimeZone timeZone -> W2
    java.lang.String getISO8601String() -> a
    int getMinute() -> b
    boolean hasTime() -> e
    void setDay(int) -> f
    void setSecond(int) -> g
    int getSecond() -> h
    void setNanoSecond(int) -> i
    int getYear() -> j
    int getMonth() -> l
    void setHour(int) -> m
    void setMinute(int) -> o
    int getNanoSecond() -> p
    void setMonth(int) -> q
    int getDay() -> r
    void setTimeZone(java.util.TimeZone) -> s
    boolean hasTimeZone() -> t
    void setYear(int) -> u
    java.util.Calendar getCalendar() -> v
    boolean hasDate() -> w
    int getHour() -> y
    java.util.TimeZone getTimeZone() -> z
com.itextpdf.kernel.xmp.impl.XMPMetaImpl -> t1.m:
    java.lang.String packetHeader -> R2
    com.itextpdf.kernel.xmp.impl.XMPNode tree -> Q2
    void setLocalizedText(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,com.itextpdf.kernel.xmp.options.PropertyOptions) -> L
    void setPropertyInteger(java.lang.String,java.lang.String,int,com.itextpdf.kernel.xmp.options.PropertyOptions) -> M
    void setObjectName(java.lang.String) -> V
    void doSetArrayItem(com.itextpdf.kernel.xmp.impl.XMPNode,int,java.lang.String,com.itextpdf.kernel.xmp.options.PropertyOptions,boolean) -> a
    boolean doesPropertyExist(java.lang.String,java.lang.String) -> b
    void appendArrayItem(java.lang.String,java.lang.String,com.itextpdf.kernel.xmp.options.PropertyOptions,java.lang.String,com.itextpdf.kernel.xmp.options.PropertyOptions) -> b0
    java.lang.Object evaluateNodeValue(int,com.itextpdf.kernel.xmp.impl.XMPNode) -> c
    int countArrayItems(java.lang.String,java.lang.String) -> c0
    com.itextpdf.kernel.xmp.properties.XMPProperty getProperty(java.lang.String,java.lang.String,int) -> d
    com.itextpdf.kernel.xmp.impl.XMPNode getRoot() -> e
    void setNode(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.Object,com.itextpdf.kernel.xmp.options.PropertyOptions,boolean) -> f
    void setPacketHeader(java.lang.String) -> g
    void setLocalizedText(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> g0
    void setProperty(java.lang.String,java.lang.String,java.lang.Object,com.itextpdf.kernel.xmp.options.PropertyOptions) -> h
    void sort() -> i
    com.itextpdf.kernel.xmp.properties.XMPProperty getProperty(java.lang.String,java.lang.String) -> q
    com.itextpdf.kernel.xmp.properties.XMPProperty getLocalizedText(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> v
    void setProperty(java.lang.String,java.lang.String,java.lang.Object) -> x0
    com.itextpdf.kernel.xmp.properties.XMPProperty getArrayItem(java.lang.String,java.lang.String,int) -> z
com.itextpdf.kernel.xmp.impl.XMPMetaImpl$1 -> t1.m$a:
    com.itextpdf.kernel.xmp.impl.XMPNode val$itemNode -> a
    com.itextpdf.kernel.xmp.impl.XMPMetaImpl this$0 -> b
com.itextpdf.kernel.xmp.impl.XMPMetaImpl$2 -> t1.m$b:
    java.lang.Object val$value -> a
    com.itextpdf.kernel.xmp.impl.XMPMetaImpl this$0 -> c
    com.itextpdf.kernel.xmp.impl.XMPNode val$propNode -> b
com.itextpdf.kernel.xmp.impl.XMPMetaParser -> t1.n:
    java.lang.Object XMP_RDF -> a
    java.lang.Object[] findRootNode(org.w3c.dom.Node,boolean,java.lang.Object[]) -> a
    com.itextpdf.kernel.xmp.XMPMeta parse(java.lang.Object,com.itextpdf.kernel.xmp.options.ParseOptions) -> b
    org.w3c.dom.Document parseInputSource(org.xml.sax.InputSource) -> c
    org.w3c.dom.Document parseXml(java.lang.Object,com.itextpdf.kernel.xmp.options.ParseOptions) -> d
    org.w3c.dom.Document parseXmlFromBytebuffer(com.itextpdf.kernel.xmp.impl.ByteBuffer,com.itextpdf.kernel.xmp.options.ParseOptions) -> e
    org.w3c.dom.Document parseXmlFromInputStream(java.io.InputStream,com.itextpdf.kernel.xmp.options.ParseOptions) -> f
    org.w3c.dom.Document parseXmlFromString(java.lang.String,com.itextpdf.kernel.xmp.options.ParseOptions) -> g
com.itextpdf.kernel.xmp.impl.XMPNode -> t1.o:
    boolean implicit -> W2
    boolean hasAliases -> X2
    boolean alias -> Y2
    java.lang.String value -> R2
    java.lang.String name -> Q2
    java.util.List qualifier -> U2
    boolean hasValueChild -> Z2
    com.itextpdf.kernel.xmp.impl.XMPNode parent -> S2
    java.util.List children -> T2
    com.itextpdf.kernel.xmp.options.PropertyOptions options -> V2
    void clear() -> A
    void cloneSubtree(com.itextpdf.kernel.xmp.impl.XMPNode) -> B
    com.itextpdf.kernel.xmp.impl.XMPNode find(java.util.List,java.lang.String) -> C
    com.itextpdf.kernel.xmp.impl.XMPNode findChildByName(java.lang.String) -> D
    com.itextpdf.kernel.xmp.impl.XMPNode findQualifierByName(java.lang.String) -> E
    com.itextpdf.kernel.xmp.impl.XMPNode getChild(int) -> F
    java.util.List getChildren() -> G
    int getChildrenLength() -> H
    boolean getHasAliases() -> I
    boolean getHasValueChild() -> J
    java.lang.String getName() -> K
    com.itextpdf.kernel.xmp.options.PropertyOptions getOptions() -> L
    com.itextpdf.kernel.xmp.impl.XMPNode getParent() -> M
    java.util.List getQualifier() -> N
    com.itextpdf.kernel.xmp.impl.XMPNode getQualifier(int) -> O
    int getQualifierLength() -> P
    java.util.List getUnmodifiableChildren() -> Q
    java.lang.String getValue() -> R
    boolean hasChildren() -> S
    boolean hasQualifier() -> T
    boolean isAlias() -> U
    boolean isImplicit() -> V
    boolean isLanguageNode() -> W
    boolean isTypeNode() -> X
    java.util.Iterator iterateChildren() -> Y
    java.util.Iterator iterateQualifier() -> Z
    void addChild(int,com.itextpdf.kernel.xmp.impl.XMPNode) -> a
    void removeChild(int) -> a0
    void removeChild(com.itextpdf.kernel.xmp.impl.XMPNode) -> b0
    void addChild(com.itextpdf.kernel.xmp.impl.XMPNode) -> c
    void removeChildren() -> c0
    void addQualifier(com.itextpdf.kernel.xmp.impl.XMPNode) -> d
    void removeQualifier(com.itextpdf.kernel.xmp.impl.XMPNode) -> d0
    void removeQualifiers() -> e0
    void replaceChild(int,com.itextpdf.kernel.xmp.impl.XMPNode) -> f0
    void setAlias(boolean) -> g0
    void setHasAliases(boolean) -> h0
    void setHasValueChild(boolean) -> i0
    void setImplicit(boolean) -> j0
    void assertChildNotExisting(java.lang.String) -> k
    void setName(java.lang.String) -> k0
    void setOptions(com.itextpdf.kernel.xmp.options.PropertyOptions) -> l0
    void setParent(com.itextpdf.kernel.xmp.impl.XMPNode) -> m0
    void assertQualifierNotExisting(java.lang.String) -> n
    void setValue(java.lang.String) -> n0
    void sort() -> o0
    void cleanupChildren() -> x
com.itextpdf.kernel.xmp.impl.XMPNode$1 -> t1.o$a:
    java.util.Iterator val$it -> Q2
    com.itextpdf.kernel.xmp.impl.XMPNode this$0 -> R2
com.itextpdf.kernel.xmp.impl.XMPNodeUtils -> t1.p:
    void appendLangItem(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String,java.lang.String) -> a
    java.lang.Object[] chooseLocalizedText(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String,java.lang.String) -> b
    void deleteNode(com.itextpdf.kernel.xmp.impl.XMPNode) -> c
    void detectAltText(com.itextpdf.kernel.xmp.impl.XMPNode) -> d
    com.itextpdf.kernel.xmp.impl.XMPNode findChildNode(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String,boolean) -> e
    int findIndexedItem(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String,boolean) -> f
    com.itextpdf.kernel.xmp.impl.XMPNode findNode(com.itextpdf.kernel.xmp.impl.XMPNode,com.itextpdf.kernel.xmp.impl.xpath.XMPPath,boolean,com.itextpdf.kernel.xmp.options.PropertyOptions) -> g
    com.itextpdf.kernel.xmp.impl.XMPNode findQualifierNode(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String,boolean) -> h
    com.itextpdf.kernel.xmp.impl.XMPNode findSchemaNode(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String,java.lang.String,boolean) -> i
    com.itextpdf.kernel.xmp.impl.XMPNode findSchemaNode(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String,boolean) -> j
    com.itextpdf.kernel.xmp.impl.XMPNode followXPathStep(com.itextpdf.kernel.xmp.impl.XMPNode,com.itextpdf.kernel.xmp.impl.xpath.XMPPathSegment,boolean) -> k
    int lookupFieldSelector(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String,java.lang.String) -> l
    int lookupLanguageItem(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String) -> m
    int lookupQualSelector(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.String,java.lang.String,int) -> n
    void normalizeLangArray(com.itextpdf.kernel.xmp.impl.XMPNode) -> o
    java.lang.String serializeNodeValue(java.lang.Object) -> p
    void setNodeValue(com.itextpdf.kernel.xmp.impl.XMPNode,java.lang.Object) -> q
    com.itextpdf.kernel.xmp.options.PropertyOptions verifySetOptions(com.itextpdf.kernel.xmp.options.PropertyOptions,java.lang.Object) -> r
com.itextpdf.kernel.xmp.impl.XMPNormalizer -> t1.q:
    java.util.Map dcArrayForms -> a
    void compareAliasedSubtrees(com.itextpdf.kernel.xmp.impl.XMPNode,com.itextpdf.kernel.xmp.impl.XMPNode,boolean) -> a
    void deleteEmptySchemas(com.itextpdf.kernel.xmp.impl.XMPNode) -> b
    void fixGPSTimeStamp(com.itextpdf.kernel.xmp.impl.XMPNode) -> c
    void initDCArrays() -> d
    void migrateAudioCopyright(com.itextpdf.kernel.xmp.XMPMeta,com.itextpdf.kernel.xmp.impl.XMPNode) -> e
    void moveExplicitAliases(com.itextpdf.kernel.xmp.impl.XMPNode,com.itextpdf.kernel.xmp.options.ParseOptions) -> f
    void normalizeDCArrays(com.itextpdf.kernel.xmp.impl.XMPNode) -> g
    com.itextpdf.kernel.xmp.XMPMeta process(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.options.ParseOptions) -> h
    void repairAltText(com.itextpdf.kernel.xmp.impl.XMPNode) -> i
    void touchUpDataModel(com.itextpdf.kernel.xmp.impl.XMPMetaImpl) -> j
    void transplantArrayItemAlias(java.util.Iterator,com.itextpdf.kernel.xmp.impl.XMPNode,com.itextpdf.kernel.xmp.impl.XMPNode) -> k
    void tweakOldXMP(com.itextpdf.kernel.xmp.impl.XMPNode) -> l
com.itextpdf.kernel.xmp.impl.XMPSchemaRegistryImpl -> t1.r:
    java.util.Map namespaceToPrefixMap -> a
    java.util.Map prefixToNamespaceMap -> b
    java.util.Map aliasMap -> c
    java.util.regex.Pattern p -> d
    java.lang.String registerNamespace(java.lang.String,java.lang.String) -> a
    com.itextpdf.kernel.xmp.properties.XMPAliasInfo findAlias(java.lang.String) -> b
    java.lang.String getNamespacePrefix(java.lang.String) -> c
    java.lang.String getNamespaceURI(java.lang.String) -> d
    void registerAlias(java.lang.String,java.lang.String,java.lang.String,java.lang.String,com.itextpdf.kernel.xmp.options.AliasOptions) -> e
    void registerStandardAliases() -> f
    void registerStandardNamespaces() -> g
com.itextpdf.kernel.xmp.impl.XMPSchemaRegistryImpl$1 -> t1.r$a:
    java.lang.String val$actualNS -> a
    com.itextpdf.kernel.xmp.options.AliasOptions val$aliasOpts -> d
    com.itextpdf.kernel.xmp.impl.XMPSchemaRegistryImpl this$0 -> e
    java.lang.String val$actualProp -> c
    java.lang.String val$actualPrefix -> b
    java.lang.String getNamespace() -> b
    java.lang.String getPrefix() -> g
    java.lang.String getPropName() -> h
    com.itextpdf.kernel.xmp.options.AliasOptions getAliasForm() -> i
com.itextpdf.kernel.xmp.impl.XMPSerializerHelper -> t1.s:
    void serialize(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,java.io.OutputStream,com.itextpdf.kernel.xmp.options.SerializeOptions) -> a
    byte[] serializeToBuffer(com.itextpdf.kernel.xmp.impl.XMPMetaImpl,com.itextpdf.kernel.xmp.options.SerializeOptions) -> b
com.itextpdf.kernel.xmp.impl.XMPSerializerRDF -> t1.t:
    java.util.Set RDF_ATTR_QUALIFIER -> g
    com.itextpdf.kernel.xmp.impl.CountOutputStream outputStream -> b
    com.itextpdf.kernel.xmp.impl.XMPMetaImpl xmp -> a
    java.io.OutputStreamWriter writer -> c
    int padding -> f
    int unicodeSize -> e
    com.itextpdf.kernel.xmp.options.SerializeOptions options -> d
    void writeTreeName() -> A
    void addPadding(int) -> a
    void appendNodeValue(java.lang.String,boolean) -> b
    boolean canBeRDFAttrProp(com.itextpdf.kernel.xmp.impl.XMPNode) -> c
    void checkOptionsConsistence() -> d
    void declareNamespace(java.lang.String,java.lang.String,java.util.Set,int) -> e
    void declareUsedNamespaces(com.itextpdf.kernel.xmp.impl.XMPNode,java.util.Set,int) -> f
    void emitRDFArrayTag(com.itextpdf.kernel.xmp.impl.XMPNode,boolean,int) -> g
    void endOuterRDFDescription(int) -> h
    void serialize(com.itextpdf.kernel.xmp.XMPMeta,java.io.OutputStream,com.itextpdf.kernel.xmp.options.SerializeOptions) -> i
    java.lang.String serializeAsRDF() -> j
    void serializeCanonicalRDFProperty(com.itextpdf.kernel.xmp.impl.XMPNode,boolean,boolean,int) -> k
    void serializeCanonicalRDFSchema(com.itextpdf.kernel.xmp.impl.XMPNode,int) -> l
    void serializeCanonicalRDFSchemas(int) -> m
    void serializeCompactRDFArrayProp(com.itextpdf.kernel.xmp.impl.XMPNode,int) -> n
    boolean serializeCompactRDFAttrProps(com.itextpdf.kernel.xmp.impl.XMPNode,int) -> o
    void serializeCompactRDFElementProps(com.itextpdf.kernel.xmp.impl.XMPNode,int) -> p
    void serializeCompactRDFGeneralQualifier(int,com.itextpdf.kernel.xmp.impl.XMPNode) -> q
    void serializeCompactRDFSchemas(int) -> r
    boolean[] serializeCompactRDFSimpleProp(com.itextpdf.kernel.xmp.impl.XMPNode) -> s
    boolean serializeCompactRDFStructProp(com.itextpdf.kernel.xmp.impl.XMPNode,int,boolean) -> t
    void startOuterRDFDescription(com.itextpdf.kernel.xmp.impl.XMPNode,int) -> u
    void write(int) -> v
    void write(java.lang.String) -> w
    void writeChars(int,char) -> x
    void writeIndent(int) -> y
    void writeNewline() -> z
com.itextpdf.kernel.xmp.impl.xpath.PathPosition -> u1.a:
    java.lang.String path -> a
    int stepBegin -> d
    int stepEnd -> e
    int nameStart -> b
    int nameEnd -> c
com.itextpdf.kernel.xmp.impl.xpath.XMPPath -> u1.b:
    java.util.List segments -> a
    void add(com.itextpdf.kernel.xmp.impl.xpath.XMPPathSegment) -> a
    com.itextpdf.kernel.xmp.impl.xpath.XMPPathSegment getSegment(int) -> b
    int size() -> c
com.itextpdf.kernel.xmp.impl.xpath.XMPPathParser -> u1.c:
    com.itextpdf.kernel.xmp.impl.xpath.XMPPath expandXPath(java.lang.String,java.lang.String) -> a
    com.itextpdf.kernel.xmp.impl.xpath.XMPPathSegment parseIndexSegment(com.itextpdf.kernel.xmp.impl.xpath.PathPosition) -> b
    void parseRootNode(java.lang.String,com.itextpdf.kernel.xmp.impl.xpath.PathPosition,com.itextpdf.kernel.xmp.impl.xpath.XMPPath) -> c
    com.itextpdf.kernel.xmp.impl.xpath.XMPPathSegment parseStructSegment(com.itextpdf.kernel.xmp.impl.xpath.PathPosition) -> d
    void skipPathDelimiter(java.lang.String,com.itextpdf.kernel.xmp.impl.xpath.PathPosition) -> e
    void verifyQualName(java.lang.String) -> f
    void verifySimpleXMLName(java.lang.String) -> g
    java.lang.String verifyXPathRoot(java.lang.String,java.lang.String) -> h
com.itextpdf.kernel.xmp.impl.xpath.XMPPathSegment -> u1.d:
    java.lang.String name -> a
    int aliasForm -> d
    int kind -> b
    boolean alias -> c
    int getAliasForm() -> a
    int getKind() -> b
    java.lang.String getName() -> c
    boolean isAlias() -> d
    void setAlias(boolean) -> e
    void setAliasForm(int) -> f
    void setKind(int) -> g
    void setName(java.lang.String) -> h
com.itextpdf.kernel.xmp.options.AliasOptions -> v1.a:
    int getValidOptions() -> f
    boolean isArray() -> i
    boolean isArrayAltText() -> j
    boolean isSimple() -> k
    com.itextpdf.kernel.xmp.options.AliasOptions setArrayAltText(boolean) -> l
    com.itextpdf.kernel.xmp.options.AliasOptions setArrayOrdered(boolean) -> m
    com.itextpdf.kernel.xmp.options.PropertyOptions toPropertyOptions() -> n
com.itextpdf.kernel.xmp.options.Options -> v1.b:
    java.util.Map optionNames -> b
    int options -> a
    void assertConsistency(int) -> a
    void assertOptionsValid(int) -> b
    boolean containsOneOf(int) -> c
    boolean getOption(int) -> d
    int getOptions() -> e
    int getValidOptions() -> f
    void setOption(int,boolean) -> g
    void setOptions(int) -> h
com.itextpdf.kernel.xmp.options.ParseOptions -> v1.c:
    int getValidOptions() -> f
    boolean getAcceptLatin1() -> i
    boolean getFixControlChars() -> j
    boolean getOmitNormalization() -> k
    boolean getRequireXMPMeta() -> l
    boolean getStrictAliasing() -> m
com.itextpdf.kernel.xmp.options.PropertyOptions -> v1.d:
    com.itextpdf.kernel.xmp.options.PropertyOptions setHasQualifiers(boolean) -> A
    com.itextpdf.kernel.xmp.options.PropertyOptions setHasType(boolean) -> B
    com.itextpdf.kernel.xmp.options.PropertyOptions setQualifier(boolean) -> C
    com.itextpdf.kernel.xmp.options.PropertyOptions setSchemaNode(boolean) -> D
    com.itextpdf.kernel.xmp.options.PropertyOptions setStruct(boolean) -> E
    com.itextpdf.kernel.xmp.options.PropertyOptions setURI(boolean) -> F
    void assertConsistency(int) -> a
    int getValidOptions() -> f
    boolean getHasLanguage() -> i
    boolean isArray() -> j
    boolean isArrayAltText() -> k
    boolean isArrayAlternate() -> l
    boolean isArrayOrdered() -> m
    boolean isCompositeProperty() -> n
    boolean isOnlyArrayOptions() -> o
    boolean isQualifier() -> p
    boolean isSchemaNode() -> q
    boolean isSimple() -> r
    boolean isStruct() -> s
    boolean isURI() -> t
    void mergeWith(com.itextpdf.kernel.xmp.options.PropertyOptions) -> u
    com.itextpdf.kernel.xmp.options.PropertyOptions setArray(boolean) -> v
    com.itextpdf.kernel.xmp.options.PropertyOptions setArrayAltText(boolean) -> w
    com.itextpdf.kernel.xmp.options.PropertyOptions setArrayAlternate(boolean) -> x
    com.itextpdf.kernel.xmp.options.PropertyOptions setArrayOrdered(boolean) -> y
    com.itextpdf.kernel.xmp.options.PropertyOptions setHasLanguage(boolean) -> z
com.itextpdf.kernel.xmp.options.SerializeOptions -> v1.e:
    int baseIndent -> f
    boolean omitVersionAttribute -> g
    int padding -> c
    java.lang.String indent -> e
    java.lang.String newline -> d
    com.itextpdf.kernel.xmp.options.SerializeOptions setPadding(int) -> A
    int getValidOptions() -> f
    int getBaseIndent() -> i
    boolean getEncodeUTF16BE() -> j
    boolean getEncodeUTF16LE() -> k
    java.lang.String getEncoding() -> l
    boolean getExactPacketLength() -> m
    boolean getIncludeThumbnailPad() -> n
    java.lang.String getIndent() -> o
    java.lang.String getNewline() -> p
    boolean getOmitPacketWrapper() -> q
    boolean getOmitVersionAttribute() -> r
    boolean getOmitXmpMetaElement() -> s
    int getPadding() -> t
    boolean getReadOnlyPacket() -> u
    boolean getSort() -> v
    boolean getUseCanonicalFormat() -> w
    com.itextpdf.kernel.xmp.options.SerializeOptions setBaseIndent(int) -> x
    com.itextpdf.kernel.xmp.options.SerializeOptions setIndent(java.lang.String) -> y
    com.itextpdf.kernel.xmp.options.SerializeOptions setNewline(java.lang.String) -> z
com.itextpdf.kernel.xmp.properties.XMPAliasInfo -> w1.a:
    java.lang.String getNamespace() -> b
    java.lang.String getPrefix() -> g
    java.lang.String getPropName() -> h
    com.itextpdf.kernel.xmp.options.AliasOptions getAliasForm() -> i
com.itextpdf.kernel.xmp.properties.XMPProperty -> w1.b:
com.itextpdf.layout.Canvas -> x1.a:
    boolean isCanvasOfPage -> d3
    com.itextpdf.kernel.pdf.PdfPage page -> c3
    com.itextpdf.kernel.geom.Rectangle rootArea -> b3
    com.itextpdf.kernel.pdf.canvas.PdfCanvas pdfCanvas -> a3
    com.itextpdf.layout.renderer.RootRenderer ensureRootRendererNotNull() -> L
    com.itextpdf.kernel.pdf.PdfPage getPage() -> O
    com.itextpdf.kernel.pdf.canvas.PdfCanvas getPdfCanvas() -> P
    com.itextpdf.kernel.pdf.PdfDocument getPdfDocument() -> Q
    com.itextpdf.kernel.geom.Rectangle getRootArea() -> R
    boolean isAutoTaggingEnabled() -> S
    boolean isCanvasOfPage() -> T
com.itextpdf.layout.Document -> x1.b:
    com.itextpdf.layout.IPropertyContainer add(com.itextpdf.layout.element.IBlockElement) -> H
    com.itextpdf.layout.renderer.RootRenderer ensureRootRendererNotNull() -> L
    com.itextpdf.layout.Document add(com.itextpdf.layout.element.IBlockElement) -> O
    void checkClosingStatus() -> P
    com.itextpdf.kernel.pdf.PdfDocument getPdfDocument() -> Q
    java.lang.Object getDefaultProperty(int) -> g
com.itextpdf.layout.ElementPropertyContainer -> x1.c:
    java.util.Map properties -> R2
    com.itextpdf.layout.IPropertyContainer setFixedPosition(float,float,com.itextpdf.layout.properties.UnitValue) -> A
    com.itextpdf.layout.IPropertyContainer setFixedPosition(int,float,float,float) -> B
    com.itextpdf.layout.IPropertyContainer setFixedPosition(int,float,float,com.itextpdf.layout.properties.UnitValue) -> C
    com.itextpdf.layout.IPropertyContainer setFont(com.itextpdf.kernel.font.PdfFont) -> D
    com.itextpdf.layout.IPropertyContainer setFontSize(float) -> E
    com.itextpdf.layout.IPropertyContainer setHorizontalAlignment(com.itextpdf.layout.properties.HorizontalAlignment) -> F
    com.itextpdf.layout.IPropertyContainer setTextAlignment(com.itextpdf.layout.properties.TextAlignment) -> G
    boolean hasOwnProperty(int) -> c
    boolean hasProperty(int) -> f
    java.lang.Object getDefaultProperty(int) -> g
    void setProperty(int,java.lang.Object) -> m
    java.lang.Object getProperty(int) -> r
    java.lang.Object getOwnProperty(int) -> u
    void deleteOwnProperty(int) -> x
    com.itextpdf.layout.IPropertyContainer setFixedPosition(float,float,float) -> z
com.itextpdf.layout.IPropertyContainer -> x1.d:
    boolean hasOwnProperty(int) -> c
    boolean hasProperty(int) -> f
    java.lang.Object getDefaultProperty(int) -> g
    void setProperty(int,java.lang.Object) -> m
    java.lang.Object getProperty(int) -> r
    java.lang.Object getOwnProperty(int) -> u
    void deleteOwnProperty(int) -> x
com.itextpdf.layout.RootElement -> x1.e:
    com.itextpdf.kernel.pdf.PdfDocument pdfDocument -> T2
    com.itextpdf.kernel.font.PdfFont defaultFont -> V2
    boolean immediateFlush -> S2
    com.itextpdf.layout.splitting.ISplitCharacters defaultSplitCharacters -> X2
    com.itextpdf.layout.font.FontProvider defaultFontProvider -> W2
    com.itextpdf.layout.tagging.LayoutTaggingHelper defaultLayoutTaggingHelper -> Z2
    java.util.List childElements -> U2
    com.itextpdf.layout.renderer.RootRenderer rootRenderer -> Y2
    com.itextpdf.layout.IPropertyContainer add(com.itextpdf.layout.element.IBlockElement) -> H
    com.itextpdf.layout.IPropertyContainer add(com.itextpdf.layout.element.Image) -> I
    com.itextpdf.layout.IPropertyContainer addElement(com.itextpdf.layout.element.IElement) -> J
    void createAndAddRendererSubTree(com.itextpdf.layout.element.IElement) -> K
    com.itextpdf.layout.renderer.RootRenderer ensureRootRendererNotNull() -> L
    com.itextpdf.layout.tagging.LayoutTaggingHelper initTaggingHelperIfNeeded() -> M
    com.itextpdf.layout.IPropertyContainer showTextAligned(com.itextpdf.layout.element.Paragraph,float,float,int,com.itextpdf.layout.properties.TextAlignment,com.itextpdf.layout.properties.VerticalAlignment,float) -> N
    boolean hasOwnProperty(int) -> c
    boolean hasProperty(int) -> f
    java.lang.Object getDefaultProperty(int) -> g
    void setProperty(int,java.lang.Object) -> m
    java.lang.Object getProperty(int) -> r
    java.lang.Object getOwnProperty(int) -> u
    void deleteOwnProperty(int) -> x
com.itextpdf.layout.Style -> x1.f:
com.itextpdf.layout.borders.Border -> y1.a:
    com.itextpdf.layout.borders.Border NO_BORDER -> d
    float width -> b
    int hash -> c
    com.itextpdf.layout.properties.TransparentColor transparentColor -> a
    void draw(com.itextpdf.kernel.pdf.canvas.PdfCanvas,float,float,float,float,float,float,float,float,com.itextpdf.layout.borders.Border$Side,float,float) -> a
    void draw(com.itextpdf.kernel.pdf.canvas.PdfCanvas,float,float,float,float,com.itextpdf.layout.borders.Border$Side,float,float) -> b
    void drawCellBorder(com.itextpdf.kernel.pdf.canvas.PdfCanvas,float,float,float,float,com.itextpdf.layout.borders.Border$Side) -> c
    com.itextpdf.layout.borders.Border$Side getBorderSide(float,float,float,float,com.itextpdf.layout.borders.Border$Side) -> d
    com.itextpdf.kernel.colors.Color getColor() -> e
    com.itextpdf.kernel.geom.Point getIntersectionPoint(com.itextpdf.kernel.geom.Point,com.itextpdf.kernel.geom.Point,com.itextpdf.kernel.geom.Point,com.itextpdf.kernel.geom.Point) -> f
    int getType() -> g
    float getWidth() -> h
com.itextpdf.layout.borders.Border$Side -> y1.a$a:
    com.itextpdf.layout.borders.Border$Side LEFT -> U2
    com.itextpdf.layout.borders.Border$Side BOTTOM -> T2
    com.itextpdf.layout.borders.Border$Side[] $VALUES -> V2
    com.itextpdf.layout.borders.Border$Side RIGHT -> S2
    com.itextpdf.layout.borders.Border$Side TOP -> R2
    com.itextpdf.layout.borders.Border$Side NONE -> Q2
com.itextpdf.layout.borders.SolidBorder -> y1.b:
    void draw(com.itextpdf.kernel.pdf.canvas.PdfCanvas,float,float,float,float,float,float,float,float,com.itextpdf.layout.borders.Border$Side,float,float) -> a
    void draw(com.itextpdf.kernel.pdf.canvas.PdfCanvas,float,float,float,float,com.itextpdf.layout.borders.Border$Side,float,float) -> b
    void drawCellBorder(com.itextpdf.kernel.pdf.canvas.PdfCanvas,float,float,float,float,com.itextpdf.layout.borders.Border$Side) -> c
    int getType() -> g
com.itextpdf.layout.borders.SolidBorder$1 -> y1.b$a:
    int[] $SwitchMap$com$itextpdf$layout$borders$Border$Side -> a
com.itextpdf.layout.element.AbstractElement -> z1.a:
    java.util.Set styles -> U2
    java.util.List childElements -> T2
    com.itextpdf.layout.renderer.IRenderer nextRenderer -> S2
    com.itextpdf.layout.renderer.IRenderer getRenderer() -> H
    boolean isEmpty() -> I
    com.itextpdf.layout.renderer.IRenderer makeNewRenderer() -> J
    boolean hasProperty(int) -> f
    com.itextpdf.layout.renderer.IRenderer createRendererSubTree() -> p
    java.lang.Object getProperty(int) -> r
com.itextpdf.layout.element.AreaBreak -> z1.b:
com.itextpdf.layout.element.BlockElement -> z1.c:
    com.itextpdf.layout.properties.UnitValue getWidth() -> K
    com.itextpdf.layout.element.IElement setMarginBottom(float) -> L
    com.itextpdf.layout.element.IElement setMarginLeft(float) -> M
    com.itextpdf.layout.element.IElement setMarginRight(float) -> N
    com.itextpdf.layout.element.IElement setMarginTop(float) -> O
    com.itextpdf.layout.element.IElement setMargins(float,float,float,float) -> P
    com.itextpdf.layout.element.IElement setMinHeight(float) -> Q
    com.itextpdf.layout.element.IElement setNeutralRole() -> R
    com.itextpdf.layout.element.IElement setRotationAngle(float) -> S
    com.itextpdf.layout.element.IElement setVerticalAlignment(com.itextpdf.layout.properties.VerticalAlignment) -> T
    com.itextpdf.layout.element.IElement setWidth(float) -> U
    java.lang.Object getDefaultProperty(int) -> g
com.itextpdf.layout.element.Cell -> z1.d:
    int row -> V2
    com.itextpdf.layout.borders.Border DEFAULT_BORDER -> a3
    int colspan -> Y2
    int col -> W2
    int rowspan -> X2
    com.itextpdf.kernel.pdf.tagutils.DefaultAccessibilityProperties tagProperties -> Z2
    com.itextpdf.layout.renderer.IRenderer getRenderer() -> H
    com.itextpdf.layout.renderer.IRenderer makeNewRenderer() -> J
    com.itextpdf.layout.element.Cell clone(boolean) -> V
    int getCol() -> W
    int getColspan() -> X
    int getRow() -> Y
    int getRowspan() -> Z
    java.lang.Object getDefaultProperty(int) -> g
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties getAccessibilityProperties() -> j
com.itextpdf.layout.element.Div -> z1.e:
    com.itextpdf.kernel.pdf.tagutils.DefaultAccessibilityProperties tagProperties -> V2
    com.itextpdf.layout.renderer.IRenderer makeNewRenderer() -> J
    com.itextpdf.layout.element.Div add(com.itextpdf.layout.element.IBlockElement) -> V
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties getAccessibilityProperties() -> j
com.itextpdf.layout.element.IBlockElement -> z1.f:
com.itextpdf.layout.element.IElement -> z1.g:
    com.itextpdf.layout.renderer.IRenderer createRendererSubTree() -> p
com.itextpdf.layout.element.ILargeElement -> z1.h:
    void flushContent() -> o
    void setDocument(com.itextpdf.layout.Document) -> q
    boolean isComplete() -> s
com.itextpdf.layout.element.ILeafElement -> z1.i:
com.itextpdf.layout.element.Image -> z1.j:
    com.itextpdf.kernel.pdf.xobject.PdfXObject xObject -> V2
    com.itextpdf.kernel.pdf.tagutils.DefaultAccessibilityProperties tagProperties -> W2
    com.itextpdf.layout.renderer.IRenderer makeNewRenderer() -> J
    com.itextpdf.io.image.ImageData checkImageType(com.itextpdf.io.image.ImageData) -> K
    float getImageHeight() -> L
    float getImageWidth() -> M
    com.itextpdf.layout.properties.ObjectFit getObjectFit() -> N
    com.itextpdf.layout.properties.UnitValue getWidth() -> O
    com.itextpdf.kernel.pdf.xobject.PdfXObject getXObject() -> P
    com.itextpdf.layout.element.Image setFixedPosition(int,float,float) -> Q
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties getAccessibilityProperties() -> j
com.itextpdf.layout.element.Paragraph -> z1.k:
    com.itextpdf.kernel.pdf.tagutils.DefaultAccessibilityProperties tagProperties -> V2
    com.itextpdf.layout.renderer.IRenderer makeNewRenderer() -> J
    com.itextpdf.layout.element.Paragraph add(com.itextpdf.layout.element.ILeafElement) -> V
    com.itextpdf.layout.element.Paragraph setMultipliedLeading(float) -> W
    java.lang.Object getDefaultProperty(int) -> g
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties getAccessibilityProperties() -> j
com.itextpdf.layout.element.Table -> z1.l:
    int rowWindowStart -> g3
    com.itextpdf.layout.element.Table footer -> b3
    com.itextpdf.layout.element.Table header -> a3
    boolean skipFirstHeader -> c3
    boolean skipLastFooter -> d3
    boolean isComplete -> e3
    com.itextpdf.layout.Document document -> h3
    java.util.List rows -> W2
    com.itextpdf.layout.element.Cell[] lastAddedRow -> i3
    int currentColumn -> Y2
    int currentRow -> Z2
    com.itextpdf.layout.properties.UnitValue[] columnWidths -> X2
    com.itextpdf.kernel.pdf.tagutils.DefaultAccessibilityProperties tagProperties -> V2
    com.itextpdf.layout.element.Div caption -> j3
    java.util.List lastAddedRowGroups -> f3
    com.itextpdf.layout.renderer.IRenderer getRenderer() -> H
    com.itextpdf.layout.renderer.IRenderer makeNewRenderer() -> J
    boolean cellBelongsToAnyRowGroup(com.itextpdf.layout.element.Cell,java.util.List) -> V
    com.itextpdf.layout.element.Div getCaption() -> W
    com.itextpdf.layout.properties.UnitValue getColumnWidth(int) -> X
    com.itextpdf.layout.element.Table getFooter() -> Y
    com.itextpdf.layout.element.Table getHeader() -> Z
    java.util.List getLastRowBottomBorder() -> a0
    int getNumberOfColumns() -> b0
    int getNumberOfRows() -> c0
    java.util.List getRowGroups() -> d0
    boolean isSkipFirstHeader() -> e0
    boolean isSkipLastFooter() -> f0
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties getAccessibilityProperties() -> j
    void flushContent() -> o
    com.itextpdf.layout.renderer.IRenderer createRendererSubTree() -> p
    void setDocument(com.itextpdf.layout.Document) -> q
    boolean isComplete() -> s
com.itextpdf.layout.element.Table$RowRange -> z1.l$a:
    int finishRow -> b
    int startRow -> a
    int getFinishRow() -> a
    int getStartRow() -> b
com.itextpdf.layout.element.Text -> z1.m:
    java.lang.String text -> V2
    com.itextpdf.kernel.pdf.tagutils.DefaultAccessibilityProperties tagProperties -> W2
    com.itextpdf.layout.renderer.IRenderer makeNewRenderer() -> J
    java.lang.String getText() -> K
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties getAccessibilityProperties() -> j
com.itextpdf.layout.font.ComplexFontSelectorStrategy -> a2.a:
    com.itextpdf.kernel.font.PdfFont font -> e
    com.itextpdf.layout.font.FontSelector selector -> f
    com.itextpdf.kernel.font.PdfFont getCurrentFont() -> b
    java.util.List nextGlyphs() -> d
    boolean isSignificantUnicodeScript(java.lang.Character$UnicodeScript) -> e
    boolean isSurrogatePair(java.lang.String,int) -> f
    int nextSignificantIndex() -> g
    java.lang.Character$UnicodeScript nextSignificantUnicodeScript(int) -> h
com.itextpdf.layout.font.FontCharacteristics -> a2.b:
    boolean isMonospace -> e
    boolean isItalic -> a
    short fontWeight -> c
    boolean isBold -> b
    boolean undefined -> d
    boolean isUndefined() -> a
    void modified() -> b
    com.itextpdf.layout.font.FontCharacteristics setBoldFlag(boolean) -> c
    com.itextpdf.layout.font.FontCharacteristics setFontStyle(java.lang.String) -> d
    com.itextpdf.layout.font.FontCharacteristics setFontWeight(java.lang.String) -> e
    com.itextpdf.layout.font.FontCharacteristics setFontWeight(short) -> f
    com.itextpdf.layout.font.FontCharacteristics setItalicFlag(boolean) -> g
    com.itextpdf.layout.font.FontCharacteristics setMonospaceFlag(boolean) -> h
com.itextpdf.layout.font.FontCharacteristicsUtils -> a2.c:
    short normalizeFontWeight(short) -> a
    short parseFontWeight(java.lang.String) -> b
com.itextpdf.layout.font.FontInfo -> a2.d:
    byte[] fontData -> b
    java.lang.String fontName -> a
    java.util.Map fontNamesCache -> e
    int hash -> c
    java.lang.String encoding -> d
    com.itextpdf.io.font.FontProgramDescriptor getDescriptor() -> a
    java.lang.String getEncoding() -> b
    byte[] getFontData() -> c
    java.lang.String getFontName() -> d
    com.itextpdf.layout.font.Range getFontUnicodeRange() -> e
com.itextpdf.layout.font.FontProvider -> a2.e:
    com.itextpdf.layout.font.FontSelectorCache fontSelectorCache -> b
    java.util.Map pdfFonts -> d
    com.itextpdf.layout.font.FontSet fontSet -> a
    java.lang.String defaultFontFamily -> c
    com.itextpdf.layout.font.FontSelector createFontSelector(java.util.Collection,java.util.List,com.itextpdf.layout.font.FontCharacteristics) -> a
    boolean getDefaultCacheFlag() -> b
    boolean getDefaultEmbeddingFlag() -> c
    java.lang.String getDefaultEncoding(com.itextpdf.io.font.FontProgram) -> d
    com.itextpdf.layout.font.FontSelector getFontSelector(java.util.List,com.itextpdf.layout.font.FontCharacteristics,com.itextpdf.layout.font.FontSet) -> e
    com.itextpdf.layout.font.FontSet getFontSet() -> f
    com.itextpdf.kernel.font.PdfFont getPdfFont(com.itextpdf.layout.font.FontInfo,com.itextpdf.layout.font.FontSet) -> g
    com.itextpdf.layout.font.FontSelectorStrategy getStrategy(java.lang.String,java.util.List,com.itextpdf.layout.font.FontCharacteristics,com.itextpdf.layout.font.FontSet) -> h
com.itextpdf.layout.font.FontSelector -> a2.f:
    java.util.List fonts -> a
    com.itextpdf.layout.font.FontInfo bestMatch() -> a
    java.util.Comparator getComparator(java.util.List,com.itextpdf.layout.font.FontCharacteristics) -> b
    java.lang.Iterable getFonts() -> c
com.itextpdf.layout.font.FontSelector$PdfFontComparator -> a2.f$a:
    java.util.List fontStyles -> b
    java.util.List fontFamilies -> a
    int characteristicsSimilarity(java.lang.String,com.itextpdf.layout.font.FontCharacteristics,com.itextpdf.layout.font.FontInfo,boolean) -> a
    int compare(com.itextpdf.layout.font.FontInfo,com.itextpdf.layout.font.FontInfo) -> b
    com.itextpdf.layout.font.FontCharacteristics parseFontStyle(java.lang.String,com.itextpdf.layout.font.FontCharacteristics) -> c
com.itextpdf.layout.font.FontSelectorCache -> a2.g:
    com.itextpdf.layout.font.FontSelectorCache$FontSetSelectors defaultSelectors -> a
    java.util.Map caches -> c
    com.itextpdf.layout.font.FontSet defaultFontSet -> b
    com.itextpdf.layout.font.FontSelector get(com.itextpdf.layout.font.FontSelectorKey) -> a
    com.itextpdf.layout.font.FontSelector get(com.itextpdf.layout.font.FontSelectorKey,com.itextpdf.layout.font.FontSet) -> b
    void put(com.itextpdf.layout.font.FontSelectorKey,com.itextpdf.layout.font.FontSelector) -> c
    void put(com.itextpdf.layout.font.FontSelectorKey,com.itextpdf.layout.font.FontSelector,com.itextpdf.layout.font.FontSet) -> d
    boolean update(com.itextpdf.layout.font.FontSelectorCache$FontSetSelectors,com.itextpdf.layout.font.FontSet) -> e
com.itextpdf.layout.font.FontSelectorCache$1 -> a2.g$a:
com.itextpdf.layout.font.FontSelectorCache$FontSetSelectors -> a2.g$b:
    java.util.Map map -> a
    int fontSetSize -> b
    boolean update(com.itextpdf.layout.font.FontSet) -> a
com.itextpdf.layout.font.FontSelectorKey -> a2.h:
    java.util.List fontFamilies -> a
    com.itextpdf.layout.font.FontCharacteristics fc -> b
com.itextpdf.layout.font.FontSelectorStrategy -> a2.i:
    com.itextpdf.layout.font.FontProvider provider -> c
    com.itextpdf.layout.font.FontSet additionalFonts -> d
    java.lang.String text -> a
    int index -> b
    boolean endOfText() -> a
    com.itextpdf.kernel.font.PdfFont getCurrentFont() -> b
    com.itextpdf.kernel.font.PdfFont getPdfFont(com.itextpdf.layout.font.FontInfo) -> c
    java.util.List nextGlyphs() -> d
com.itextpdf.layout.font.FontSet -> a2.j:
    java.util.Map fontPrograms -> b
    java.util.Set fonts -> a
    long id -> c
    java.util.concurrent.atomic.AtomicLong lastId -> d
    com.itextpdf.io.font.FontProgram getFontProgram(com.itextpdf.layout.font.FontInfo) -> a
    java.util.Collection getFonts(com.itextpdf.layout.font.FontSet) -> b
    long getId() -> c
    boolean isEmpty() -> d
    int size() -> e
com.itextpdf.layout.font.FontSetCollection -> a2.k:
    java.util.Collection additional -> R2
    java.util.Collection primary -> Q2
    java.util.Collection access$000(com.itextpdf.layout.font.FontSetCollection) -> a
    java.util.Collection access$100(com.itextpdf.layout.font.FontSetCollection) -> b
com.itextpdf.layout.font.FontSetCollection$1 -> a2.k$a:
    java.util.Iterator i -> Q2
    boolean isPrimary -> R2
    com.itextpdf.layout.font.FontSetCollection this$0 -> S2
    com.itextpdf.layout.font.FontInfo next() -> a
com.itextpdf.layout.font.Range -> a2.l:
com.itextpdf.layout.hyphenation.Hyphenation -> b2.a:
com.itextpdf.layout.hyphenation.HyphenationConfig -> b2.b:
    com.itextpdf.layout.hyphenation.Hyphenation hyphenate(java.lang.String) -> a
com.itextpdf.layout.layout.LayoutArea -> c2.a:
    int pageNumber -> Q2
    com.itextpdf.kernel.geom.Rectangle bBox -> R2
    com.itextpdf.layout.layout.LayoutArea clone() -> a
    com.itextpdf.kernel.geom.Rectangle getBBox() -> b
    int getPageNumber() -> c
    void setBBox(com.itextpdf.kernel.geom.Rectangle) -> d
com.itextpdf.layout.layout.LayoutContext -> c2.b:
    java.util.List floatRendererAreas -> c
    com.itextpdf.layout.margincollapse.MarginsCollapseInfo marginsCollapseInfo -> b
    com.itextpdf.layout.layout.LayoutArea area -> a
    boolean clippedHeight -> d
    com.itextpdf.layout.layout.LayoutArea getArea() -> a
    java.util.List getFloatRendererAreas() -> b
    com.itextpdf.layout.margincollapse.MarginsCollapseInfo getMarginsCollapseInfo() -> c
    boolean isClippedHeight() -> d
    void setClippedHeight(boolean) -> e
com.itextpdf.layout.layout.LayoutResult -> c2.c:
    com.itextpdf.layout.renderer.IRenderer splitRenderer -> c
    com.itextpdf.layout.renderer.IRenderer overflowRenderer -> d
    com.itextpdf.layout.renderer.IRenderer causeOfNothing -> e
    com.itextpdf.layout.layout.LayoutArea occupiedArea -> b
    int status -> a
    com.itextpdf.layout.element.AreaBreak getAreaBreak() -> a
    com.itextpdf.layout.renderer.IRenderer getCauseOfNothing() -> b
    com.itextpdf.layout.layout.LayoutArea getOccupiedArea() -> c
    com.itextpdf.layout.renderer.IRenderer getOverflowRenderer() -> d
    com.itextpdf.layout.renderer.IRenderer getSplitRenderer() -> e
    int getStatus() -> f
    com.itextpdf.layout.layout.LayoutResult setAreaBreak(com.itextpdf.layout.element.AreaBreak) -> g
    void setOverflowRenderer(com.itextpdf.layout.renderer.IRenderer) -> h
    void setSplitRenderer(com.itextpdf.layout.renderer.IRenderer) -> i
    void setStatus(int) -> j
com.itextpdf.layout.layout.LineLayoutContext -> c2.d:
    float textIndent -> f
    boolean floatOverflowedToNextPageWithNothing -> e
    float getTextIndent() -> f
    boolean isFloatOverflowedToNextPageWithNothing() -> g
    com.itextpdf.layout.layout.LineLayoutContext setFloatOverflowedToNextPageWithNothing(boolean) -> h
    com.itextpdf.layout.layout.LineLayoutContext setTextIndent(float) -> i
com.itextpdf.layout.layout.LineLayoutResult -> c2.e:
    boolean splitForcedByNewline -> g
    java.util.List floatsOverflowedToNextPage -> h
    java.util.List getFloatsOverflowedToNextPage() -> m
    boolean isSplitForcedByNewline() -> n
    void setFloatsOverflowedToNextPage(java.util.List) -> o
    com.itextpdf.layout.layout.LineLayoutResult setSplitForcedByNewline(boolean) -> p
com.itextpdf.layout.layout.MinMaxWidthLayoutResult -> c2.f:
    com.itextpdf.layout.minmaxwidth.MinMaxWidth minMaxWidth -> f
    com.itextpdf.layout.minmaxwidth.MinMaxWidth getMinMaxWidth() -> k
    com.itextpdf.layout.layout.MinMaxWidthLayoutResult setMinMaxWidth(com.itextpdf.layout.minmaxwidth.MinMaxWidth) -> l
com.itextpdf.layout.layout.PositionedLayoutContext -> c2.g:
    com.itextpdf.layout.layout.LayoutArea parentOccupiedArea -> e
    com.itextpdf.layout.layout.LayoutArea getParentOccupiedArea() -> f
com.itextpdf.layout.layout.RootLayoutArea -> c2.h:
    boolean emptyArea -> S2
    com.itextpdf.layout.layout.LayoutArea clone() -> a
    boolean isEmptyArea() -> e
    void setEmptyArea(boolean) -> f
com.itextpdf.layout.layout.TextLayoutResult -> c2.i:
    float leftMinWidth -> l
    boolean containsPossibleBreak -> i
    boolean startsWithSplitCharacterWhiteSpace -> j
    boolean endsWithSplitCharacter -> k
    boolean wordHasBeenSplit -> g
    boolean splitForcedByNewline -> h
    float rightMinWidth -> m
    float getLeftMinWidth() -> m
    float getRightMinWidth() -> n
    boolean isContainsPossibleBreak() -> o
    boolean isEndsWithSplitCharacter() -> p
    boolean isSplitForcedByNewline() -> q
    boolean isStartsWithSplitCharacterWhiteSpace() -> r
    boolean isWordHasBeenSplit() -> s
    com.itextpdf.layout.layout.TextLayoutResult setContainsPossibleBreak(boolean) -> t
    com.itextpdf.layout.layout.TextLayoutResult setEndsWithSplitCharacter(boolean) -> u
    com.itextpdf.layout.layout.TextLayoutResult setLeftMinWidth(float) -> v
    com.itextpdf.layout.layout.TextLayoutResult setRightMinWidth(float) -> w
    com.itextpdf.layout.layout.TextLayoutResult setSplitForcedByNewline(boolean) -> x
    com.itextpdf.layout.layout.TextLayoutResult setStartsWithSplitCharacterWhiteSpace(boolean) -> y
    com.itextpdf.layout.layout.TextLayoutResult setWordHasBeenSplit(boolean) -> z
com.itextpdf.layout.margincollapse.MarginsCollapse -> d2.a:
    float maxPositiveMargin -> Q2
    float minNegativeMargin -> R2
    com.itextpdf.layout.margincollapse.MarginsCollapse clone() -> a
    float getCollapsedMarginsSize() -> b
    void joinMargin(float) -> c
    void joinMargin(com.itextpdf.layout.margincollapse.MarginsCollapse) -> d
com.itextpdf.layout.margincollapse.MarginsCollapseHandler -> d2.b:
    com.itextpdf.layout.renderer.IRenderer renderer -> a
    com.itextpdf.kernel.geom.Rectangle backupLayoutBox -> h
    com.itextpdf.layout.margincollapse.MarginsCollapseInfo backupCollapseInfo -> i
    boolean lastKidCollapsedAfterHasClearanceApplied -> j
    com.itextpdf.layout.margincollapse.MarginsCollapseInfo prevChildMarginInfo -> d
    int processedChildrenNum -> f
    com.itextpdf.layout.margincollapse.MarginsCollapseInfo childMarginInfo -> c
    com.itextpdf.layout.margincollapse.MarginsCollapseInfo collapseInfo -> b
    int firstNotEmptyKidIndex -> e
    java.util.List rendererChildren -> g
    boolean lastChildMarginAdjoinedToParent(com.itextpdf.layout.renderer.IRenderer) -> A
    boolean marginsCouldBeSelfCollapsing(com.itextpdf.layout.renderer.IRenderer) -> B
    void overrideModelBottomMargin(com.itextpdf.layout.renderer.IRenderer,float) -> C
    void overrideModelMargin(com.itextpdf.layout.renderer.IRenderer,int,float) -> D
    void overrideModelTopMargin(com.itextpdf.layout.renderer.IRenderer,float) -> E
    void prepareBoxForLayoutAttempt(com.itextpdf.kernel.geom.Rectangle,int,boolean) -> F
    void processFixedHeightAdjustment(float) -> G
    void processUsedChildBufferSpaceOnTop(com.itextpdf.kernel.geom.Rectangle) -> H
    com.itextpdf.layout.renderer.IRenderer removeRendererChild(int) -> I
    boolean rendererIsFloated(com.itextpdf.layout.renderer.IRenderer) -> J
    void restoreLayoutBoxAfterFailedLayoutAttempt(com.itextpdf.kernel.geom.Rectangle) -> K
    com.itextpdf.layout.margincollapse.MarginsCollapseInfo startChildMarginsHandling(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.kernel.geom.Rectangle) -> L
    void startMarginsCollapse(com.itextpdf.kernel.geom.Rectangle) -> M
    void subtractUsedTopBufferFromBottomBuffer(float) -> N
    void updateCollapseBeforeIfPrevKidIsFirstAndSelfCollapsed(com.itextpdf.layout.margincollapse.MarginsCollapse) -> O
    void addNotYetAppliedTopMargin(com.itextpdf.kernel.geom.Rectangle) -> a
    void applyBottomMargin(com.itextpdf.kernel.geom.Rectangle,float) -> b
    void applyClearance(float) -> c
    void applySelfCollapsedKidMarginWithClearance(com.itextpdf.kernel.geom.Rectangle) -> d
    void applyTopMargin(com.itextpdf.kernel.geom.Rectangle,float) -> e
    com.itextpdf.layout.margincollapse.MarginsCollapseInfo createMarginsInfoForBlockChild(int) -> f
    float defineBottomMarginValueForCollapse(com.itextpdf.layout.renderer.IRenderer) -> g
    float defineMarginValueForCollapse(com.itextpdf.layout.renderer.IRenderer,int) -> h
    float defineTopMarginValueForCollapse(com.itextpdf.layout.renderer.IRenderer) -> i
    void endChildMarginsHandling(com.itextpdf.kernel.geom.Rectangle) -> j
    void endMarginsCollapse(com.itextpdf.kernel.geom.Rectangle) -> k
    boolean firstChildMarginAdjoinedToParent(com.itextpdf.layout.renderer.IRenderer) -> l
    void fixPrevChildOccupiedArea(int) -> m
    com.itextpdf.layout.renderer.IRenderer getRendererChild(int) -> n
    void getRidOfCollapseArtifactsAtopOccupiedArea() -> o
    boolean hasBorders(com.itextpdf.layout.renderer.IRenderer,int) -> p
    boolean hasBottomBorders(com.itextpdf.layout.renderer.IRenderer) -> q
    boolean hasBottomPadding(com.itextpdf.layout.renderer.IRenderer) -> r
    boolean hasHeightProp(com.itextpdf.layout.renderer.IRenderer) -> s
    boolean hasPadding(com.itextpdf.layout.renderer.IRenderer,int) -> t
    boolean hasPositiveHeight(com.itextpdf.layout.renderer.IRenderer) -> u
    boolean hasTopBorders(com.itextpdf.layout.renderer.IRenderer) -> v
    boolean hasTopPadding(com.itextpdf.layout.renderer.IRenderer) -> w
    void ignoreModelBottomMargin(com.itextpdf.layout.renderer.IRenderer) -> x
    void ignoreModelTopMargin(com.itextpdf.layout.renderer.IRenderer) -> y
    boolean isBlockElement(com.itextpdf.layout.renderer.IRenderer) -> z
com.itextpdf.layout.margincollapse.MarginsCollapseInfo -> d2.c:
    float usedBufferSpaceOnBottom -> j
    float usedBufferSpaceOnTop -> i
    float bufferSpaceOnBottom -> h
    float bufferSpaceOnTop -> g
    boolean clearanceApplied -> k
    com.itextpdf.layout.margincollapse.MarginsCollapse collapseBefore -> c
    com.itextpdf.layout.margincollapse.MarginsCollapse collapseAfter -> d
    boolean isSelfCollapsing -> f
    com.itextpdf.layout.margincollapse.MarginsCollapse ownCollapseAfter -> e
    boolean ignoreOwnMarginTop -> a
    boolean ignoreOwnMarginBottom -> b
    void copyTo(com.itextpdf.layout.margincollapse.MarginsCollapseInfo) -> a
    com.itextpdf.layout.margincollapse.MarginsCollapseInfo createDeepCopy(com.itextpdf.layout.margincollapse.MarginsCollapseInfo) -> b
    float getBufferSpaceOnBottom() -> c
    float getBufferSpaceOnTop() -> d
    com.itextpdf.layout.margincollapse.MarginsCollapse getCollapseAfter() -> e
    com.itextpdf.layout.margincollapse.MarginsCollapse getCollapseBefore() -> f
    com.itextpdf.layout.margincollapse.MarginsCollapse getOwnCollapseAfter() -> g
    float getUsedBufferSpaceOnBottom() -> h
    float getUsedBufferSpaceOnTop() -> i
    boolean isClearanceApplied() -> j
    boolean isIgnoreOwnMarginBottom() -> k
    boolean isIgnoreOwnMarginTop() -> l
    boolean isSelfCollapsing() -> m
    void setBufferSpaceOnBottom(float) -> n
    void setBufferSpaceOnTop(float) -> o
    void setClearanceApplied(boolean) -> p
    void setCollapseAfter(com.itextpdf.layout.margincollapse.MarginsCollapse) -> q
    void setOwnCollapseAfter(com.itextpdf.layout.margincollapse.MarginsCollapse) -> r
    void setSelfCollapsing(boolean) -> s
    void setUsedBufferSpaceOnBottom(float) -> t
    void setUsedBufferSpaceOnTop(float) -> u
    void updateFromCopy(com.itextpdf.layout.margincollapse.MarginsCollapseInfo,com.itextpdf.layout.margincollapse.MarginsCollapseInfo) -> v
com.itextpdf.layout.minmaxwidth.MinMaxWidth -> e2.a:
    float additionalWidth -> c
    float childrenMaxWidth -> b
    float childrenMinWidth -> a
    float getAdditionalWidth() -> a
    float getChildrenMaxWidth() -> b
    float getChildrenMinWidth() -> c
    float getMaxWidth() -> d
    float getMinWidth() -> e
    void setAdditionalWidth(float) -> f
    void setChildrenMaxWidth(float) -> g
    void setChildrenMinWidth(float) -> h
com.itextpdf.layout.minmaxwidth.MinMaxWidthUtils -> e2.b:
    com.itextpdf.layout.minmaxwidth.MinMaxWidth countDefaultMinMaxWidth(com.itextpdf.layout.renderer.IRenderer) -> a
    float getEps() -> b
    float getInfHeight() -> c
    float getInfWidth() -> d
    boolean isEqual(double,double) -> e
com.itextpdf.layout.minmaxwidth.RotationMinMaxWidth -> e2.c:
    double minWidthOrigin -> d
    double maxWidthOrigin -> e
    double minWidthHeight -> f
    double maxWidthHeight -> g
    double access$000(double) -> i
    double access$100(double) -> j
    com.itextpdf.layout.minmaxwidth.RotationMinMaxWidth calculate(double,double,com.itextpdf.layout.minmaxwidth.MinMaxWidth) -> k
    com.itextpdf.layout.minmaxwidth.RotationMinMaxWidth calculate(double,double,com.itextpdf.layout.minmaxwidth.MinMaxWidth,double) -> l
    com.itextpdf.layout.minmaxwidth.RotationMinMaxWidth calculate(com.itextpdf.layout.minmaxwidth.RotationMinMaxWidth$WidthFunction,double,double) -> m
    double calculateRotatedWidth(com.itextpdf.kernel.geom.Rectangle,double) -> n
    double correctSinCos(double) -> o
    double cos(double) -> p
    double getMaxWidthHeight() -> q
    double getMaxWidthOrigin() -> r
    double getMinWidthHeight() -> s
    double getMinWidthOrigin() -> t
    double sin(double) -> u
com.itextpdf.layout.minmaxwidth.RotationMinMaxWidth$WidthFunction -> e2.c$a:
    double sin -> a
    double cos -> b
    double area -> c
    double getRotatedHeight(double) -> a
    double getRotatedWidth(double) -> b
    com.itextpdf.layout.minmaxwidth.RotationMinMaxWidth$WidthFunction$Interval getValidOriginalWidths(double) -> c
    double getWidthDerivativeZeroPoint() -> d
com.itextpdf.layout.minmaxwidth.RotationMinMaxWidth$WidthFunction$Interval -> e2.c$a$a:
    double min -> a
    double max -> b
    double getMax() -> a
    double getMin() -> b
com.itextpdf.layout.properties.Background -> f2.a:
    float extraBottom -> e
    float extraTop -> d
    float extraRight -> c
    float extraLeft -> b
    com.itextpdf.layout.properties.BackgroundBox backgroundClip -> f
    com.itextpdf.layout.properties.TransparentColor transparentColor -> a
    com.itextpdf.layout.properties.BackgroundBox getBackgroundClip() -> a
    com.itextpdf.kernel.colors.Color getColor() -> b
    float getExtraBottom() -> c
    float getExtraLeft() -> d
    float getExtraRight() -> e
    float getExtraTop() -> f
    float getOpacity() -> g
com.itextpdf.layout.properties.BackgroundBox -> f2.b:
    com.itextpdf.layout.properties.BackgroundBox BORDER_BOX -> Q2
    com.itextpdf.layout.properties.BackgroundBox PADDING_BOX -> R2
    com.itextpdf.layout.properties.BackgroundBox CONTENT_BOX -> S2
    com.itextpdf.layout.properties.BackgroundBox[] $VALUES -> T2
com.itextpdf.layout.properties.BackgroundImage -> f2.c:
    com.itextpdf.kernel.pdf.xobject.PdfXObject image -> a
    com.itextpdf.layout.properties.BlendMode DEFAULT_BLEND_MODE -> d
    com.itextpdf.layout.properties.BackgroundSize backgroundSize -> b
    com.itextpdf.layout.properties.BackgroundBox backgroundOrigin -> c
    com.itextpdf.layout.properties.BackgroundBox getBackgroundOrigin() -> a
    com.itextpdf.layout.properties.BackgroundPosition getBackgroundPosition() -> b
    com.itextpdf.layout.properties.BackgroundSize getBackgroundSize() -> c
    com.itextpdf.kernel.pdf.xobject.PdfFormXObject getForm() -> d
    com.itextpdf.kernel.pdf.xobject.PdfImageXObject getImage() -> e
    float getImageHeight() -> f
    float getImageWidth() -> g
    com.itextpdf.kernel.colors.gradients.AbstractLinearGradientBuilder getLinearGradientBuilder() -> h
    boolean isBackgroundSpecified() -> i
com.itextpdf.layout.properties.BackgroundPosition -> f2.d:
com.itextpdf.layout.properties.BackgroundSize -> f2.e:
    com.itextpdf.layout.properties.UnitValue backgroundWidthSize -> a
    com.itextpdf.layout.properties.UnitValue backgroundHeightSize -> b
    boolean cover -> c
    boolean contain -> d
    void clear() -> a
    com.itextpdf.layout.properties.UnitValue getBackgroundHeightSize() -> b
    com.itextpdf.layout.properties.UnitValue getBackgroundWidthSize() -> c
    boolean isContain() -> d
    boolean isCover() -> e
    boolean isSpecificSize() -> f
    void setBackgroundSizeToValues(com.itextpdf.layout.properties.UnitValue,com.itextpdf.layout.properties.UnitValue) -> g
com.itextpdf.layout.properties.BaseDirection -> f2.f:
    com.itextpdf.layout.properties.BaseDirection[] $VALUES -> U2
    com.itextpdf.layout.properties.BaseDirection RIGHT_TO_LEFT -> T2
    com.itextpdf.layout.properties.BaseDirection LEFT_TO_RIGHT -> S2
    com.itextpdf.layout.properties.BaseDirection DEFAULT_BIDI -> R2
    com.itextpdf.layout.properties.BaseDirection NO_BIDI -> Q2
com.itextpdf.layout.properties.BlendMode -> f2.g:
    com.itextpdf.layout.properties.BlendMode SCREEN -> T2
    com.itextpdf.layout.properties.BlendMode OVERLAY -> U2
    com.itextpdf.layout.properties.BlendMode NORMAL -> R2
    com.itextpdf.layout.properties.BlendMode MULTIPLY -> S2
    com.itextpdf.layout.properties.BlendMode COLOR_DODGE -> X2
    com.itextpdf.layout.properties.BlendMode[] $VALUES -> h3
    com.itextpdf.layout.properties.BlendMode COLOR_BURN -> Y2
    com.itextpdf.layout.properties.BlendMode DARKEN -> V2
    com.itextpdf.layout.properties.BlendMode LIGHTEN -> W2
    com.itextpdf.layout.properties.BlendMode HARD_LIGHT -> Z2
    com.itextpdf.layout.properties.BlendMode SOFT_LIGHT -> a3
    com.itextpdf.layout.properties.BlendMode DIFFERENCE -> b3
    com.itextpdf.layout.properties.BlendMode SATURATION -> e3
    com.itextpdf.layout.properties.BlendMode COLOR -> f3
    com.itextpdf.layout.properties.BlendMode EXCLUSION -> c3
    com.itextpdf.kernel.pdf.PdfName pdfRepresentation -> Q2
    com.itextpdf.layout.properties.BlendMode HUE -> d3
    com.itextpdf.layout.properties.BlendMode LUMINOSITY -> g3
com.itextpdf.layout.properties.BorderCollapsePropertyValue -> f2.h:
    com.itextpdf.layout.properties.BorderCollapsePropertyValue COLLAPSE -> Q2
    com.itextpdf.layout.properties.BorderCollapsePropertyValue SEPARATE -> R2
    com.itextpdf.layout.properties.BorderCollapsePropertyValue[] $VALUES -> S2
com.itextpdf.layout.properties.BorderRadius -> f2.i:
    com.itextpdf.layout.properties.UnitValue horizontalRadius -> a
    com.itextpdf.layout.properties.UnitValue verticalRadius -> b
    com.itextpdf.layout.properties.UnitValue getHorizontalRadius() -> a
    com.itextpdf.layout.properties.UnitValue getVerticalRadius() -> b
com.itextpdf.layout.properties.BoxSizingPropertyValue -> f2.j:
    com.itextpdf.layout.properties.BoxSizingPropertyValue CONTENT_BOX -> Q2
    com.itextpdf.layout.properties.BoxSizingPropertyValue BORDER_BOX -> R2
    com.itextpdf.layout.properties.BoxSizingPropertyValue[] $VALUES -> S2
com.itextpdf.layout.properties.CaptionSide -> f2.k:
    com.itextpdf.layout.properties.CaptionSide[] $VALUES -> S2
    com.itextpdf.layout.properties.CaptionSide BOTTOM -> Q2
    com.itextpdf.layout.properties.CaptionSide TOP -> R2
com.itextpdf.layout.properties.ClearPropertyValue -> f2.l:
    com.itextpdf.layout.properties.ClearPropertyValue BOTH -> T2
    com.itextpdf.layout.properties.ClearPropertyValue RIGHT -> S2
    com.itextpdf.layout.properties.ClearPropertyValue[] $VALUES -> U2
    com.itextpdf.layout.properties.ClearPropertyValue NONE -> R2
    com.itextpdf.layout.properties.ClearPropertyValue LEFT -> Q2
com.itextpdf.layout.properties.FloatPropertyValue -> f2.m:
    com.itextpdf.layout.properties.FloatPropertyValue[] $VALUES -> T2
    com.itextpdf.layout.properties.FloatPropertyValue LEFT -> Q2
    com.itextpdf.layout.properties.FloatPropertyValue RIGHT -> S2
    com.itextpdf.layout.properties.FloatPropertyValue NONE -> R2
com.itextpdf.layout.properties.FontKerning -> f2.n:
    com.itextpdf.layout.properties.FontKerning YES -> Q2
    com.itextpdf.layout.properties.FontKerning NO -> R2
    com.itextpdf.layout.properties.FontKerning[] $VALUES -> S2
com.itextpdf.layout.properties.HorizontalAlignment -> f2.o:
    com.itextpdf.layout.properties.HorizontalAlignment RIGHT -> S2
    com.itextpdf.layout.properties.HorizontalAlignment LEFT -> Q2
    com.itextpdf.layout.properties.HorizontalAlignment CENTER -> R2
    com.itextpdf.layout.properties.HorizontalAlignment[] $VALUES -> T2
com.itextpdf.layout.properties.Leading -> f2.p:
    float value -> b
    int type -> a
    int getType() -> a
    float getValue() -> b
com.itextpdf.layout.properties.LineHeight -> f2.q:
    float value -> b
    int type -> a
    float getValue() -> a
    boolean isFixedValue() -> b
    boolean isNormalValue() -> c
com.itextpdf.layout.properties.ListNumberingType -> f2.r:
    com.itextpdf.layout.properties.ListNumberingType ZAPF_DINGBATS_4 -> b3
    com.itextpdf.layout.properties.ListNumberingType ZAPF_DINGBATS_1 -> Y2
    com.itextpdf.layout.properties.ListNumberingType ZAPF_DINGBATS_2 -> Z2
    com.itextpdf.layout.properties.ListNumberingType ZAPF_DINGBATS_3 -> a3
    com.itextpdf.layout.properties.ListNumberingType ROMAN_LOWER -> S2
    com.itextpdf.layout.properties.ListNumberingType ROMAN_UPPER -> T2
    com.itextpdf.layout.properties.ListNumberingType DECIMAL -> Q2
    com.itextpdf.layout.properties.ListNumberingType DECIMAL_LEADING_ZERO -> R2
    com.itextpdf.layout.properties.ListNumberingType GREEK_LOWER -> W2
    com.itextpdf.layout.properties.ListNumberingType GREEK_UPPER -> X2
    com.itextpdf.layout.properties.ListNumberingType ENGLISH_LOWER -> U2
    com.itextpdf.layout.properties.ListNumberingType ENGLISH_UPPER -> V2
    com.itextpdf.layout.properties.ListNumberingType[] $VALUES -> c3
com.itextpdf.layout.properties.ObjectFit -> f2.s:
    com.itextpdf.layout.properties.ObjectFit CONTAIN -> R2
    com.itextpdf.layout.properties.ObjectFit COVER -> S2
    com.itextpdf.layout.properties.ObjectFit FILL -> Q2
    com.itextpdf.layout.properties.ObjectFit[] $VALUES -> V2
    com.itextpdf.layout.properties.ObjectFit SCALE_DOWN -> T2
    com.itextpdf.layout.properties.ObjectFit NONE -> U2
com.itextpdf.layout.properties.OverflowPropertyValue -> f2.t:
    com.itextpdf.layout.properties.OverflowPropertyValue FIT -> Q2
    com.itextpdf.layout.properties.OverflowPropertyValue HIDDEN -> S2
    com.itextpdf.layout.properties.OverflowPropertyValue[] $VALUES -> T2
    com.itextpdf.layout.properties.OverflowPropertyValue VISIBLE -> R2
com.itextpdf.layout.properties.OverflowWrapPropertyValue -> f2.u:
    com.itextpdf.layout.properties.OverflowWrapPropertyValue NORMAL -> S2
    com.itextpdf.layout.properties.OverflowWrapPropertyValue BREAK_WORD -> R2
    com.itextpdf.layout.properties.OverflowWrapPropertyValue ANYWHERE -> Q2
    com.itextpdf.layout.properties.OverflowWrapPropertyValue[] $VALUES -> T2
com.itextpdf.layout.properties.ParagraphOrphansControl -> f2.v:
    int minOrphans -> a
    int getMinOrphans() -> a
    void handleViolatedOrphans(com.itextpdf.layout.renderer.ParagraphRenderer,java.lang.String) -> b
com.itextpdf.layout.properties.ParagraphWidowsControl -> f2.w:
    int maxLinesToMove -> b
    boolean overflowOnWidowsViolation -> c
    int minWidows -> a
    int getMaxLinesToMove() -> a
    int getMinWidows() -> b
    void handleViolatedWidows(com.itextpdf.layout.renderer.ParagraphRenderer,java.lang.String) -> c
    boolean isOverflowOnWidowsViolation() -> d
com.itextpdf.layout.properties.Property -> f2.x:
    boolean[] INHERITED_PROPERTIES -> a
    boolean isPropertyInherited(int) -> a
com.itextpdf.layout.properties.RenderingMode -> f2.y:
    com.itextpdf.layout.properties.RenderingMode DEFAULT_LAYOUT_MODE -> Q2
    com.itextpdf.layout.properties.RenderingMode[] $VALUES -> S2
    com.itextpdf.layout.properties.RenderingMode HTML_MODE -> R2
com.itextpdf.layout.properties.TextAlignment -> f2.z:
    com.itextpdf.layout.properties.TextAlignment LEFT -> Q2
    com.itextpdf.layout.properties.TextAlignment CENTER -> R2
    com.itextpdf.layout.properties.TextAlignment RIGHT -> S2
    com.itextpdf.layout.properties.TextAlignment JUSTIFIED -> T2
    com.itextpdf.layout.properties.TextAlignment[] $VALUES -> V2
    com.itextpdf.layout.properties.TextAlignment JUSTIFIED_ALL -> U2
com.itextpdf.layout.properties.Transform -> f2.a0:
    java.util.List multipleTransform -> a
    com.itextpdf.kernel.geom.AffineTransform getAffineTransform(com.itextpdf.layout.properties.Transform,float,float) -> a
    java.util.List getMultipleTransform() -> b
com.itextpdf.layout.properties.Transform$SingleTransform -> f2.a0$a:
    com.itextpdf.layout.properties.UnitValue ty -> f
    com.itextpdf.layout.properties.UnitValue tx -> e
    float[] getFloats() -> a
    com.itextpdf.layout.properties.UnitValue[] getUnitValues() -> b
com.itextpdf.layout.properties.TransparentColor -> f2.b0:
    com.itextpdf.kernel.colors.Color color -> a
    float opacity -> b
    void applyFillTransparency(com.itextpdf.kernel.pdf.canvas.PdfCanvas) -> a
    void applyStrokeTransparency(com.itextpdf.kernel.pdf.canvas.PdfCanvas) -> b
    void applyTransparency(com.itextpdf.kernel.pdf.canvas.PdfCanvas,boolean) -> c
    com.itextpdf.kernel.colors.Color getColor() -> d
    float getOpacity() -> e
    boolean isTransparent() -> f
com.itextpdf.layout.properties.Underline -> f2.c0:
    float yPositionMul -> e
    float yPosition -> d
    int lineCapStyle -> f
    float thicknessMul -> c
    float thickness -> b
    com.itextpdf.layout.properties.TransparentColor transparentColor -> a
    com.itextpdf.kernel.colors.Color getColor() -> a
    int getLineCapStyle() -> b
    float getOpacity() -> c
    float getThickness(float) -> d
    float getYPosition(float) -> e
com.itextpdf.layout.properties.UnitValue -> f2.d0:
    float value -> b
    int unitType -> a
    com.itextpdf.layout.properties.UnitValue createPercentValue(float) -> a
    com.itextpdf.layout.properties.UnitValue createPointValue(float) -> b
    int getUnitType() -> c
    float getValue() -> d
    boolean isPercentValue() -> e
    boolean isPointValue() -> f
    void setValue(float) -> g
com.itextpdf.layout.properties.VerticalAlignment -> f2.e0:
    com.itextpdf.layout.properties.VerticalAlignment[] $VALUES -> T2
    com.itextpdf.layout.properties.VerticalAlignment MIDDLE -> R2
    com.itextpdf.layout.properties.VerticalAlignment TOP -> Q2
    com.itextpdf.layout.properties.VerticalAlignment BOTTOM -> S2
com.itextpdf.layout.renderer.AbstractRenderer -> g2.a:
    java.util.List childRenderers -> Q2
    boolean isLastRendererForModelElement -> X2
    java.util.List positionedRenderers -> R2
    boolean flushed -> T2
    com.itextpdf.layout.renderer.IRenderer parent -> V2
    java.util.Map properties -> W2
    com.itextpdf.layout.IPropertyContainer modelElement -> S2
    com.itextpdf.layout.layout.LayoutArea occupiedArea -> U2
    void addChildRenderer(com.itextpdf.layout.renderer.IRenderer) -> A
    com.itextpdf.kernel.geom.Rectangle getInnerAreaBBox() -> A0
    com.itextpdf.kernel.font.PdfFont resolveFirstPdfFont() -> A1
    void adjustPositionedRendererLayoutBoxWidth(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.kernel.geom.Rectangle,java.lang.Float,java.lang.Float) -> B
    java.lang.Float getLastYLineRecursively() -> B0
    com.itextpdf.kernel.font.PdfFont resolveFirstPdfFont(java.lang.String[],com.itextpdf.layout.font.FontProvider,com.itextpdf.layout.font.FontCharacteristics,com.itextpdf.layout.font.FontSet) -> B1
    void alignChildHorizontally(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.kernel.geom.Rectangle) -> C
    com.itextpdf.layout.properties.UnitValue[] getMargins() -> C0
    java.lang.Float retrieveDirectParentDeclaredHeight() -> C1
    boolean allowLastYLineRecursiveExtraction() -> D
    com.itextpdf.layout.properties.UnitValue[] getMargins(com.itextpdf.layout.renderer.IRenderer) -> D0
    java.lang.Float retrieveHeight() -> D1
    void applyAbsolutePosition(com.itextpdf.kernel.geom.Rectangle) -> E
    com.itextpdf.layout.minmaxwidth.MinMaxWidth getMinMaxWidth() -> E0
    java.lang.Float retrieveMaxHeight() -> E1
    void applyAbsolutePositionIfNeeded(com.itextpdf.layout.layout.LayoutContext) -> F
    com.itextpdf.kernel.geom.Rectangle getOccupiedAreaBBox() -> F0
    java.lang.Float retrieveMaxWidth(float) -> F1
    void applyAction(com.itextpdf.kernel.pdf.PdfDocument) -> G
    java.util.Map getOwnProperties() -> G0
    java.lang.Float retrieveMinHeight() -> G1
    com.itextpdf.kernel.geom.Rectangle applyBackgroundBoxProperty(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.properties.BackgroundBox) -> H
    com.itextpdf.layout.properties.UnitValue[] getPaddings() -> H0
    java.lang.Float retrieveMinWidth(float) -> H1
    com.itextpdf.kernel.geom.Rectangle applyBorderBox(com.itextpdf.kernel.geom.Rectangle,boolean) -> I
    com.itextpdf.layout.properties.UnitValue[] getPaddings(com.itextpdf.layout.renderer.IRenderer) -> I0
    java.lang.Float retrieveResolvedParentDeclaredHeight() -> I1
    com.itextpdf.kernel.geom.Rectangle applyBorderBox(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.borders.Border[],boolean) -> J
    com.itextpdf.kernel.pdf.PdfDocument getPdfDocument() -> J0
    java.lang.Float retrieveUnitValue(float,int) -> J1
    void applyDestination(com.itextpdf.kernel.pdf.PdfDocument) -> K
    java.lang.Object getProperty(int,java.lang.Object) -> K0
    java.lang.Float retrieveUnitValue(float,int,boolean) -> K1
    void applyDestinationsAndAnnotation(com.itextpdf.layout.renderer.DrawContext) -> L
    java.lang.Boolean getPropertyAsBoolean(int) -> L0
    java.lang.Float retrieveWidth(float) -> L1
    void applyLinkAnnotation(com.itextpdf.kernel.pdf.PdfDocument) -> M
    com.itextpdf.kernel.colors.Color getPropertyAsColor(int) -> M0
    com.itextpdf.layout.renderer.AbstractRenderer setBorders(com.itextpdf.layout.borders.Border,int) -> M1
    com.itextpdf.kernel.geom.Rectangle applyMargins(com.itextpdf.kernel.geom.Rectangle,boolean) -> N
    java.lang.Float getPropertyAsFloat(int) -> N0
    com.itextpdf.layout.renderer.IRenderer setChildRenderer(int,com.itextpdf.layout.renderer.IRenderer) -> N1
    com.itextpdf.kernel.geom.Rectangle applyMargins(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.properties.UnitValue[],boolean) -> O
    java.lang.Float getPropertyAsFloat(int,java.lang.Float) -> O0
    void setChildRenderers(java.util.List) -> O1
    com.itextpdf.kernel.geom.Rectangle applyPaddings(com.itextpdf.kernel.geom.Rectangle,boolean) -> P
    java.lang.Float getPropertyAsFloat(com.itextpdf.layout.renderer.IRenderer,int) -> P0
    boolean setMinMaxWidthBasedOnFixedWidth(com.itextpdf.layout.minmaxwidth.MinMaxWidth) -> P1
    com.itextpdf.kernel.geom.Rectangle applyPaddings(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.properties.UnitValue[],boolean) -> Q
    com.itextpdf.kernel.font.PdfFont getPropertyAsFont(int) -> Q0
    void setThisAsParent(java.util.Collection) -> Q1
    void applyRelativePositioningTranslation(boolean) -> R
    java.lang.Integer getPropertyAsInteger(int) -> R0
    void shrinkOccupiedAreaForAbsolutePosition() -> R1
    void beginElementOpacityApplying(com.itextpdf.layout.renderer.DrawContext) -> S
    com.itextpdf.layout.properties.TransparentColor getPropertyAsTransparentColor(int) -> S0
    java.util.List transformPoints(java.util.List,com.itextpdf.kernel.geom.AffineTransform) -> S1
    void beginTransformationIfApplied(com.itextpdf.kernel.pdf.canvas.PdfCanvas) -> T
    com.itextpdf.layout.properties.UnitValue getPropertyAsUnitValue(int) -> T0
    void updateHeight(com.itextpdf.layout.properties.UnitValue) -> T1
    com.itextpdf.kernel.geom.Rectangle calculateAbsolutePdfBBox() -> U
    com.itextpdf.layout.properties.UnitValue getPropertyAsUnitValue(com.itextpdf.layout.renderer.IRenderer,int) -> U0
    void updateHeightsOnSplit(float,boolean,com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.layout.renderer.AbstractRenderer,boolean) -> U1
    float calculateAdditionalWidth(com.itextpdf.layout.renderer.AbstractRenderer) -> V
    com.itextpdf.layout.renderer.RootRenderer getRootRenderer() -> V0
    void updateHeightsOnSplit(boolean,com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.layout.renderer.AbstractRenderer) -> V1
    com.itextpdf.kernel.geom.Rectangle calculateBBox(java.util.List) -> W
    boolean hasAbsoluteUnitValue(int) -> W0
    void updateMaxHeight(com.itextpdf.layout.properties.UnitValue) -> W1
    float calculatePaddingBorderHeight(com.itextpdf.layout.renderer.AbstractRenderer) -> X
    boolean hasOwnOrModelProperty(int) -> X0
    void updateMinHeight(com.itextpdf.layout.properties.UnitValue) -> X1
    float calculatePaddingBorderWidth(com.itextpdf.layout.renderer.AbstractRenderer) -> Y
    boolean hasOwnOrModelProperty(com.itextpdf.layout.renderer.IRenderer,int) -> Y0
    void updateMinHeightForAbsolutelyPositionedRenderer(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.kernel.geom.Rectangle,java.lang.Float,java.lang.Float) -> Y1
    float[] calculateRadii(com.itextpdf.layout.properties.BorderRadius[],com.itextpdf.kernel.geom.Rectangle,boolean) -> Z
    java.util.List initElementAreas(com.itextpdf.layout.layout.LayoutArea) -> Z0
    void updateWidth(com.itextpdf.layout.properties.UnitValue) -> Z1
    float[] calculateShiftToPositionBBoxOfPointsAt(float,float,java.util.List) -> a0
    boolean isAbsolutePosition() -> a1
    boolean clipArea(com.itextpdf.layout.renderer.DrawContext,com.itextpdf.kernel.geom.Rectangle,boolean,boolean,boolean,boolean) -> b0
    boolean isBorderBoxSizing(com.itextpdf.layout.renderer.IRenderer) -> b1
    boolean hasOwnProperty(int) -> c
    boolean clipBackgroundArea(com.itextpdf.layout.renderer.DrawContext,com.itextpdf.kernel.geom.Rectangle) -> c0
    boolean isFirstOnRootArea() -> c1
    void draw(com.itextpdf.layout.renderer.DrawContext) -> d
    boolean clipBackgroundArea(com.itextpdf.layout.renderer.DrawContext,com.itextpdf.kernel.geom.Rectangle,boolean) -> d0
    boolean isFirstOnRootArea(boolean) -> d1
    boolean clipBorderArea(com.itextpdf.layout.renderer.DrawContext,com.itextpdf.kernel.geom.Rectangle) -> e0
    boolean isFixedLayout() -> e1
    boolean hasProperty(int) -> f
    void clipInnerArea(com.itextpdf.kernel.pdf.canvas.PdfCanvas,float[],float[],float[],float[],float[],float[]) -> f0
    boolean isKeepTogether() -> f1
    java.lang.Object getDefaultProperty(int) -> g
    void clipOuterArea(com.itextpdf.kernel.pdf.canvas.PdfCanvas,float[],float[],float[],float[],float[]) -> g0
    boolean isKeepTogether(com.itextpdf.layout.renderer.IRenderer) -> g1
    com.itextpdf.layout.renderer.IRenderer setParent(com.itextpdf.layout.renderer.IRenderer) -> h
    com.itextpdf.layout.font.FontCharacteristics createFontCharacteristics() -> h0
    boolean isNotFittingHeight(com.itextpdf.layout.layout.LayoutArea) -> h1
    com.itextpdf.kernel.geom.AffineTransform createTransformationInsideOccupiedArea() -> i0
    boolean isNotFittingLayoutArea(com.itextpdf.layout.layout.LayoutArea) -> i1
    void addAllChildRenderers(int,java.util.List) -> j
    float[] decreaseBorderRadiiWithBorders(float[],float[],float[],float[],float[]) -> j0
    boolean isNotFittingWidth(com.itextpdf.layout.layout.LayoutArea) -> j1
    java.util.List getChildRenderers() -> k
    void deleteProperty(int) -> k0
    boolean isOverflowFit(com.itextpdf.layout.properties.OverflowPropertyValue) -> k1
    void move(float,float) -> l
    void drawBackground(com.itextpdf.layout.renderer.DrawContext) -> l0
    boolean isOverflowProperty(com.itextpdf.layout.properties.OverflowPropertyValue,int) -> l1
    void setProperty(int,java.lang.Object) -> m
    void drawBackgroundImage(com.itextpdf.layout.properties.BackgroundImage,com.itextpdf.layout.renderer.DrawContext,com.itextpdf.kernel.geom.Rectangle) -> m0
    boolean isOverflowProperty(com.itextpdf.layout.properties.OverflowPropertyValue,com.itextpdf.layout.properties.OverflowPropertyValue) -> m1
    boolean isFlushed() -> n
    boolean drawBackgroundImagesList(java.util.List,boolean,com.itextpdf.layout.renderer.DrawContext,com.itextpdf.kernel.geom.Rectangle) -> n0
    boolean isOverflowProperty(com.itextpdf.layout.properties.OverflowPropertyValue,com.itextpdf.layout.renderer.IRenderer,int) -> n1
    void drawBorder(com.itextpdf.layout.renderer.DrawContext) -> o0
    boolean isPositioned() -> o1
    void drawChildren(com.itextpdf.layout.renderer.DrawContext) -> p0
    boolean isRelativePosition() -> p1
    void drawColorBackground(com.itextpdf.layout.properties.Background,com.itextpdf.layout.renderer.DrawContext,com.itextpdf.kernel.geom.Rectangle) -> q0
    boolean isStaticLayout() -> q1
    java.lang.Object getProperty(int) -> r
    void drawPositionedChildren(com.itextpdf.layout.renderer.DrawContext) -> r0
    boolean logWarningIfGetNextRendererNotOverridden(java.lang.Class,java.lang.Class) -> r1
    void endElementOpacityApplying(com.itextpdf.layout.renderer.DrawContext) -> s0
    boolean noAbsolutePositionInfo(com.itextpdf.layout.renderer.IRenderer) -> s1
    com.itextpdf.layout.layout.LayoutArea getOccupiedArea() -> t
    void endTransformationIfApplied(com.itextpdf.kernel.pdf.canvas.PdfCanvas) -> t0
    void preparePositionedRendererAndAreaForLayout(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle) -> t1
    java.lang.Object getOwnProperty(int) -> u
    com.itextpdf.kernel.geom.Rectangle getBackgroundArea(com.itextpdf.kernel.geom.Rectangle) -> u0
    void processWaitingDrawing(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.layout.properties.Transform,java.util.List) -> u1
    com.itextpdf.layout.IPropertyContainer getModelElement() -> v
    com.itextpdf.kernel.geom.Rectangle getBorderAreaBBox() -> v0
    java.util.List rectangleToPointsList(com.itextpdf.kernel.geom.Rectangle) -> v1
    void addChild(com.itextpdf.layout.renderer.IRenderer) -> w
    com.itextpdf.layout.properties.BorderRadius[] getBorderRadii() -> w0
    boolean removeAllChildRenderers(java.util.Collection) -> w1
    void deleteOwnProperty(int) -> x
    com.itextpdf.layout.properties.BorderRadius[] getBorderRadii(com.itextpdf.layout.renderer.IRenderer) -> x0
    com.itextpdf.layout.renderer.IRenderer removeChildRenderer(int) -> x1
    void addAllChildRenderers(java.util.List) -> y
    com.itextpdf.layout.borders.Border[] getBorders() -> y0
    void removeThisFromParent(com.itextpdf.layout.renderer.IRenderer) -> y1
    void addAllProperties(java.util.Map) -> z
    com.itextpdf.layout.borders.Border[] getBorders(com.itextpdf.layout.renderer.IRenderer) -> z0
    void removeThisFromParents(java.util.Collection) -> z1
com.itextpdf.layout.renderer.AbstractRenderer$1 -> g2.a$a:
    int[] $SwitchMap$com$itextpdf$layout$properties$HorizontalAlignment -> a
com.itextpdf.layout.renderer.AbstractWidthHandler -> g2.b:
    com.itextpdf.layout.minmaxwidth.MinMaxWidth minMaxWidth -> a
    void updateMaxChildWidth(float) -> a
    void updateMinChildWidth(float) -> b
com.itextpdf.layout.renderer.AccessibleAttributesApplier -> g2.c:
    void applyBlockLevelLayoutAttributes(java.lang.String,com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.kernel.pdf.PdfDictionary) -> a
    void applyBorderAttributes(com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.kernel.pdf.PdfDictionary) -> b
    void applyCommonLayoutAttributes(com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.kernel.pdf.PdfDictionary) -> c
    void applyIllustrationLayoutAttributes(com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.kernel.pdf.PdfDictionary) -> d
    void applyInlineLevelLayoutAttributes(com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.kernel.pdf.PdfDictionary) -> e
    void applyPaddingAttribute(com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.kernel.pdf.PdfDictionary) -> f
    com.itextpdf.kernel.pdf.tagging.PdfStructureAttributes getLayoutAttributes(com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> g
    com.itextpdf.kernel.pdf.tagging.PdfStructureAttributes getListAttributes(com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> h
    com.itextpdf.kernel.pdf.tagging.PdfStructureAttributes getTableAttributes(com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> i
    boolean isTagStructurePdf2(com.itextpdf.kernel.pdf.tagging.PdfNamespace) -> j
    com.itextpdf.kernel.pdf.tagutils.IRoleMappingResolver resolveMappingToStandard(com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> k
    com.itextpdf.kernel.pdf.PdfName transformBlockAlignToName(com.itextpdf.layout.properties.HorizontalAlignment) -> l
    com.itextpdf.kernel.pdf.PdfName transformBorderTypeToName(int) -> m
    com.itextpdf.kernel.pdf.PdfName transformNumberingTypeToName(com.itextpdf.layout.properties.ListNumberingType,boolean) -> n
    com.itextpdf.kernel.pdf.PdfName transformTextAlignmentValueToName(com.itextpdf.layout.properties.TextAlignment) -> o
com.itextpdf.layout.renderer.AccessibleAttributesApplier$1 -> g2.c$a:
    int[] $SwitchMap$com$itextpdf$layout$properties$HorizontalAlignment -> b
    int[] $SwitchMap$com$itextpdf$layout$properties$ListNumberingType -> c
    int[] $SwitchMap$com$itextpdf$layout$properties$TextAlignment -> a
com.itextpdf.layout.renderer.AccessibleTypes -> g2.d:
    java.util.Set blockLevelRoles -> g
    java.util.Set inlineLevelRoles -> h
    java.util.Set illustrationRoles -> i
    java.util.Set groupingRoles -> f
    int InlineLevel -> d
    int Illustration -> e
    int Grouping -> b
    int BlockLevel -> c
    int Unknown -> a
    int identifyType(java.lang.String) -> a
com.itextpdf.layout.renderer.BackgroundSizeCalculationUtil -> g2.e:
    com.itextpdf.layout.properties.UnitValue PERCENT_VALUE_100 -> a
    void calculateBackgroundHeight(com.itextpdf.layout.properties.UnitValue,float,boolean,com.itextpdf.layout.properties.BackgroundImage,java.lang.Float[]) -> a
    float[] calculateBackgroundImageSize(com.itextpdf.layout.properties.BackgroundImage,float,float) -> b
    com.itextpdf.layout.properties.BackgroundSize calculateBackgroundSizeForArea(com.itextpdf.layout.properties.BackgroundImage,float,float) -> c
    void calculateBackgroundWidth(com.itextpdf.layout.properties.UnitValue,float,boolean,com.itextpdf.layout.properties.BackgroundImage,java.lang.Float[]) -> d
    com.itextpdf.layout.properties.BackgroundSize createSizeWithMaxValueSide(boolean) -> e
    void scaleHeight(float,com.itextpdf.layout.properties.BackgroundImage,java.lang.Float[]) -> f
    void scaleWidth(float,com.itextpdf.layout.properties.BackgroundImage,java.lang.Float[]) -> g
    void setDefaultSizeIfNull(java.lang.Float[],float,float,com.itextpdf.layout.properties.BackgroundImage,boolean) -> h
com.itextpdf.layout.renderer.BlockFormattingContextUtil -> g2.f:
    boolean isAbsolutePosition(com.itextpdf.layout.renderer.IRenderer) -> a
    boolean isCaption(com.itextpdf.layout.renderer.IRenderer) -> b
    boolean isFixedPosition(com.itextpdf.layout.renderer.IRenderer) -> c
    boolean isInlineBlock(com.itextpdf.layout.renderer.IRenderer) -> d
    boolean isRendererCreateBfc(com.itextpdf.layout.renderer.IRenderer) -> e
com.itextpdf.layout.renderer.BlockRenderer -> g2.g:
    com.itextpdf.layout.minmaxwidth.MinMaxWidth getMinMaxWidth() -> E0
    com.itextpdf.kernel.geom.Rectangle getOccupiedAreaBBox() -> F0
    boolean applyMaxHeight(com.itextpdf.kernel.geom.Rectangle,java.lang.Float,com.itextpdf.layout.margincollapse.MarginsCollapseHandler,boolean,boolean,com.itextpdf.layout.properties.OverflowPropertyValue) -> a2
    com.itextpdf.layout.renderer.AbstractRenderer applyMinHeight(com.itextpdf.layout.properties.OverflowPropertyValue,com.itextpdf.kernel.geom.Rectangle) -> b2
    void applyRotationLayout(com.itextpdf.kernel.geom.Rectangle) -> c2
    void draw(com.itextpdf.layout.renderer.DrawContext) -> d
    void applyVerticalAlignment() -> d2
    void applyWidth(com.itextpdf.kernel.geom.Rectangle,java.lang.Float,com.itextpdf.layout.properties.OverflowPropertyValue) -> e2
    void beginRotationIfApplied(com.itextpdf.kernel.pdf.canvas.PdfCanvas) -> f2
    void correctFixedLayout(com.itextpdf.kernel.geom.Rectangle) -> g2
    com.itextpdf.layout.renderer.AbstractRenderer createOverflowRenderer(int) -> h2
    com.itextpdf.layout.layout.LayoutResult layout(com.itextpdf.layout.layout.LayoutContext) -> i
    com.itextpdf.kernel.geom.AffineTransform createRotationTransformInsideOccupiedArea() -> i2
    com.itextpdf.layout.renderer.AbstractRenderer[] createSplitAndOverflowRenderers(int,int,com.itextpdf.layout.layout.LayoutResult,java.util.Map,java.util.List) -> j2
    com.itextpdf.layout.renderer.AbstractRenderer createSplitRenderer(int) -> k2
    void decreaseLayoutBoxAfterChildPlacement(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.layout.LayoutResult,com.itextpdf.layout.renderer.IRenderer) -> l2
    void endRotationIfApplied(com.itextpdf.kernel.pdf.canvas.PdfCanvas) -> m2
    void fixOccupiedAreaIfOverflowedX(com.itextpdf.layout.properties.OverflowPropertyValue,com.itextpdf.kernel.geom.Rectangle) -> n2
    void fixOccupiedAreaIfOverflowedY(com.itextpdf.layout.properties.OverflowPropertyValue,com.itextpdf.kernel.geom.Rectangle) -> o2
    com.itextpdf.layout.layout.LayoutResult processNotFullChildResult(com.itextpdf.layout.layout.LayoutContext,java.util.Map,java.util.List,boolean,java.util.List,boolean,float,com.itextpdf.layout.borders.Border[],com.itextpdf.layout.properties.UnitValue[],java.util.List,int,com.itextpdf.kernel.geom.Rectangle,java.util.Set,com.itextpdf.layout.renderer.IRenderer,boolean,int,com.itextpdf.layout.layout.LayoutResult) -> p2
    com.itextpdf.kernel.geom.Rectangle recalculateLayoutBoxBeforeChildLayout(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.renderer.IRenderer,com.itextpdf.kernel.geom.Rectangle) -> q2
    void recalculateOccupiedAreaAfterChildLayout(com.itextpdf.kernel.geom.Rectangle,java.lang.Float) -> r2
    void replaceSplitRendererKidFloats(java.util.Map,com.itextpdf.layout.renderer.IRenderer) -> s2
    com.itextpdf.layout.margincollapse.MarginsCollapseInfo startChildMarginsHandling(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.margincollapse.MarginsCollapseHandler) -> t2
    boolean stopLayoutingChildrenIfChildResultNotFull(com.itextpdf.layout.layout.LayoutResult) -> u2
com.itextpdf.layout.renderer.BlockRenderer$1 -> g2.g$a:
    int[] $SwitchMap$com$itextpdf$layout$properties$VerticalAlignment -> a
com.itextpdf.layout.renderer.CanvasRenderer -> g2.h:
    com.itextpdf.layout.Canvas canvas -> i3
    com.itextpdf.layout.renderer.IRenderer getNextRenderer() -> b
    void flushSingleRenderer(com.itextpdf.layout.renderer.IRenderer) -> e2
    com.itextpdf.layout.layout.LayoutArea updateCurrentArea(com.itextpdf.layout.layout.LayoutResult) -> m2
    void addChild(com.itextpdf.layout.renderer.IRenderer) -> w
com.itextpdf.layout.renderer.CellRenderer -> g2.i:
    com.itextpdf.kernel.geom.Rectangle applyBorderBox(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.borders.Border[],boolean) -> J
    java.lang.Float retrieveWidth(float) -> L1
    com.itextpdf.kernel.geom.Rectangle applyMargins(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.properties.UnitValue[],boolean) -> O
    com.itextpdf.layout.renderer.IRenderer getNextRenderer() -> b
    com.itextpdf.layout.renderer.AbstractRenderer createOverflowRenderer(int) -> h2
    com.itextpdf.layout.renderer.AbstractRenderer createSplitRenderer(int) -> k2
    void drawBackground(com.itextpdf.layout.renderer.DrawContext) -> l0
    void drawBorder(com.itextpdf.layout.renderer.DrawContext) -> o0
    com.itextpdf.layout.IPropertyContainer getModelElement() -> v
    com.itextpdf.kernel.geom.Rectangle applySpacings(com.itextpdf.kernel.geom.Rectangle,boolean) -> v2
    com.itextpdf.kernel.geom.Rectangle applySpacings(com.itextpdf.kernel.geom.Rectangle,float[],boolean) -> w2
com.itextpdf.layout.renderer.CollapsedTableBorders -> g2.j:
    java.util.Comparator borderComparator -> n
    java.util.List verticalBottomBorderCollapseWith -> m
    java.util.List bottomBorderCollapseWith -> l
    java.util.List topBorderCollapseWith -> k
    java.util.List getVerticalBorder(int) -> A
    com.itextpdf.layout.renderer.TableBorders skipFooter(com.itextpdf.layout.borders.Border[]) -> K
    com.itextpdf.layout.renderer.TableBorders skipHeader(com.itextpdf.layout.borders.Border[]) -> L
    com.itextpdf.layout.renderer.TableBorders updateBordersOnNewPage(boolean,boolean,com.itextpdf.layout.renderer.TableRenderer,com.itextpdf.layout.renderer.TableRenderer,com.itextpdf.layout.renderer.TableRenderer) -> M
    void buildBordersArrays(com.itextpdf.layout.renderer.CellRenderer,int,boolean) -> N
    boolean checkAndReplaceBorderInArray(java.util.List,int,int,com.itextpdf.layout.borders.Border,boolean) -> O
    com.itextpdf.layout.borders.Border getCollapsedBorder(com.itextpdf.layout.borders.Border,com.itextpdf.layout.borders.Border) -> P
    java.util.List getCollapsedList(java.util.List,java.util.List) -> Q
    java.util.List getCrossingBorders(int,int) -> R
    java.util.List getTopBorderCollapseWith() -> S
    java.util.List getVerticalBordersCrossingTopHorizontalBorder() -> T
    float getWidestBorderWidth(com.itextpdf.layout.borders.Border[]) -> U
    boolean isBorderWider(com.itextpdf.layout.borders.Border,com.itextpdf.layout.borders.Border) -> V
    boolean isBorderWider(com.itextpdf.layout.borders.Border,com.itextpdf.layout.borders.Border,boolean) -> W
    com.itextpdf.layout.renderer.CollapsedTableBorders setBottomBorderCollapseWith(java.util.List,java.util.List) -> X
    com.itextpdf.layout.renderer.CollapsedTableBorders setTopBorderCollapseWith(java.util.List) -> Y
    com.itextpdf.layout.renderer.TableBorders applyBottomTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean) -> a
    com.itextpdf.layout.renderer.TableBorders applyBottomTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean,boolean,boolean) -> b
    com.itextpdf.layout.renderer.TableBorders applyCellIndents(com.itextpdf.kernel.geom.Rectangle,float,float,float,float,boolean) -> c
    com.itextpdf.layout.renderer.TableBorders applyLeftAndRightTableBorder(com.itextpdf.kernel.geom.Rectangle,boolean) -> d
    com.itextpdf.layout.renderer.TableBorders applyTopTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean) -> e
    com.itextpdf.layout.renderer.TableBorders applyTopTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean,boolean,boolean) -> f
    void buildBordersArrays(com.itextpdf.layout.renderer.CellRenderer,int,int,int[]) -> g
    com.itextpdf.layout.renderer.TableBorders collapseTableWithFooter(com.itextpdf.layout.renderer.TableBorders,boolean) -> h
    com.itextpdf.layout.renderer.TableBorders collapseTableWithHeader(com.itextpdf.layout.renderer.TableBorders,boolean) -> i
    com.itextpdf.layout.renderer.TableBorders drawHorizontalBorder(com.itextpdf.kernel.pdf.canvas.PdfCanvas,com.itextpdf.layout.renderer.TableBorderDescriptor) -> j
    com.itextpdf.layout.renderer.TableBorders drawVerticalBorder(com.itextpdf.kernel.pdf.canvas.PdfCanvas,com.itextpdf.layout.renderer.TableBorderDescriptor) -> k
    com.itextpdf.layout.renderer.TableBorders fixHeaderOccupiedArea(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle) -> l
    float[] getCellBorderIndents(int,int,int,int) -> m
    float getCellVerticalAddition(float[]) -> n
    java.util.List getHorizontalBorder(int) -> q
com.itextpdf.layout.renderer.CollapsedTableBorders$1 -> g2.j$a:
com.itextpdf.layout.renderer.CollapsedTableBorders$BorderComparator -> g2.j$b:
    int compare(com.itextpdf.layout.borders.Border,com.itextpdf.layout.borders.Border) -> a
com.itextpdf.layout.renderer.DivRenderer -> g2.k:
    com.itextpdf.layout.renderer.IRenderer getNextRenderer() -> b
com.itextpdf.layout.renderer.DocumentRenderer -> g2.l:
    com.itextpdf.layout.Document document -> i3
    java.util.List wrappedContentPage -> j3
    com.itextpdf.layout.renderer.TargetCounterHandler targetCounterHandler -> k3
    com.itextpdf.layout.renderer.IRenderer getNextRenderer() -> b
    void flushSingleRenderer(com.itextpdf.layout.renderer.IRenderer) -> e2
    com.itextpdf.layout.layout.LayoutArea updateCurrentArea(com.itextpdf.layout.layout.LayoutResult) -> m2
    com.itextpdf.kernel.geom.PageSize addNewPage(com.itextpdf.kernel.geom.PageSize) -> o2
    com.itextpdf.kernel.geom.PageSize ensureDocumentHasNPages(int,com.itextpdf.kernel.geom.PageSize) -> p2
    com.itextpdf.kernel.geom.Rectangle getCurrentPageEffectiveArea(com.itextpdf.kernel.geom.PageSize) -> q2
    com.itextpdf.layout.renderer.TargetCounterHandler getTargetCounterHandler() -> r2
    void possiblyFlushPreviousPage(int) -> s2
    com.itextpdf.layout.layout.LayoutArea getOccupiedArea() -> t
com.itextpdf.layout.renderer.DrawContext -> g2.m:
    com.itextpdf.kernel.pdf.PdfDocument document -> a
    com.itextpdf.kernel.pdf.canvas.PdfCanvas canvas -> b
    boolean taggingEnabled -> c
    com.itextpdf.kernel.pdf.canvas.PdfCanvas getCanvas() -> a
    com.itextpdf.kernel.pdf.PdfDocument getDocument() -> b
    boolean isTaggingEnabled() -> c
com.itextpdf.layout.renderer.FloatingHelper -> g2.n:
    void adjustBlockAreaAccordingToFloatRenderers(java.util.List,com.itextpdf.kernel.geom.Rectangle,float,boolean) -> a
    void adjustBoxForFloatRight(com.itextpdf.kernel.geom.Rectangle,float) -> b
    java.lang.Float adjustFloatedBlockLayoutBox(com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.kernel.geom.Rectangle,java.lang.Float,java.util.List,com.itextpdf.layout.properties.FloatPropertyValue,com.itextpdf.layout.properties.OverflowPropertyValue) -> c
    void adjustFloatedTableLayoutBox(com.itextpdf.layout.renderer.TableRenderer,com.itextpdf.kernel.geom.Rectangle,float,java.util.List,com.itextpdf.layout.properties.FloatPropertyValue) -> d
    float adjustLayoutBoxAccordingToFloats(java.util.List,com.itextpdf.kernel.geom.Rectangle,java.lang.Float,float,com.itextpdf.layout.margincollapse.MarginsCollapseHandler) -> e
    void adjustLineAreaAccordingToFloats(java.util.List,com.itextpdf.kernel.geom.Rectangle) -> f
    com.itextpdf.layout.layout.LayoutArea adjustResultOccupiedAreaForFloatAndClear(com.itextpdf.layout.renderer.IRenderer,java.util.List,com.itextpdf.kernel.geom.Rectangle,float,boolean) -> g
    void applyClearance(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.margincollapse.MarginsCollapseHandler,float,boolean) -> h
    float calculateClearHeightCorrection(com.itextpdf.layout.renderer.IRenderer,java.util.List,com.itextpdf.kernel.geom.Rectangle) -> i
    java.lang.Float calculateLineShiftUnderFloats(java.util.List,com.itextpdf.kernel.geom.Rectangle) -> j
    com.itextpdf.layout.minmaxwidth.MinMaxWidth calculateMinMaxWidthForFloat(com.itextpdf.layout.renderer.AbstractRenderer,com.itextpdf.layout.properties.FloatPropertyValue) -> k
    com.itextpdf.kernel.geom.Rectangle[] findLastLeftAndRightBoxes(com.itextpdf.kernel.geom.Rectangle,java.util.List) -> l
    java.util.List getBoxesAtYLevel(java.util.List,float) -> m
    com.itextpdf.kernel.geom.Rectangle includeChildFloatsInOccupiedArea(java.util.List,com.itextpdf.kernel.geom.Rectangle,java.util.Set) -> n
    void includeChildFloatsInOccupiedArea(java.util.List,com.itextpdf.layout.renderer.IRenderer,java.util.Set) -> o
    boolean isClearanceApplied(java.util.List,com.itextpdf.layout.properties.ClearPropertyValue) -> p
    boolean isRendererFloating(com.itextpdf.layout.renderer.IRenderer) -> q
    boolean isRendererFloating(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.layout.properties.FloatPropertyValue) -> r
    void removeFloatsAboveRendererBottom(java.util.List,com.itextpdf.layout.renderer.IRenderer) -> s
    void removeParentArtifactsOnPageSplitIfOnlyFloatsOverflow(com.itextpdf.layout.renderer.IRenderer) -> t
com.itextpdf.layout.renderer.ILeafElementRenderer -> g2.o:
    float getDescent() -> a
    float getAscent() -> e
com.itextpdf.layout.renderer.IRenderer -> g2.p:
    com.itextpdf.layout.renderer.IRenderer getNextRenderer() -> b
    void draw(com.itextpdf.layout.renderer.DrawContext) -> d
    com.itextpdf.layout.renderer.IRenderer setParent(com.itextpdf.layout.renderer.IRenderer) -> h
    com.itextpdf.layout.layout.LayoutResult layout(com.itextpdf.layout.layout.LayoutContext) -> i
    java.util.List getChildRenderers() -> k
    void move(float,float) -> l
    boolean isFlushed() -> n
    com.itextpdf.layout.layout.LayoutArea getOccupiedArea() -> t
    com.itextpdf.layout.IPropertyContainer getModelElement() -> v
    void addChild(com.itextpdf.layout.renderer.IRenderer) -> w
com.itextpdf.layout.renderer.ImageRenderer -> g2.q:
    float renderedImageHeight -> h3
    float[] matrix -> e3
    boolean doesObjectFitRequireCutting -> j3
    float renderedImageWidth -> i3
    float rotatedDeltaX -> l3
    java.lang.Float fixedXPosition -> Y2
    float rotatedDeltaY -> m3
    java.lang.Float height -> f3
    com.itextpdf.kernel.geom.Rectangle initialOccupiedAreaBBox -> k3
    java.lang.Float width -> g3
    java.lang.Float fixedYPosition -> Z2
    float deltaX -> b3
    float pivotY -> a3
    float imageHeight -> d3
    float imageWidth -> c3
    com.itextpdf.layout.minmaxwidth.MinMaxWidth getMinMaxWidth() -> E0
    com.itextpdf.kernel.geom.Rectangle applyPaddings(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.properties.UnitValue[],boolean) -> Q
    float getDescent() -> a
    float adjustPositionAfterRotation(float,float,float) -> a2
    com.itextpdf.layout.renderer.IRenderer getNextRenderer() -> b
    void applyConcatMatrix(com.itextpdf.layout.renderer.DrawContext,java.lang.Float) -> b2
    void applyObjectFit(com.itextpdf.layout.properties.ObjectFit,float,float) -> c2
    void draw(com.itextpdf.layout.renderer.DrawContext) -> d
    void applyRotationLayout(float) -> d2
    float getAscent() -> e
    com.itextpdf.layout.renderer.ImageRenderer autoScale(com.itextpdf.layout.layout.LayoutArea) -> e2
    void beginObjectFitImageClipping(com.itextpdf.kernel.pdf.canvas.PdfCanvas) -> f2
    void calculateImageDimensions(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.AffineTransform,com.itextpdf.kernel.pdf.xobject.PdfXObject) -> g2
    void endObjectFitImageClipping(com.itextpdf.kernel.pdf.canvas.PdfCanvas) -> h2
    com.itextpdf.layout.layout.LayoutResult layout(com.itextpdf.layout.layout.LayoutContext) -> i
    void getMatrix(com.itextpdf.kernel.geom.AffineTransform,float,float) -> i2
    void translateImage(float,float,com.itextpdf.kernel.geom.AffineTransform) -> j2
    void move(float,float) -> l
    com.itextpdf.kernel.geom.Rectangle getBorderAreaBBox() -> v0
com.itextpdf.layout.renderer.LineHeightHelper -> g2.r:
    float DEFAULT_LINE_HEIGHT_COEFF -> a
    float calculateLineHeight(com.itextpdf.layout.renderer.AbstractRenderer) -> a
    float[] getActualAscenderDescender(com.itextpdf.layout.renderer.AbstractRenderer) -> b
    float[] getFontAscenderDescenderNormalized(com.itextpdf.layout.renderer.AbstractRenderer) -> c
com.itextpdf.layout.renderer.LineRenderer -> g2.s:
    float maxAscent -> Y2
    byte[] levels -> a3
    float maxDescent -> Z2
    float maxTextAscent -> b3
    float maxBlockAscent -> d3
    float maxTextDescent -> c3
    float maxBlockDescent -> e3
    org.slf4j.Logger logger -> f3
    com.itextpdf.layout.renderer.LineRenderer[] split() -> A2
    java.lang.Float getLastYLineRecursively() -> B0
    com.itextpdf.layout.renderer.LineRenderer$LineSplitIntoGlyphsData splitLineIntoGlyphs(com.itextpdf.layout.renderer.LineRenderer) -> B2
    com.itextpdf.layout.renderer.LineRenderer[] splitNotFittingFloat(int,com.itextpdf.layout.layout.LayoutResult) -> C2
    int trimFirst() -> D2
    com.itextpdf.layout.minmaxwidth.MinMaxWidth getMinMaxWidth() -> E0
    com.itextpdf.layout.renderer.LineRenderer trimLast() -> E2
    void updateAscentDescentAfterChildLayout(float[],com.itextpdf.layout.renderer.IRenderer,boolean) -> F2
    float[] updateAscentDescentAfterTextRendererSequenceProcessing(int,com.itextpdf.layout.renderer.LineRenderer$LineAscentDescentState,java.util.Map) -> G2
    void updateBidiLevels(int,com.itextpdf.layout.properties.BaseDirection) -> H2
    void updateChildrenParent() -> I2
    void adjustChildPositionsAfterReordering(java.util.List,float) -> a2
    com.itextpdf.layout.renderer.IRenderer getNextRenderer() -> b
    com.itextpdf.layout.renderer.LineRenderer adjustChildrenYLine() -> b2
    void adjustLineOnFloatPlaced(com.itextpdf.kernel.geom.Rectangle,int,com.itextpdf.layout.properties.FloatPropertyValue,com.itextpdf.kernel.geom.Rectangle) -> c2
    void applyLeading(float) -> d2
    com.itextpdf.layout.properties.BaseDirection applyOtf() -> e2
    int baseCharactersCount() -> f2
    boolean containsImage() -> g2
    com.itextpdf.layout.renderer.LineRenderer createOverflowRenderer() -> h2
    com.itextpdf.layout.layout.LayoutResult layout(com.itextpdf.layout.layout.LayoutContext) -> i
    com.itextpdf.layout.renderer.LineRenderer createSplitRenderer() -> i2
    float decreaseRelativeWidthByChildAdditionalWidth(com.itextpdf.layout.renderer.IRenderer,float) -> j2
    float[] getAscentDescentOfLayoutedChildRenderer(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.layout.layout.LayoutResult,com.itextpdf.layout.properties.RenderingMode,boolean) -> k2
    float getBottomLeadingIndent(com.itextpdf.layout.properties.Leading) -> l2
    com.itextpdf.layout.renderer.IRenderer getLastNonFloatChildRenderer() -> m2
    float getMaxAscent() -> n2
    float getMaxDescent() -> o2
    int getNumberOfSpaces() -> p2
    float getTopLeadingIndent(com.itextpdf.layout.properties.Leading) -> q2
    float getYLine() -> r2
    boolean hasChildRendererInHtmlMode() -> s2
    boolean isChildFloating(com.itextpdf.layout.renderer.IRenderer) -> t2
    boolean isForceOverflowForTextRendererPartialResult(com.itextpdf.layout.renderer.IRenderer,boolean,com.itextpdf.layout.properties.OverflowPropertyValue,com.itextpdf.layout.layout.LayoutContext,com.itextpdf.kernel.geom.Rectangle,boolean) -> u2
    boolean isInlineBlockChild(com.itextpdf.layout.renderer.IRenderer) -> v2
    void justify(float) -> w2
    void reorder(com.itextpdf.layout.renderer.LineRenderer,com.itextpdf.layout.renderer.LineRenderer$LineSplitIntoGlyphsData,int[]) -> x2
    void replaceSplitRendererKidFloats(java.util.Map,com.itextpdf.layout.renderer.LineRenderer) -> y2
    void resolveChildrenFonts() -> z2
com.itextpdf.layout.renderer.LineRenderer$LineAscentDescentState -> g2.s$a:
    float maxTextDescent -> d
    float maxTextAscent -> c
    float maxDescent -> b
    float maxAscent -> a
com.itextpdf.layout.renderer.LineRenderer$LineSplitIntoGlyphsData -> g2.s$b:
    java.util.List lineGlyphs -> a
    java.util.Map insertAfter -> b
    java.util.List starterNonTextRenderers -> c
    void addInsertAfter(com.itextpdf.layout.renderer.TextRenderer,com.itextpdf.layout.renderer.IRenderer) -> a
    void addLineGlyph(com.itextpdf.layout.renderer.LineRenderer$RendererGlyph) -> b
    java.util.List getInsertAfterAndRemove(com.itextpdf.layout.renderer.TextRenderer) -> c
    java.util.List getLineGlyphs() -> d
    java.util.List getStarterNonTextRenderers() -> e
com.itextpdf.layout.renderer.LineRenderer$RendererGlyph -> g2.s$c:
    com.itextpdf.layout.renderer.TextRenderer renderer -> b
    com.itextpdf.io.font.otf.Glyph glyph -> a
com.itextpdf.layout.renderer.MaxMaxWidthHandler -> g2.t:
    void updateMaxChildWidth(float) -> a
    void updateMinChildWidth(float) -> b
com.itextpdf.layout.renderer.MaxSumWidthHandler -> g2.u:
    void updateMaxChildWidth(float) -> a
    void updateMinChildWidth(float) -> b
com.itextpdf.layout.renderer.MetaInfoContainer -> g2.v:
    com.itextpdf.commons.actions.contexts.IMetaInfo metaInfo -> a
    com.itextpdf.commons.actions.contexts.IMetaInfo getMetaInfo() -> a
com.itextpdf.layout.renderer.OrphansWidowsLayoutHelper -> g2.w:
    com.itextpdf.layout.renderer.OrphansWidowsLayoutHelper$OrphansWidowsLayoutAttempt attemptLayout(com.itextpdf.layout.renderer.ParagraphRenderer,com.itextpdf.layout.layout.LayoutContext,com.itextpdf.layout.layout.LayoutArea) -> a
    com.itextpdf.layout.layout.LayoutResult handleAttemptAsSuccessful(com.itextpdf.layout.renderer.OrphansWidowsLayoutHelper$OrphansWidowsLayoutAttempt,com.itextpdf.layout.layout.LayoutContext) -> b
    com.itextpdf.layout.layout.LayoutResult orphansWidowsAwareLayout(com.itextpdf.layout.renderer.ParagraphRenderer,com.itextpdf.layout.layout.LayoutContext,com.itextpdf.layout.properties.ParagraphOrphansControl,com.itextpdf.layout.properties.ParagraphWidowsControl) -> c
com.itextpdf.layout.renderer.OrphansWidowsLayoutHelper$1 -> g2.w$a:
com.itextpdf.layout.renderer.OrphansWidowsLayoutHelper$OrphansWidowsLayoutAttempt -> g2.w$b:
    com.itextpdf.layout.layout.LayoutResult attemptResult -> b
    com.itextpdf.layout.layout.LayoutContext attemptContext -> a
com.itextpdf.layout.renderer.ParagraphRenderer -> g2.x:
    java.util.List lines -> Y2
    com.itextpdf.layout.renderer.ParagraphRenderer createSplitRenderer(com.itextpdf.layout.renderer.IRenderer) -> A2
    java.lang.Float getLastYLineRecursively() -> B0
    com.itextpdf.layout.layout.LayoutResult directLayout(com.itextpdf.layout.layout.LayoutContext) -> B2
    void fixOverflowRenderer(com.itextpdf.layout.renderer.ParagraphRenderer) -> C2
    java.util.List getLines() -> D2
    com.itextpdf.layout.minmaxwidth.MinMaxWidth getMinMaxWidth() -> E0
    com.itextpdf.layout.renderer.ParagraphRenderer[] split() -> E2
    void updateParentLines(com.itextpdf.layout.renderer.ParagraphRenderer) -> F2
    com.itextpdf.layout.renderer.IRenderer getNextRenderer() -> b
    java.lang.Object getDefaultProperty(int) -> g
    com.itextpdf.layout.renderer.AbstractRenderer createOverflowRenderer(int) -> h2
    com.itextpdf.layout.layout.LayoutResult layout(com.itextpdf.layout.layout.LayoutContext) -> i
    void move(float,float) -> l
    void drawChildren(com.itextpdf.layout.renderer.DrawContext) -> p0
    void alignStaticKids(com.itextpdf.layout.renderer.LineRenderer,float) -> v2
    void applyTextAlignment(com.itextpdf.layout.properties.TextAlignment,com.itextpdf.layout.layout.LineLayoutResult,com.itextpdf.layout.renderer.LineRenderer,com.itextpdf.kernel.geom.Rectangle,java.util.List,boolean,float) -> w2
    com.itextpdf.layout.renderer.ParagraphRenderer createOverflowRenderer() -> x2
    com.itextpdf.layout.renderer.ParagraphRenderer createOverflowRenderer(com.itextpdf.layout.renderer.IRenderer) -> y2
    com.itextpdf.layout.renderer.ParagraphRenderer createSplitRenderer() -> z2
com.itextpdf.layout.renderer.ParagraphRenderer$1 -> g2.x$a:
    int[] $SwitchMap$com$itextpdf$layout$properties$TextAlignment -> a
com.itextpdf.layout.renderer.RootRenderer -> g2.y:
    java.util.List floatRendererAreas -> b3
    java.util.List waitingDrawingElements -> a3
    boolean floatOverflowedCompletely -> h3
    boolean immediateFlush -> Y2
    com.itextpdf.layout.layout.LayoutResult keepWithNextHangingRendererLayoutResult -> d3
    com.itextpdf.layout.layout.RootLayoutArea currentArea -> Z2
    com.itextpdf.layout.layout.LayoutArea initialCurrentArea -> f3
    com.itextpdf.layout.margincollapse.MarginsCollapseHandler marginsCollapseHandler -> e3
    com.itextpdf.layout.renderer.IRenderer keepWithNextHangingRenderer -> c3
    java.util.List waitingNextPageRenderers -> g3
    void addAllWaitingNextPageRenderers() -> a2
    void addWaitingNextPageRenderers() -> b2
    void close() -> c2
    void flush() -> d2
    void flushSingleRenderer(com.itextpdf.layout.renderer.IRenderer) -> e2
    void flushWaitingDrawingElements(boolean) -> f2
    void linkRenderToDocument(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.kernel.pdf.PdfDocument) -> g2
    void processRenderer(com.itextpdf.layout.renderer.IRenderer,java.util.List) -> h2
    com.itextpdf.layout.layout.LayoutResult layout(com.itextpdf.layout.layout.LayoutContext) -> i
    void processWaitingKeepWithNextElement(com.itextpdf.layout.renderer.IRenderer) -> i2
    void shrinkCurrentAreaAndProcessRenderer(com.itextpdf.layout.renderer.IRenderer,java.util.List,com.itextpdf.layout.layout.LayoutResult) -> j2
    boolean tryDisableKeepTogether(com.itextpdf.layout.layout.LayoutResult,boolean,com.itextpdf.layout.renderer.RootRendererAreaStateHandler) -> k2
    void updateCurrentAndInitialArea(com.itextpdf.layout.layout.LayoutResult) -> l2
    com.itextpdf.layout.layout.LayoutArea updateCurrentArea(com.itextpdf.layout.layout.LayoutResult) -> m2
    boolean updateForcedPlacement(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.layout.renderer.IRenderer) -> n2
    void addChild(com.itextpdf.layout.renderer.IRenderer) -> w
com.itextpdf.layout.renderer.RootRendererAreaStateHandler -> g2.z:
    com.itextpdf.layout.layout.RootLayoutArea storedNextArea -> b
    com.itextpdf.layout.layout.RootLayoutArea storedPreviousArea -> a
    java.util.List storedNextFloatRenderAreas -> d
    java.util.List storedPreviousFloatRenderAreas -> c
    boolean attemptGoBackToStoredPreviousStateAndStoreNextState(com.itextpdf.layout.renderer.RootRenderer) -> a
    boolean attemptGoForwardToStoredNextState(com.itextpdf.layout.renderer.RootRenderer) -> b
    com.itextpdf.layout.renderer.RootRendererAreaStateHandler storePreviousState(com.itextpdf.layout.renderer.RootRenderer) -> c
com.itextpdf.layout.renderer.RotationUtils -> g2.a0:
    com.itextpdf.layout.minmaxwidth.MinMaxWidth countRotationMinMaxWidth(com.itextpdf.layout.minmaxwidth.MinMaxWidth,com.itextpdf.layout.renderer.AbstractRenderer) -> a
    java.lang.Float getLayoutRotatedWidth(com.itextpdf.layout.renderer.AbstractRenderer,float,com.itextpdf.kernel.geom.Rectangle,double) -> b
    java.lang.Float retrieveRotatedLayoutWidth(float,com.itextpdf.layout.renderer.AbstractRenderer) -> c
com.itextpdf.layout.renderer.RotationUtils$PropertiesBackup -> g2.a0$a:
    java.util.HashMap propertiesBackup -> b
    com.itextpdf.layout.renderer.AbstractRenderer renderer -> a
    void restoreProperty(int) -> a
    java.lang.Float storeFloatProperty(int) -> b
    java.lang.Object storeProperty(int) -> c
com.itextpdf.layout.renderer.RotationUtils$PropertiesBackup$PropertyBackup -> g2.a0$a$a:
    java.lang.Object propertyValue -> a
    boolean isOwnedByRender -> b
    java.lang.Object getValue() -> a
    boolean isOwnedByRender() -> b
com.itextpdf.layout.renderer.SeparatedTableBorders -> g2.b0:
    java.util.List getVerticalBorder(int) -> A
    com.itextpdf.layout.renderer.TableBorders initializeBorders() -> D
    com.itextpdf.layout.renderer.TableBorders skipFooter(com.itextpdf.layout.borders.Border[]) -> K
    com.itextpdf.layout.renderer.TableBorders skipHeader(com.itextpdf.layout.borders.Border[]) -> L
    com.itextpdf.layout.renderer.TableBorders updateBordersOnNewPage(boolean,boolean,com.itextpdf.layout.renderer.TableRenderer,com.itextpdf.layout.renderer.TableRenderer,com.itextpdf.layout.renderer.TableRenderer) -> M
    boolean checkAndReplaceBorderInArray(java.util.List,int,int,com.itextpdf.layout.borders.Border,boolean) -> N
    com.itextpdf.layout.renderer.TableBorders applyBottomTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean) -> a
    com.itextpdf.layout.renderer.TableBorders applyBottomTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean,boolean,boolean) -> b
    com.itextpdf.layout.renderer.TableBorders applyCellIndents(com.itextpdf.kernel.geom.Rectangle,float,float,float,float,boolean) -> c
    com.itextpdf.layout.renderer.TableBorders applyLeftAndRightTableBorder(com.itextpdf.kernel.geom.Rectangle,boolean) -> d
    com.itextpdf.layout.renderer.TableBorders applyTopTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean) -> e
    com.itextpdf.layout.renderer.TableBorders applyTopTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean,boolean,boolean) -> f
    void buildBordersArrays(com.itextpdf.layout.renderer.CellRenderer,int,int,int[]) -> g
    com.itextpdf.layout.renderer.TableBorders collapseTableWithFooter(com.itextpdf.layout.renderer.TableBorders,boolean) -> h
    com.itextpdf.layout.renderer.TableBorders collapseTableWithHeader(com.itextpdf.layout.renderer.TableBorders,boolean) -> i
    com.itextpdf.layout.renderer.TableBorders drawHorizontalBorder(com.itextpdf.kernel.pdf.canvas.PdfCanvas,com.itextpdf.layout.renderer.TableBorderDescriptor) -> j
    com.itextpdf.layout.renderer.TableBorders drawVerticalBorder(com.itextpdf.kernel.pdf.canvas.PdfCanvas,com.itextpdf.layout.renderer.TableBorderDescriptor) -> k
    com.itextpdf.layout.renderer.TableBorders fixHeaderOccupiedArea(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle) -> l
    float[] getCellBorderIndents(int,int,int,int) -> m
    float getCellVerticalAddition(float[]) -> n
    java.util.List getFirstHorizontalBorder() -> p
    java.util.List getHorizontalBorder(int) -> q
    java.util.List getLastHorizontalBorder() -> r
    float getMaxBottomWidth() -> t
    float getMaxLeftWidth() -> u
    float getMaxRightWidth() -> v
    float getMaxTopWidth() -> w
com.itextpdf.layout.renderer.SumSumWidthHandler -> g2.c0:
    void updateMaxChildWidth(float) -> a
    void updateMinChildWidth(float) -> b
com.itextpdf.layout.renderer.TableBorderDescriptor -> g2.d0:
    float crossCoordinate -> c
    float mainCoordinateStart -> b
    float[] mainCoordinateWidths -> d
    int borderIndex -> a
    int getBorderIndex() -> a
    float getCrossCoordinate() -> b
    float getMainCoordinateStart() -> c
    float[] getMainCoordinateWidths() -> d
com.itextpdf.layout.renderer.TableBorderUtil -> g2.e0:
    java.util.List createAndFillBorderList(java.util.List,com.itextpdf.layout.borders.Border,int) -> a
    com.itextpdf.layout.borders.Border getCellSideBorder(com.itextpdf.layout.element.Cell,int) -> b
    com.itextpdf.layout.borders.Border getWidestBorder(java.util.List) -> c
com.itextpdf.layout.renderer.TableBorders -> g2.f0:
    java.util.List verticalBorders -> b
    java.util.List horizontalBorders -> a
    float rightBorderMaxWidth -> i
    float leftBorderMaxWidth -> h
    int largeTableIndexOffset -> j
    java.util.List rows -> e
    com.itextpdf.layout.borders.Border[] tableBoundingBorders -> d
    int startRow -> f
    int finishRow -> g
    int numberOfColumns -> c
    java.util.List getVerticalBorder(int) -> A
    com.itextpdf.layout.borders.Border getWidestHorizontalBorder(int) -> B
    com.itextpdf.layout.borders.Border getWidestVerticalBorder(int) -> C
    com.itextpdf.layout.renderer.TableBorders initializeBorders() -> D
    com.itextpdf.layout.renderer.TableBorders processAllBordersAndEmptyRows() -> E
    void removeRows(int,int) -> F
    com.itextpdf.layout.renderer.TableBorders setFinishRow(int) -> G
    com.itextpdf.layout.renderer.TableBorders setRowRange(int,int) -> H
    com.itextpdf.layout.renderer.TableBorders setStartRow(int) -> I
    com.itextpdf.layout.renderer.TableBorders setTableBoundingBorders(com.itextpdf.layout.borders.Border[]) -> J
    com.itextpdf.layout.renderer.TableBorders skipFooter(com.itextpdf.layout.borders.Border[]) -> K
    com.itextpdf.layout.renderer.TableBorders skipHeader(com.itextpdf.layout.borders.Border[]) -> L
    com.itextpdf.layout.renderer.TableBorders updateBordersOnNewPage(boolean,boolean,com.itextpdf.layout.renderer.TableRenderer,com.itextpdf.layout.renderer.TableRenderer,com.itextpdf.layout.renderer.TableRenderer) -> M
    com.itextpdf.layout.renderer.TableBorders applyBottomTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean) -> a
    com.itextpdf.layout.renderer.TableBorders applyBottomTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean,boolean,boolean) -> b
    com.itextpdf.layout.renderer.TableBorders applyCellIndents(com.itextpdf.kernel.geom.Rectangle,float,float,float,float,boolean) -> c
    com.itextpdf.layout.renderer.TableBorders applyLeftAndRightTableBorder(com.itextpdf.kernel.geom.Rectangle,boolean) -> d
    com.itextpdf.layout.renderer.TableBorders applyTopTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean) -> e
    com.itextpdf.layout.renderer.TableBorders applyTopTableBorder(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle,boolean,boolean,boolean) -> f
    void buildBordersArrays(com.itextpdf.layout.renderer.CellRenderer,int,int,int[]) -> g
    com.itextpdf.layout.renderer.TableBorders collapseTableWithFooter(com.itextpdf.layout.renderer.TableBorders,boolean) -> h
    com.itextpdf.layout.renderer.TableBorders collapseTableWithHeader(com.itextpdf.layout.renderer.TableBorders,boolean) -> i
    com.itextpdf.layout.renderer.TableBorders drawHorizontalBorder(com.itextpdf.kernel.pdf.canvas.PdfCanvas,com.itextpdf.layout.renderer.TableBorderDescriptor) -> j
    com.itextpdf.layout.renderer.TableBorders drawVerticalBorder(com.itextpdf.kernel.pdf.canvas.PdfCanvas,com.itextpdf.layout.renderer.TableBorderDescriptor) -> k
    com.itextpdf.layout.renderer.TableBorders fixHeaderOccupiedArea(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.kernel.geom.Rectangle) -> l
    float[] getCellBorderIndents(int,int,int,int) -> m
    float getCellVerticalAddition(float[]) -> n
    int getFinishRow() -> o
    java.util.List getFirstHorizontalBorder() -> p
    java.util.List getHorizontalBorder(int) -> q
    java.util.List getLastHorizontalBorder() -> r
    float getLeftBorderMaxWidth() -> s
    float getMaxBottomWidth() -> t
    float getMaxLeftWidth() -> u
    float getMaxRightWidth() -> v
    float getMaxTopWidth() -> w
    int getNumberOfColumns() -> x
    float getRightBorderMaxWidth() -> y
    int getStartRow() -> z
com.itextpdf.layout.renderer.TableRenderer -> g2.g0:
    float[] countedColumnWidth -> h3
    float topBorderMaxWidth -> j3
    com.itextpdf.layout.element.Table$RowRange rowRange -> Z2
    com.itextpdf.layout.renderer.TableRenderer footerRenderer -> b3
    float[] columnWidths -> f3
    float totalWidthForColumns -> i3
    com.itextpdf.layout.renderer.TableRenderer headerRenderer -> a3
    com.itextpdf.layout.renderer.DivRenderer captionRenderer -> c3
    boolean isOriginalNonSplitRenderer -> d3
    java.util.List rows -> Y2
    com.itextpdf.layout.renderer.TableBorders bordersHandler -> e3
    java.util.List heights -> g3
    boolean isBottomTablePart() -> A2
    boolean isEmptyTableRenderer() -> B2
    boolean isFooterRenderer() -> C2
    boolean allowLastYLineRecursiveExtraction() -> D
    boolean isFooterRendererOfLargeTable() -> D2
    com.itextpdf.layout.minmaxwidth.MinMaxWidth getMinMaxWidth() -> E0
    boolean isHeaderRenderer() -> E2
    boolean isOriginalRenderer() -> F2
    boolean isTopTablePart() -> G2
    com.itextpdf.layout.renderer.TableRenderer prepareFooterOrHeaderRendererForLayout(com.itextpdf.layout.renderer.TableRenderer,float) -> H2
    void setRowRange(com.itextpdf.layout.element.Table$RowRange) -> I2
    com.itextpdf.kernel.geom.Rectangle applyBorderBox(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.borders.Border[],boolean) -> J
    com.itextpdf.layout.renderer.TableRenderer[] split(int,boolean,boolean) -> J2
    java.lang.Float retrieveWidth(float) -> L1
    com.itextpdf.kernel.geom.Rectangle applyPaddings(com.itextpdf.kernel.geom.Rectangle,boolean) -> P
    com.itextpdf.kernel.geom.Rectangle applyPaddings(com.itextpdf.kernel.geom.Rectangle,com.itextpdf.layout.properties.UnitValue[],boolean) -> Q
    void adjustCaptionAndFixOccupiedArea(com.itextpdf.kernel.geom.Rectangle,float) -> a2
    com.itextpdf.layout.renderer.IRenderer getNextRenderer() -> b
    void adjustFooterAndFixOccupiedArea(com.itextpdf.kernel.geom.Rectangle,float) -> b2
    void applyFixedXOrYPosition(boolean,com.itextpdf.kernel.geom.Rectangle) -> c2
    void draw(com.itextpdf.layout.renderer.DrawContext) -> d
    void applyMarginsAndPaddingsAndCalculateColumnWidths(com.itextpdf.kernel.geom.Rectangle) -> d2
    com.itextpdf.kernel.geom.Rectangle applySingleSpacing(com.itextpdf.kernel.geom.Rectangle,float,boolean,boolean) -> e2
    com.itextpdf.kernel.geom.Rectangle applySpacing(com.itextpdf.kernel.geom.Rectangle,float,float,boolean) -> f2
    void calculateColumnWidths(float) -> g2
    void correctLayoutedCellsOccupiedAreas(com.itextpdf.layout.layout.LayoutResult[],int,int[],java.lang.Float,com.itextpdf.kernel.geom.Rectangle,java.util.List,boolean,boolean,boolean) -> h2
    com.itextpdf.layout.layout.LayoutResult layout(com.itextpdf.layout.layout.LayoutContext) -> i
    void correctRowCellsOccupiedAreas(com.itextpdf.layout.layout.LayoutResult[],int,int[],int,java.util.List,float,float) -> i2
    void correctRowRange() -> j2
    com.itextpdf.layout.renderer.TableRenderer createOverflowRenderer(com.itextpdf.layout.element.Table$RowRange) -> k2
    void move(float,float) -> l
    void drawBackground(com.itextpdf.layout.renderer.DrawContext) -> l0
    com.itextpdf.layout.renderer.TableRenderer createSplitRenderer(com.itextpdf.layout.element.Table$RowRange) -> l2
    void drawBackgrounds(com.itextpdf.layout.renderer.DrawContext) -> m2
    void drawBorders(com.itextpdf.layout.renderer.DrawContext) -> n2
    void drawBorder(com.itextpdf.layout.renderer.DrawContext) -> o0
    void drawBorders(com.itextpdf.layout.renderer.DrawContext,boolean,boolean) -> o2
    void drawChildren(com.itextpdf.layout.renderer.DrawContext) -> p0
    void drawCaption(com.itextpdf.layout.renderer.DrawContext) -> p2
    void enlargeCell(int,int,int,com.itextpdf.layout.renderer.CellRenderer[],com.itextpdf.layout.renderer.TableRenderer$OverflowRowsWrapper,int[],com.itextpdf.layout.renderer.TableRenderer[]) -> q2
    void enlargeCellWithBigRowspan(com.itextpdf.layout.renderer.CellRenderer[],com.itextpdf.layout.renderer.TableRenderer$OverflowRowsWrapper,int,int,int,com.itextpdf.layout.renderer.TableRenderer[],int[]) -> r2
    void ensureFooterOrHeaderHasTheSamePropertiesAsParentTableRenderer(com.itextpdf.layout.renderer.TableRenderer) -> s2
    void extendLastRow(com.itextpdf.layout.renderer.CellRenderer[],com.itextpdf.kernel.geom.Rectangle) -> t2
    com.itextpdf.layout.element.Table getTable() -> u2
    float getTableWidth() -> v2
    void addChild(com.itextpdf.layout.renderer.IRenderer) -> w
    com.itextpdf.layout.renderer.TableRenderer initFooterOrHeaderRenderer(boolean,com.itextpdf.layout.borders.Border[]) -> w2
    void initializeCaptionRenderer(com.itextpdf.layout.element.Div) -> x2
    void initializeHeaderAndFooter(boolean) -> y2
    void initializeTableLayoutBorders() -> z2
com.itextpdf.layout.renderer.TableRenderer$CellRendererInfo -> g2.g0$a:
    com.itextpdf.layout.renderer.CellRenderer cellRenderer -> a
    int column -> b
    int finishRowInd -> c
com.itextpdf.layout.renderer.TableRenderer$OverflowRowsWrapper -> g2.g0$b:
    com.itextpdf.layout.renderer.TableRenderer overflowRenderer -> a
    java.util.HashMap isRowReplaced -> b
    boolean isReplaced -> c
    com.itextpdf.layout.renderer.CellRenderer getCell(int,int) -> a
    com.itextpdf.layout.renderer.CellRenderer setCell(int,int,com.itextpdf.layout.renderer.CellRenderer) -> b
com.itextpdf.layout.renderer.TableWidths -> g2.h0:
    float tableMinWidth -> l
    float layoutMinWidth -> k
    com.itextpdf.layout.renderer.TableRenderer tableRenderer -> a
    com.itextpdf.layout.properties.UnitValue ZeroWidth -> n
    float tableWidth -> h
    boolean fixedTableWidth -> i
    com.itextpdf.layout.renderer.TableWidths$ColumnWidthData[] widths -> e
    boolean fixedTableLayout -> j
    float horizontalBorderSpacing -> f
    float leftBorderMaxWidth -> d
    float rightBorderMaxWidth -> c
    int numberOfColumns -> b
    java.util.List cells -> g
    float tableMaxWidth -> m
    float[] autoLayout() -> a
    void calculateMinMaxWidths() -> b
    void calculateTableWidth(float,boolean) -> c
    float[] extractWidths() -> d
    void fillAndSortCells() -> e
    void fillRendererCells(com.itextpdf.layout.renderer.TableRenderer,byte) -> f
    float[] fixedLayout() -> g
    float[] getCellBorderIndents(com.itextpdf.layout.renderer.TableWidths$CellInfo) -> h
    com.itextpdf.layout.properties.UnitValue getCellWidth(com.itextpdf.layout.renderer.CellRenderer,boolean) -> i
    float getMinWidth() -> j
    com.itextpdf.layout.element.Table getTable() -> k
    boolean hasFixedLayout() -> l
    float[] layout() -> m
    void processCell(com.itextpdf.layout.renderer.TableWidths$CellInfo) -> n
    void processCellsRemainWidth(com.itextpdf.layout.renderer.TableWidths$CellInfo,com.itextpdf.layout.properties.UnitValue) -> o
    void processColumns() -> p
    void recalculate(float) -> q
    com.itextpdf.layout.properties.UnitValue resolveMinMaxCollision(com.itextpdf.layout.renderer.CellRenderer,com.itextpdf.layout.properties.UnitValue) -> r
    float retrieveTableWidth(float) -> s
    java.lang.Float retrieveTableWidth(com.itextpdf.layout.properties.UnitValue,float) -> t
    void warn100percent() -> u
com.itextpdf.layout.renderer.TableWidths$CellInfo -> g2.h0$a:
    int col -> S2
    byte region -> T2
    com.itextpdf.layout.renderer.CellRenderer cell -> Q2
    int row -> R2
    void setParent(com.itextpdf.layout.renderer.TableRenderer) -> A
    int compareTo(com.itextpdf.layout.renderer.TableWidths$CellInfo) -> a
    com.itextpdf.layout.renderer.CellRenderer getCell() -> c
    int getCol() -> d
    int getColspan() -> k
    int getRow() -> n
    int getRowspan() -> x
com.itextpdf.layout.renderer.TableWidths$ColumnWidthData -> g2.h0$b:
    float finalWidth -> d
    boolean isPercent -> e
    float width -> c
    boolean isFixed -> f
    float max -> b
    float min -> a
    com.itextpdf.layout.renderer.TableWidths$ColumnWidthData addPercents(float) -> a
    com.itextpdf.layout.renderer.TableWidths$ColumnWidthData addPoints(float) -> b
    boolean isFlexible() -> c
    com.itextpdf.layout.renderer.TableWidths$ColumnWidthData resetPoints(float) -> d
    com.itextpdf.layout.renderer.TableWidths$ColumnWidthData setFixed(boolean) -> e
    com.itextpdf.layout.renderer.TableWidths$ColumnWidthData setPercents(float) -> f
    com.itextpdf.layout.renderer.TableWidths$ColumnWidthData setPoints(float) -> g
com.itextpdf.layout.renderer.TargetCounterHandler -> g2.i0:
    java.util.Map renderersPages -> a
    java.util.Map previousRenderersPages -> b
    void addPageByID(com.itextpdf.layout.renderer.IRenderer) -> a
    com.itextpdf.layout.renderer.TargetCounterHandler getTargetCounterHandler(com.itextpdf.layout.renderer.IRenderer) -> b
com.itextpdf.layout.renderer.TextPreprocessingUtil -> g2.j0:
    com.itextpdf.io.font.otf.GlyphLine replaceSpecialWhitespaceGlyphs(com.itextpdf.io.font.otf.GlyphLine,com.itextpdf.kernel.font.PdfFont) -> a
com.itextpdf.layout.renderer.TextRenderer -> g2.k0:
    float yLineOffset -> Y2
    boolean otfFeaturesApplied -> d3
    int indexOfFirstCharacterToBeForcedToOverflow -> j3
    com.itextpdf.kernel.font.PdfFont font -> Z2
    com.itextpdf.io.font.otf.GlyphLine savedWordBreakAtLineEnding -> g3
    int specialScriptFirstNotFittingIndex -> i3
    com.itextpdf.io.font.otf.GlyphLine text -> a3
    java.lang.String strToBeConverted -> c3
    com.itextpdf.io.font.otf.GlyphLine line -> b3
    java.util.List reversedRanges -> f3
    java.util.List specialScriptsWordBreakPoints -> h3
    float tabAnchorCharacterPosition -> e3
    int length() -> A2
    java.lang.Float getLastYLineRecursively() -> B0
    com.itextpdf.kernel.font.PdfFont resolveFirstPdfFont(java.lang.String[],com.itextpdf.layout.font.FontProvider,com.itextpdf.layout.font.FontCharacteristics,com.itextpdf.layout.font.FontSet) -> B1
    int lineLength() -> B2
    boolean noPrint(com.itextpdf.io.font.otf.Glyph) -> C2
    int numberOfElementsLessThan(java.util.ArrayList,int) -> D2
    com.itextpdf.layout.minmaxwidth.MinMaxWidth getMinMaxWidth() -> E0
    int numberOfElementsLessThanOrEqual(java.util.ArrayList,int) -> E2
    com.itextpdf.layout.renderer.TextRenderer removeReversedRanges() -> F2
    boolean resolveFonts(java.util.List) -> G2
    void saveWordBreakIfNotYetSaved(com.itextpdf.io.font.otf.Glyph) -> H2
    float scaleXAdvance(float,float,java.lang.Float) -> I2
    void setIndexOfFirstCharacterToBeForcedToOverflow(int) -> J2
    void setProcessedGlyphLineAndFont(com.itextpdf.io.font.otf.GlyphLine,com.itextpdf.kernel.font.PdfFont) -> K2
    void setSpecialScriptFirstNotFittingIndex(int) -> L2
    void setSpecialScriptsWordBreakPoints(java.util.List) -> M2
    com.itextpdf.layout.renderer.TextRenderer[] split(int) -> N2
    com.itextpdf.layout.renderer.TextRenderer[] splitIgnoreFirstNewLine(int) -> O2
    boolean textContainsSpecialScriptGlyphs(boolean) -> P2
    void trimFirst() -> Q2
    float trimLast() -> R2
    void updateFontAndText() -> S2
    void updateRangeBasedOnRemovedCharacters(java.util.ArrayList,int[]) -> T2
    float getDescent() -> a
    boolean access$100(com.itextpdf.io.font.otf.Glyph) -> a2
    com.itextpdf.layout.renderer.IRenderer getNextRenderer() -> b
    void applyOtf() -> b2
    int baseCharactersCount() -> c2
    void draw(com.itextpdf.layout.renderer.DrawContext) -> d
    float[] calculateAscenderDescender(com.itextpdf.kernel.font.PdfFont,com.itextpdf.layout.properties.RenderingMode) -> d2
    float getAscent() -> e
    float calculateLineWidth() -> e2
    boolean codePointIsOfSpecialScript(int) -> f2
    com.itextpdf.layout.renderer.TextRenderer createCopy(com.itextpdf.io.font.otf.GlyphLine,com.itextpdf.kernel.font.PdfFont) -> g2
    com.itextpdf.layout.renderer.TextRenderer createOverflowRenderer() -> h2
    com.itextpdf.layout.layout.LayoutResult layout(com.itextpdf.layout.layout.LayoutContext) -> i
    com.itextpdf.layout.renderer.TextRenderer createSplitRenderer() -> i2
    void drawSingleUnderline(com.itextpdf.layout.properties.Underline,com.itextpdf.layout.properties.TransparentColor,com.itextpdf.kernel.pdf.canvas.PdfCanvas,float,float) -> j2
    int findPossibleBreaksSplitPosition(java.util.List,int,boolean) -> k2
    float getCharWidth(com.itextpdf.io.font.otf.Glyph,float,java.lang.Float,java.lang.Float,java.lang.Float) -> l2
    float getGlyphLineWidth(com.itextpdf.io.font.otf.GlyphLine,float,float,java.lang.Float,java.lang.Float) -> m2
    int getNumberOfSpaces() -> n2
    java.util.List getReversedRanges() -> o2
    int getSpecialScriptFirstNotFittingIndex() -> p2
    java.util.List getSpecialScriptsWordBreakPoints() -> q2
    com.itextpdf.io.font.otf.GlyphLine getText() -> r2
    int[] getWordBoundsForHyphenation(com.itextpdf.io.font.otf.GlyphLine,int,int,int) -> s2
    float getYLine() -> t2
    com.itextpdf.kernel.geom.Rectangle getBackgroundArea(com.itextpdf.kernel.geom.Rectangle) -> u0
    boolean glyphBelongsToNonBreakingHyphenRelatedChunk(com.itextpdf.io.font.otf.GlyphLine,int) -> u2
    boolean hasOtfFont() -> v2
    void increaseYLineOffset(com.itextpdf.layout.properties.UnitValue[],com.itextpdf.layout.borders.Border[],com.itextpdf.layout.properties.UnitValue[]) -> w2
    java.util.List initReversedRanges() -> x2
    boolean isGlyphPartOfWordForHyphenation(com.itextpdf.io.font.otf.Glyph) -> y2
    boolean[] isStartsWithSplitCharWhiteSpaceAndEndsWithSplitChar(com.itextpdf.layout.splitting.ISplitCharacters) -> z2
com.itextpdf.layout.renderer.TextRenderer$1 -> g2.k0$a:
com.itextpdf.layout.renderer.TextRenderer$CustomGlyphLineFilter -> g2.k0$b:
    boolean accept(com.itextpdf.io.font.otf.Glyph) -> a
com.itextpdf.layout.renderer.TextRenderer$ReversedCharsIterator -> g2.k0$c:
    java.util.List outStart -> Q2
    java.util.List reversed -> S2
    java.util.List outEnd -> R2
    int currentInd -> T2
    boolean useReversed -> U2
    com.itextpdf.io.font.otf.GlyphLine$GlyphLinePart next() -> a
    com.itextpdf.layout.renderer.TextRenderer$ReversedCharsIterator setUseReversed(boolean) -> b
com.itextpdf.layout.renderer.TextRenderer$ScriptRange -> g2.k0$d:
    int rangeEnd -> b
    java.lang.Character$UnicodeScript script -> a
com.itextpdf.layout.renderer.TextSequenceWordWrapping -> g2.l0:
    java.util.List convertPossibleBreakPointsToGlyphLineBased(java.util.List,java.util.List,java.util.List) -> a
    void distributePossibleBreakPointsOverSequentialTextRenderers(com.itextpdf.layout.renderer.LineRenderer,int,int,java.util.List,java.util.List) -> b
    void fillActualTextChunkRelatedLists(com.itextpdf.io.font.otf.GlyphLine,java.util.List,java.util.List) -> c
    float getCurWidthRelayoutedTextSequenceDecrement(int,int,java.util.Map) -> d
    com.itextpdf.layout.renderer.TextSequenceWordWrapping$LastFittingChildRendererData getIndexAndLayoutResultOfTheLastTextRendererContainingSpecialScripts(com.itextpdf.layout.renderer.LineRenderer,int,java.util.Map,boolean,boolean) -> e
    com.itextpdf.layout.renderer.TextSequenceWordWrapping$LastFittingChildRendererData getIndexAndLayoutResultOfTheLastTextRendererWithNoSpecialScripts(com.itextpdf.layout.renderer.LineRenderer,int,java.util.Map,boolean,boolean,boolean) -> f
    com.itextpdf.layout.renderer.TextSequenceWordWrapping$SpecialScriptsContainingSequenceStatus getSpecialScriptsContainingSequenceStatus(com.itextpdf.layout.renderer.LineRenderer,int) -> g
    com.itextpdf.layout.renderer.TextSequenceWordWrapping$SpecialScriptsContainingTextRendererSequenceInfo getSpecialScriptsContainingTextRendererSequenceInfo(com.itextpdf.layout.renderer.LineRenderer,int) -> h
    boolean isTextRendererAndRequiresSpecialScriptPreLayoutProcessing(com.itextpdf.layout.renderer.IRenderer) -> i
    boolean postprocessTextSequenceOverflowX(com.itextpdf.layout.renderer.LineRenderer,boolean,int,com.itextpdf.layout.renderer.IRenderer,com.itextpdf.layout.layout.LayoutResult,boolean) -> j
    void preprocessTextSequenceOverflowX(com.itextpdf.layout.renderer.LineRenderer,boolean,com.itextpdf.layout.renderer.IRenderer,boolean,com.itextpdf.layout.properties.OverflowPropertyValue) -> k
    void processSpecialScriptPreLayout(com.itextpdf.layout.renderer.LineRenderer,int) -> l
    void resetTextSequenceIfItEnded(java.util.Map,boolean,com.itextpdf.layout.renderer.IRenderer,int,com.itextpdf.layout.renderer.TextSequenceWordWrapping$MinMaxWidthOfTextRendererSequenceHelper,boolean,com.itextpdf.layout.renderer.AbstractWidthHandler) -> m
    void updateMinMaxWidthOfLineRendererAfterTextRendererSequenceProcessing(boolean,int,com.itextpdf.layout.layout.LayoutResult,com.itextpdf.layout.renderer.AbstractWidthHandler,com.itextpdf.layout.renderer.TextSequenceWordWrapping$MinMaxWidthOfTextRendererSequenceHelper,java.util.Map) -> n
    com.itextpdf.layout.renderer.LineRenderer$LineAscentDescentState updateTextRendererSequenceAscentDescent(com.itextpdf.layout.renderer.LineRenderer,java.util.Map,int,float[],com.itextpdf.layout.renderer.LineRenderer$LineAscentDescentState) -> o
    com.itextpdf.layout.renderer.TextSequenceWordWrapping$MinMaxWidthOfTextRendererSequenceHelper updateTextRendererSequenceMinMaxWidth(com.itextpdf.layout.renderer.LineRenderer,com.itextpdf.layout.renderer.AbstractWidthHandler,int,com.itextpdf.layout.renderer.TextSequenceWordWrapping$MinMaxWidthOfTextRendererSequenceHelper,boolean,java.util.Map,java.util.Map,float) -> p
    void updateTextSequenceLayoutResults(java.util.Map,boolean,com.itextpdf.layout.renderer.IRenderer,int,com.itextpdf.layout.layout.LayoutResult) -> q
com.itextpdf.layout.renderer.TextSequenceWordWrapping$LastFittingChildRendererData -> g2.l0$a:
    com.itextpdf.layout.layout.LayoutResult childLayoutResult -> b
    int childIndex -> a
com.itextpdf.layout.renderer.TextSequenceWordWrapping$MinMaxWidthOfTextRendererSequenceHelper -> g2.l0$b:
    float textIndent -> b
    float minWidthPreSequence -> a
    boolean anythingPlacedBeforeTextRendererSequence -> c
com.itextpdf.layout.renderer.TextSequenceWordWrapping$SpecialScriptsContainingSequenceStatus -> g2.l0$c:
    com.itextpdf.layout.renderer.TextSequenceWordWrapping$SpecialScriptsContainingSequenceStatus MOVE_TO_PREVIOUS_TEXT_RENDERER_CONTAINING_SPECIAL_SCRIPTS -> R2
    com.itextpdf.layout.renderer.TextSequenceWordWrapping$SpecialScriptsContainingSequenceStatus FORCED_SPLIT -> S2
    com.itextpdf.layout.renderer.TextSequenceWordWrapping$SpecialScriptsContainingSequenceStatus MOVE_SEQUENCE_CONTAINING_SPECIAL_SCRIPTS_ON_NEXT_LINE -> Q2
    com.itextpdf.layout.renderer.TextSequenceWordWrapping$SpecialScriptsContainingSequenceStatus[] $VALUES -> T2
com.itextpdf.layout.renderer.TextSequenceWordWrapping$SpecialScriptsContainingTextRendererSequenceInfo -> g2.l0$d:
    java.util.List indicesOfFloating -> c
    java.lang.String sequentialTextContent -> b
    int numberOfSequentialTextRenderers -> a
com.itextpdf.layout.renderer.TypographyUtils -> g2.m0:
    com.itextpdf.layout.renderer.typography.AbstractTypographyApplier applierInstance -> a
    void applyKerning(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.otf.GlyphLine,com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.contexts.IMetaInfo) -> a
    void applyOtfScript(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.otf.GlyphLine,java.lang.Character$UnicodeScript,java.lang.Object,com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.contexts.IMetaInfo) -> b
    byte[] getBidiLevels(com.itextpdf.layout.properties.BaseDirection,int[],com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.contexts.IMetaInfo) -> c
    java.util.List getPossibleBreaks(java.lang.String) -> d
    java.util.Collection getSupportedScripts() -> e
    java.util.Collection getSupportedScripts(java.lang.Object) -> f
    java.lang.Class getTypographyClass(java.lang.String) -> g
    boolean isPdfCalligraphAvailable() -> h
    int[] reorderLine(java.util.List,byte[],byte[]) -> i
    void setTypographyApplierInstance(com.itextpdf.layout.renderer.typography.AbstractTypographyApplier) -> j
com.itextpdf.layout.renderer.objectfit.ObjectFitApplyingResult -> h2.a:
    double renderedImageWidth -> a
    double renderedImageHeight -> b
    boolean imageCuttingRequired -> c
    double getRenderedImageHeight() -> a
    double getRenderedImageWidth() -> b
    boolean isImageCuttingRequired() -> c
com.itextpdf.layout.renderer.objectfit.ObjectFitCalculator -> h2.b:
    com.itextpdf.layout.renderer.objectfit.ObjectFitApplyingResult calculateRenderedImageSize(com.itextpdf.layout.properties.ObjectFit,double,double,double,double) -> a
    com.itextpdf.layout.renderer.objectfit.ObjectFitApplyingResult processContain(double,double,double,double) -> b
    com.itextpdf.layout.renderer.objectfit.ObjectFitApplyingResult processCover(double,double,double,double) -> c
    com.itextpdf.layout.renderer.objectfit.ObjectFitApplyingResult processFill(double,double) -> d
    com.itextpdf.layout.renderer.objectfit.ObjectFitApplyingResult processNone(double,double,double,double) -> e
    com.itextpdf.layout.renderer.objectfit.ObjectFitApplyingResult processScaleDown(double,double,double,double) -> f
    com.itextpdf.layout.renderer.objectfit.ObjectFitApplyingResult processToFitSide(double,double,double,double,boolean) -> g
com.itextpdf.layout.renderer.objectfit.ObjectFitCalculator$1 -> h2.b$a:
    int[] $SwitchMap$com$itextpdf$layout$properties$ObjectFit -> a
com.itextpdf.layout.renderer.typography.AbstractTypographyApplier -> i2.a:
    boolean applyKerning(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.otf.GlyphLine,com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.contexts.IMetaInfo) -> b
    boolean applyOtfScript(com.itextpdf.io.font.TrueTypeFont,com.itextpdf.io.font.otf.GlyphLine,java.lang.Character$UnicodeScript,java.lang.Object,com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.contexts.IMetaInfo) -> c
    byte[] getBidiLevels(com.itextpdf.layout.properties.BaseDirection,int[],com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.contexts.IMetaInfo) -> d
    java.util.List getPossibleBreaks(java.lang.String) -> e
    java.util.Collection getSupportedScripts() -> f
    java.util.Collection getSupportedScripts(java.lang.Object) -> g
    boolean isPdfCalligraphInstance() -> h
    int[] reorderLine(java.util.List,byte[],byte[]) -> i
com.itextpdf.layout.renderer.typography.DefaultTypographyApplier -> i2.b:
    org.slf4j.Logger LOGGER -> b
    boolean applyKerning(com.itextpdf.io.font.FontProgram,com.itextpdf.io.font.otf.GlyphLine,com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.contexts.IMetaInfo) -> b
    boolean applyOtfScript(com.itextpdf.io.font.TrueTypeFont,com.itextpdf.io.font.otf.GlyphLine,java.lang.Character$UnicodeScript,java.lang.Object,com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.contexts.IMetaInfo) -> c
    byte[] getBidiLevels(com.itextpdf.layout.properties.BaseDirection,int[],com.itextpdf.commons.actions.sequence.SequenceId,com.itextpdf.commons.actions.contexts.IMetaInfo) -> d
    java.util.List getPossibleBreaks(java.lang.String) -> e
    java.util.Collection getSupportedScripts() -> f
    java.util.Collection getSupportedScripts(java.lang.Object) -> g
    boolean isPdfCalligraphInstance() -> h
    int[] reorderLine(java.util.List,byte[],byte[]) -> i
com.itextpdf.layout.splitting.DefaultSplitCharacters -> j2.a:
    boolean isSplitCharacter(com.itextpdf.io.font.otf.GlyphLine,int) -> a
    boolean isADigitChar(com.itextpdf.io.font.otf.GlyphLine,int) -> b
com.itextpdf.layout.splitting.ISplitCharacters -> j2.b:
    boolean isSplitCharacter(com.itextpdf.io.font.otf.GlyphLine,int) -> a
com.itextpdf.layout.tagging.IAccessibleElement -> k2.a:
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties getAccessibilityProperties() -> j
com.itextpdf.layout.tagging.ITaggingRule -> k2.b:
    boolean onTagFinish(com.itextpdf.layout.tagging.LayoutTaggingHelper,com.itextpdf.layout.tagging.TaggingHintKey) -> a
com.itextpdf.layout.tagging.LayoutTaggingHelper -> k2.c:
    com.itextpdf.kernel.pdf.tagutils.TagStructureContext context -> a
    java.util.Map kidsHints -> d
    int RETVAL_PARENT_AND_KID_FINISHED -> j
    com.itextpdf.kernel.pdf.PdfDocument document -> b
    int RETVAL_NO_PARENT -> i
    java.util.Map parentHints -> e
    java.util.Map autoTaggingPointerSavedPosition -> f
    boolean immediateFlush -> c
    java.util.Map taggingRules -> g
    java.util.Map existingTagsDummies -> h
    void markArtifactHint(com.itextpdf.layout.IPropertyContainer) -> A
    int moveKidHint(com.itextpdf.layout.tagging.TaggingHintKey,com.itextpdf.layout.tagging.TaggingHintKey) -> B
    int moveKidHint(com.itextpdf.layout.tagging.TaggingHintKey,com.itextpdf.layout.tagging.TaggingHintKey,int) -> C
    void moveKidTagIfCreated(com.itextpdf.layout.tagging.TaggingHintKey,com.itextpdf.layout.tagging.TaggingHintKey) -> D
    void registerRules(com.itextpdf.kernel.pdf.PdfVersion) -> E
    void registerSingleRule(java.lang.String,com.itextpdf.layout.tagging.ITaggingRule) -> F
    void releaseAllHints() -> G
    void releaseFinishedHints() -> H
    void releaseHint(com.itextpdf.layout.tagging.TaggingHintKey,java.util.Set,boolean) -> I
    int removeParentHint(com.itextpdf.layout.tagging.TaggingHintKey) -> J
    int removeParentHint(com.itextpdf.layout.tagging.TaggingHintKey,com.itextpdf.layout.tagging.TaggingHintKey) -> K
    int replaceKidHint(com.itextpdf.layout.tagging.TaggingHintKey,java.util.Collection) -> L
    void restoreAutoTaggingPointerPosition(com.itextpdf.layout.renderer.IRenderer) -> M
    com.itextpdf.kernel.pdf.tagutils.TagTreePointer useAutoTaggingPointerAndRememberItsPosition(com.itextpdf.layout.renderer.IRenderer) -> N
    void addKidsHint(com.itextpdf.layout.tagging.TaggingHintKey,java.util.Collection,int) -> a
    void addKidsHint(com.itextpdf.layout.tagging.TaggingHintKey,java.util.Collection,int,boolean) -> b
    void addKidsHint(com.itextpdf.kernel.pdf.tagutils.TagTreePointer,java.lang.Iterable) -> c
    void addKidsHint(com.itextpdf.layout.IPropertyContainer,java.lang.Iterable) -> d
    void addKidsHint(com.itextpdf.layout.IPropertyContainer,java.lang.Iterable,int) -> e
    void addTreeHints(com.itextpdf.layout.tagging.LayoutTaggingHelper,com.itextpdf.layout.renderer.IRenderer) -> f
    boolean createSingleTag(com.itextpdf.layout.tagging.TaggingHintKey,com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> g
    boolean createTag(com.itextpdf.layout.renderer.IRenderer,com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> h
    boolean createTag(com.itextpdf.layout.tagging.TaggingHintKey,com.itextpdf.kernel.pdf.tagutils.TagTreePointer) -> i
    void finishDummyKids(java.util.List) -> j
    void finishTaggingHint(com.itextpdf.layout.IPropertyContainer) -> k
    java.util.List getAccessibleKidsHint(com.itextpdf.layout.tagging.TaggingHintKey) -> l
    com.itextpdf.layout.tagging.TaggingHintKey getAccessibleParentHint(com.itextpdf.layout.tagging.TaggingHintKey) -> m
    com.itextpdf.layout.tagging.TaggingHintKey getHintKey(com.itextpdf.layout.IPropertyContainer) -> n
    java.util.List getKidsHint(com.itextpdf.layout.tagging.TaggingHintKey) -> o
    int getNearestNextSiblingTagIndex(com.itextpdf.kernel.pdf.tagutils.WaitingTagsManager,com.itextpdf.kernel.pdf.tagutils.TagTreePointer,java.util.List,int) -> p
    com.itextpdf.layout.tagging.TaggingHintKey getOrCreateHintKey(com.itextpdf.layout.IPropertyContainer) -> q
    com.itextpdf.layout.tagging.TaggingHintKey getOrCreateHintKey(com.itextpdf.layout.IPropertyContainer,boolean) -> r
    com.itextpdf.layout.tagging.TaggingHintKey getParentHint(com.itextpdf.layout.tagging.TaggingHintKey) -> s
    com.itextpdf.kernel.pdf.PdfDocument getPdfDocument() -> t
    boolean isArtifact(com.itextpdf.layout.IPropertyContainer) -> u
    boolean isNonAccessibleHint(com.itextpdf.layout.tagging.TaggingHintKey) -> v
    boolean isSomeKidNotFinished(com.itextpdf.layout.tagging.TaggingHintKey) -> w
    boolean isSomeParentNotFinished(com.itextpdf.layout.tagging.TaggingHintKey) -> x
    boolean isTagAlreadyExistsForHint(com.itextpdf.layout.tagging.TaggingHintKey) -> y
    void markArtifactHint(com.itextpdf.layout.tagging.TaggingHintKey) -> z
com.itextpdf.layout.tagging.TableTaggingPriorToOneFiveVersionRule -> k2.d:
    java.util.Set finishForbidden -> a
    boolean onTagFinish(com.itextpdf.layout.tagging.LayoutTaggingHelper,com.itextpdf.layout.tagging.TaggingHintKey) -> a
    void removeTagUnavailableInPriorToOneDotFivePdf(com.itextpdf.layout.tagging.TaggingHintKey,com.itextpdf.layout.tagging.LayoutTaggingHelper) -> b
com.itextpdf.layout.tagging.TableTaggingRule -> k2.e:
    boolean onTagFinish(com.itextpdf.layout.tagging.LayoutTaggingHelper,com.itextpdf.layout.tagging.TaggingHintKey) -> a
com.itextpdf.layout.tagging.TaggingDummyElement -> k2.f:
    com.itextpdf.kernel.pdf.tagutils.DefaultAccessibilityProperties properties -> Q2
    java.lang.Object id -> R2
    boolean hasProperty(int) -> f
    java.lang.Object getDefaultProperty(int) -> g
    com.itextpdf.kernel.pdf.tagutils.AccessibilityProperties getAccessibilityProperties() -> j
    void setProperty(int,java.lang.Object) -> m
    java.lang.Object getProperty(int) -> r
    void deleteOwnProperty(int) -> x
com.itextpdf.layout.tagging.TaggingHintKey -> k2.g:
    boolean elementBasedFinishingOnly -> e
    com.itextpdf.layout.tagging.IAccessibleElement elem -> a
    boolean isArtifact -> b
    boolean isFinished -> c
    java.lang.String overriddenRole -> d
    com.itextpdf.layout.tagging.IAccessibleElement getAccessibleElement() -> a
    java.lang.String getOverriddenRole() -> b
    boolean isArtifact() -> c
    boolean isElementBasedFinishingOnly() -> d
    boolean isFinished() -> e
    void setArtifact() -> f
    void setFinished() -> g
com.mr.flutter.plugin.filepicker.FileInfo -> com.mr.flutter.plugin.filepicker.a:
    java.lang.String path -> a
    long size -> d
    java.lang.String name -> b
    android.net.Uri uri -> c
    byte[] bytes -> e
    java.util.HashMap toMap() -> a
com.mr.flutter.plugin.filepicker.FileInfo$Builder -> com.mr.flutter.plugin.filepicker.a$a:
    java.lang.String path -> a
    long size -> d
    java.lang.String name -> b
    android.net.Uri uri -> c
    byte[] bytes -> e
    com.mr.flutter.plugin.filepicker.FileInfo build() -> a
    com.mr.flutter.plugin.filepicker.FileInfo$Builder withData(byte[]) -> b
    com.mr.flutter.plugin.filepicker.FileInfo$Builder withName(java.lang.String) -> c
    com.mr.flutter.plugin.filepicker.FileInfo$Builder withPath(java.lang.String) -> d
    com.mr.flutter.plugin.filepicker.FileInfo$Builder withSize(long) -> e
    com.mr.flutter.plugin.filepicker.FileInfo$Builder withUri(android.net.Uri) -> f
com.mr.flutter.plugin.filepicker.FilePickerDelegate -> com.mr.flutter.plugin.filepicker.b:
    java.lang.String type -> f
    com.mr.flutter.plugin.filepicker.FilePickerDelegate$PermissionManager permissionManager -> b
    int REQUEST_CODE -> i
    boolean loadDataToMemory -> e
    java.lang.String[] allowedExtensions -> g
    io.flutter.plugin.common.EventChannel$EventSink eventSink -> h
    android.app.Activity activity -> a
    io.flutter.plugin.common.MethodChannel$Result pendingResult -> c
    boolean isMultipleSelection -> d
    boolean onRequestPermissionsResult(int,java.lang.String[],int[]) -> a
    boolean onActivityResult(int,int,android.content.Intent) -> b
    android.app.Activity access$000(com.mr.flutter.plugin.filepicker.FilePickerDelegate) -> c
    boolean access$100(com.mr.flutter.plugin.filepicker.FilePickerDelegate) -> d
    void access$200(com.mr.flutter.plugin.filepicker.FilePickerDelegate,java.lang.Object) -> e
    java.lang.String access$300(com.mr.flutter.plugin.filepicker.FilePickerDelegate) -> f
    void access$400(com.mr.flutter.plugin.filepicker.FilePickerDelegate,java.lang.String,java.lang.String) -> g
    java.util.ArrayList access$500(com.mr.flutter.plugin.filepicker.FilePickerDelegate,android.os.Bundle) -> h
    io.flutter.plugin.common.EventChannel$EventSink access$600(com.mr.flutter.plugin.filepicker.FilePickerDelegate) -> i
    void clearPendingResult() -> j
    void dispatchEventStatus(boolean) -> k
    void finishWithAlreadyActiveError(io.flutter.plugin.common.MethodChannel$Result) -> l
    void finishWithError(java.lang.String,java.lang.String) -> m
    void finishWithSuccess(java.lang.Object) -> n
    java.util.ArrayList getSelectedItems(android.os.Bundle) -> o
    void setEventHandler(io.flutter.plugin.common.EventChannel$EventSink) -> p
    boolean setPendingMethodCallAndResult(io.flutter.plugin.common.MethodChannel$Result) -> q
    void startFileExplorer() -> r
    void startFileExplorer(java.lang.String,boolean,boolean,java.lang.String[],io.flutter.plugin.common.MethodChannel$Result) -> s
com.mr.flutter.plugin.filepicker.FilePickerDelegate$1 -> com.mr.flutter.plugin.filepicker.b$a:
    android.app.Activity val$activity -> a
    boolean isPermissionGranted(java.lang.String) -> a
    void askForPermission(java.lang.String,int) -> b
com.mr.flutter.plugin.filepicker.FilePickerDelegate$2 -> com.mr.flutter.plugin.filepicker.b$b:
    android.content.Intent val$data -> Q2
    com.mr.flutter.plugin.filepicker.FilePickerDelegate this$0 -> R2
com.mr.flutter.plugin.filepicker.FilePickerDelegate$3 -> com.mr.flutter.plugin.filepicker.b$c:
    boolean val$status -> a
    com.mr.flutter.plugin.filepicker.FilePickerDelegate this$0 -> b
com.mr.flutter.plugin.filepicker.FilePickerDelegate$PermissionManager -> com.mr.flutter.plugin.filepicker.b$d:
    boolean isPermissionGranted(java.lang.String) -> a
    void askForPermission(java.lang.String,int) -> b
com.mr.flutter.plugin.filepicker.FilePickerPlugin -> com.mr.flutter.plugin.filepicker.FilePickerPlugin:
    android.app.Application application -> c
    com.mr.flutter.plugin.filepicker.FilePickerPlugin$LifeCycleObserver observer -> f
    android.app.Activity activity -> g
    java.lang.String fileType -> i
    io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding pluginBinding -> d
    io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding activityBinding -> a
    boolean isMultipleSelection -> j
    boolean withData -> k
    io.flutter.plugin.common.MethodChannel channel -> h
    androidx.lifecycle.Lifecycle lifecycle -> e
    com.mr.flutter.plugin.filepicker.FilePickerDelegate delegate -> b
    void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> a
    void onReattachedToActivityForConfigChanges(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> b
    void onDetachedFromActivity() -> c
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
    void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> e
    void onAttachedToActivity(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> f
    void onDetachedFromActivityForConfigChanges() -> g
    com.mr.flutter.plugin.filepicker.FilePickerDelegate access$100(com.mr.flutter.plugin.filepicker.FilePickerPlugin) -> h
    java.lang.String resolveType(java.lang.String) -> i
    void setup(io.flutter.plugin.common.BinaryMessenger,android.app.Application,android.app.Activity,io.flutter.plugin.common.PluginRegistry$Registrar,io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> j
    void tearDown() -> k
com.mr.flutter.plugin.filepicker.FilePickerPlugin$1 -> com.mr.flutter.plugin.filepicker.FilePickerPlugin$a:
    com.mr.flutter.plugin.filepicker.FilePickerPlugin this$0 -> a
    void onCancel(java.lang.Object) -> a
    void onListen(java.lang.Object,io.flutter.plugin.common.EventChannel$EventSink) -> b
com.mr.flutter.plugin.filepicker.FilePickerPlugin$LifeCycleObserver -> com.mr.flutter.plugin.filepicker.FilePickerPlugin$LifeCycleObserver:
    android.app.Activity thisActivity -> a
    com.mr.flutter.plugin.filepicker.FilePickerPlugin this$0 -> b
    void onResume(androidx.lifecycle.LifecycleOwner) -> a
    void onDestroy(androidx.lifecycle.LifecycleOwner) -> b
    void onCreate(androidx.lifecycle.LifecycleOwner) -> c
    void onPause(androidx.lifecycle.LifecycleOwner) -> e
    void onStop(androidx.lifecycle.LifecycleOwner) -> f
    void onStart(androidx.lifecycle.LifecycleOwner) -> g
com.mr.flutter.plugin.filepicker.FilePickerPlugin$MethodResultWrapper -> com.mr.flutter.plugin.filepicker.FilePickerPlugin$b:
    io.flutter.plugin.common.MethodChannel$Result methodResult -> a
    android.os.Handler handler -> b
    void success(java.lang.Object) -> a
    void error(java.lang.String,java.lang.String,java.lang.Object) -> b
    void notImplemented() -> c
    io.flutter.plugin.common.MethodChannel$Result access$000(com.mr.flutter.plugin.filepicker.FilePickerPlugin$MethodResultWrapper) -> d
com.mr.flutter.plugin.filepicker.FilePickerPlugin$MethodResultWrapper$1 -> com.mr.flutter.plugin.filepicker.FilePickerPlugin$b$a:
    java.lang.Object val$result -> Q2
    com.mr.flutter.plugin.filepicker.FilePickerPlugin$MethodResultWrapper this$0 -> R2
com.mr.flutter.plugin.filepicker.FilePickerPlugin$MethodResultWrapper$2 -> com.mr.flutter.plugin.filepicker.FilePickerPlugin$b$b:
    java.lang.String val$errorMessage -> R2
    java.lang.String val$errorCode -> Q2
    java.lang.Object val$errorDetails -> S2
    com.mr.flutter.plugin.filepicker.FilePickerPlugin$MethodResultWrapper this$0 -> T2
com.mr.flutter.plugin.filepicker.FilePickerPlugin$MethodResultWrapper$3 -> com.mr.flutter.plugin.filepicker.FilePickerPlugin$b$c:
    com.mr.flutter.plugin.filepicker.FilePickerPlugin$MethodResultWrapper this$0 -> Q2
com.mr.flutter.plugin.filepicker.FileUtils -> com.mr.flutter.plugin.filepicker.c:
    boolean clearCache(android.content.Context) -> a
    java.lang.String getDirectoryPath(java.lang.Class,java.lang.Object) -> b
    java.lang.String getDocumentPathFromTreeUri(android.net.Uri) -> c
    java.lang.String getFileName(android.net.Uri,android.content.Context) -> d
    java.lang.String getFullPathFromTreeUri(android.net.Uri,android.content.Context) -> e
    java.lang.String[] getMimeTypes(java.util.ArrayList) -> f
    java.lang.String getVolumeIdFromTreeUri(android.net.Uri) -> g
    java.lang.String getVolumePath(java.lang.String,android.content.Context) -> h
    boolean isDownloadsDocument(android.net.Uri) -> i
    void loadData(java.io.File,com.mr.flutter.plugin.filepicker.FileInfo$Builder) -> j
    com.mr.flutter.plugin.filepicker.FileInfo openFileStream(android.content.Context,android.net.Uri,boolean) -> k
com.shockwave.pdfium.PdfDocument -> com.shockwave.pdfium.PdfDocument:
    android.os.ParcelFileDescriptor parcelFileDescriptor -> b
    java.util.Map mNativePagesPtr -> c
    long mNativeDocPtr -> a
com.shockwave.pdfium.PdfDocument$Bookmark -> com.shockwave.pdfium.PdfDocument$Bookmark:
    java.util.List children -> a
    long mNativePtr -> d
    long pageIdx -> c
    java.lang.String title -> b
    java.util.List getChildren() -> a
com.shockwave.pdfium.PdfDocument$Link -> com.shockwave.pdfium.PdfDocument$Link:
    android.graphics.RectF bounds -> a
    java.lang.String uri -> c
    java.lang.Integer destPageIdx -> b
    android.graphics.RectF getBounds() -> a
    java.lang.Integer getDestPageIdx() -> b
    java.lang.String getUri() -> c
com.shockwave.pdfium.PdfDocument$Meta -> com.shockwave.pdfium.PdfDocument$Meta:
    java.lang.String creationDate -> g
    java.lang.String producer -> f
    java.lang.String modDate -> h
    java.lang.String title -> a
    java.lang.String subject -> c
    java.lang.String author -> b
    java.lang.String creator -> e
    java.lang.String keywords -> d
com.shockwave.pdfium.PdfiumCore -> com.shockwave.pdfium.PdfiumCore:
    java.lang.Object lock -> d
    java.lang.reflect.Field mFdField -> e
    java.lang.String TAG -> b
    int mCurrentDpi -> a
    java.lang.Class FD_CLASS -> c
    void closeDocument(com.shockwave.pdfium.PdfDocument) -> a
    com.shockwave.pdfium.PdfDocument$Meta getDocumentMeta(com.shockwave.pdfium.PdfDocument) -> b
    int getNumFd(android.os.ParcelFileDescriptor) -> c
    int getPageCount(com.shockwave.pdfium.PdfDocument) -> d
    java.util.List getPageLinks(com.shockwave.pdfium.PdfDocument,int) -> e
    com.shockwave.pdfium.util.Size getPageSize(com.shockwave.pdfium.PdfDocument,int) -> f
    java.util.List getTableOfContents(com.shockwave.pdfium.PdfDocument) -> g
    android.graphics.Point mapPageCoordsToDevice(com.shockwave.pdfium.PdfDocument,int,int,int,int,int,int,double,double) -> h
    android.graphics.RectF mapRectToDevice(com.shockwave.pdfium.PdfDocument,int,int,int,int,int,int,android.graphics.RectF) -> i
    com.shockwave.pdfium.PdfDocument newDocument(android.os.ParcelFileDescriptor,java.lang.String) -> j
    com.shockwave.pdfium.PdfDocument newDocument(byte[],java.lang.String) -> k
    long openPage(com.shockwave.pdfium.PdfDocument,int) -> l
    void recursiveGetBookmark(java.util.List,com.shockwave.pdfium.PdfDocument,long) -> m
    void renderPageBitmap(com.shockwave.pdfium.PdfDocument,android.graphics.Bitmap,int,int,int,int,int,boolean) -> n
com.shockwave.pdfium.util.Size -> com.shockwave.pdfium.util.Size:
    int height -> b
    int width -> a
    int getHeight() -> a
    int getWidth() -> b
com.shockwave.pdfium.util.SizeF -> com.shockwave.pdfium.util.SizeF:
    float height -> b
    float width -> a
    float getHeight() -> a
    float getWidth() -> b
dev.fluttercommunity.plus.share.MethodCallHandler -> l2.a:
    dev.fluttercommunity.plus.share.Share share -> a
    dev.fluttercommunity.plus.share.ShareSuccessManager manager -> b
    void expectMapArguments(io.flutter.plugin.common.MethodCall) -> a
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
dev.fluttercommunity.plus.share.Share -> l2.b:
    android.content.Context context -> a
    kotlin.Lazy providerAuthority$delegate -> d
    kotlin.Lazy immutabilityIntentFlags$delegate -> e
    dev.fluttercommunity.plus.share.ShareSuccessManager manager -> c
    android.app.Activity activity -> b
    android.content.Context access$getContext(dev.fluttercommunity.plus.share.Share) -> a
    void clearShareCacheFolder() -> b
    java.io.File copyToShareCacheFolder(java.io.File) -> c
    boolean fileIsInShareCache(java.io.File) -> d
    android.content.Context getContext() -> e
    int getImmutabilityIntentFlags() -> f
    java.lang.String getMimeTypeBase(java.lang.String) -> g
    java.lang.String getProviderAuthority() -> h
    java.io.File getShareCacheFolder() -> i
    java.util.ArrayList getUrisForPaths(java.util.List) -> j
    java.lang.String reduceMimeTypes(java.util.List) -> k
    void setActivity(android.app.Activity) -> l
    void share(java.lang.String,java.lang.String,boolean) -> m
    void shareFiles(java.util.List,java.util.List,java.lang.String,java.lang.String,boolean) -> n
    void startActivity(android.content.Intent,boolean) -> o
dev.fluttercommunity.plus.share.Share$immutabilityIntentFlags$2 -> l2.b$a:
    dev.fluttercommunity.plus.share.Share$immutabilityIntentFlags$2 INSTANCE -> Q2
    java.lang.Integer invoke() -> a
dev.fluttercommunity.plus.share.Share$providerAuthority$2 -> l2.b$b:
    dev.fluttercommunity.plus.share.Share this$0 -> Q2
    java.lang.String invoke() -> a
dev.fluttercommunity.plus.share.SharePlusPendingIntent -> dev.fluttercommunity.plus.share.SharePlusPendingIntent:
    dev.fluttercommunity.plus.share.SharePlusPendingIntent$Companion Companion -> a
    java.lang.String result -> b
    java.lang.String access$getResult$cp() -> a
    void access$setResult$cp(java.lang.String) -> b
dev.fluttercommunity.plus.share.SharePlusPendingIntent$Companion -> dev.fluttercommunity.plus.share.SharePlusPendingIntent$a:
    java.lang.String getResult() -> a
    void setResult(java.lang.String) -> b
dev.fluttercommunity.plus.share.SharePlusPlugin -> l2.c:
    dev.fluttercommunity.plus.share.SharePlusPlugin$Companion Companion -> d
    dev.fluttercommunity.plus.share.Share share -> a
    dev.fluttercommunity.plus.share.ShareSuccessManager manager -> b
    io.flutter.plugin.common.MethodChannel methodChannel -> c
    void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> a
    void onReattachedToActivityForConfigChanges(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> b
    void onDetachedFromActivity() -> c
    void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> e
    void onAttachedToActivity(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> f
    void onDetachedFromActivityForConfigChanges() -> g
dev.fluttercommunity.plus.share.SharePlusPlugin$Companion -> l2.c$a:
dev.fluttercommunity.plus.share.ShareSuccessManager -> l2.d:
    android.content.Context context -> a
    java.util.concurrent.atomic.AtomicBoolean isCalledBack -> c
    dev.fluttercommunity.plus.share.ShareSuccessManager$Companion Companion -> d
    io.flutter.plugin.common.MethodChannel$Result callback -> b
    void returnResult(java.lang.String) -> a
    boolean onActivityResult(int,int,android.content.Intent) -> b
    boolean setCallback(io.flutter.plugin.common.MethodChannel$Result) -> c
    void unavailable() -> d
dev.fluttercommunity.plus.share.ShareSuccessManager$Companion -> l2.d$a:
f0.TrueTypeFont$$ExternalSyntheticLambda0 -> f0.v:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.io.font.TrueTypeFont com.itextpdf.io.font.TrueTypeFont$$InternalSyntheticLambda$1$2a69282c9cfaa3dec8121a469408c3be34b435b3207867988cba7baed0e9bfbe$0.f$0 -> a
    void com.itextpdf.io.font.TrueTypeFont$$InternalSyntheticLambda$1$2a69282c9cfaa3dec8121a469408c3be34b435b3207867988cba7baed0e9bfbe$0.<init>(com.itextpdf.io.font.TrueTypeFont) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object com.itextpdf.io.font.TrueTypeFont$$InternalSyntheticLambda$1$2a69282c9cfaa3dec8121a469408c3be34b435b3207867988cba7baed0e9bfbe$0.apply(java.lang.Object) -> apply
      # {"id":"com.android.tools.r8.synthesized"}
f3.Messages$PathProviderApi$$ExternalSyntheticLambda0 -> f3.b:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugins.pathprovider.Messages$PathProviderApi io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$0.f$0 -> a
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$0.<init>(io.flutter.plugins.pathprovider.Messages$PathProviderApi) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$0.onMessage(java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> a
      # {"id":"com.android.tools.r8.synthesized"}
f3.Messages$PathProviderApi$$ExternalSyntheticLambda1 -> f3.c:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugins.pathprovider.Messages$PathProviderApi io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$1.f$0 -> a
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$1.<init>(io.flutter.plugins.pathprovider.Messages$PathProviderApi) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$1.onMessage(java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> a
      # {"id":"com.android.tools.r8.synthesized"}
f3.Messages$PathProviderApi$$ExternalSyntheticLambda2 -> f3.d:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugins.pathprovider.Messages$PathProviderApi io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$2.f$0 -> a
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$2.<init>(io.flutter.plugins.pathprovider.Messages$PathProviderApi) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$2.onMessage(java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> a
      # {"id":"com.android.tools.r8.synthesized"}
f3.Messages$PathProviderApi$$ExternalSyntheticLambda3 -> f3.e:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugins.pathprovider.Messages$PathProviderApi io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$3.f$0 -> a
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$3.<init>(io.flutter.plugins.pathprovider.Messages$PathProviderApi) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$3.onMessage(java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> a
      # {"id":"com.android.tools.r8.synthesized"}
f3.Messages$PathProviderApi$$ExternalSyntheticLambda4 -> f3.f:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugins.pathprovider.Messages$PathProviderApi io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$4.f$0 -> a
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$4.<init>(io.flutter.plugins.pathprovider.Messages$PathProviderApi) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$4.onMessage(java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> a
      # {"id":"com.android.tools.r8.synthesized"}
f3.Messages$PathProviderApi$$ExternalSyntheticLambda5 -> f3.g:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugins.pathprovider.Messages$PathProviderApi io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$5.f$0 -> a
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$5.<init>(io.flutter.plugins.pathprovider.Messages$PathProviderApi) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugins.pathprovider.Messages$PathProviderApi$$InternalSyntheticLambda$1$3b37b83339974dd347b68fe5b235e9d3690f45e922a8888479de9ed059ddddbd$5.onMessage(java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> a
      # {"id":"com.android.tools.r8.synthesized"}
g3.ViewUtils$$ExternalSyntheticLambda0 -> g3.f:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    java.lang.Class[] io.flutter.util.ViewUtils$$InternalSyntheticLambda$1$c0aa1774cd8831658692c914ac238b83368f5d4eb3adf605ed1d77e75423b804$0.f$0 -> a
    void io.flutter.util.ViewUtils$$InternalSyntheticLambda$1$c0aa1774cd8831658692c914ac238b83368f5d4eb3adf605ed1d77e75423b804$0.<init>(java.lang.Class[]) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    boolean io.flutter.util.ViewUtils$$InternalSyntheticLambda$1$c0aa1774cd8831658692c914ac238b83368f5d4eb3adf605ed1d77e75423b804$0.run(android.view.View) -> a
      # {"id":"com.android.tools.r8.synthesized"}
g3.ViewUtils$$ExternalSyntheticLambda1 -> g3.g:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.util.ViewUtils$$InternalSyntheticLambda$0$2558b30c7d8a101be24861ba93623c43e35b819105eb8e3b22ac358044105fcf$0 io.flutter.util.ViewUtils$$InternalSyntheticLambda$0$2558b30c7d8a101be24861ba93623c43e35b819105eb8e3b22ac358044105fcf$0.INSTANCE -> a
    void io.flutter.util.ViewUtils$$InternalSyntheticLambda$0$2558b30c7d8a101be24861ba93623c43e35b819105eb8e3b22ac358044105fcf$0.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.util.ViewUtils$$InternalSyntheticLambda$0$2558b30c7d8a101be24861ba93623c43e35b819105eb8e3b22ac358044105fcf$0.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    boolean io.flutter.util.ViewUtils$$InternalSyntheticLambda$0$2558b30c7d8a101be24861ba93623c43e35b819105eb8e3b22ac358044105fcf$0.run(android.view.View) -> a
      # {"id":"com.android.tools.r8.synthesized"}
i1.BaseInputOutPutConvertors$$ExternalSyntheticLambda0 -> i1.b:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    double com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$$InternalSyntheticLambda$1$7eb7efb647a64a9fa8942f61d6489a922202962b812dc0946944ef443690c365$0.f$1 -> b
    int com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$$InternalSyntheticLambda$1$7eb7efb647a64a9fa8942f61d6489a922202962b812dc0946944ef443690c365$0.f$0 -> a
    void com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$$InternalSyntheticLambda$1$7eb7efb647a64a9fa8942f61d6489a922202962b812dc0946944ef443690c365$0.<init>(int,double) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    double[] com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$$InternalSyntheticLambda$1$7eb7efb647a64a9fa8942f61d6489a922202962b812dc0946944ef443690c365$0.convert(byte[],int,int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
i1.BaseInputOutPutConvertors$$ExternalSyntheticLambda1 -> i1.c:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    double com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$$InternalSyntheticLambda$1$89bc95d007137a22d8a4b81b146ed6d74316b0cae6e8e3218ca9523b74d07ff6$0.f$1 -> b
    int com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$$InternalSyntheticLambda$1$89bc95d007137a22d8a4b81b146ed6d74316b0cae6e8e3218ca9523b74d07ff6$0.f$0 -> a
    void com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$$InternalSyntheticLambda$1$89bc95d007137a22d8a4b81b146ed6d74316b0cae6e8e3218ca9523b74d07ff6$0.<init>(int,double) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    byte[] com.itextpdf.kernel.pdf.function.BaseInputOutPutConvertors$$InternalSyntheticLambda$1$89bc95d007137a22d8a4b81b146ed6d74316b0cae6e8e3218ca9523b74d07ff6$0.convert(double[]) -> a
      # {"id":"com.android.tools.r8.synthesized"}
i1.PdfType0Function$$ExternalSyntheticLambda0 -> i1.h:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.function.PdfType0Function$$InternalSyntheticLambda$1$a03a3b75cf57ff0217748965839ba221403aa2793967c45cd2a5580df421131c$0 com.itextpdf.kernel.pdf.function.PdfType0Function$$InternalSyntheticLambda$1$a03a3b75cf57ff0217748965839ba221403aa2793967c45cd2a5580df421131c$0.INSTANCE -> a
    void com.itextpdf.kernel.pdf.function.PdfType0Function$$InternalSyntheticLambda$1$a03a3b75cf57ff0217748965839ba221403aa2793967c45cd2a5580df421131c$0.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.function.PdfType0Function$$InternalSyntheticLambda$1$a03a3b75cf57ff0217748965839ba221403aa2793967c45cd2a5580df421131c$0.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    int com.itextpdf.kernel.pdf.function.PdfType0Function$$InternalSyntheticLambda$1$a03a3b75cf57ff0217748965839ba221403aa2793967c45cd2a5580df421131c$0.applyAsInt(int,int) -> applyAsInt
      # {"id":"com.android.tools.r8.synthesized"}
i1.PdfType3Function$$ExternalSyntheticLambda0 -> i1.k:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.function.PdfType3Function$$InternalSyntheticLambda$1$61af3658e77f770d3d37b3dcbbbf07c2ca4cba243eccc98d45b0a149e4e13b41$0 com.itextpdf.kernel.pdf.function.PdfType3Function$$InternalSyntheticLambda$1$61af3658e77f770d3d37b3dcbbbf07c2ca4cba243eccc98d45b0a149e4e13b41$0.INSTANCE -> a
    void com.itextpdf.kernel.pdf.function.PdfType3Function$$InternalSyntheticLambda$1$61af3658e77f770d3d37b3dcbbbf07c2ca4cba243eccc98d45b0a149e4e13b41$0.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.kernel.pdf.function.PdfType3Function$$InternalSyntheticLambda$1$61af3658e77f770d3d37b3dcbbbf07c2ca4cba243eccc98d45b0a149e4e13b41$0.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.kernel.pdf.function.IPdfFunction com.itextpdf.kernel.pdf.function.PdfType3Function$$InternalSyntheticLambda$1$61af3658e77f770d3d37b3dcbbbf07c2ca4cba243eccc98d45b0a149e4e13b41$0.create(com.itextpdf.kernel.pdf.PdfObject) -> a
      # {"id":"com.android.tools.r8.synthesized"}
io.endigo.plugins.pdfviewflutter.FlutterPDFView -> m2.a:
    com.github.barteksc.pdfviewer.PDFView pdfView -> a
    com.github.barteksc.pdfviewer.link.LinkHandler linkHandler -> c
    io.flutter.plugin.common.MethodChannel methodChannel -> b
    void dispose() -> a
    void onFlutterViewAttached(android.view.View) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void onFlutterViewDetached() -> c
      # {"id":"com.android.tools.r8.synthesized"}
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
    void onInputConnectionUnlocked() -> e
      # {"id":"com.android.tools.r8.synthesized"}
    void onInputConnectionLocked() -> f
      # {"id":"com.android.tools.r8.synthesized"}
    android.view.View getView() -> g
    io.flutter.plugin.common.MethodChannel access$000(io.endigo.plugins.pdfviewflutter.FlutterPDFView) -> h
    void applySettings(java.util.Map) -> i
    boolean getBoolean(java.util.Map,java.lang.String) -> j
    void getCurrentPage(io.flutter.plugin.common.MethodChannel$Result) -> k
    com.github.barteksc.pdfviewer.util.FitPolicy getFitPolicy(java.util.Map) -> l
    int getInt(java.util.Map,java.lang.String) -> m
    void getPageCount(io.flutter.plugin.common.MethodChannel$Result) -> n
    java.lang.String getString(java.util.Map,java.lang.String) -> o
    android.net.Uri getURI(java.lang.String) -> p
    void setPage(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> q
    void updateSettings(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> r
io.endigo.plugins.pdfviewflutter.FlutterPDFView$1 -> m2.a$a:
    io.endigo.plugins.pdfviewflutter.FlutterPDFView this$0 -> a
    void onInitiallyRendered(int) -> a
io.endigo.plugins.pdfviewflutter.FlutterPDFView$2 -> m2.a$b:
    io.endigo.plugins.pdfviewflutter.FlutterPDFView this$0 -> a
    void onPageError(int,java.lang.Throwable) -> a
io.endigo.plugins.pdfviewflutter.FlutterPDFView$3 -> m2.a$c:
    io.endigo.plugins.pdfviewflutter.FlutterPDFView this$0 -> a
    void onError(java.lang.Throwable) -> a
io.endigo.plugins.pdfviewflutter.FlutterPDFView$4 -> m2.a$d:
    io.endigo.plugins.pdfviewflutter.FlutterPDFView this$0 -> a
    void onPageChanged(int,int) -> a
io.endigo.plugins.pdfviewflutter.PDFLinkHandler -> m2.b:
    android.content.Context context -> b
    com.github.barteksc.pdfviewer.PDFView pdfView -> a
    io.flutter.plugin.common.MethodChannel methodChannel -> c
    boolean preventLinkNavigation -> d
    void handleLinkEvent(com.github.barteksc.pdfviewer.model.LinkTapEvent) -> a
    void handlePage(int) -> b
    void handleUri(java.lang.String) -> c
    void onLinkHandler(java.lang.String) -> d
    void setPreventLinkNavigation(boolean) -> e
io.endigo.plugins.pdfviewflutter.PDFViewFactory -> m2.c:
    io.flutter.plugin.common.BinaryMessenger messenger -> b
    io.flutter.plugin.platform.PlatformView create(android.content.Context,int,java.lang.Object) -> a
io.endigo.plugins.pdfviewflutter.PDFViewFlutterPlugin -> m2.d:
    void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> a
    void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> e
io.flutter.FlutterInjector -> n2.a:
    java.util.concurrent.ExecutorService executorService -> d
    io.flutter.embedding.engine.FlutterJNI$Factory flutterJniFactory -> c
    io.flutter.embedding.engine.loader.FlutterLoader flutterLoader -> a
    boolean accessed -> f
    io.flutter.embedding.engine.deferredcomponents.DeferredComponentManager deferredComponentManager -> b
    io.flutter.FlutterInjector instance -> e
    io.flutter.embedding.engine.deferredcomponents.DeferredComponentManager deferredComponentManager() -> a
    java.util.concurrent.ExecutorService executorService() -> b
    io.flutter.embedding.engine.loader.FlutterLoader flutterLoader() -> c
    io.flutter.embedding.engine.FlutterJNI$Factory getFlutterJNIFactory() -> d
    io.flutter.FlutterInjector instance() -> e
io.flutter.FlutterInjector$1 -> n2.a$a:
io.flutter.FlutterInjector$Builder -> n2.a$b:
    java.util.concurrent.ExecutorService executorService -> d
    io.flutter.embedding.engine.FlutterJNI$Factory flutterJniFactory -> c
    io.flutter.embedding.engine.loader.FlutterLoader flutterLoader -> a
    io.flutter.embedding.engine.deferredcomponents.DeferredComponentManager deferredComponentManager -> b
    io.flutter.FlutterInjector build() -> a
    void fillDefaults() -> b
io.flutter.FlutterInjector$Builder$NamedThreadFactory -> n2.a$b$a:
    io.flutter.FlutterInjector$Builder this$0 -> b
    int threadId -> a
io.flutter.Log -> n2.b:
    void d(java.lang.String,java.lang.String) -> a
    void e(java.lang.String,java.lang.String) -> b
    void e(java.lang.String,java.lang.String,java.lang.Throwable) -> c
    java.lang.String getStackTraceString(java.lang.Throwable) -> d
    void i(java.lang.String,java.lang.String) -> e
    void v(java.lang.String,java.lang.String) -> f
    void w(java.lang.String,java.lang.String) -> g
    void w(java.lang.String,java.lang.String,java.lang.Throwable) -> h
io.flutter.embedding.android.AndroidTouchProcessor -> io.flutter.embedding.android.a:
    io.flutter.embedding.android.MotionEventTracker motionEventTracker -> b
    java.util.Map ongoingPans -> d
    io.flutter.embedding.engine.renderer.FlutterRenderer renderer -> a
    android.graphics.Matrix IDENTITY_TRANSFORM -> e
    boolean trackMotionEvents -> c
    void addPointerForIndex(android.view.MotionEvent,int,int,int,android.graphics.Matrix,java.nio.ByteBuffer) -> a
    int getPointerChangeForAction(int) -> b
    int getPointerChangeForPanZoom(int) -> c
    int getPointerDeviceTypeForToolType(int) -> d
    boolean onGenericMotionEvent(android.view.MotionEvent) -> e
    boolean onTouchEvent(android.view.MotionEvent) -> f
    boolean onTouchEvent(android.view.MotionEvent,android.graphics.Matrix) -> g
io.flutter.embedding.android.DrawableSplashScreen -> io.flutter.embedding.android.b:
    android.widget.ImageView$ScaleType scaleType -> b
    io.flutter.embedding.android.DrawableSplashScreen$DrawableSplashScreenView splashView -> d
    long crossfadeDurationInMillis -> c
    android.graphics.drawable.Drawable drawable -> a
    void transitionToFlutter(java.lang.Runnable) -> a
    boolean doesSplashViewRememberItsTransition() -> b
      # {"id":"com.android.tools.r8.synthesized"}
    android.view.View createSplashView(android.content.Context,android.os.Bundle) -> c
    android.os.Bundle saveSplashScreenState() -> d
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.embedding.android.DrawableSplashScreen$1 -> io.flutter.embedding.android.b$a:
    java.lang.Runnable val$onTransitionComplete -> a
    io.flutter.embedding.android.DrawableSplashScreen this$0 -> b
io.flutter.embedding.android.DrawableSplashScreen$DrawableSplashScreenView -> io.flutter.embedding.android.b$b:
    void setSplashDrawable(android.graphics.drawable.Drawable,android.widget.ImageView$ScaleType) -> a
io.flutter.embedding.android.ExclusiveAppComponent -> io.flutter.embedding.android.c:
    void detachFromFlutterEngine() -> e
    java.lang.Object getAppComponent() -> f
io.flutter.embedding.android.FlutterActivity -> io.flutter.embedding.android.d:
    android.window.OnBackInvokedCallback onBackInvokedCallback -> c
    io.flutter.embedding.android.FlutterActivityAndFragmentDelegate delegate -> a
    int FLUTTER_VIEW_ID -> d
    androidx.lifecycle.LifecycleRegistry lifecycle -> b
    io.flutter.embedding.android.TransparencyMode getTransparencyMode() -> A
    void onFlutterTextureViewCreated(io.flutter.embedding.android.FlutterTextureView) -> B
    void configureFlutterEngine(io.flutter.embedding.engine.FlutterEngine) -> C
    void configureStatusBarForFullscreenFlutterExperience() -> D
    void configureWindowForTransparency() -> E
    android.view.View createFlutterView() -> F
    io.flutter.embedding.android.FlutterActivityLaunchConfigs$BackgroundMode getBackgroundMode() -> G
    io.flutter.embedding.engine.FlutterEngine getFlutterEngine() -> H
    android.os.Bundle getMetaData() -> I
    android.graphics.drawable.Drawable getSplashScreenFromManifest() -> J
    boolean isDebuggable() -> K
    void registerOnBackInvokedCallback() -> L
    void release() -> M
    boolean stillAttachedForEvent(java.lang.String) -> N
    void switchLaunchThemeForNormalTheme() -> O
    void unregisterOnBackInvokedCallback() -> P
    androidx.lifecycle.Lifecycle getLifecycle() -> a
    boolean popSystemNavigator() -> b
    void onFlutterUiNoLongerDisplayed() -> c
    android.app.Activity getActivity() -> d
    void detachFromFlutterEngine() -> e
    void onFlutterUiDisplayed() -> f
    java.lang.String getInitialRoute() -> g
    io.flutter.embedding.engine.FlutterShellArgs getFlutterShellArgs() -> h
    java.util.List getDartEntrypointArgs() -> k
    boolean shouldAttachEngineToActivity() -> l
    io.flutter.embedding.android.RenderMode getRenderMode() -> m
    boolean shouldDestroyEngineWithHost() -> n
    boolean shouldDispatchAppLifecycleState() -> o
    java.lang.String getCachedEngineId() -> p
    boolean shouldRestoreAndSaveState() -> q
    java.lang.String getDartEntrypointFunctionName() -> r
    void cleanUpFlutterEngine(io.flutter.embedding.engine.FlutterEngine) -> s
    io.flutter.embedding.android.SplashScreen provideSplashScreen() -> t
    java.lang.String getDartEntrypointLibraryUri() -> u
    io.flutter.plugin.platform.PlatformPlugin providePlatformPlugin(android.app.Activity,io.flutter.embedding.engine.FlutterEngine) -> v
    void onFlutterSurfaceViewCreated(io.flutter.embedding.android.FlutterSurfaceView) -> w
    java.lang.String getAppBundlePath() -> x
    io.flutter.embedding.engine.FlutterEngine provideFlutterEngine(android.content.Context) -> y
    boolean shouldHandleDeeplinking() -> z
io.flutter.embedding.android.FlutterActivity$1 -> io.flutter.embedding.android.d$a:
    io.flutter.embedding.android.FlutterActivity this$0 -> a
io.flutter.embedding.android.FlutterActivityAndFragmentDelegate -> io.flutter.embedding.android.e:
    io.flutter.embedding.engine.renderer.FlutterUiDisplayListener flutterUiDisplayListener -> k
    boolean isAttached -> i
    io.flutter.plugin.platform.PlatformPlugin platformPlugin -> d
    android.view.ViewTreeObserver$OnPreDrawListener activePreDrawListener -> e
    io.flutter.embedding.android.FlutterView flutterView -> c
    java.lang.Integer previousVisibility -> j
    io.flutter.embedding.engine.FlutterEngine flutterEngine -> b
    boolean isFlutterEngineFromHost -> f
    boolean isFlutterUiDisplayed -> g
    io.flutter.embedding.android.FlutterActivityAndFragmentDelegate$Host host -> a
    boolean isFirstFrameRendered -> h
    void onSaveInstanceState(android.os.Bundle) -> A
    void onStart() -> B
    void onStop() -> C
    void onTrimMemory(int) -> D
    void onUserLeaveHint() -> E
    void release() -> F
    void setupFlutterEngine() -> G
    void updateSystemUiOverlays() -> H
    io.flutter.embedding.android.FlutterActivityAndFragmentDelegate$Host access$000(io.flutter.embedding.android.FlutterActivityAndFragmentDelegate) -> a
    boolean access$100(io.flutter.embedding.android.FlutterActivityAndFragmentDelegate) -> b
    boolean access$102(io.flutter.embedding.android.FlutterActivityAndFragmentDelegate,boolean) -> c
    boolean access$202(io.flutter.embedding.android.FlutterActivityAndFragmentDelegate,boolean) -> d
    void detachFromFlutterEngine() -> e
    java.lang.Object getAppComponent() -> f
    void delayFirstAndroidViewDraw(io.flutter.embedding.android.FlutterView) -> g
    void doInitialFlutterViewRun() -> h
    void ensureAlive() -> i
    android.app.Activity getAppComponent() -> j
    io.flutter.embedding.engine.FlutterEngine getFlutterEngine() -> k
    boolean isAttached() -> l
    boolean isFlutterEngineFromHost() -> m
    java.lang.String maybeGetInitialRouteFromIntent(android.content.Intent) -> n
    void onActivityResult(int,int,android.content.Intent) -> o
    void onAttach(android.content.Context) -> p
    void onBackPressed() -> q
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle,int,boolean) -> r
    void onDestroyView() -> s
    void onDetach() -> t
    void onNewIntent(android.content.Intent) -> u
    void onPause() -> v
    void onPostResume() -> w
    void onRequestPermissionsResult(int,java.lang.String[],int[]) -> x
    void onRestoreInstanceState(android.os.Bundle) -> y
    void onResume() -> z
io.flutter.embedding.android.FlutterActivityAndFragmentDelegate$1 -> io.flutter.embedding.android.e$a:
    io.flutter.embedding.android.FlutterActivityAndFragmentDelegate this$0 -> a
    void onFlutterUiNoLongerDisplayed() -> c
    void onFlutterUiDisplayed() -> f
io.flutter.embedding.android.FlutterActivityAndFragmentDelegate$2 -> io.flutter.embedding.android.e$b:
    io.flutter.embedding.android.FlutterView val$flutterView -> a
    io.flutter.embedding.android.FlutterActivityAndFragmentDelegate this$0 -> b
io.flutter.embedding.android.FlutterActivityAndFragmentDelegate$Host -> io.flutter.embedding.android.e$c:
    io.flutter.embedding.android.TransparencyMode getTransparencyMode() -> A
    void onFlutterTextureViewCreated(io.flutter.embedding.android.FlutterTextureView) -> B
    void configureFlutterEngine(io.flutter.embedding.engine.FlutterEngine) -> C
    androidx.lifecycle.Lifecycle getLifecycle() -> a
    void onFlutterUiNoLongerDisplayed() -> c
    android.app.Activity getActivity() -> d
    void detachFromFlutterEngine() -> e
    void onFlutterUiDisplayed() -> f
    java.lang.String getInitialRoute() -> g
    io.flutter.embedding.engine.FlutterShellArgs getFlutterShellArgs() -> h
    java.util.List getDartEntrypointArgs() -> k
    boolean shouldAttachEngineToActivity() -> l
    io.flutter.embedding.android.RenderMode getRenderMode() -> m
    boolean shouldDestroyEngineWithHost() -> n
    boolean shouldDispatchAppLifecycleState() -> o
    java.lang.String getCachedEngineId() -> p
    boolean shouldRestoreAndSaveState() -> q
    java.lang.String getDartEntrypointFunctionName() -> r
    void cleanUpFlutterEngine(io.flutter.embedding.engine.FlutterEngine) -> s
    io.flutter.embedding.android.SplashScreen provideSplashScreen() -> t
    java.lang.String getDartEntrypointLibraryUri() -> u
    io.flutter.plugin.platform.PlatformPlugin providePlatformPlugin(android.app.Activity,io.flutter.embedding.engine.FlutterEngine) -> v
    void onFlutterSurfaceViewCreated(io.flutter.embedding.android.FlutterSurfaceView) -> w
    java.lang.String getAppBundlePath() -> x
    io.flutter.embedding.engine.FlutterEngine provideFlutterEngine(android.content.Context) -> y
    boolean shouldHandleDeeplinking() -> z
io.flutter.embedding.android.FlutterActivityLaunchConfigs$BackgroundMode -> io.flutter.embedding.android.f:
    io.flutter.embedding.android.FlutterActivityLaunchConfigs$BackgroundMode[] $VALUES -> S2
    io.flutter.embedding.android.FlutterActivityLaunchConfigs$BackgroundMode transparent -> R2
    io.flutter.embedding.android.FlutterActivityLaunchConfigs$BackgroundMode opaque -> Q2
io.flutter.embedding.android.FlutterImageView -> io.flutter.embedding.android.g:
    io.flutter.embedding.engine.renderer.FlutterRenderer flutterRenderer -> d
    android.graphics.Bitmap currentBitmap -> c
    android.media.Image currentImage -> b
    boolean isAttachedToFlutterRenderer -> f
    android.media.ImageReader imageReader -> a
    io.flutter.embedding.android.FlutterImageView$SurfaceKind kind -> e
    void pause() -> a
    void detachFromRenderer() -> b
    void attachToRenderer(io.flutter.embedding.engine.renderer.FlutterRenderer) -> c
    boolean acquireLatestImage() -> d
    void closeCurrentImage() -> e
    void closeImageReader() -> f
    android.media.ImageReader createImageReader(int,int) -> g
    void init() -> h
    void logW(java.lang.String,java.lang.Object[]) -> i
    void resizeIfNeeded(int,int) -> j
    void updateCurrentBitmap() -> k
io.flutter.embedding.android.FlutterImageView$1 -> io.flutter.embedding.android.g$a:
    int[] $SwitchMap$io$flutter$embedding$android$FlutterImageView$SurfaceKind -> a
io.flutter.embedding.android.FlutterImageView$SurfaceKind -> io.flutter.embedding.android.g$b:
    io.flutter.embedding.android.FlutterImageView$SurfaceKind background -> Q2
    io.flutter.embedding.android.FlutterImageView$SurfaceKind overlay -> R2
    io.flutter.embedding.android.FlutterImageView$SurfaceKind[] $VALUES -> S2
io.flutter.embedding.android.FlutterSplashView -> io.flutter.embedding.android.FlutterSplashView:
    io.flutter.embedding.android.SplashScreen splashScreen -> a
    java.lang.String previousCompletedSplashIsolate -> f
    io.flutter.embedding.engine.renderer.FlutterUiDisplayListener flutterUiDisplayListener -> h
    java.lang.Runnable onTransitionComplete -> i
    java.lang.String TAG -> j
    io.flutter.embedding.android.FlutterView flutterView -> b
    android.os.Bundle splashScreenState -> d
    io.flutter.embedding.android.FlutterView$FlutterEngineAttachmentListener flutterEngineAttachmentListener -> g
    android.view.View splashScreenView -> c
    java.lang.String transitioningIsolateId -> e
    io.flutter.embedding.android.FlutterView access$000(io.flutter.embedding.android.FlutterSplashView) -> a
    io.flutter.embedding.android.SplashScreen access$100(io.flutter.embedding.android.FlutterSplashView) -> b
    void access$200(io.flutter.embedding.android.FlutterSplashView) -> c
    android.view.View access$300(io.flutter.embedding.android.FlutterSplashView) -> d
    java.lang.String access$402(io.flutter.embedding.android.FlutterSplashView,java.lang.String) -> e
    java.lang.String access$500(io.flutter.embedding.android.FlutterSplashView) -> f
    void displayFlutterViewWithSplash(io.flutter.embedding.android.FlutterView,io.flutter.embedding.android.SplashScreen) -> g
    boolean hasSplashCompleted() -> h
    boolean isSplashScreenNeededNow() -> i
    boolean isSplashScreenTransitionNeededNow() -> j
    void transitionToFlutter() -> k
    boolean wasPreviousSplashTransitionInterrupted() -> l
io.flutter.embedding.android.FlutterSplashView$1 -> io.flutter.embedding.android.FlutterSplashView$a:
    io.flutter.embedding.android.FlutterSplashView this$0 -> a
    void onFlutterEngineAttachedToFlutterView(io.flutter.embedding.engine.FlutterEngine) -> a
    void onFlutterEngineDetachedFromFlutterView() -> b
io.flutter.embedding.android.FlutterSplashView$2 -> io.flutter.embedding.android.FlutterSplashView$b:
    io.flutter.embedding.android.FlutterSplashView this$0 -> a
    void onFlutterUiNoLongerDisplayed() -> c
    void onFlutterUiDisplayed() -> f
io.flutter.embedding.android.FlutterSplashView$3 -> io.flutter.embedding.android.FlutterSplashView$c:
    io.flutter.embedding.android.FlutterSplashView this$0 -> Q2
io.flutter.embedding.android.FlutterSplashView$SavedState$1 -> io.flutter.embedding.android.FlutterSplashView$SavedState$a:
    io.flutter.embedding.android.FlutterSplashView$SavedState createFromParcel(android.os.Parcel) -> a
    io.flutter.embedding.android.FlutterSplashView$SavedState[] newArray(int) -> b
io.flutter.embedding.android.FlutterSurfaceView -> io.flutter.embedding.android.h:
    io.flutter.embedding.engine.renderer.FlutterRenderer flutterRenderer -> e
    io.flutter.embedding.engine.renderer.FlutterUiDisplayListener flutterUiDisplayListener -> g
    android.view.SurfaceHolder$Callback surfaceCallback -> f
    boolean renderTransparently -> a
    boolean isSurfaceAvailableForRendering -> b
    boolean isPaused -> c
    boolean isAttachedToFlutterRenderer -> d
    void pause() -> a
    void detachFromRenderer() -> b
    void attachToRenderer(io.flutter.embedding.engine.renderer.FlutterRenderer) -> c
    boolean access$002(io.flutter.embedding.android.FlutterSurfaceView,boolean) -> d
    boolean access$100(io.flutter.embedding.android.FlutterSurfaceView) -> e
    void access$200(io.flutter.embedding.android.FlutterSurfaceView) -> f
    void access$300(io.flutter.embedding.android.FlutterSurfaceView,int,int) -> g
    void access$400(io.flutter.embedding.android.FlutterSurfaceView) -> h
    io.flutter.embedding.engine.renderer.FlutterRenderer access$500(io.flutter.embedding.android.FlutterSurfaceView) -> i
    void changeSurfaceSize(int,int) -> j
    void connectSurfaceToRenderer() -> k
    void disconnectSurfaceFromRenderer() -> l
    void init() -> m
io.flutter.embedding.android.FlutterSurfaceView$1 -> io.flutter.embedding.android.h$a:
    io.flutter.embedding.android.FlutterSurfaceView this$0 -> a
io.flutter.embedding.android.FlutterSurfaceView$2 -> io.flutter.embedding.android.h$b:
    io.flutter.embedding.android.FlutterSurfaceView this$0 -> a
    void onFlutterUiNoLongerDisplayed() -> c
    void onFlutterUiDisplayed() -> f
io.flutter.embedding.android.FlutterTextureView -> io.flutter.embedding.android.i:
    io.flutter.embedding.engine.renderer.FlutterRenderer flutterRenderer -> d
    android.view.TextureView$SurfaceTextureListener surfaceTextureListener -> f
    android.view.Surface renderSurface -> e
    boolean isSurfaceAvailableForRendering -> a
    boolean isAttachedToFlutterRenderer -> b
    boolean isPaused -> c
    void pause() -> a
    void detachFromRenderer() -> b
    void attachToRenderer(io.flutter.embedding.engine.renderer.FlutterRenderer) -> c
    boolean access$002(io.flutter.embedding.android.FlutterTextureView,boolean) -> d
    boolean access$100(io.flutter.embedding.android.FlutterTextureView) -> e
    void access$200(io.flutter.embedding.android.FlutterTextureView) -> f
    void access$300(io.flutter.embedding.android.FlutterTextureView,int,int) -> g
    void access$400(io.flutter.embedding.android.FlutterTextureView) -> h
    android.view.Surface access$500(io.flutter.embedding.android.FlutterTextureView) -> i
    android.view.Surface access$502(io.flutter.embedding.android.FlutterTextureView,android.view.Surface) -> j
    void changeSurfaceSize(int,int) -> k
    void connectSurfaceToRenderer() -> l
    void disconnectSurfaceFromRenderer() -> m
    void init() -> n
io.flutter.embedding.android.FlutterTextureView$1 -> io.flutter.embedding.android.i$a:
    io.flutter.embedding.android.FlutterTextureView this$0 -> a
io.flutter.embedding.android.FlutterView -> io.flutter.embedding.android.k:
    io.flutter.embedding.android.KeyboardManager keyboardManager -> n
    io.flutter.embedding.engine.FlutterEngine flutterEngine -> h
    io.flutter.embedding.engine.renderer.FlutterRenderer$ViewportMetrics viewportMetrics -> s
    io.flutter.embedding.android.FlutterTextureView flutterTextureView -> b
    io.flutter.embedding.android.WindowInfoRepositoryCallbackAdapterWrapper windowInfoRepo -> r
    io.flutter.plugin.mouse.MouseCursorPlugin mouseCursorPlugin -> j
    androidx.core.util.Consumer windowInfoListener -> w
    io.flutter.embedding.android.FlutterSurfaceView flutterSurfaceView -> a
    android.view.textservice.TextServicesManager textServicesManager -> q
    java.util.Set flutterEngineAttachmentListeners -> i
    android.database.ContentObserver systemSettingsObserver -> u
    io.flutter.embedding.android.AndroidTouchProcessor androidTouchProcessor -> o
    io.flutter.view.AccessibilityBridge accessibilityBridge -> p
    io.flutter.embedding.engine.renderer.RenderSurface renderSurface -> d
    io.flutter.plugin.editing.TextInputPlugin textInputPlugin -> k
    io.flutter.embedding.engine.renderer.RenderSurface previousRenderSurface -> e
    java.util.Set flutterUiDisplayListeners -> f
    io.flutter.plugin.editing.SpellCheckPlugin spellCheckPlugin -> l
    io.flutter.view.AccessibilityBridge$OnAccessibilityChangeListener onAccessibilityChangeListener -> t
    io.flutter.embedding.android.FlutterImageView flutterImageView -> c
    boolean isFlutterUiDisplayed -> g
    io.flutter.embedding.engine.renderer.FlutterUiDisplayListener flutterUiDisplayListener -> v
    io.flutter.plugin.localization.LocalizationPlugin localizationPlugin -> m
    void resetWillNotDraw(boolean,boolean) -> A
    void revertImageView(java.lang.Runnable) -> B
    void sendUserSettingsToFlutter() -> C
    void sendViewportMetricsToFlutter() -> D
    void redispatch(android.view.KeyEvent) -> a
    boolean onTextInputKeyEvent(android.view.KeyEvent) -> b
    android.view.PointerIcon getSystemPointerIcon(int) -> c
    boolean $r8$lambda$d2mxEi96GCrk9QQKk7dEG7SoNrw(android.view.textservice.SpellCheckerInfo) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    void access$000(io.flutter.embedding.android.FlutterView,boolean,boolean) -> e
    io.flutter.embedding.engine.FlutterEngine access$100(io.flutter.embedding.android.FlutterView) -> f
    boolean access$202(io.flutter.embedding.android.FlutterView,boolean) -> g
    java.util.Set access$300(io.flutter.embedding.android.FlutterView) -> h
    io.flutter.embedding.android.FlutterImageView access$400(io.flutter.embedding.android.FlutterView) -> i
    boolean acquireLatestImageViewFrame() -> j
    void addFlutterEngineAttachmentListener(io.flutter.embedding.android.FlutterView$FlutterEngineAttachmentListener) -> k
    void addOnFirstFrameRenderedListener(io.flutter.embedding.engine.renderer.FlutterUiDisplayListener) -> l
    void attachOverlaySurfaceToRender(io.flutter.embedding.android.FlutterImageView) -> m
    void attachToFlutterEngine(io.flutter.embedding.engine.FlutterEngine) -> n
    io.flutter.embedding.android.FlutterView$ZeroSides calculateShouldZeroSides() -> o
    void convertToImageView() -> p
    io.flutter.embedding.android.FlutterImageView createImageView() -> q
    io.flutter.embedding.android.WindowInfoRepositoryCallbackAdapterWrapper createWindowInfoRepo() -> r
    void detachFromFlutterEngine() -> s
    int guessBottomKeyboardInset(android.view.WindowInsets) -> t
    boolean hasRenderedFirstFrame() -> u
    void init() -> v
    boolean isAttachedToFlutterEngine() -> w
    boolean lambda$sendUserSettingsToFlutter$0(android.view.textservice.SpellCheckerInfo) -> x
    void removeFlutterEngineAttachmentListener(io.flutter.embedding.android.FlutterView$FlutterEngineAttachmentListener) -> y
    void removeOnFirstFrameRenderedListener(io.flutter.embedding.engine.renderer.FlutterUiDisplayListener) -> z
io.flutter.embedding.android.FlutterView$$ExternalSyntheticLambda0 -> io.flutter.embedding.android.j:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.android.FlutterView$$InternalSyntheticLambda$0$c4c6007cd547f9ce602424902c34cd0890267c293b00c52a08dd4f1a30e59df3$0 io.flutter.embedding.android.FlutterView$$InternalSyntheticLambda$0$c4c6007cd547f9ce602424902c34cd0890267c293b00c52a08dd4f1a30e59df3$0.INSTANCE -> a
    void io.flutter.embedding.android.FlutterView$$InternalSyntheticLambda$0$c4c6007cd547f9ce602424902c34cd0890267c293b00c52a08dd4f1a30e59df3$0.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.android.FlutterView$$InternalSyntheticLambda$0$c4c6007cd547f9ce602424902c34cd0890267c293b00c52a08dd4f1a30e59df3$0.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    boolean io.flutter.embedding.android.FlutterView$$InternalSyntheticLambda$0$c4c6007cd547f9ce602424902c34cd0890267c293b00c52a08dd4f1a30e59df3$0.test(java.lang.Object) -> test
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.embedding.android.FlutterView$1 -> io.flutter.embedding.android.k$a:
    io.flutter.embedding.android.FlutterView this$0 -> a
    void onAccessibilityChanged(boolean,boolean) -> a
io.flutter.embedding.android.FlutterView$2 -> io.flutter.embedding.android.k$b:
    io.flutter.embedding.android.FlutterView this$0 -> a
io.flutter.embedding.android.FlutterView$3 -> io.flutter.embedding.android.k$c:
    io.flutter.embedding.android.FlutterView this$0 -> a
    void onFlutterUiNoLongerDisplayed() -> c
    void onFlutterUiDisplayed() -> f
io.flutter.embedding.android.FlutterView$4 -> io.flutter.embedding.android.k$d:
    io.flutter.embedding.android.FlutterView this$0 -> a
    void accept(androidx.window.layout.WindowLayoutInfo) -> a
io.flutter.embedding.android.FlutterView$5 -> io.flutter.embedding.android.k$e:
    java.lang.Runnable val$onDone -> b
    io.flutter.embedding.engine.renderer.FlutterRenderer val$renderer -> a
    io.flutter.embedding.android.FlutterView this$0 -> c
    void onFlutterUiNoLongerDisplayed() -> c
    void onFlutterUiDisplayed() -> f
io.flutter.embedding.android.FlutterView$FlutterEngineAttachmentListener -> io.flutter.embedding.android.k$f:
    void onFlutterEngineAttachedToFlutterView(io.flutter.embedding.engine.FlutterEngine) -> a
    void onFlutterEngineDetachedFromFlutterView() -> b
io.flutter.embedding.android.FlutterView$ZeroSides -> io.flutter.embedding.android.k$g:
    io.flutter.embedding.android.FlutterView$ZeroSides LEFT -> R2
    io.flutter.embedding.android.FlutterView$ZeroSides NONE -> Q2
    io.flutter.embedding.android.FlutterView$ZeroSides BOTH -> T2
    io.flutter.embedding.android.FlutterView$ZeroSides RIGHT -> S2
    io.flutter.embedding.android.FlutterView$ZeroSides[] $VALUES -> U2
io.flutter.embedding.android.KeyChannelResponder -> io.flutter.embedding.android.m:
    io.flutter.embedding.engine.systemchannels.KeyEventChannel keyEventChannel -> a
    io.flutter.embedding.android.KeyboardManager$CharacterCombiner characterCombiner -> b
    void handleEvent(android.view.KeyEvent,io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback) -> a
    void $r8$lambda$2j1oQDNrug8exq2tp8d8ktXWyJI(io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback,boolean) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void lambda$handleEvent$0(io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback,boolean) -> c
io.flutter.embedding.android.KeyChannelResponder$$ExternalSyntheticLambda0 -> io.flutter.embedding.android.l:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback io.flutter.embedding.android.KeyChannelResponder$$InternalSyntheticLambda$0$cf5bb92e2b133ed4958c8cd4422a67f2702c41d504a4d346cc4c4bc1e1bd865e$0.f$0 -> a
    void io.flutter.embedding.android.KeyChannelResponder$$InternalSyntheticLambda$0$cf5bb92e2b133ed4958c8cd4422a67f2702c41d504a4d346cc4c4bc1e1bd865e$0.<init>(io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.android.KeyChannelResponder$$InternalSyntheticLambda$0$cf5bb92e2b133ed4958c8cd4422a67f2702c41d504a4d346cc4c4bc1e1bd865e$0.onFrameworkResponse(boolean) -> a
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.embedding.android.KeyData -> io.flutter.embedding.android.n:
    java.lang.String character -> f
    io.flutter.embedding.android.KeyData$Type type -> b
    boolean synthesized -> e
    long timestamp -> a
    long logicalKey -> d
    long physicalKey -> c
    java.nio.ByteBuffer toBytes() -> a
io.flutter.embedding.android.KeyData$Type -> io.flutter.embedding.android.n$a:
    io.flutter.embedding.android.KeyData$Type kUp -> S2
    io.flutter.embedding.android.KeyData$Type kRepeat -> T2
    io.flutter.embedding.android.KeyData$Type kDown -> R2
    io.flutter.embedding.android.KeyData$Type[] $VALUES -> U2
    long value -> Q2
    long getValue() -> a
io.flutter.embedding.android.KeyEmbedderResponder -> io.flutter.embedding.android.r:
    io.flutter.plugin.common.BinaryMessenger messenger -> a
    java.util.HashMap pressingRecords -> b
    io.flutter.embedding.android.KeyboardManager$CharacterCombiner characterCombiner -> d
    java.util.HashMap togglingGoals -> c
    void handleEvent(android.view.KeyEvent,io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback) -> a
    void $r8$lambda$Usbaa64Go-Inz_pnHu4Hlllp4NQ(io.flutter.embedding.android.KeyEmbedderResponder,io.flutter.embedding.android.KeyboardMap$KeyPair,android.view.KeyEvent) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$VKF-feFqVV2c2diHOYJl9TFRWNI(io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback,java.nio.ByteBuffer) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$u49qZcV7pBZIuZzpJy2XDxE4ka4(io.flutter.embedding.android.KeyEmbedderResponder,io.flutter.embedding.android.KeyboardMap$KeyPair,long,android.view.KeyEvent) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.android.KeyData$Type getEventType(android.view.KeyEvent) -> e
    java.lang.Long getLogicalKey(android.view.KeyEvent) -> f
    java.lang.Long getPhysicalKey(android.view.KeyEvent) -> g
    boolean handleEventImpl(android.view.KeyEvent,io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback) -> h
    long keyOfPlane(long,long) -> i
    void lambda$sendKeyEvent$2(io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback,java.nio.ByteBuffer) -> j
    void lambda$synchronizePressingKey$0(io.flutter.embedding.android.KeyboardMap$KeyPair,long,android.view.KeyEvent) -> k
    void lambda$synchronizePressingKey$1(io.flutter.embedding.android.KeyboardMap$KeyPair,android.view.KeyEvent) -> l
    void sendKeyEvent(io.flutter.embedding.android.KeyData,io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback) -> m
    void synchronizePressingKey(io.flutter.embedding.android.KeyboardMap$PressingGoal,boolean,long,long,android.view.KeyEvent,java.util.ArrayList) -> n
    void synchronizeTogglingKey(io.flutter.embedding.android.KeyboardMap$TogglingGoal,boolean,long,android.view.KeyEvent) -> o
    void synthesizeEvent(boolean,java.lang.Long,java.lang.Long,long) -> p
    void updatePressingState(java.lang.Long,java.lang.Long) -> q
io.flutter.embedding.android.KeyEmbedderResponder$$ExternalSyntheticLambda0 -> io.flutter.embedding.android.o:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$6507d676e68eca9658ab3e3290a65055cc36dddf2daa4d3e93e689f917200d2b$0.f$0 -> a
    void io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$6507d676e68eca9658ab3e3290a65055cc36dddf2daa4d3e93e689f917200d2b$0.<init>(io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$6507d676e68eca9658ab3e3290a65055cc36dddf2daa4d3e93e689f917200d2b$0.reply(java.nio.ByteBuffer) -> a
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.embedding.android.KeyEmbedderResponder$$ExternalSyntheticLambda1 -> io.flutter.embedding.android.p:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    android.view.KeyEvent io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$0.f$3 -> T2
    io.flutter.embedding.android.KeyboardMap$KeyPair io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$0.f$1 -> R2
    io.flutter.embedding.android.KeyEmbedderResponder io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$0.f$0 -> Q2
    long io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$0.f$2 -> S2
    void io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$0.<init>(io.flutter.embedding.android.KeyEmbedderResponder,io.flutter.embedding.android.KeyboardMap$KeyPair,long,android.view.KeyEvent) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.embedding.android.KeyEmbedderResponder$$ExternalSyntheticLambda2 -> io.flutter.embedding.android.q:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    android.view.KeyEvent io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$1.f$2 -> S2
    io.flutter.embedding.android.KeyboardMap$KeyPair io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$1.f$1 -> R2
    io.flutter.embedding.android.KeyEmbedderResponder io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$1.f$0 -> Q2
    void io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$1.<init>(io.flutter.embedding.android.KeyEmbedderResponder,io.flutter.embedding.android.KeyboardMap$KeyPair,android.view.KeyEvent) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.android.KeyEmbedderResponder$$InternalSyntheticLambda$0$b443f1685234fb1a1fec61ee582d5e8ff9a32d81e104782d09b7b851ae380117$1.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.embedding.android.KeyEmbedderResponder$1 -> io.flutter.embedding.android.r$a:
    int[] $SwitchMap$io$flutter$embedding$android$KeyData$Type -> a
io.flutter.embedding.android.KeyboardManager -> io.flutter.embedding.android.s:
    java.util.HashSet redispatchedEvents -> b
    io.flutter.embedding.android.KeyboardManager$Responder[] responders -> a
    io.flutter.embedding.android.KeyboardManager$ViewDelegate viewDelegate -> c
    boolean handleEvent(android.view.KeyEvent) -> a
    void access$000(io.flutter.embedding.android.KeyboardManager,android.view.KeyEvent) -> b
    void destroy() -> c
    void onUnhandled(android.view.KeyEvent) -> d
io.flutter.embedding.android.KeyboardManager$1 -> io.flutter.embedding.android.s$a:
io.flutter.embedding.android.KeyboardManager$CharacterCombiner -> io.flutter.embedding.android.s$b:
    int combiningCharacter -> a
    java.lang.Character applyCombiningCharacterToBaseCharacter(int) -> a
io.flutter.embedding.android.KeyboardManager$PerEventCallbackBuilder -> io.flutter.embedding.android.s$c:
    android.view.KeyEvent keyEvent -> a
    io.flutter.embedding.android.KeyboardManager this$0 -> d
    int unrepliedCount -> b
    boolean isEventHandled -> c
    io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback buildCallback() -> a
io.flutter.embedding.android.KeyboardManager$PerEventCallbackBuilder$Callback -> io.flutter.embedding.android.s$c$a:
    io.flutter.embedding.android.KeyboardManager$PerEventCallbackBuilder this$1 -> b
    boolean isCalled -> a
    void onKeyEventHandled(boolean) -> a
io.flutter.embedding.android.KeyboardManager$Responder -> io.flutter.embedding.android.s$d:
    void handleEvent(android.view.KeyEvent,io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback) -> a
io.flutter.embedding.android.KeyboardManager$Responder$OnKeyEventHandledCallback -> io.flutter.embedding.android.s$d$a:
    void onKeyEventHandled(boolean) -> a
io.flutter.embedding.android.KeyboardManager$ViewDelegate -> io.flutter.embedding.android.s$e:
    void redispatch(android.view.KeyEvent) -> a
    boolean onTextInputKeyEvent(android.view.KeyEvent) -> b
io.flutter.embedding.android.KeyboardMap -> io.flutter.embedding.android.t:
    java.util.HashMap keyCodeToLogical -> b
    java.util.HashMap scanCodeToPhysical -> a
    io.flutter.embedding.android.KeyboardMap$PressingGoal[] pressingGoals -> c
    io.flutter.embedding.android.KeyboardMap$TogglingGoal[] getTogglingGoals() -> a
io.flutter.embedding.android.KeyboardMap$1 -> io.flutter.embedding.android.t$a:
io.flutter.embedding.android.KeyboardMap$2 -> io.flutter.embedding.android.t$b:
io.flutter.embedding.android.KeyboardMap$KeyPair -> io.flutter.embedding.android.t$c:
    long logicalKey -> b
    long physicalKey -> a
io.flutter.embedding.android.KeyboardMap$PressingGoal -> io.flutter.embedding.android.t$d:
    io.flutter.embedding.android.KeyboardMap$KeyPair[] keys -> b
    int mask -> a
io.flutter.embedding.android.KeyboardMap$TogglingGoal -> io.flutter.embedding.android.t$e:
    long physicalKey -> b
    long logicalKey -> c
    int mask -> a
    boolean enabled -> d
io.flutter.embedding.android.MotionEventTracker -> io.flutter.embedding.android.u:
    java.util.PriorityQueue unusedEvents -> b
    android.util.LongSparseArray eventById -> a
    io.flutter.embedding.android.MotionEventTracker INSTANCE -> c
    io.flutter.embedding.android.MotionEventTracker getInstance() -> a
    android.view.MotionEvent pop(io.flutter.embedding.android.MotionEventTracker$MotionEventId) -> b
    io.flutter.embedding.android.MotionEventTracker$MotionEventId track(android.view.MotionEvent) -> c
io.flutter.embedding.android.MotionEventTracker$MotionEventId -> io.flutter.embedding.android.u$a:
    java.util.concurrent.atomic.AtomicLong ID_COUNTER -> b
    long id -> a
    long access$000(io.flutter.embedding.android.MotionEventTracker$MotionEventId) -> a
    io.flutter.embedding.android.MotionEventTracker$MotionEventId createUnique() -> b
    io.flutter.embedding.android.MotionEventTracker$MotionEventId from(long) -> c
    long getId() -> d
io.flutter.embedding.android.RenderMode -> io.flutter.embedding.android.v:
    io.flutter.embedding.android.RenderMode surface -> Q2
    io.flutter.embedding.android.RenderMode texture -> R2
    io.flutter.embedding.android.RenderMode image -> S2
    io.flutter.embedding.android.RenderMode[] $VALUES -> T2
io.flutter.embedding.android.SplashScreen -> io.flutter.embedding.android.x:
    void transitionToFlutter(java.lang.Runnable) -> a
    boolean doesSplashViewRememberItsTransition() -> b
    android.view.View createSplashView(android.content.Context,android.os.Bundle) -> c
    android.os.Bundle saveSplashScreenState() -> d
io.flutter.embedding.android.SplashScreen$-CC -> io.flutter.embedding.android.w:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    boolean $default$doesSplashViewRememberItsTransition(io.flutter.embedding.android.SplashScreen) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    android.os.Bundle $default$saveSplashScreenState(io.flutter.embedding.android.SplashScreen) -> b
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.embedding.android.TransparencyMode -> io.flutter.embedding.android.y:
    io.flutter.embedding.android.TransparencyMode opaque -> Q2
    io.flutter.embedding.android.TransparencyMode transparent -> R2
    io.flutter.embedding.android.TransparencyMode[] $VALUES -> S2
io.flutter.embedding.android.WindowInfoRepositoryCallbackAdapterWrapper -> io.flutter.embedding.android.z:
    androidx.window.java.layout.WindowInfoTrackerCallbackAdapter adapter -> a
    void addWindowLayoutInfoListener(android.app.Activity,java.util.concurrent.Executor,androidx.core.util.Consumer) -> a
    void removeWindowLayoutInfoListener(androidx.core.util.Consumer) -> b
io.flutter.embedding.engine.FlutterEngine -> io.flutter.embedding.engine.a:
    io.flutter.embedding.engine.systemchannels.RestorationChannel restorationChannel -> l
    io.flutter.embedding.engine.dart.DartExecutor dartExecutor -> c
    io.flutter.embedding.engine.systemchannels.LifecycleChannel lifecycleChannel -> h
    java.util.Set engineLifecycleListeners -> s
    io.flutter.embedding.engine.FlutterEngine$EngineLifecycleListener engineLifecycleListener -> t
    io.flutter.embedding.engine.systemchannels.LocalizationChannel localizationChannel -> i
    io.flutter.embedding.engine.systemchannels.AccessibilityChannel accessibilityChannel -> f
    io.flutter.embedding.engine.systemchannels.DeferredComponentChannel deferredComponentChannel -> g
    io.flutter.embedding.engine.systemchannels.TextInputChannel textInputChannel -> q
    io.flutter.embedding.engine.FlutterEngineConnectionRegistry pluginRegistry -> d
    io.flutter.embedding.engine.systemchannels.SpellCheckChannel spellCheckChannel -> o
    io.flutter.embedding.engine.FlutterJNI flutterJNI -> a
    io.flutter.embedding.engine.systemchannels.MouseCursorChannel mouseCursorChannel -> j
    io.flutter.embedding.engine.systemchannels.NavigationChannel navigationChannel -> k
    io.flutter.embedding.engine.systemchannels.SettingsChannel settingsChannel -> n
    io.flutter.plugin.localization.LocalizationPlugin localizationPlugin -> e
    io.flutter.embedding.engine.systemchannels.SystemChannel systemChannel -> p
    io.flutter.embedding.engine.renderer.FlutterRenderer renderer -> b
    io.flutter.embedding.engine.systemchannels.PlatformChannel platformChannel -> m
    io.flutter.plugin.platform.PlatformViewsController platformViewsController -> r
    java.util.Set access$000(io.flutter.embedding.engine.FlutterEngine) -> a
    io.flutter.plugin.platform.PlatformViewsController access$100(io.flutter.embedding.engine.FlutterEngine) -> b
    io.flutter.embedding.engine.systemchannels.RestorationChannel access$200(io.flutter.embedding.engine.FlutterEngine) -> c
    void attachToJni() -> d
    void destroy() -> e
    io.flutter.embedding.engine.systemchannels.AccessibilityChannel getAccessibilityChannel() -> f
    io.flutter.embedding.engine.plugins.activity.ActivityControlSurface getActivityControlSurface() -> g
    io.flutter.embedding.engine.dart.DartExecutor getDartExecutor() -> h
    io.flutter.embedding.engine.systemchannels.LifecycleChannel getLifecycleChannel() -> i
    io.flutter.plugin.localization.LocalizationPlugin getLocalizationPlugin() -> j
    io.flutter.embedding.engine.systemchannels.MouseCursorChannel getMouseCursorChannel() -> k
    io.flutter.embedding.engine.systemchannels.NavigationChannel getNavigationChannel() -> l
    io.flutter.embedding.engine.systemchannels.PlatformChannel getPlatformChannel() -> m
    io.flutter.plugin.platform.PlatformViewsController getPlatformViewsController() -> n
    io.flutter.embedding.engine.plugins.PluginRegistry getPlugins() -> o
    io.flutter.embedding.engine.renderer.FlutterRenderer getRenderer() -> p
    io.flutter.embedding.engine.systemchannels.RestorationChannel getRestorationChannel() -> q
    io.flutter.embedding.engine.systemchannels.SettingsChannel getSettingsChannel() -> r
    io.flutter.embedding.engine.systemchannels.SpellCheckChannel getSpellCheckChannel() -> s
    io.flutter.embedding.engine.systemchannels.SystemChannel getSystemChannel() -> t
    io.flutter.embedding.engine.systemchannels.TextInputChannel getTextInputChannel() -> u
    boolean isAttachedToJni() -> v
io.flutter.embedding.engine.FlutterEngine$1 -> io.flutter.embedding.engine.a$a:
    io.flutter.embedding.engine.FlutterEngine this$0 -> a
    void onPreEngineRestart() -> a
    void onEngineWillDestroy() -> b
io.flutter.embedding.engine.FlutterEngine$EngineLifecycleListener -> io.flutter.embedding.engine.a$b:
    void onPreEngineRestart() -> a
    void onEngineWillDestroy() -> b
io.flutter.embedding.engine.FlutterEngineCache -> io.flutter.embedding.engine.b:
    java.util.Map cachedEngines -> a
    io.flutter.embedding.engine.FlutterEngineCache instance -> b
    io.flutter.embedding.engine.FlutterEngine get(java.lang.String) -> a
    io.flutter.embedding.engine.FlutterEngineCache getInstance() -> b
    void put(java.lang.String,io.flutter.embedding.engine.FlutterEngine) -> c
    void remove(java.lang.String) -> d
io.flutter.embedding.engine.FlutterEngineConnectionRegistry -> io.flutter.embedding.engine.c:
    android.content.BroadcastReceiver broadcastReceiver -> k
    io.flutter.embedding.android.ExclusiveAppComponent exclusiveActivity -> e
    io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding pluginBinding -> c
    android.app.Service service -> i
    java.util.Map plugins -> a
    android.content.ContentProvider contentProvider -> m
    java.util.Map activityAwarePlugins -> d
    io.flutter.embedding.engine.FlutterEngine flutterEngine -> b
    java.util.Map broadcastReceiverAwarePlugins -> j
    boolean isWaitingForActivityReattachment -> g
    java.util.Map contentProviderAwarePlugins -> l
    io.flutter.embedding.engine.FlutterEngineConnectionRegistry$FlutterEngineActivityPluginBinding activityPluginBinding -> f
    java.util.Map serviceAwarePlugins -> h
    boolean onRequestPermissionsResult(int,java.lang.String[],int[]) -> a
    boolean onActivityResult(int,int,android.content.Intent) -> b
    void onNewIntent(android.content.Intent) -> c
    void onRestoreInstanceState(android.os.Bundle) -> d
    void onSaveInstanceState(android.os.Bundle) -> e
    void onUserLeaveHint() -> f
    void attachToActivity(io.flutter.embedding.android.ExclusiveAppComponent,androidx.lifecycle.Lifecycle) -> g
    void detachFromActivity() -> h
    void add(io.flutter.embedding.engine.plugins.FlutterPlugin) -> i
    void detachFromActivityForConfigChanges() -> j
    void attachToActivityInternal(android.app.Activity,androidx.lifecycle.Lifecycle) -> k
    void destroy() -> l
    void detachFromActivityInternal() -> m
    void detachFromAppComponent() -> n
    void detachFromBroadcastReceiver() -> o
    void detachFromContentProvider() -> p
    void detachFromService() -> q
    boolean has(java.lang.Class) -> r
    boolean isAttachedToActivity() -> s
    boolean isAttachedToBroadcastReceiver() -> t
    boolean isAttachedToContentProvider() -> u
    boolean isAttachedToService() -> v
    void remove(java.lang.Class) -> w
    void remove(java.util.Set) -> x
    void removeAll() -> y
io.flutter.embedding.engine.FlutterEngineConnectionRegistry$1 -> io.flutter.embedding.engine.c$a:
io.flutter.embedding.engine.FlutterEngineConnectionRegistry$DefaultFlutterAssets -> io.flutter.embedding.engine.c$b:
    io.flutter.embedding.engine.loader.FlutterLoader flutterLoader -> a
io.flutter.embedding.engine.FlutterEngineConnectionRegistry$FlutterEngineActivityPluginBinding -> io.flutter.embedding.engine.c$c:
    java.util.Set onSaveInstanceStateListeners -> g
    java.util.Set onRequestPermissionsResultListeners -> c
    java.util.Set onActivityResultListeners -> d
    java.util.Set onNewIntentListeners -> e
    java.util.Set onUserLeaveHintListeners -> f
    io.flutter.embedding.engine.plugins.lifecycle.HiddenLifecycleReference hiddenLifecycleReference -> b
    android.app.Activity activity -> a
    java.lang.Object getLifecycle() -> a
    void addRequestPermissionsResultListener(io.flutter.plugin.common.PluginRegistry$RequestPermissionsResultListener) -> b
    void addActivityResultListener(io.flutter.plugin.common.PluginRegistry$ActivityResultListener) -> c
    android.app.Activity getActivity() -> d
    void removeActivityResultListener(io.flutter.plugin.common.PluginRegistry$ActivityResultListener) -> e
    void removeRequestPermissionsResultListener(io.flutter.plugin.common.PluginRegistry$RequestPermissionsResultListener) -> f
    boolean onActivityResult(int,int,android.content.Intent) -> g
    void onNewIntent(android.content.Intent) -> h
    boolean onRequestPermissionsResult(int,java.lang.String[],int[]) -> i
    void onRestoreInstanceState(android.os.Bundle) -> j
    void onSaveInstanceState(android.os.Bundle) -> k
    void onUserLeaveHint() -> l
io.flutter.embedding.engine.FlutterJNI -> io.flutter.embedding.engine.FlutterJNI:
    void $r8$lambda$2fUF03zsar2dpLbGJv6IUmJU-0A(long,android.graphics.ImageDecoder,android.graphics.ImageDecoder$ImageInfo,android.graphics.ImageDecoder$Source) -> a
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.embedding.engine.FlutterJNI$$ExternalSyntheticLambda0 -> io.flutter.embedding.engine.d:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    long io.flutter.embedding.engine.FlutterJNI$$InternalSyntheticLambda$0$2a5524ed219e708ff31c82ad8e0395d5d0898b08cb74f1a02a2f346a4db7f98c$0.f$0 -> a
    void io.flutter.embedding.engine.FlutterJNI$$InternalSyntheticLambda$0$2a5524ed219e708ff31c82ad8e0395d5d0898b08cb74f1a02a2f346a4db7f98c$0.<init>(long) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.engine.FlutterJNI$$InternalSyntheticLambda$0$2a5524ed219e708ff31c82ad8e0395d5d0898b08cb74f1a02a2f346a4db7f98c$0.onHeaderDecoded(android.graphics.ImageDecoder,android.graphics.ImageDecoder$ImageInfo,android.graphics.ImageDecoder$Source) -> onHeaderDecoded
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.embedding.engine.FlutterJNI$AccessibilityDelegate -> io.flutter.embedding.engine.FlutterJNI$a:
    void updateSemantics(java.nio.ByteBuffer,java.lang.String[],java.nio.ByteBuffer[]) -> a
    void updateCustomAccessibilityActions(java.nio.ByteBuffer,java.lang.String[]) -> b
io.flutter.embedding.engine.FlutterJNI$AsyncWaitForVsyncDelegate -> io.flutter.embedding.engine.FlutterJNI$b:
    void asyncWaitForVsync(long) -> a
io.flutter.embedding.engine.FlutterJNI$Factory -> io.flutter.embedding.engine.FlutterJNI$c:
    io.flutter.embedding.engine.FlutterJNI provideFlutterJNI() -> a
io.flutter.embedding.engine.FlutterShellArgs -> io.flutter.embedding.engine.e:
    java.util.Set args -> a
    io.flutter.embedding.engine.FlutterShellArgs fromIntent(android.content.Intent) -> a
    java.lang.String[] toArray() -> b
io.flutter.embedding.engine.dart.DartExecutor -> o2.a:
    io.flutter.embedding.engine.FlutterJNI flutterJNI -> a
    io.flutter.embedding.engine.dart.DartExecutor$IsolateServiceIdListener isolateServiceIdListener -> g
    java.lang.String isolateServiceId -> f
    io.flutter.embedding.engine.dart.DartMessenger dartMessenger -> c
    io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler isolateChannelMessageHandler -> h
    android.content.res.AssetManager assetManager -> b
    boolean isApplicationRunning -> e
    io.flutter.plugin.common.BinaryMessenger binaryMessenger -> d
    io.flutter.plugin.common.BinaryMessenger$TaskQueue makeBackgroundTaskQueue(io.flutter.plugin.common.BinaryMessenger$TaskQueueOptions) -> a
    void setMessageHandler(java.lang.String,io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler,io.flutter.plugin.common.BinaryMessenger$TaskQueue) -> b
    void send(java.lang.String,java.nio.ByteBuffer) -> c
    java.lang.String access$000(io.flutter.embedding.engine.dart.DartExecutor) -> d
    io.flutter.plugin.common.BinaryMessenger$TaskQueue makeBackgroundTaskQueue() -> e
      # {"id":"com.android.tools.r8.synthesized"}
    void send(java.lang.String,java.nio.ByteBuffer,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> f
    java.lang.String access$002(io.flutter.embedding.engine.dart.DartExecutor,java.lang.String) -> g
    void setMessageHandler(java.lang.String,io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler) -> h
    io.flutter.embedding.engine.dart.DartExecutor$IsolateServiceIdListener access$100(io.flutter.embedding.engine.dart.DartExecutor) -> i
    void executeDartEntrypoint(io.flutter.embedding.engine.dart.DartExecutor$DartEntrypoint,java.util.List) -> j
    java.lang.String getIsolateServiceId() -> k
    boolean isExecutingDart() -> l
    void notifyLowMemoryWarning() -> m
    void onAttachedToJNI() -> n
    void onDetachedFromJNI() -> o
io.flutter.embedding.engine.dart.DartExecutor$1 -> o2.a$a:
    io.flutter.embedding.engine.dart.DartExecutor this$0 -> a
    void onMessage(java.nio.ByteBuffer,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> a
io.flutter.embedding.engine.dart.DartExecutor$DartEntrypoint -> o2.a$b:
    java.lang.String pathToBundle -> a
    java.lang.String dartEntrypointFunctionName -> c
    java.lang.String dartEntrypointLibrary -> b
io.flutter.embedding.engine.dart.DartExecutor$DefaultBinaryMessenger -> o2.a$c:
    io.flutter.embedding.engine.dart.DartMessenger messenger -> a
    io.flutter.plugin.common.BinaryMessenger$TaskQueue makeBackgroundTaskQueue(io.flutter.plugin.common.BinaryMessenger$TaskQueueOptions) -> a
    void setMessageHandler(java.lang.String,io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler,io.flutter.plugin.common.BinaryMessenger$TaskQueue) -> b
    void send(java.lang.String,java.nio.ByteBuffer) -> c
    io.flutter.plugin.common.BinaryMessenger$TaskQueue makeBackgroundTaskQueue() -> e
      # {"id":"com.android.tools.r8.synthesized"}
    void send(java.lang.String,java.nio.ByteBuffer,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> f
    void setMessageHandler(java.lang.String,io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler) -> h
io.flutter.embedding.engine.dart.DartExecutor$IsolateServiceIdListener -> o2.a$d:
    void onIsolateServiceIdAvailable(java.lang.String) -> a
io.flutter.embedding.engine.dart.DartMessenger -> o2.c:
    io.flutter.embedding.engine.FlutterJNI flutterJNI -> a
    java.util.Map messageHandlers -> b
    io.flutter.embedding.engine.dart.DartMessenger$TaskQueueFactory taskQueueFactory -> j
    java.util.Map bufferedMessages -> c
    java.util.concurrent.atomic.AtomicBoolean enableBufferingIncomingMessages -> e
    io.flutter.embedding.engine.dart.DartMessenger$DartMessengerTaskQueue platformTaskQueue -> h
    java.util.WeakHashMap createdTaskQueues -> i
    java.lang.Object handlersLock -> d
    int nextReplyId -> g
    java.util.Map pendingReplies -> f
    io.flutter.plugin.common.BinaryMessenger$TaskQueue makeBackgroundTaskQueue(io.flutter.plugin.common.BinaryMessenger$TaskQueueOptions) -> a
    void setMessageHandler(java.lang.String,io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler,io.flutter.plugin.common.BinaryMessenger$TaskQueue) -> b
    void send(java.lang.String,java.nio.ByteBuffer) -> c
    void handlePlatformMessageResponse(int,java.nio.ByteBuffer) -> d
    io.flutter.plugin.common.BinaryMessenger$TaskQueue makeBackgroundTaskQueue() -> e
      # {"id":"com.android.tools.r8.synthesized"}
    void send(java.lang.String,java.nio.ByteBuffer,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> f
    void handleMessageFromDart(java.lang.String,java.nio.ByteBuffer,int,long) -> g
    void setMessageHandler(java.lang.String,io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler) -> h
    void $r8$lambda$2j2MERcK825A5j1fv5sZ7xB2Iuo(io.flutter.embedding.engine.dart.DartMessenger,java.lang.String,int,io.flutter.embedding.engine.dart.DartMessenger$HandlerInfo,java.nio.ByteBuffer,long) -> i
      # {"id":"com.android.tools.r8.synthesized"}
    void dispatchMessageToQueue(java.lang.String,io.flutter.embedding.engine.dart.DartMessenger$HandlerInfo,java.nio.ByteBuffer,int,long) -> j
    void handleError(java.lang.Error) -> k
    void invokeHandler(io.flutter.embedding.engine.dart.DartMessenger$HandlerInfo,java.nio.ByteBuffer,int) -> l
    void lambda$dispatchMessageToQueue$0(java.lang.String,int,io.flutter.embedding.engine.dart.DartMessenger$HandlerInfo,java.nio.ByteBuffer,long) -> m
io.flutter.embedding.engine.dart.DartMessenger$1 -> o2.c$a:
io.flutter.embedding.engine.dart.DartMessenger$BufferedMessageInfo -> o2.c$b:
    long messageData -> c
    int replyId -> b
    java.nio.ByteBuffer message -> a
io.flutter.embedding.engine.dart.DartMessenger$ConcurrentTaskQueue -> o2.c$c:
    java.util.concurrent.ExecutorService executor -> a
    void dispatch(java.lang.Runnable) -> a
io.flutter.embedding.engine.dart.DartMessenger$DartMessengerTaskQueue -> o2.c$d:
    void dispatch(java.lang.Runnable) -> a
io.flutter.embedding.engine.dart.DartMessenger$DefaultTaskQueueFactory -> o2.c$e:
    java.util.concurrent.ExecutorService executorService -> a
    io.flutter.embedding.engine.dart.DartMessenger$DartMessengerTaskQueue makeBackgroundTaskQueue(io.flutter.plugin.common.BinaryMessenger$TaskQueueOptions) -> a
io.flutter.embedding.engine.dart.DartMessenger$HandlerInfo -> o2.c$f:
    io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler handler -> a
    io.flutter.embedding.engine.dart.DartMessenger$DartMessengerTaskQueue taskQueue -> b
io.flutter.embedding.engine.dart.DartMessenger$Reply -> o2.c$g:
    io.flutter.embedding.engine.FlutterJNI flutterJNI -> a
    java.util.concurrent.atomic.AtomicBoolean done -> c
    int replyId -> b
    void reply(java.nio.ByteBuffer) -> a
io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue -> o2.c$h:
    java.util.concurrent.atomic.AtomicBoolean isRunning -> c
    java.util.concurrent.ConcurrentLinkedQueue queue -> b
    java.util.concurrent.ExecutorService executor -> a
    void dispatch(java.lang.Runnable) -> a
    void $r8$lambda$F0iXMzLdPiwUET1ugdCo3vpOFvI(io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$Z_QpOFGAZlPwSj4jhPkDhTfI820(io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    void flush() -> d
    void lambda$dispatch$0() -> e
    void lambda$flush$1() -> f
io.flutter.embedding.engine.dart.DartMessenger$TaskQueueFactory -> o2.c$i:
    io.flutter.embedding.engine.dart.DartMessenger$DartMessengerTaskQueue makeBackgroundTaskQueue(io.flutter.plugin.common.BinaryMessenger$TaskQueueOptions) -> a
io.flutter.embedding.engine.dart.DartMessenger$TaskQueueToken -> o2.c$j:
io.flutter.embedding.engine.dart.PlatformMessageHandler -> o2.f:
    void handlePlatformMessageResponse(int,java.nio.ByteBuffer) -> d
    void handleMessageFromDart(java.lang.String,java.nio.ByteBuffer,int,long) -> g
io.flutter.embedding.engine.dart.PlatformTaskQueue -> o2.g:
    android.os.Handler handler -> a
    void dispatch(java.lang.Runnable) -> a
io.flutter.embedding.engine.deferredcomponents.DeferredComponentManager -> p2.a:
    java.lang.String getDeferredComponentInstallState(int,java.lang.String) -> a
    void installDeferredComponent(int,java.lang.String) -> b
    void setDeferredComponentChannel(io.flutter.embedding.engine.systemchannels.DeferredComponentChannel) -> c
    boolean uninstallDeferredComponent(int,java.lang.String) -> d
    void setJNI(io.flutter.embedding.engine.FlutterJNI) -> e
io.flutter.embedding.engine.loader.ApplicationInfoLoader -> q2.a:
    java.lang.String PUBLIC_AOT_SHARED_LIBRARY_NAME -> a
    java.lang.String PUBLIC_ISOLATE_SNAPSHOT_DATA_KEY -> c
    java.lang.String PUBLIC_VM_SNAPSHOT_DATA_KEY -> b
    java.lang.String PUBLIC_FLUTTER_ASSETS_DIR_KEY -> d
    android.content.pm.ApplicationInfo getApplicationInfo(android.content.Context) -> a
    boolean getBoolean(android.os.Bundle,java.lang.String,boolean) -> b
    java.lang.String getNetworkPolicy(android.content.pm.ApplicationInfo,android.content.Context) -> c
    java.lang.String getString(android.os.Bundle,java.lang.String) -> d
    io.flutter.embedding.engine.loader.FlutterApplicationInfo load(android.content.Context) -> e
    void parseDomain(android.content.res.XmlResourceParser,org.json.JSONArray,boolean) -> f
    void parseDomainConfig(android.content.res.XmlResourceParser,org.json.JSONArray,boolean) -> g
    void skipTag(android.content.res.XmlResourceParser) -> h
io.flutter.embedding.engine.loader.FlutterApplicationInfo -> q2.b:
    java.lang.String nativeLibraryDir -> f
    java.lang.String aotSharedLibraryName -> a
    boolean automaticallyRegisterPlugins -> g
    java.lang.String isolateSnapshotData -> c
    java.lang.String vmSnapshotData -> b
    java.lang.String domainNetworkPolicy -> e
    java.lang.String flutterAssetsDir -> d
io.flutter.embedding.engine.loader.FlutterLoader -> q2.d:
    io.flutter.embedding.engine.loader.FlutterApplicationInfo flutterApplicationInfo -> d
    java.util.concurrent.ExecutorService executorService -> f
    long initStartTimestampMillis -> c
    java.util.concurrent.Future initResultFuture -> g
    boolean initialized -> a
    io.flutter.embedding.engine.FlutterJNI flutterJNI -> e
    io.flutter.embedding.engine.loader.FlutterLoader$Settings settings -> b
    io.flutter.embedding.engine.loader.ResourceExtractor access$000(io.flutter.embedding.engine.loader.FlutterLoader,android.content.Context) -> a
    io.flutter.embedding.engine.FlutterJNI access$100(io.flutter.embedding.engine.loader.FlutterLoader) -> b
    java.util.concurrent.ExecutorService access$200(io.flutter.embedding.engine.loader.FlutterLoader) -> c
    boolean automaticallyRegisterPlugins() -> d
    void ensureInitializationComplete(android.content.Context,java.lang.String[]) -> e
    java.lang.String findAppBundlePath() -> f
    io.flutter.embedding.engine.loader.ResourceExtractor initResources(android.content.Context) -> g
    boolean isLeakVM(android.os.Bundle) -> h
    void startInitialization(android.content.Context) -> i
    void startInitialization(android.content.Context,io.flutter.embedding.engine.loader.FlutterLoader$Settings) -> j
io.flutter.embedding.engine.loader.FlutterLoader$1 -> q2.d$a:
    android.content.Context val$appContext -> a
    io.flutter.embedding.engine.loader.FlutterLoader this$0 -> b
    void $r8$lambda$7aDWRJH5QhLJRySlof0NX61HOhE(io.flutter.embedding.engine.loader.FlutterLoader$1) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.engine.loader.FlutterLoader$InitResult call() -> b
    void lambda$call$0() -> c
io.flutter.embedding.engine.loader.FlutterLoader$InitResult -> q2.d$b:
    java.lang.String appStoragePath -> a
    java.lang.String dataDirPath -> c
    java.lang.String engineCachesPath -> b
io.flutter.embedding.engine.loader.FlutterLoader$Settings -> q2.d$c:
    java.lang.String logTag -> a
    java.lang.String getLogTag() -> a
io.flutter.embedding.engine.loader.ResourceExtractor -> q2.e:
io.flutter.embedding.engine.mutatorsstack.FlutterMutatorView -> r2.a:
    android.view.ViewTreeObserver$OnGlobalFocusChangeListener activeFocusListener -> h
    int prevTop -> f
    float screenDensity -> b
    int top -> d
    io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack mutatorsStack -> a
    int prevLeft -> e
    io.flutter.embedding.android.AndroidTouchProcessor androidTouchProcessor -> g
    int left -> c
    void readyToDisplay(io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack,int,int,int,int) -> a
    void unsetOnDescendantFocusChangeListener() -> b
io.flutter.embedding.engine.mutatorsstack.FlutterMutatorView$1 -> r2.a$a:
    android.view.View$OnFocusChangeListener val$userFocusListener -> a
    io.flutter.embedding.engine.mutatorsstack.FlutterMutatorView this$0 -> c
    android.view.View val$mutatorView -> b
io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$FlutterMutator -> io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$a:
    io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$FlutterMutatorType type -> d
    float[] radiis -> c
    android.graphics.Matrix matrix -> a
    android.graphics.Rect rect -> b
    io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack this$0 -> e
    android.graphics.Matrix getMatrix() -> a
io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$FlutterMutatorType -> io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$b:
    io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$FlutterMutatorType CLIP_PATH -> S2
    io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$FlutterMutatorType TRANSFORM -> T2
    io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$FlutterMutatorType OPACITY -> U2
    io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$FlutterMutatorType[] $VALUES -> V2
    io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$FlutterMutatorType CLIP_RECT -> Q2
    io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack$FlutterMutatorType CLIP_RRECT -> R2
io.flutter.embedding.engine.plugins.FlutterPlugin -> s2.a:
    void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> a
    void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> e
io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterAssets -> s2.a$a:
io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding -> s2.a$b:
    android.content.Context applicationContext -> a
    io.flutter.plugin.platform.PlatformViewRegistry platformViewRegistry -> e
    io.flutter.view.TextureRegistry textureRegistry -> d
    io.flutter.embedding.engine.FlutterEngine flutterEngine -> b
    io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterAssets flutterAssets -> f
    io.flutter.plugin.common.BinaryMessenger binaryMessenger -> c
    android.content.Context getApplicationContext() -> a
    io.flutter.plugin.common.BinaryMessenger getBinaryMessenger() -> b
    io.flutter.plugin.platform.PlatformViewRegistry getPlatformViewRegistry() -> c
io.flutter.embedding.engine.plugins.PluginRegistry -> s2.b:
    void add(io.flutter.embedding.engine.plugins.FlutterPlugin) -> i
io.flutter.embedding.engine.plugins.activity.ActivityAware -> t2.a:
    void onReattachedToActivityForConfigChanges(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> b
    void onDetachedFromActivity() -> c
    void onAttachedToActivity(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> f
    void onDetachedFromActivityForConfigChanges() -> g
io.flutter.embedding.engine.plugins.activity.ActivityControlSurface -> t2.b:
    boolean onRequestPermissionsResult(int,java.lang.String[],int[]) -> a
    boolean onActivityResult(int,int,android.content.Intent) -> b
    void onNewIntent(android.content.Intent) -> c
    void onRestoreInstanceState(android.os.Bundle) -> d
    void onSaveInstanceState(android.os.Bundle) -> e
    void onUserLeaveHint() -> f
    void attachToActivity(io.flutter.embedding.android.ExclusiveAppComponent,androidx.lifecycle.Lifecycle) -> g
    void detachFromActivity() -> h
    void detachFromActivityForConfigChanges() -> j
io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding -> t2.c:
    java.lang.Object getLifecycle() -> a
    void addRequestPermissionsResultListener(io.flutter.plugin.common.PluginRegistry$RequestPermissionsResultListener) -> b
    void addActivityResultListener(io.flutter.plugin.common.PluginRegistry$ActivityResultListener) -> c
    android.app.Activity getActivity() -> d
    void removeActivityResultListener(io.flutter.plugin.common.PluginRegistry$ActivityResultListener) -> e
    void removeRequestPermissionsResultListener(io.flutter.plugin.common.PluginRegistry$RequestPermissionsResultListener) -> f
io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding$OnSaveInstanceStateListener -> t2.c$a:
    void onRestoreInstanceState(android.os.Bundle) -> d
    void onSaveInstanceState(android.os.Bundle) -> e
io.flutter.embedding.engine.plugins.broadcastreceiver.BroadcastReceiverAware -> u2.a:
    void onAttachedToBroadcastReceiver(io.flutter.embedding.engine.plugins.broadcastreceiver.BroadcastReceiverPluginBinding) -> a
    void onDetachedFromBroadcastReceiver() -> b
io.flutter.embedding.engine.plugins.broadcastreceiver.BroadcastReceiverPluginBinding -> u2.b:
io.flutter.embedding.engine.plugins.contentprovider.ContentProviderAware -> v2.a:
    void onDetachedFromContentProvider() -> a
    void onAttachedToContentProvider(io.flutter.embedding.engine.plugins.contentprovider.ContentProviderPluginBinding) -> b
io.flutter.embedding.engine.plugins.contentprovider.ContentProviderPluginBinding -> v2.b:
io.flutter.embedding.engine.plugins.lifecycle.FlutterLifecycleAdapter -> w2.a:
    androidx.lifecycle.Lifecycle getActivityLifecycle(io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding) -> a
io.flutter.embedding.engine.plugins.service.ServiceAware -> x2.a:
    void onAttachedToService(io.flutter.embedding.engine.plugins.service.ServicePluginBinding) -> a
    void onDetachedFromService() -> b
io.flutter.embedding.engine.plugins.service.ServicePluginBinding -> x2.b:
io.flutter.embedding.engine.plugins.util.GeneratedPluginRegister -> y2.a:
    void registerGeneratedPlugins(io.flutter.embedding.engine.FlutterEngine) -> a
io.flutter.embedding.engine.renderer.FlutterRenderer -> z2.a:
    io.flutter.embedding.engine.FlutterJNI flutterJNI -> a
    android.os.Handler handler -> e
    java.util.concurrent.atomic.AtomicLong nextTextureId -> b
    io.flutter.embedding.engine.renderer.FlutterUiDisplayListener flutterUiDisplayListener -> g
    android.view.Surface surface -> c
    java.util.Set onTrimMemoryListeners -> f
    boolean isDisplayingFlutterUi -> d
    io.flutter.view.TextureRegistry$SurfaceTextureEntry createSurfaceTexture() -> a
    boolean access$002(io.flutter.embedding.engine.renderer.FlutterRenderer,boolean) -> b
    io.flutter.embedding.engine.FlutterJNI access$300(io.flutter.embedding.engine.renderer.FlutterRenderer) -> c
    void access$500(io.flutter.embedding.engine.renderer.FlutterRenderer,long) -> d
    android.os.Handler access$700(io.flutter.embedding.engine.renderer.FlutterRenderer) -> e
    void addIsDisplayingFlutterUiListener(io.flutter.embedding.engine.renderer.FlutterUiDisplayListener) -> f
    void addOnTrimMemoryListener(io.flutter.view.TextureRegistry$OnTrimMemoryListener) -> g
    void clearDeadListeners() -> h
    void dispatchPointerDataPacket(java.nio.ByteBuffer,int) -> i
    boolean isDisplayingFlutterUi() -> j
    boolean isSoftwareRenderingEnabled() -> k
    void markTextureFrameAvailable(long) -> l
    void onTrimMemory(int) -> m
    io.flutter.view.TextureRegistry$SurfaceTextureEntry registerSurfaceTexture(android.graphics.SurfaceTexture) -> n
    void registerTexture(long,io.flutter.embedding.engine.renderer.SurfaceTextureWrapper) -> o
    void removeIsDisplayingFlutterUiListener(io.flutter.embedding.engine.renderer.FlutterUiDisplayListener) -> p
    void setSemanticsEnabled(boolean) -> q
    void setViewportMetrics(io.flutter.embedding.engine.renderer.FlutterRenderer$ViewportMetrics) -> r
    void startRenderingToSurface(android.view.Surface,boolean) -> s
    void stopRenderingToSurface() -> t
    void surfaceChanged(int,int) -> u
    void swapSurface(android.view.Surface) -> v
io.flutter.embedding.engine.renderer.FlutterRenderer$1 -> z2.a$a:
    io.flutter.embedding.engine.renderer.FlutterRenderer this$0 -> a
    void onFlutterUiNoLongerDisplayed() -> c
    void onFlutterUiDisplayed() -> f
io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeature -> z2.a$b:
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureState state -> c
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureType type -> b
    android.graphics.Rect bounds -> a
io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureState -> z2.a$c:
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureState POSTURE_FLAT -> S2
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureState UNKNOWN -> R2
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureState POSTURE_HALF_OPENED -> T2
    int encodedValue -> Q2
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureState[] $VALUES -> U2
io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureType -> z2.a$d:
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureType[] $VALUES -> V2
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureType CUTOUT -> U2
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureType HINGE -> T2
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureType FOLD -> S2
    int encodedValue -> Q2
    io.flutter.embedding.engine.renderer.FlutterRenderer$DisplayFeatureType UNKNOWN -> R2
io.flutter.embedding.engine.renderer.FlutterRenderer$SurfaceTextureFinalizerRunnable -> z2.a$e:
    io.flutter.embedding.engine.FlutterJNI flutterJNI -> R2
    long id -> Q2
io.flutter.embedding.engine.renderer.FlutterRenderer$SurfaceTextureRegistryEntry -> z2.a$f:
    io.flutter.view.TextureRegistry$OnFrameConsumedListener frameConsumedListener -> e
    io.flutter.embedding.engine.renderer.SurfaceTextureWrapper textureWrapper -> b
    java.lang.Runnable onFrameConsumed -> f
    long id -> a
    io.flutter.view.TextureRegistry$OnTrimMemoryListener trimMemoryListener -> d
    boolean released -> c
    android.graphics.SurfaceTexture$OnFrameAvailableListener onFrameListener -> g
    io.flutter.embedding.engine.renderer.FlutterRenderer this$0 -> h
    long id() -> a
    void setOnTrimMemoryListener(io.flutter.view.TextureRegistry$OnTrimMemoryListener) -> b
    void setOnFrameConsumedListener(io.flutter.view.TextureRegistry$OnFrameConsumedListener) -> c
    android.graphics.SurfaceTexture surfaceTexture() -> d
    io.flutter.view.TextureRegistry$OnFrameConsumedListener access$100(io.flutter.embedding.engine.renderer.FlutterRenderer$SurfaceTextureRegistryEntry) -> e
    boolean access$200(io.flutter.embedding.engine.renderer.FlutterRenderer$SurfaceTextureRegistryEntry) -> f
    long access$400(io.flutter.embedding.engine.renderer.FlutterRenderer$SurfaceTextureRegistryEntry) -> g
    io.flutter.embedding.engine.renderer.SurfaceTextureWrapper textureWrapper() -> h
io.flutter.embedding.engine.renderer.FlutterRenderer$SurfaceTextureRegistryEntry$1 -> z2.a$f$a:
    io.flutter.embedding.engine.renderer.FlutterRenderer$SurfaceTextureRegistryEntry this$1 -> Q2
io.flutter.embedding.engine.renderer.FlutterRenderer$SurfaceTextureRegistryEntry$2 -> z2.a$f$b:
    io.flutter.embedding.engine.renderer.FlutterRenderer$SurfaceTextureRegistryEntry this$1 -> a
io.flutter.embedding.engine.renderer.FlutterRenderer$ViewportMetrics -> z2.a$g:
    int systemGestureInsetBottom -> n
    int systemGestureInsetLeft -> o
    java.util.List displayFeatures -> q
    int systemGestureInsetTop -> l
    int systemGestureInsetRight -> m
    int viewInsetBottom -> j
    int viewInsetLeft -> k
    int viewInsetTop -> h
    int viewInsetRight -> i
    int viewPaddingBottom -> f
    int viewPaddingLeft -> g
    int viewPaddingTop -> d
    float devicePixelRatio -> a
    int viewPaddingRight -> e
    int width -> b
    int height -> c
    int physicalTouchSlop -> p
    boolean validate() -> a
io.flutter.embedding.engine.renderer.FlutterUiDisplayListener -> z2.b:
    void onFlutterUiNoLongerDisplayed() -> c
    void onFlutterUiDisplayed() -> f
io.flutter.embedding.engine.renderer.RenderSurface -> z2.c:
    void pause() -> a
    void detachFromRenderer() -> b
    void attachToRenderer(io.flutter.embedding.engine.renderer.FlutterRenderer) -> c
io.flutter.embedding.engine.systemchannels.AccessibilityChannel -> a3.a:
    io.flutter.embedding.engine.FlutterJNI flutterJNI -> b
    io.flutter.embedding.engine.systemchannels.AccessibilityChannel$AccessibilityMessageHandler handler -> c
    io.flutter.plugin.common.BasicMessageChannel$MessageHandler parsingMessageHandler -> d
    io.flutter.plugin.common.BasicMessageChannel channel -> a
    io.flutter.embedding.engine.systemchannels.AccessibilityChannel$AccessibilityMessageHandler access$000(io.flutter.embedding.engine.systemchannels.AccessibilityChannel) -> a
    void dispatchSemanticsAction(int,io.flutter.view.AccessibilityBridge$Action) -> b
    void dispatchSemanticsAction(int,io.flutter.view.AccessibilityBridge$Action,java.lang.Object) -> c
    void onAndroidAccessibilityDisabled() -> d
    void onAndroidAccessibilityEnabled() -> e
    void setAccessibilityFeatures(int) -> f
    void setAccessibilityMessageHandler(io.flutter.embedding.engine.systemchannels.AccessibilityChannel$AccessibilityMessageHandler) -> g
io.flutter.embedding.engine.systemchannels.AccessibilityChannel$1 -> a3.a$a:
    io.flutter.embedding.engine.systemchannels.AccessibilityChannel this$0 -> a
    void onMessage(java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> a
io.flutter.embedding.engine.systemchannels.AccessibilityChannel$AccessibilityMessageHandler -> a3.a$b:
    void onTooltip(java.lang.String) -> c
    void onLongPress(int) -> d
    void announce(java.lang.String) -> e
    void onTap(int) -> f
io.flutter.embedding.engine.systemchannels.DeferredComponentChannel -> a3.b:
    java.util.Map componentNameToResults -> c
    io.flutter.plugin.common.MethodChannel$MethodCallHandler parsingMethodHandler -> d
    io.flutter.embedding.engine.deferredcomponents.DeferredComponentManager deferredComponentManager -> b
    io.flutter.plugin.common.MethodChannel channel -> a
    io.flutter.embedding.engine.deferredcomponents.DeferredComponentManager access$000(io.flutter.embedding.engine.systemchannels.DeferredComponentChannel) -> a
    java.util.Map access$100(io.flutter.embedding.engine.systemchannels.DeferredComponentChannel) -> b
    void setDeferredComponentManager(io.flutter.embedding.engine.deferredcomponents.DeferredComponentManager) -> c
io.flutter.embedding.engine.systemchannels.DeferredComponentChannel$1 -> a3.b$a:
    io.flutter.embedding.engine.systemchannels.DeferredComponentChannel this$0 -> a
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
io.flutter.embedding.engine.systemchannels.KeyEventChannel -> a3.d:
    io.flutter.plugin.common.BasicMessageChannel channel -> a
    void $r8$lambda$RL0HJ5TnZGrDabOeA71yhjryCe4(io.flutter.embedding.engine.systemchannels.KeyEventChannel$EventResponseHandler,java.lang.Object) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.BasicMessageChannel$Reply createReplyHandler(io.flutter.embedding.engine.systemchannels.KeyEventChannel$EventResponseHandler) -> b
    java.util.Map encodeKeyEvent(io.flutter.embedding.engine.systemchannels.KeyEventChannel$FlutterKeyEvent,boolean) -> c
    void lambda$createReplyHandler$0(io.flutter.embedding.engine.systemchannels.KeyEventChannel$EventResponseHandler,java.lang.Object) -> d
    void sendFlutterKeyEvent(io.flutter.embedding.engine.systemchannels.KeyEventChannel$FlutterKeyEvent,boolean,io.flutter.embedding.engine.systemchannels.KeyEventChannel$EventResponseHandler) -> e
io.flutter.embedding.engine.systemchannels.KeyEventChannel$EventResponseHandler -> a3.d$a:
    void onFrameworkResponse(boolean) -> a
io.flutter.embedding.engine.systemchannels.KeyEventChannel$FlutterKeyEvent -> a3.d$b:
    android.view.KeyEvent event -> a
    java.lang.Character complexCharacter -> b
io.flutter.embedding.engine.systemchannels.LifecycleChannel -> a3.e:
    io.flutter.plugin.common.BasicMessageChannel channel -> a
    void appIsDetached() -> a
    void appIsInactive() -> b
    void appIsPaused() -> c
    void appIsResumed() -> d
io.flutter.embedding.engine.systemchannels.LocalizationChannel -> a3.f:
    io.flutter.plugin.common.MethodChannel$MethodCallHandler handler -> c
    io.flutter.plugin.common.MethodChannel channel -> a
    io.flutter.embedding.engine.systemchannels.LocalizationChannel$LocalizationMessageHandler localizationMessageHandler -> b
    io.flutter.embedding.engine.systemchannels.LocalizationChannel$LocalizationMessageHandler access$000(io.flutter.embedding.engine.systemchannels.LocalizationChannel) -> a
    void sendLocales(java.util.List) -> b
    void setLocalizationMessageHandler(io.flutter.embedding.engine.systemchannels.LocalizationChannel$LocalizationMessageHandler) -> c
io.flutter.embedding.engine.systemchannels.LocalizationChannel$1 -> a3.f$a:
    io.flutter.embedding.engine.systemchannels.LocalizationChannel this$0 -> a
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
io.flutter.embedding.engine.systemchannels.LocalizationChannel$LocalizationMessageHandler -> a3.f$b:
    java.lang.String getStringResource(java.lang.String,java.lang.String) -> a
io.flutter.embedding.engine.systemchannels.MouseCursorChannel -> a3.g:
    io.flutter.embedding.engine.systemchannels.MouseCursorChannel$MouseCursorMethodHandler mouseCursorMethodHandler -> b
    io.flutter.plugin.common.MethodChannel$MethodCallHandler parsingMethodCallHandler -> c
    io.flutter.plugin.common.MethodChannel channel -> a
    io.flutter.embedding.engine.systemchannels.MouseCursorChannel$MouseCursorMethodHandler access$000(io.flutter.embedding.engine.systemchannels.MouseCursorChannel) -> a
    void setMethodHandler(io.flutter.embedding.engine.systemchannels.MouseCursorChannel$MouseCursorMethodHandler) -> b
io.flutter.embedding.engine.systemchannels.MouseCursorChannel$1 -> a3.g$a:
    io.flutter.embedding.engine.systemchannels.MouseCursorChannel this$0 -> a
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
io.flutter.embedding.engine.systemchannels.MouseCursorChannel$MouseCursorMethodHandler -> a3.g$b:
    void activateSystemCursor(java.lang.String) -> a
io.flutter.embedding.engine.systemchannels.NavigationChannel -> a3.h:
    io.flutter.plugin.common.MethodChannel$MethodCallHandler defaultHandler -> b
    io.flutter.plugin.common.MethodChannel channel -> a
    void popRoute() -> a
    void pushRoute(java.lang.String) -> b
    void setInitialRoute(java.lang.String) -> c
io.flutter.embedding.engine.systemchannels.NavigationChannel$1 -> a3.h$a:
    io.flutter.embedding.engine.systemchannels.NavigationChannel this$0 -> a
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
io.flutter.embedding.engine.systemchannels.PlatformChannel -> a3.i:
    io.flutter.plugin.common.MethodChannel$MethodCallHandler parsingMethodCallHandler -> c
    io.flutter.embedding.engine.systemchannels.PlatformChannel$PlatformMessageHandler platformMessageHandler -> b
    io.flutter.plugin.common.MethodChannel channel -> a
    io.flutter.embedding.engine.systemchannels.PlatformChannel$PlatformMessageHandler access$000(io.flutter.embedding.engine.systemchannels.PlatformChannel) -> a
    int access$100(io.flutter.embedding.engine.systemchannels.PlatformChannel,org.json.JSONArray) -> b
    io.flutter.embedding.engine.systemchannels.PlatformChannel$AppSwitcherDescription access$200(io.flutter.embedding.engine.systemchannels.PlatformChannel,org.json.JSONObject) -> c
    java.util.List access$300(io.flutter.embedding.engine.systemchannels.PlatformChannel,org.json.JSONArray) -> d
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode access$400(io.flutter.embedding.engine.systemchannels.PlatformChannel,java.lang.String) -> e
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemChromeStyle access$500(io.flutter.embedding.engine.systemchannels.PlatformChannel,org.json.JSONObject) -> f
    io.flutter.embedding.engine.systemchannels.PlatformChannel$AppSwitcherDescription decodeAppSwitcherDescription(org.json.JSONObject) -> g
    int decodeOrientations(org.json.JSONArray) -> h
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemChromeStyle decodeSystemChromeStyle(org.json.JSONObject) -> i
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode decodeSystemUiMode(java.lang.String) -> j
    java.util.List decodeSystemUiOverlays(org.json.JSONArray) -> k
    void setPlatformMessageHandler(io.flutter.embedding.engine.systemchannels.PlatformChannel$PlatformMessageHandler) -> l
    void systemChromeChanged(boolean) -> m
io.flutter.embedding.engine.systemchannels.PlatformChannel$1 -> a3.i$a:
    io.flutter.embedding.engine.systemchannels.PlatformChannel this$0 -> a
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
io.flutter.embedding.engine.systemchannels.PlatformChannel$2 -> a3.i$b:
    int[] $SwitchMap$io$flutter$embedding$engine$systemchannels$PlatformChannel$SystemUiOverlay -> b
    int[] $SwitchMap$io$flutter$embedding$engine$systemchannels$PlatformChannel$SystemUiMode -> c
    int[] $SwitchMap$io$flutter$embedding$engine$systemchannels$PlatformChannel$DeviceOrientation -> a
io.flutter.embedding.engine.systemchannels.PlatformChannel$AppSwitcherDescription -> a3.i$c:
    java.lang.String label -> b
    int color -> a
io.flutter.embedding.engine.systemchannels.PlatformChannel$Brightness -> a3.i$d:
    io.flutter.embedding.engine.systemchannels.PlatformChannel$Brightness DARK -> S2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$Brightness LIGHT -> R2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$Brightness[] $VALUES -> T2
    java.lang.String encodedName -> Q2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$Brightness fromValue(java.lang.String) -> a
io.flutter.embedding.engine.systemchannels.PlatformChannel$ClipboardContentFormat -> a3.i$e:
    io.flutter.embedding.engine.systemchannels.PlatformChannel$ClipboardContentFormat[] $VALUES -> S2
    java.lang.String encodedName -> Q2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$ClipboardContentFormat PLAIN_TEXT -> R2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$ClipboardContentFormat fromValue(java.lang.String) -> a
io.flutter.embedding.engine.systemchannels.PlatformChannel$DeviceOrientation -> a3.i$f:
    io.flutter.embedding.engine.systemchannels.PlatformChannel$DeviceOrientation[] $VALUES -> V2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$DeviceOrientation PORTRAIT_DOWN -> S2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$DeviceOrientation PORTRAIT_UP -> R2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$DeviceOrientation LANDSCAPE_RIGHT -> U2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$DeviceOrientation LANDSCAPE_LEFT -> T2
    java.lang.String encodedName -> Q2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$DeviceOrientation fromValue(java.lang.String) -> a
io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType -> a3.i$g:
    io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType SELECTION_CLICK -> V2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType MEDIUM_IMPACT -> T2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType HEAVY_IMPACT -> U2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType[] $VALUES -> W2
    java.lang.String encodedName -> Q2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType STANDARD -> R2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType LIGHT_IMPACT -> S2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType fromValue(java.lang.String) -> a
io.flutter.embedding.engine.systemchannels.PlatformChannel$PlatformMessageHandler -> a3.i$h:
    void popSystemNavigator() -> b
    void setSystemUiChangeListener() -> c
    void restoreSystemUiOverlays() -> d
    void setClipboardData(java.lang.String) -> e
    void setSystemUiOverlayStyle(io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemChromeStyle) -> f
    java.lang.CharSequence getClipboardData(io.flutter.embedding.engine.systemchannels.PlatformChannel$ClipboardContentFormat) -> g
    void setPreferredOrientations(int) -> h
    void playSystemSound(io.flutter.embedding.engine.systemchannels.PlatformChannel$SoundType) -> i
    void showSystemOverlays(java.util.List) -> j
    void vibrateHapticFeedback(io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType) -> k
    boolean clipboardHasStrings() -> l
    void setApplicationSwitcherDescription(io.flutter.embedding.engine.systemchannels.PlatformChannel$AppSwitcherDescription) -> m
    void showSystemUiMode(io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode) -> n
io.flutter.embedding.engine.systemchannels.PlatformChannel$SoundType -> a3.i$i:
    java.lang.String encodedName -> Q2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SoundType[] $VALUES -> T2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SoundType ALERT -> S2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SoundType CLICK -> R2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SoundType fromValue(java.lang.String) -> a
io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemChromeStyle -> a3.i$j:
    java.lang.Boolean systemNavigationBarContrastEnforced -> g
    java.lang.Integer systemNavigationBarColor -> d
    java.lang.Integer systemNavigationBarDividerColor -> f
    io.flutter.embedding.engine.systemchannels.PlatformChannel$Brightness systemNavigationBarIconBrightness -> e
    io.flutter.embedding.engine.systemchannels.PlatformChannel$Brightness statusBarIconBrightness -> b
    java.lang.Boolean systemStatusBarContrastEnforced -> c
    java.lang.Integer statusBarColor -> a
io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode -> a3.i$k:
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode[] $VALUES -> V2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode IMMERSIVE -> S2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode LEAN_BACK -> R2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode EDGE_TO_EDGE -> U2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode IMMERSIVE_STICKY -> T2
    java.lang.String encodedName -> Q2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode fromValue(java.lang.String) -> a
io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiOverlay -> a3.i$l:
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiOverlay TOP_OVERLAYS -> R2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiOverlay BOTTOM_OVERLAYS -> S2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiOverlay[] $VALUES -> T2
    java.lang.String encodedName -> Q2
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiOverlay fromValue(java.lang.String) -> a
io.flutter.embedding.engine.systemchannels.PlatformViewsChannel -> a3.k:
    io.flutter.plugin.common.MethodChannel$MethodCallHandler parsingHandler -> c
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewsHandler handler -> b
    io.flutter.plugin.common.MethodChannel channel -> a
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewsHandler access$000(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel) -> a
    java.lang.String access$100(java.lang.Exception) -> b
    java.lang.String detailedExceptionString(java.lang.Exception) -> c
    void invokeViewFocused(int) -> d
    void setPlatformViewsHandler(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewsHandler) -> e
io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$1 -> a3.k$a:
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel this$0 -> a
    void $r8$lambda$pMHhgo3vaqdzoS3K-OFSVbonOaM(io.flutter.plugin.common.MethodChannel$Result,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferSize) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    void clearFocus(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> b
    void create(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> c
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
    void dispose(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> e
    void lambda$resize$0(io.flutter.plugin.common.MethodChannel$Result,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferSize) -> f
    void offset(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> g
    void resize(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> h
    void setDirection(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> i
    void synchronizeToNativeViewHierarchy(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> j
    void touch(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> k
io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized -> a3.k$b:
    void run(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferSize) -> a
io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferSize -> a3.k$c:
    int height -> b
    int width -> a
io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest -> a3.k$d:
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode displayMode -> h
    java.nio.ByteBuffer params -> i
    double logicalWidth -> c
    int direction -> g
    double logicalHeight -> d
    double logicalTop -> e
    double logicalLeft -> f
    java.lang.String viewType -> b
    int viewId -> a
io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode -> a3.k$d$a:
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode[] $VALUES -> T2
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode HYBRID_ONLY -> S2
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode TEXTURE_WITH_VIRTUAL_FALLBACK -> Q2
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest$RequestedDisplayMode TEXTURE_WITH_HYBRID_FALLBACK -> R2
io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewResizeRequest -> a3.k$e:
    double newLogicalWidth -> b
    double newLogicalHeight -> c
    int viewId -> a
io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewTouch -> a3.k$f:
    int source -> n
    float yPrecision -> k
    int flags -> o
    float xPrecision -> j
    int deviceId -> l
    int edgeFlags -> m
    java.lang.Object rawPointerPropertiesList -> f
    java.lang.Object rawPointerCoords -> g
    int metaState -> h
    int buttonState -> i
    int action -> d
    int pointerCount -> e
    int viewId -> a
    java.lang.Number downTime -> b
    java.lang.Number eventTime -> c
    long motionEventId -> p
io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewsHandler -> a3.k$g:
    void clearFocus(int) -> a
    void synchronizeToNativeViewHierarchy(boolean) -> b
    void resize(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewResizeRequest,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized) -> c
    void offset(int,double,double) -> d
    void setDirection(int,int) -> e
    void createForPlatformViewLayer(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest) -> f
    void dispose(int) -> g
    long createForTextureLayer(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest) -> h
    void onTouch(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewTouch) -> i
io.flutter.embedding.engine.systemchannels.RestorationChannel -> a3.l:
    byte[] restorationData -> b
    io.flutter.plugin.common.MethodChannel$MethodCallHandler handler -> g
    boolean engineHasProvidedData -> e
    boolean frameworkHasRequestedData -> f
    boolean waitForRestorationData -> a
    io.flutter.plugin.common.MethodChannel channel -> c
    io.flutter.plugin.common.MethodChannel$Result pendingFrameworkRestorationChannelRequest -> d
    byte[] access$000(io.flutter.embedding.engine.systemchannels.RestorationChannel) -> a
    byte[] access$002(io.flutter.embedding.engine.systemchannels.RestorationChannel,byte[]) -> b
    boolean access$102(io.flutter.embedding.engine.systemchannels.RestorationChannel,boolean) -> c
    boolean access$200(io.flutter.embedding.engine.systemchannels.RestorationChannel) -> d
    java.util.Map access$300(io.flutter.embedding.engine.systemchannels.RestorationChannel,byte[]) -> e
    io.flutter.plugin.common.MethodChannel$Result access$402(io.flutter.embedding.engine.systemchannels.RestorationChannel,io.flutter.plugin.common.MethodChannel$Result) -> f
    void clearData() -> g
    byte[] getRestorationData() -> h
    java.util.Map packageData(byte[]) -> i
    void setRestorationData(byte[]) -> j
io.flutter.embedding.engine.systemchannels.RestorationChannel$1 -> a3.l$a:
    byte[] val$data -> a
    io.flutter.embedding.engine.systemchannels.RestorationChannel this$0 -> b
    void success(java.lang.Object) -> a
    void error(java.lang.String,java.lang.String,java.lang.Object) -> b
    void notImplemented() -> c
io.flutter.embedding.engine.systemchannels.RestorationChannel$2 -> a3.l$b:
    io.flutter.embedding.engine.systemchannels.RestorationChannel this$0 -> a
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
io.flutter.embedding.engine.systemchannels.SettingsChannel -> a3.m:
    io.flutter.plugin.common.BasicMessageChannel channel -> a
    io.flutter.embedding.engine.systemchannels.SettingsChannel$MessageBuilder startMessage() -> a
io.flutter.embedding.engine.systemchannels.SettingsChannel$MessageBuilder -> a3.m$a:
    java.util.Map message -> b
    io.flutter.plugin.common.BasicMessageChannel channel -> a
    void send() -> a
    io.flutter.embedding.engine.systemchannels.SettingsChannel$MessageBuilder setBrieflyShowPassword(boolean) -> b
    io.flutter.embedding.engine.systemchannels.SettingsChannel$MessageBuilder setNativeSpellCheckServiceDefined(boolean) -> c
    io.flutter.embedding.engine.systemchannels.SettingsChannel$MessageBuilder setPlatformBrightness(io.flutter.embedding.engine.systemchannels.SettingsChannel$PlatformBrightness) -> d
    io.flutter.embedding.engine.systemchannels.SettingsChannel$MessageBuilder setTextScaleFactor(float) -> e
    io.flutter.embedding.engine.systemchannels.SettingsChannel$MessageBuilder setUse24HourFormat(boolean) -> f
io.flutter.embedding.engine.systemchannels.SettingsChannel$PlatformBrightness -> a3.m$b:
    io.flutter.embedding.engine.systemchannels.SettingsChannel$PlatformBrightness light -> R2
    io.flutter.embedding.engine.systemchannels.SettingsChannel$PlatformBrightness dark -> S2
    java.lang.String name -> Q2
    io.flutter.embedding.engine.systemchannels.SettingsChannel$PlatformBrightness[] $VALUES -> T2
io.flutter.embedding.engine.systemchannels.SpellCheckChannel -> a3.n:
    io.flutter.embedding.engine.systemchannels.SpellCheckChannel$SpellCheckMethodHandler spellCheckMethodHandler -> b
    io.flutter.plugin.common.MethodChannel$MethodCallHandler parsingMethodHandler -> c
    io.flutter.plugin.common.MethodChannel channel -> a
    io.flutter.embedding.engine.systemchannels.SpellCheckChannel$SpellCheckMethodHandler access$000(io.flutter.embedding.engine.systemchannels.SpellCheckChannel) -> a
    void setSpellCheckMethodHandler(io.flutter.embedding.engine.systemchannels.SpellCheckChannel$SpellCheckMethodHandler) -> b
io.flutter.embedding.engine.systemchannels.SpellCheckChannel$1 -> a3.n$a:
    io.flutter.embedding.engine.systemchannels.SpellCheckChannel this$0 -> a
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
io.flutter.embedding.engine.systemchannels.SpellCheckChannel$SpellCheckMethodHandler -> a3.n$b:
    void initiateSpellCheck(java.lang.String,java.lang.String,io.flutter.plugin.common.MethodChannel$Result) -> a
io.flutter.embedding.engine.systemchannels.SystemChannel -> a3.o:
    io.flutter.plugin.common.BasicMessageChannel channel -> a
    void sendMemoryPressureWarning() -> a
io.flutter.embedding.engine.systemchannels.TextInputChannel -> a3.p:
    io.flutter.plugin.common.MethodChannel$MethodCallHandler parsingMethodHandler -> c
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputMethodHandler textInputMethodHandler -> b
    io.flutter.plugin.common.MethodChannel channel -> a
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputMethodHandler access$000(io.flutter.embedding.engine.systemchannels.TextInputChannel) -> a
    void commitContent(int,java.util.Map) -> b
    java.util.HashMap createEditingDeltaJSON(java.util.ArrayList) -> c
    java.util.HashMap createEditingStateJSON(java.lang.String,int,int,int,int) -> d
    void done(int) -> e
    void go(int) -> f
    void newline(int) -> g
    void next(int) -> h
    void performPrivateCommand(int,java.lang.String,android.os.Bundle) -> i
    void previous(int) -> j
    void requestExistingInputState() -> k
    void search(int) -> l
    void send(int) -> m
    void setTextInputMethodHandler(io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputMethodHandler) -> n
    void unspecifiedAction(int) -> o
    void updateEditingState(int,java.lang.String,int,int,int,int) -> p
    void updateEditingStateWithDeltas(int,java.util.ArrayList) -> q
    void updateEditingStateWithTag(int,java.util.HashMap) -> r
io.flutter.embedding.engine.systemchannels.TextInputChannel$1 -> a3.p$a:
    io.flutter.embedding.engine.systemchannels.TextInputChannel this$0 -> a
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration -> a3.p$b:
    java.lang.String actionLabel -> i
    io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration[] fields -> l
    java.lang.Integer inputAction -> h
    java.lang.String[] contentCommitMimeTypes -> k
    boolean enableDeltaModel -> e
    io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration$Autofill autofill -> j
    boolean obscureText -> a
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextCapitalization textCapitalization -> f
    io.flutter.embedding.engine.systemchannels.TextInputChannel$InputType inputType -> g
    boolean autocorrect -> b
    boolean enableSuggestions -> c
    boolean enableIMEPersonalizedLearning -> d
    io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration fromJson(org.json.JSONObject) -> a
    java.lang.Integer inputActionFromTextInputAction(java.lang.String) -> b
io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration$Autofill -> a3.p$b$a:
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextEditState editState -> c
    java.lang.String uniqueIdentifier -> a
    java.lang.String[] hints -> b
    java.lang.String hintText -> d
    io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration$Autofill fromJson(org.json.JSONObject) -> a
    java.lang.String translateAutofillHint(java.lang.String) -> b
io.flutter.embedding.engine.systemchannels.TextInputChannel$InputType -> a3.p$c:
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType type -> a
    boolean isSigned -> b
    boolean isDecimal -> c
    io.flutter.embedding.engine.systemchannels.TextInputChannel$InputType fromJson(org.json.JSONObject) -> a
io.flutter.embedding.engine.systemchannels.TextInputChannel$TextCapitalization -> a3.p$d:
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextCapitalization CHARACTERS -> R2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextCapitalization[] $VALUES -> V2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextCapitalization NONE -> U2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextCapitalization SENTENCES -> T2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextCapitalization WORDS -> S2
    java.lang.String encodedName -> Q2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextCapitalization fromValue(java.lang.String) -> a
io.flutter.embedding.engine.systemchannels.TextInputChannel$TextEditState -> a3.p$e:
    java.lang.String text -> a
    int composingStart -> d
    int composingEnd -> e
    int selectionStart -> b
    int selectionEnd -> c
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextEditState fromJson(org.json.JSONObject) -> a
    boolean hasComposing() -> b
    boolean hasSelection() -> c
io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputMethodHandler -> a3.p$f:
    void show() -> a
    void hide() -> b
    void sendAppPrivateCommand(java.lang.String,android.os.Bundle) -> c
    void clearClient() -> d
    void setPlatformViewClient(int,boolean) -> e
    void setEditableSizeAndTransform(double,double,double[]) -> f
    void requestAutofill() -> g
    void setEditingState(io.flutter.embedding.engine.systemchannels.TextInputChannel$TextEditState) -> h
    void setClient(int,io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration) -> i
    void finishAutofillContext(boolean) -> j
io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType -> a3.p$g:
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType VISIBLE_PASSWORD -> a3
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType[] $VALUES -> c3
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType NONE -> b3
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType MULTILINE -> X2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType PHONE -> W2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType NUMBER -> V2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType POSTAL_ADDRESS -> U2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType URL -> Z2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType EMAIL_ADDRESS -> Y2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType NAME -> T2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType DATETIME -> S2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType TEXT -> R2
    java.lang.String encodedName -> Q2
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextInputType fromValue(java.lang.String) -> a
io.flutter.plugin.common.BasicMessageChannel -> b3.a:
    io.flutter.plugin.common.MessageCodec codec -> c
    io.flutter.plugin.common.BinaryMessenger$TaskQueue taskQueue -> d
    io.flutter.plugin.common.BinaryMessenger messenger -> a
    java.lang.String name -> b
    io.flutter.plugin.common.MessageCodec access$200(io.flutter.plugin.common.BasicMessageChannel) -> a
    java.lang.String access$300(io.flutter.plugin.common.BasicMessageChannel) -> b
    void send(java.lang.Object) -> c
    void send(java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> d
    void setMessageHandler(io.flutter.plugin.common.BasicMessageChannel$MessageHandler) -> e
io.flutter.plugin.common.BasicMessageChannel$1 -> b3.a$a:
io.flutter.plugin.common.BasicMessageChannel$IncomingMessageHandler -> b3.a$b:
    io.flutter.plugin.common.BasicMessageChannel$MessageHandler handler -> a
    io.flutter.plugin.common.BasicMessageChannel this$0 -> b
    void onMessage(java.nio.ByteBuffer,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> a
io.flutter.plugin.common.BasicMessageChannel$IncomingMessageHandler$1 -> b3.a$b$a:
    io.flutter.plugin.common.BinaryMessenger$BinaryReply val$callback -> a
    io.flutter.plugin.common.BasicMessageChannel$IncomingMessageHandler this$1 -> b
    void reply(java.lang.Object) -> a
io.flutter.plugin.common.BasicMessageChannel$IncomingReplyHandler -> b3.a$c:
    io.flutter.plugin.common.BasicMessageChannel$Reply callback -> a
    io.flutter.plugin.common.BasicMessageChannel this$0 -> b
    void reply(java.nio.ByteBuffer) -> a
io.flutter.plugin.common.BasicMessageChannel$MessageHandler -> b3.a$d:
    void onMessage(java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> a
io.flutter.plugin.common.BasicMessageChannel$Reply -> b3.a$e:
    void reply(java.lang.Object) -> a
io.flutter.plugin.common.BinaryMessenger -> b3.c:
    io.flutter.plugin.common.BinaryMessenger$TaskQueue makeBackgroundTaskQueue(io.flutter.plugin.common.BinaryMessenger$TaskQueueOptions) -> a
    void setMessageHandler(java.lang.String,io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler,io.flutter.plugin.common.BinaryMessenger$TaskQueue) -> b
    void send(java.lang.String,java.nio.ByteBuffer) -> c
    io.flutter.plugin.common.BinaryMessenger$TaskQueue makeBackgroundTaskQueue() -> e
    void send(java.lang.String,java.nio.ByteBuffer,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> f
    void setMessageHandler(java.lang.String,io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler) -> h
io.flutter.plugin.common.BinaryMessenger$-CC -> b3.b:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.BinaryMessenger$TaskQueue $default$makeBackgroundTaskQueue(io.flutter.plugin.common.BinaryMessenger) -> a
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.plugin.common.BinaryMessenger$BinaryMessageHandler -> b3.c$a:
    void onMessage(java.nio.ByteBuffer,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> a
io.flutter.plugin.common.BinaryMessenger$BinaryReply -> b3.c$b:
    void reply(java.nio.ByteBuffer) -> a
io.flutter.plugin.common.BinaryMessenger$TaskQueue -> b3.c$c:
io.flutter.plugin.common.BinaryMessenger$TaskQueueOptions -> b3.c$d:
    boolean isSerial -> a
    boolean getIsSerial() -> a
io.flutter.plugin.common.EventChannel -> b3.d:
    io.flutter.plugin.common.MethodCodec codec -> c
    io.flutter.plugin.common.BinaryMessenger$TaskQueue taskQueue -> d
    io.flutter.plugin.common.BinaryMessenger messenger -> a
    java.lang.String name -> b
    io.flutter.plugin.common.MethodCodec access$000(io.flutter.plugin.common.EventChannel) -> a
    java.lang.String access$200(io.flutter.plugin.common.EventChannel) -> b
    io.flutter.plugin.common.BinaryMessenger access$400(io.flutter.plugin.common.EventChannel) -> c
    void setStreamHandler(io.flutter.plugin.common.EventChannel$StreamHandler) -> d
io.flutter.plugin.common.EventChannel$1 -> b3.d$a:
io.flutter.plugin.common.EventChannel$EventSink -> b3.d$b:
    void success(java.lang.Object) -> a
io.flutter.plugin.common.EventChannel$IncomingStreamRequestHandler -> b3.d$c:
    io.flutter.plugin.common.EventChannel this$0 -> c
    java.util.concurrent.atomic.AtomicReference activeSink -> b
    io.flutter.plugin.common.EventChannel$StreamHandler handler -> a
    void onMessage(java.nio.ByteBuffer,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> a
    java.util.concurrent.atomic.AtomicReference access$300(io.flutter.plugin.common.EventChannel$IncomingStreamRequestHandler) -> b
    void onCancel(java.lang.Object,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> c
    void onListen(java.lang.Object,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> d
io.flutter.plugin.common.EventChannel$IncomingStreamRequestHandler$EventSinkImplementation -> b3.d$c$a:
    io.flutter.plugin.common.EventChannel$IncomingStreamRequestHandler this$1 -> b
    java.util.concurrent.atomic.AtomicBoolean hasEnded -> a
    void success(java.lang.Object) -> a
io.flutter.plugin.common.EventChannel$StreamHandler -> b3.d$d:
    void onCancel(java.lang.Object) -> a
    void onListen(java.lang.Object,io.flutter.plugin.common.EventChannel$EventSink) -> b
io.flutter.plugin.common.FlutterException -> b3.e:
    java.lang.Object details -> R2
    java.lang.String code -> Q2
io.flutter.plugin.common.JSONMessageCodec -> b3.f:
    io.flutter.plugin.common.JSONMessageCodec INSTANCE -> a
    java.lang.Object decodeMessage(java.nio.ByteBuffer) -> a
    java.nio.ByteBuffer encodeMessage(java.lang.Object) -> b
io.flutter.plugin.common.JSONMethodCodec -> b3.g:
    io.flutter.plugin.common.JSONMethodCodec INSTANCE -> a
    java.nio.ByteBuffer encodeMethodCall(io.flutter.plugin.common.MethodCall) -> a
    java.nio.ByteBuffer encodeSuccessEnvelope(java.lang.Object) -> b
    io.flutter.plugin.common.MethodCall decodeMethodCall(java.nio.ByteBuffer) -> c
    java.lang.Object decodeEnvelope(java.nio.ByteBuffer) -> d
    java.nio.ByteBuffer encodeErrorEnvelopeWithStacktrace(java.lang.String,java.lang.String,java.lang.Object,java.lang.String) -> e
    java.nio.ByteBuffer encodeErrorEnvelope(java.lang.String,java.lang.String,java.lang.Object) -> f
    java.lang.Object unwrapNull(java.lang.Object) -> g
io.flutter.plugin.common.JSONUtil -> b3.h:
    java.lang.Object wrap(java.lang.Object) -> a
io.flutter.plugin.common.MessageCodec -> b3.i:
    java.lang.Object decodeMessage(java.nio.ByteBuffer) -> a
    java.nio.ByteBuffer encodeMessage(java.lang.Object) -> b
io.flutter.plugin.common.MethodCall -> b3.j:
    java.lang.Object arguments -> b
    java.lang.String method -> a
    java.lang.Object argument(java.lang.String) -> a
    java.lang.Object arguments() -> b
    boolean hasArgument(java.lang.String) -> c
io.flutter.plugin.common.MethodChannel -> b3.k:
    io.flutter.plugin.common.MethodCodec codec -> c
    io.flutter.plugin.common.BinaryMessenger$TaskQueue taskQueue -> d
    io.flutter.plugin.common.BinaryMessenger messenger -> a
    java.lang.String name -> b
    io.flutter.plugin.common.MethodCodec access$000(io.flutter.plugin.common.MethodChannel) -> a
    java.lang.String access$100(io.flutter.plugin.common.MethodChannel) -> b
    void invokeMethod(java.lang.String,java.lang.Object) -> c
    void invokeMethod(java.lang.String,java.lang.Object,io.flutter.plugin.common.MethodChannel$Result) -> d
    void setMethodCallHandler(io.flutter.plugin.common.MethodChannel$MethodCallHandler) -> e
io.flutter.plugin.common.MethodChannel$IncomingMethodCallHandler -> b3.k$a:
    io.flutter.plugin.common.MethodChannel$MethodCallHandler handler -> a
    io.flutter.plugin.common.MethodChannel this$0 -> b
    void onMessage(java.nio.ByteBuffer,io.flutter.plugin.common.BinaryMessenger$BinaryReply) -> a
io.flutter.plugin.common.MethodChannel$IncomingMethodCallHandler$1 -> b3.k$a$a:
    io.flutter.plugin.common.BinaryMessenger$BinaryReply val$reply -> a
    io.flutter.plugin.common.MethodChannel$IncomingMethodCallHandler this$1 -> b
    void success(java.lang.Object) -> a
    void error(java.lang.String,java.lang.String,java.lang.Object) -> b
    void notImplemented() -> c
io.flutter.plugin.common.MethodChannel$IncomingResultHandler -> b3.k$b:
    io.flutter.plugin.common.MethodChannel$Result callback -> a
    io.flutter.plugin.common.MethodChannel this$0 -> b
    void reply(java.nio.ByteBuffer) -> a
io.flutter.plugin.common.MethodChannel$MethodCallHandler -> b3.k$c:
    void onMethodCall(io.flutter.plugin.common.MethodCall,io.flutter.plugin.common.MethodChannel$Result) -> d
io.flutter.plugin.common.MethodChannel$Result -> b3.k$d:
    void success(java.lang.Object) -> a
    void error(java.lang.String,java.lang.String,java.lang.Object) -> b
    void notImplemented() -> c
io.flutter.plugin.common.MethodCodec -> b3.l:
    java.nio.ByteBuffer encodeMethodCall(io.flutter.plugin.common.MethodCall) -> a
    java.nio.ByteBuffer encodeSuccessEnvelope(java.lang.Object) -> b
    io.flutter.plugin.common.MethodCall decodeMethodCall(java.nio.ByteBuffer) -> c
    java.lang.Object decodeEnvelope(java.nio.ByteBuffer) -> d
    java.nio.ByteBuffer encodeErrorEnvelopeWithStacktrace(java.lang.String,java.lang.String,java.lang.Object,java.lang.String) -> e
    java.nio.ByteBuffer encodeErrorEnvelope(java.lang.String,java.lang.String,java.lang.Object) -> f
io.flutter.plugin.common.PluginRegistry$ActivityResultListener -> b3.m:
    boolean onActivityResult(int,int,android.content.Intent) -> b
io.flutter.plugin.common.PluginRegistry$NewIntentListener -> b3.n:
    boolean onNewIntent(android.content.Intent) -> c
io.flutter.plugin.common.PluginRegistry$Registrar -> b3.o:
    io.flutter.plugin.common.PluginRegistry$Registrar addRequestPermissionsResultListener(io.flutter.plugin.common.PluginRegistry$RequestPermissionsResultListener) -> b
    io.flutter.plugin.common.PluginRegistry$Registrar addActivityResultListener(io.flutter.plugin.common.PluginRegistry$ActivityResultListener) -> c
io.flutter.plugin.common.PluginRegistry$RequestPermissionsResultListener -> b3.p:
    boolean onRequestPermissionsResult(int,java.lang.String[],int[]) -> a
io.flutter.plugin.common.PluginRegistry$UserLeaveHintListener -> b3.q:
    void onUserLeaveHint() -> f
io.flutter.plugin.common.StandardMessageCodec -> b3.r:
    java.nio.charset.Charset UTF8 -> c
    io.flutter.plugin.common.StandardMessageCodec INSTANCE -> a
    boolean LITTLE_ENDIAN -> b
    java.lang.Object decodeMessage(java.nio.ByteBuffer) -> a
    java.nio.ByteBuffer encodeMessage(java.lang.Object) -> b
    void readAlignment(java.nio.ByteBuffer,int) -> c
    byte[] readBytes(java.nio.ByteBuffer) -> d
    int readSize(java.nio.ByteBuffer) -> e
    java.lang.Object readValue(java.nio.ByteBuffer) -> f
    java.lang.Object readValueOfType(byte,java.nio.ByteBuffer) -> g
    void writeAlignment(java.io.ByteArrayOutputStream,int) -> h
    void writeBytes(java.io.ByteArrayOutputStream,byte[]) -> i
    void writeChar(java.io.ByteArrayOutputStream,int) -> j
    void writeDouble(java.io.ByteArrayOutputStream,double) -> k
    void writeFloat(java.io.ByteArrayOutputStream,float) -> l
    void writeInt(java.io.ByteArrayOutputStream,int) -> m
    void writeLong(java.io.ByteArrayOutputStream,long) -> n
    void writeSize(java.io.ByteArrayOutputStream,int) -> o
    void writeValue(java.io.ByteArrayOutputStream,java.lang.Object) -> p
io.flutter.plugin.common.StandardMessageCodec$ExposedByteArrayOutputStream -> b3.r$a:
    byte[] buffer() -> a
io.flutter.plugin.common.StandardMethodCodec -> b3.s:
    io.flutter.plugin.common.StandardMessageCodec messageCodec -> a
    io.flutter.plugin.common.StandardMethodCodec INSTANCE -> b
    java.nio.ByteBuffer encodeMethodCall(io.flutter.plugin.common.MethodCall) -> a
    java.nio.ByteBuffer encodeSuccessEnvelope(java.lang.Object) -> b
    io.flutter.plugin.common.MethodCall decodeMethodCall(java.nio.ByteBuffer) -> c
    java.lang.Object decodeEnvelope(java.nio.ByteBuffer) -> d
    java.nio.ByteBuffer encodeErrorEnvelopeWithStacktrace(java.lang.String,java.lang.String,java.lang.Object,java.lang.String) -> e
    java.nio.ByteBuffer encodeErrorEnvelope(java.lang.String,java.lang.String,java.lang.Object) -> f
io.flutter.plugin.common.StringCodec -> b3.t:
    java.nio.charset.Charset UTF8 -> a
    io.flutter.plugin.common.StringCodec INSTANCE -> b
    java.lang.Object decodeMessage(java.nio.ByteBuffer) -> a
    java.nio.ByteBuffer encodeMessage(java.lang.Object) -> b
    java.lang.String decodeMessage(java.nio.ByteBuffer) -> c
    java.nio.ByteBuffer encodeMessage(java.lang.String) -> d
io.flutter.plugin.editing.FlutterTextUtils -> io.flutter.plugin.editing.a:
    io.flutter.embedding.engine.FlutterJNI flutterJNI -> a
    int getOffsetAfter(java.lang.CharSequence,int) -> a
    int getOffsetBefore(java.lang.CharSequence,int) -> b
    boolean isEmoji(int) -> c
    boolean isEmojiModifier(int) -> d
    boolean isEmojiModifierBase(int) -> e
    boolean isKeycapBase(int) -> f
    boolean isRegionalIndicatorSymbol(int) -> g
    boolean isTagSpecChar(int) -> h
    boolean isVariationSelector(int) -> i
io.flutter.plugin.editing.ImeSyncDeferringInsetsCallback$1 -> io.flutter.plugin.editing.ImeSyncDeferringInsetsCallback$a:
io.flutter.plugin.editing.ImeSyncDeferringInsetsCallback$InsetsListener -> io.flutter.plugin.editing.ImeSyncDeferringInsetsCallback$b:
    io.flutter.plugin.editing.ImeSyncDeferringInsetsCallback this$0 -> a
io.flutter.plugin.editing.InputConnectionAdaptor -> io.flutter.plugin.editing.b:
    int batchEditNestDepth -> n
    io.flutter.plugin.editing.InputConnectionAdaptor$KeyboardDelegate keyboardDelegate -> m
    android.view.inputmethod.InputMethodManager mImm -> j
    int mClient -> b
    android.view.inputmethod.CursorAnchorInfo$Builder mCursorAnchorInfoBuilder -> h
    android.view.inputmethod.ExtractedTextRequest mExtractRequest -> f
    io.flutter.embedding.engine.systemchannels.TextInputChannel textInputChannel -> c
    android.view.inputmethod.EditorInfo mEditorInfo -> e
    io.flutter.plugin.editing.FlutterTextUtils flutterTextUtils -> l
    android.view.View mFlutterView -> a
    android.text.Layout mLayout -> k
    boolean mMonitorCursorUpdate -> g
    android.view.inputmethod.ExtractedText mExtractedText -> i
    io.flutter.plugin.editing.ListenableEditingState mEditable -> d
    void didChangeEditingState(boolean,boolean,boolean) -> a
    boolean doPerformContextMenuAction(int) -> b
    android.view.inputmethod.CursorAnchorInfo getCursorAnchorInfo() -> c
    android.view.inputmethod.ExtractedText getExtractedText(android.view.inputmethod.ExtractedTextRequest) -> d
    boolean handleHorizontalMovement(boolean,boolean) -> e
    boolean handleKeyEvent(android.view.KeyEvent) -> f
    boolean handleVerticalMovement(boolean,boolean) -> g
    byte[] readStreamFully(java.io.InputStream,int) -> h
io.flutter.plugin.editing.InputConnectionAdaptor$KeyboardDelegate -> io.flutter.plugin.editing.b$a:
    boolean handleEvent(android.view.KeyEvent) -> a
io.flutter.plugin.editing.ListenableEditingState -> io.flutter.plugin.editing.c:
    java.util.ArrayList mPendingListeners -> T2
    java.util.ArrayList mListeners -> S2
    java.util.ArrayList mBatchTextEditingDeltas -> U2
    int mSelectionEndWhenBeginBatchEdit -> Y2
    java.lang.String mTextWhenBeginBatchEdit -> W2
    int mComposingStartWhenBeginBatchEdit -> Z2
    java.lang.String mToStringCache -> V2
    int mSelectionStartWhenBeginBatchEdit -> X2
    android.view.inputmethod.BaseInputConnection mDummyConnection -> b3
    int mBatchEditNestDepth -> Q2
    int mChangeNotificationDepth -> R2
    int mComposingEndWhenBeginBatchEdit -> a3
    void addEditingStateListener(io.flutter.plugin.editing.ListenableEditingState$EditingStateWatcher) -> a
    void beginBatchEdit() -> b
    void clearBatchDeltas() -> c
    void endBatchEdit() -> d
    java.util.ArrayList extractBatchTextEditingDeltas() -> e
    int getComposingEnd() -> f
    int getComposingStart() -> g
    int getSelectionEnd() -> h
    int getSelectionStart() -> i
    void notifyListener(io.flutter.plugin.editing.ListenableEditingState$EditingStateWatcher,boolean,boolean,boolean) -> j
    void notifyListenersIfNeeded(boolean,boolean,boolean) -> k
    void removeEditingStateListener(io.flutter.plugin.editing.ListenableEditingState$EditingStateWatcher) -> l
    void setComposingRange(int,int) -> m
    void setEditingState(io.flutter.embedding.engine.systemchannels.TextInputChannel$TextEditState) -> n
io.flutter.plugin.editing.ListenableEditingState$1 -> io.flutter.plugin.editing.c$a:
    android.text.Editable val$self -> a
    io.flutter.plugin.editing.ListenableEditingState this$0 -> b
io.flutter.plugin.editing.ListenableEditingState$EditingStateWatcher -> io.flutter.plugin.editing.c$b:
    void didChangeEditingState(boolean,boolean,boolean) -> a
io.flutter.plugin.editing.SpellCheckPlugin -> io.flutter.plugin.editing.d:
    io.flutter.embedding.engine.systemchannels.SpellCheckChannel mSpellCheckChannel -> a
    android.view.textservice.TextServicesManager mTextServicesManager -> b
    android.view.textservice.SpellCheckerSession mSpellCheckerSession -> c
    io.flutter.plugin.common.MethodChannel$Result pendingResult -> d
    void initiateSpellCheck(java.lang.String,java.lang.String,io.flutter.plugin.common.MethodChannel$Result) -> a
    void destroy() -> b
    void performSpellCheck(java.lang.String,java.lang.String) -> c
io.flutter.plugin.editing.TextEditingDelta -> io.flutter.plugin.editing.e:
    java.lang.CharSequence oldText -> a
    java.lang.CharSequence deltaText -> b
    int newComposingEnd -> h
    int newSelectionEnd -> f
    int newComposingStart -> g
    int deltaEnd -> d
    int newSelectionStart -> e
    int deltaStart -> c
    void setDeltas(java.lang.CharSequence,java.lang.CharSequence,int,int) -> a
    org.json.JSONObject toJSON() -> b
io.flutter.plugin.editing.TextInputPlugin -> io.flutter.plugin.editing.f:
    android.view.autofill.AutofillManager afm -> c
    boolean isInputConnectionLocked -> o
    io.flutter.plugin.editing.TextInputPlugin$InputTarget inputTarget -> e
    boolean mRestartInputPending -> i
    io.flutter.plugin.platform.PlatformViewsController platformViewsController -> k
    io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration configuration -> f
    android.view.inputmethod.InputConnection lastInputConnection -> j
    android.view.inputmethod.InputMethodManager mImm -> b
    io.flutter.embedding.engine.systemchannels.TextInputChannel textInputChannel -> d
    android.graphics.Rect lastClientRect -> l
    android.view.View mView -> a
    android.util.SparseArray autofillConfiguration -> g
    io.flutter.plugin.editing.ListenableEditingState mEditable -> h
    io.flutter.embedding.engine.systemchannels.TextInputChannel$TextEditState mLastKnownFrameworkTextEditingState -> n
    io.flutter.plugin.editing.ImeSyncDeferringInsetsCallback imeSyncCallback -> m
    void saveEditableSizeAndTransform(double,double,double[]) -> A
    void sendTextInputAppPrivateCommand(java.lang.String,android.os.Bundle) -> B
    void setPlatformViewTextInputClient(int,boolean) -> C
    void setTextInputClient(int,io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration) -> D
    void setTextInputEditingState(android.view.View,io.flutter.embedding.engine.systemchannels.TextInputChannel$TextEditState) -> E
    void showTextInput(android.view.View) -> F
    void unlockPlatformViewInputConnection() -> G
    void updateAutofillConfigurationIfNeeded(io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration) -> H
    void didChangeEditingState(boolean,boolean,boolean) -> a
    android.view.View access$000(io.flutter.plugin.editing.TextInputPlugin) -> b
    io.flutter.plugin.editing.TextInputPlugin$InputTarget access$100(io.flutter.plugin.editing.TextInputPlugin) -> c
    void access$200(io.flutter.plugin.editing.TextInputPlugin) -> d
    void access$300(io.flutter.plugin.editing.TextInputPlugin,android.view.View) -> e
    void access$400(io.flutter.plugin.editing.TextInputPlugin) -> f
    android.view.autofill.AutofillManager access$500(io.flutter.plugin.editing.TextInputPlugin) -> g
    void access$600(io.flutter.plugin.editing.TextInputPlugin,int,boolean) -> h
    void access$700(io.flutter.plugin.editing.TextInputPlugin,double,double,double[]) -> i
    void autofill(android.util.SparseArray) -> j
    boolean canShowTextInput() -> k
    void clearPlatformViewClient(int) -> l
    void clearTextInputClient() -> m
    boolean composingChanged(io.flutter.embedding.engine.systemchannels.TextInputChannel$TextEditState,io.flutter.embedding.engine.systemchannels.TextInputChannel$TextEditState) -> n
    android.view.inputmethod.InputConnection createInputConnection(android.view.View,io.flutter.embedding.android.KeyboardManager,android.view.inputmethod.EditorInfo) -> o
    void destroy() -> p
    android.view.inputmethod.InputMethodManager getInputMethodManager() -> q
    boolean handleKeyEvent(android.view.KeyEvent) -> r
    void hideTextInput(android.view.View) -> s
    int inputTypeFromTextInputType(io.flutter.embedding.engine.systemchannels.TextInputChannel$InputType,boolean,boolean,boolean,boolean,io.flutter.embedding.engine.systemchannels.TextInputChannel$TextCapitalization) -> t
    void lockPlatformViewInputConnection() -> u
    boolean needsAutofill() -> v
    void notifyValueChanged(java.lang.String) -> w
    void notifyViewEntered() -> x
    void notifyViewExited() -> y
    void onProvideAutofillVirtualStructure(android.view.ViewStructure,int) -> z
io.flutter.plugin.editing.TextInputPlugin$1 -> io.flutter.plugin.editing.f$a:
    io.flutter.plugin.editing.TextInputPlugin this$0 -> a
    void show() -> a
    void hide() -> b
    void sendAppPrivateCommand(java.lang.String,android.os.Bundle) -> c
    void clearClient() -> d
    void setPlatformViewClient(int,boolean) -> e
    void setEditableSizeAndTransform(double,double,double[]) -> f
    void requestAutofill() -> g
    void setEditingState(io.flutter.embedding.engine.systemchannels.TextInputChannel$TextEditState) -> h
    void setClient(int,io.flutter.embedding.engine.systemchannels.TextInputChannel$Configuration) -> i
    void finishAutofillContext(boolean) -> j
io.flutter.plugin.editing.TextInputPlugin$2 -> io.flutter.plugin.editing.f$b:
    double[] val$matrix -> b
    double[] val$minMax -> c
    boolean val$isAffine -> a
    io.flutter.plugin.editing.TextInputPlugin this$0 -> d
    void inspect(double,double) -> a
io.flutter.plugin.editing.TextInputPlugin$InputTarget -> io.flutter.plugin.editing.f$c:
    io.flutter.plugin.editing.TextInputPlugin$InputTarget$Type type -> a
    int id -> b
io.flutter.plugin.editing.TextInputPlugin$InputTarget$Type -> io.flutter.plugin.editing.f$c$a:
    io.flutter.plugin.editing.TextInputPlugin$InputTarget$Type FRAMEWORK_CLIENT -> R2
    io.flutter.plugin.editing.TextInputPlugin$InputTarget$Type VIRTUAL_DISPLAY_PLATFORM_VIEW -> S2
    io.flutter.plugin.editing.TextInputPlugin$InputTarget$Type NO_TARGET -> Q2
    io.flutter.plugin.editing.TextInputPlugin$InputTarget$Type PHYSICAL_DISPLAY_PLATFORM_VIEW -> T2
    io.flutter.plugin.editing.TextInputPlugin$InputTarget$Type[] $VALUES -> U2
io.flutter.plugin.editing.TextInputPlugin$MinMax -> io.flutter.plugin.editing.f$d:
    void inspect(double,double) -> a
io.flutter.plugin.localization.LocalizationPlugin -> c3.a:
    io.flutter.embedding.engine.systemchannels.LocalizationChannel$LocalizationMessageHandler localizationMessageHandler -> c
    android.content.Context context -> b
    io.flutter.embedding.engine.systemchannels.LocalizationChannel localizationChannel -> a
    android.content.Context access$000(io.flutter.plugin.localization.LocalizationPlugin) -> a
    java.util.Locale localeFromString(java.lang.String) -> b
    java.util.Locale resolveNativeLocale(java.util.List) -> c
    void sendLocalesToFlutter(android.content.res.Configuration) -> d
io.flutter.plugin.localization.LocalizationPlugin$1 -> c3.a$a:
    io.flutter.plugin.localization.LocalizationPlugin this$0 -> a
    java.lang.String getStringResource(java.lang.String,java.lang.String) -> a
io.flutter.plugin.mouse.MouseCursorPlugin -> d3.a:
    io.flutter.plugin.mouse.MouseCursorPlugin$MouseCursorViewDelegate mView -> a
    io.flutter.embedding.engine.systemchannels.MouseCursorChannel mouseCursorChannel -> b
    java.util.HashMap systemCursorConstants -> c
    android.view.PointerIcon access$000(io.flutter.plugin.mouse.MouseCursorPlugin,java.lang.String) -> a
    io.flutter.plugin.mouse.MouseCursorPlugin$MouseCursorViewDelegate access$100(io.flutter.plugin.mouse.MouseCursorPlugin) -> b
    void destroy() -> c
    android.view.PointerIcon resolveSystemCursor(java.lang.String) -> d
io.flutter.plugin.mouse.MouseCursorPlugin$1 -> d3.a$a:
    io.flutter.plugin.mouse.MouseCursorPlugin this$0 -> a
    void activateSystemCursor(java.lang.String) -> a
io.flutter.plugin.mouse.MouseCursorPlugin$2 -> d3.a$b:
    io.flutter.plugin.mouse.MouseCursorPlugin this$0 -> Q2
io.flutter.plugin.mouse.MouseCursorPlugin$MouseCursorViewDelegate -> d3.a$c:
    android.view.PointerIcon getSystemPointerIcon(int) -> c
io.flutter.plugin.platform.AccessibilityEventsDelegate -> io.flutter.plugin.platform.a:
    io.flutter.view.AccessibilityBridge accessibilityBridge -> a
    boolean onAccessibilityHoverEvent(android.view.MotionEvent,boolean) -> a
    boolean requestSendAccessibilityEvent(android.view.View,android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void setAccessibilityBridge(io.flutter.view.AccessibilityBridge) -> c
io.flutter.plugin.platform.PlatformOverlayView -> io.flutter.plugin.platform.b:
    io.flutter.plugin.platform.AccessibilityEventsDelegate accessibilityDelegate -> g
io.flutter.plugin.platform.PlatformPlugin -> io.flutter.plugin.platform.c:
    io.flutter.plugin.platform.PlatformPlugin$PlatformPluginDelegate platformPluginDelegate -> c
    io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemChromeStyle currentTheme -> d
    io.flutter.embedding.engine.systemchannels.PlatformChannel$PlatformMessageHandler mPlatformMessageHandler -> f
    int mEnabledOverlays -> e
    android.app.Activity activity -> a
    io.flutter.embedding.engine.systemchannels.PlatformChannel platformChannel -> b
    void updateSystemUiOverlays() -> A
    void vibrateHapticFeedback(io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType) -> B
    void access$000(io.flutter.plugin.platform.PlatformPlugin,io.flutter.embedding.engine.systemchannels.PlatformChannel$SoundType) -> a
    void access$100(io.flutter.plugin.platform.PlatformPlugin,int) -> b
    void access$1000(io.flutter.plugin.platform.PlatformPlugin,java.lang.String) -> c
    boolean access$1100(io.flutter.plugin.platform.PlatformPlugin) -> d
    io.flutter.embedding.engine.systemchannels.PlatformChannel access$1200(io.flutter.plugin.platform.PlatformPlugin) -> e
    void access$200(io.flutter.plugin.platform.PlatformPlugin,io.flutter.embedding.engine.systemchannels.PlatformChannel$AppSwitcherDescription) -> f
    void access$300(io.flutter.plugin.platform.PlatformPlugin,java.util.List) -> g
    void access$400(io.flutter.plugin.platform.PlatformPlugin,io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode) -> h
    void access$500(io.flutter.plugin.platform.PlatformPlugin) -> i
    void access$600(io.flutter.plugin.platform.PlatformPlugin) -> j
    void access$700(io.flutter.plugin.platform.PlatformPlugin,io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemChromeStyle) -> k
    void access$800(io.flutter.plugin.platform.PlatformPlugin) -> l
    java.lang.CharSequence access$900(io.flutter.plugin.platform.PlatformPlugin,io.flutter.embedding.engine.systemchannels.PlatformChannel$ClipboardContentFormat) -> m
    boolean clipboardHasStrings() -> n
    void destroy() -> o
    java.lang.CharSequence getClipboardData(io.flutter.embedding.engine.systemchannels.PlatformChannel$ClipboardContentFormat) -> p
    void playSystemSound(io.flutter.embedding.engine.systemchannels.PlatformChannel$SoundType) -> q
    void popSystemNavigator() -> r
    void restoreSystemChromeSystemUIOverlays() -> s
    void setClipboardData(java.lang.String) -> t
    void setSystemChromeApplicationSwitcherDescription(io.flutter.embedding.engine.systemchannels.PlatformChannel$AppSwitcherDescription) -> u
    void setSystemChromeChangeListener() -> v
    void setSystemChromeEnabledSystemUIMode(io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode) -> w
    void setSystemChromeEnabledSystemUIOverlays(java.util.List) -> x
    void setSystemChromePreferredOrientations(int) -> y
    void setSystemChromeSystemUIOverlayStyle(io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemChromeStyle) -> z
io.flutter.plugin.platform.PlatformPlugin$1 -> io.flutter.plugin.platform.c$a:
    io.flutter.plugin.platform.PlatformPlugin this$0 -> a
    void popSystemNavigator() -> b
    void setSystemUiChangeListener() -> c
    void restoreSystemUiOverlays() -> d
    void setClipboardData(java.lang.String) -> e
    void setSystemUiOverlayStyle(io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemChromeStyle) -> f
    java.lang.CharSequence getClipboardData(io.flutter.embedding.engine.systemchannels.PlatformChannel$ClipboardContentFormat) -> g
    void setPreferredOrientations(int) -> h
    void playSystemSound(io.flutter.embedding.engine.systemchannels.PlatformChannel$SoundType) -> i
    void showSystemOverlays(java.util.List) -> j
    void vibrateHapticFeedback(io.flutter.embedding.engine.systemchannels.PlatformChannel$HapticFeedbackType) -> k
    boolean clipboardHasStrings() -> l
    void setApplicationSwitcherDescription(io.flutter.embedding.engine.systemchannels.PlatformChannel$AppSwitcherDescription) -> m
    void showSystemUiMode(io.flutter.embedding.engine.systemchannels.PlatformChannel$SystemUiMode) -> n
io.flutter.plugin.platform.PlatformPlugin$2 -> io.flutter.plugin.platform.c$b:
    io.flutter.plugin.platform.PlatformPlugin this$0 -> b
    android.view.View val$decorView -> a
    void $r8$lambda$9FqC1sSWYJ_hsKn0VYLiRoem8So(io.flutter.plugin.platform.PlatformPlugin$2,int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    void lambda$onSystemUiVisibilityChange$0(int) -> b
io.flutter.plugin.platform.PlatformPlugin$2$$ExternalSyntheticLambda0 -> io.flutter.plugin.platform.d:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.platform.PlatformPlugin$2 io.flutter.plugin.platform.PlatformPlugin$2$$InternalSyntheticLambda$1$98d42420615e67cd125f78441563d4957a7e16ad96e9ebe33be10666bcded632$0.f$0 -> Q2
    int io.flutter.plugin.platform.PlatformPlugin$2$$InternalSyntheticLambda$1$98d42420615e67cd125f78441563d4957a7e16ad96e9ebe33be10666bcded632$0.f$1 -> R2
    void io.flutter.plugin.platform.PlatformPlugin$2$$InternalSyntheticLambda$1$98d42420615e67cd125f78441563d4957a7e16ad96e9ebe33be10666bcded632$0.<init>(io.flutter.plugin.platform.PlatformPlugin$2,int) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugin.platform.PlatformPlugin$2$$InternalSyntheticLambda$1$98d42420615e67cd125f78441563d4957a7e16ad96e9ebe33be10666bcded632$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.plugin.platform.PlatformPlugin$3 -> io.flutter.plugin.platform.c$c:
    int[] $SwitchMap$io$flutter$embedding$engine$systemchannels$PlatformChannel$SystemUiOverlay -> b
    int[] $SwitchMap$io$flutter$embedding$engine$systemchannels$PlatformChannel$Brightness -> c
    int[] $SwitchMap$io$flutter$embedding$engine$systemchannels$PlatformChannel$HapticFeedbackType -> a
io.flutter.plugin.platform.PlatformPlugin$PlatformPluginDelegate -> io.flutter.plugin.platform.c$d:
    boolean popSystemNavigator() -> b
io.flutter.plugin.platform.PlatformView -> io.flutter.plugin.platform.f:
    void dispose() -> a
    void onFlutterViewAttached(android.view.View) -> b
    void onFlutterViewDetached() -> c
    void onInputConnectionUnlocked() -> e
    void onInputConnectionLocked() -> f
    android.view.View getView() -> g
io.flutter.plugin.platform.PlatformView$-CC -> io.flutter.plugin.platform.e:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    void $default$onFlutterViewAttached(io.flutter.plugin.platform.PlatformView,android.view.View) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    void $default$onFlutterViewDetached(io.flutter.plugin.platform.PlatformView) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void $default$onInputConnectionLocked(io.flutter.plugin.platform.PlatformView) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    void $default$onInputConnectionUnlocked(io.flutter.plugin.platform.PlatformView) -> d
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.plugin.platform.PlatformViewFactory -> io.flutter.plugin.platform.g:
    io.flutter.plugin.common.MessageCodec createArgsCodec -> a
    io.flutter.plugin.platform.PlatformView create(android.content.Context,int,java.lang.Object) -> a
    io.flutter.plugin.common.MessageCodec getCreateArgsCodec() -> b
io.flutter.plugin.platform.PlatformViewRegistry -> io.flutter.plugin.platform.h:
    boolean registerViewFactory(java.lang.String,io.flutter.plugin.platform.PlatformViewFactory) -> a
io.flutter.plugin.platform.PlatformViewRegistryImpl -> io.flutter.plugin.platform.i:
    java.util.Map viewFactories -> a
    boolean registerViewFactory(java.lang.String,io.flutter.plugin.platform.PlatformViewFactory) -> a
    io.flutter.plugin.platform.PlatformViewFactory getFactory(java.lang.String) -> b
io.flutter.plugin.platform.PlatformViewWrapper -> io.flutter.plugin.platform.j:
    boolean shouldRecreateSurfaceForLowMemory -> m
    int bufferHeight -> f
    int top -> d
    java.util.concurrent.atomic.AtomicLong pendingFramesCount -> k
    int bufferWidth -> e
    int prevTop -> b
    android.view.ViewTreeObserver$OnGlobalFocusChangeListener activeFocusListener -> j
    int left -> c
    int prevLeft -> a
    io.flutter.view.TextureRegistry$OnTrimMemoryListener trimMemoryListener -> n
    android.graphics.SurfaceTexture tx -> g
    android.view.Surface surface -> h
    io.flutter.view.TextureRegistry$OnFrameConsumedListener frameConsumedListener -> l
    io.flutter.embedding.android.AndroidTouchProcessor touchProcessor -> i
    java.util.concurrent.atomic.AtomicLong access$000(io.flutter.plugin.platform.PlatformViewWrapper) -> a
    boolean access$102(io.flutter.plugin.platform.PlatformViewWrapper,boolean) -> b
    android.view.Surface createSurface(android.graphics.SurfaceTexture) -> c
    int getBufferHeight() -> d
    int getBufferWidth() -> e
    void onFrameProduced() -> f
    void recreateSurfaceIfNeeded() -> g
    void release() -> h
    void setBufferSize(int,int) -> i
    void setLayoutParams(android.widget.FrameLayout$LayoutParams) -> j
    void setOnDescendantFocusChangeListener(android.view.View$OnFocusChangeListener) -> k
    void setTexture(android.graphics.SurfaceTexture) -> l
    void setTouchProcessor(io.flutter.embedding.android.AndroidTouchProcessor) -> m
    boolean shouldDrawToSurfaceNow() -> n
    void unsetOnDescendantFocusChangeListener() -> o
io.flutter.plugin.platform.PlatformViewWrapper$1 -> io.flutter.plugin.platform.j$a:
    io.flutter.plugin.platform.PlatformViewWrapper this$0 -> a
    void onFrameConsumed() -> a
io.flutter.plugin.platform.PlatformViewWrapper$2 -> io.flutter.plugin.platform.j$b:
    io.flutter.plugin.platform.PlatformViewWrapper this$0 -> a
io.flutter.plugin.platform.PlatformViewWrapper$3 -> io.flutter.plugin.platform.j$c:
    io.flutter.plugin.platform.PlatformViewWrapper this$0 -> b
    android.view.View$OnFocusChangeListener val$userFocusListener -> a
io.flutter.plugin.platform.PlatformViewsAccessibilityDelegate -> io.flutter.plugin.platform.k:
    void detachAccessibilityBridge() -> a
    void attachAccessibilityBridge(io.flutter.view.AccessibilityBridge) -> b
    boolean usesVirtualDisplay(int) -> c
    android.view.View getPlatformViewById(int) -> d
io.flutter.plugin.platform.PlatformViewsController -> io.flutter.plugin.platform.q:
    java.util.HashMap contextToEmbeddedView -> j
    java.util.HashMap vdControllers -> i
    int nextOverlayLayerId -> o
    android.content.Context context -> c
    android.util.SparseArray overlayLayerViews -> m
    io.flutter.embedding.android.MotionEventTracker motionEventTracker -> t
    android.util.SparseArray viewWrappers -> n
    boolean flutterViewConvertedToImageView -> p
    io.flutter.plugin.platform.AccessibilityEventsDelegate accessibilityEventsDelegate -> h
    io.flutter.embedding.android.FlutterView flutterView -> d
    java.util.HashSet currentFrameUsedPlatformViewIds -> s
    java.util.HashSet currentFrameUsedOverlayLayerIds -> r
    io.flutter.embedding.android.AndroidTouchProcessor androidTouchProcessor -> b
    io.flutter.view.TextureRegistry textureRegistry -> e
    boolean usesSoftwareRendering -> u
    io.flutter.plugin.platform.PlatformViewRegistryImpl registry -> a
    io.flutter.plugin.editing.TextInputPlugin textInputPlugin -> f
    boolean synchronizeToNativeViewHierarchy -> q
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewsHandler channelHandler -> v
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel platformViewsChannel -> g
    android.util.SparseArray platformViews -> k
    java.lang.Class[] VIEW_TYPES_REQUIRE_VIRTUAL_DISPLAY -> w
    android.util.SparseArray platformViewParent -> l
    void access$900(io.flutter.plugin.platform.PlatformViewsController,io.flutter.plugin.platform.VirtualDisplayController) -> A
    void attach(android.content.Context,io.flutter.view.TextureRegistry,io.flutter.embedding.engine.dart.DartExecutor) -> B
    void attachTextInputPlugin(io.flutter.plugin.editing.TextInputPlugin) -> C
    void attachToFlutterRenderer(io.flutter.embedding.engine.renderer.FlutterRenderer) -> D
    void attachToView(io.flutter.embedding.android.FlutterView) -> E
    boolean checkInputConnectionProxy(android.view.View) -> F
    io.flutter.embedding.engine.FlutterOverlaySurface createOverlaySurface() -> G
    io.flutter.embedding.engine.FlutterOverlaySurface createOverlaySurface(io.flutter.plugin.platform.PlatformOverlayView) -> H
    void destroyOverlaySurfaces() -> I
    void detach() -> J
    void detachFromView() -> K
    void detachTextInputPlugin() -> L
    void diposeAllViews() -> M
    void finishFrame(boolean) -> N
    float getDisplayDensity() -> O
    io.flutter.plugin.platform.PlatformViewRegistry getRegistry() -> P
    void initializePlatformViewIfNeeded(int) -> Q
    void initializeRootImageViewIfNeeded() -> R
    void lambda$initializePlatformViewIfNeeded$0(int,android.view.View,boolean) -> S
    void lambda$onEndFrame$1() -> T
    void lockInputConnection(io.flutter.plugin.platform.VirtualDisplayController) -> U
    void onAttachedToJNI() -> V
    void onBeginFrame() -> W
    void onDetachedFromJNI() -> X
    void onDisplayOverlaySurface(int,int,int,int,int) -> Y
    void onDisplayPlatformView(int,int,int,int,int,int,int,io.flutter.embedding.engine.mutatorsstack.FlutterMutatorsStack) -> Z
    void detachAccessibilityBridge() -> a
    void onEndFrame() -> a0
    void attachAccessibilityBridge(io.flutter.view.AccessibilityBridge) -> b
    void onPreEngineRestart() -> b0
    boolean usesVirtualDisplay(int) -> c
    android.view.MotionEvent$PointerCoords parsePointerCoords(java.lang.Object,float) -> c0
    android.view.View getPlatformViewById(int) -> d
    java.util.List parsePointerCoordsList(java.lang.Object,float) -> d0
    void $r8$lambda$mrTTqqceK22Bx_mOvsp7tso--yo(io.flutter.plugin.platform.PlatformViewsController) -> e
      # {"id":"com.android.tools.r8.synthesized"}
    android.view.MotionEvent$PointerProperties parsePointerProperties(java.lang.Object) -> e0
    void $r8$lambda$w2AODWB0BzvCt5q_c3ufSP3Z0mw(io.flutter.plugin.platform.PlatformViewsController,int,android.view.View,boolean) -> f
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List parsePointerPropertiesList(java.lang.Object) -> f0
    android.util.SparseArray access$000(io.flutter.plugin.platform.PlatformViewsController) -> g
    void removeOverlaySurfaces() -> g0
    io.flutter.view.TextureRegistry access$100(io.flutter.plugin.platform.PlatformViewsController) -> h
    void setSoftwareRendering(boolean) -> h0
    int access$1000(io.flutter.plugin.platform.PlatformViewsController,double) -> i
    int toLogicalPixels(double) -> i0
    android.content.Context access$1100(io.flutter.plugin.platform.PlatformViewsController) -> j
    int toLogicalPixels(double,float) -> j0
    boolean access$1200(int) -> k
    android.view.MotionEvent toMotionEvent(float,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewTouch,boolean) -> k0
    io.flutter.plugin.platform.PlatformViewRegistryImpl access$1300(io.flutter.plugin.platform.PlatformViewsController) -> l
    int toPhysicalPixels(double) -> l0
    io.flutter.plugin.platform.AccessibilityEventsDelegate access$1400(io.flutter.plugin.platform.PlatformViewsController) -> m
    void unlockInputConnection(io.flutter.plugin.platform.VirtualDisplayController) -> m0
    io.flutter.embedding.android.AndroidTouchProcessor access$1500(io.flutter.plugin.platform.PlatformViewsController) -> n
    boolean validateDirection(int) -> n0
    boolean access$1602(io.flutter.plugin.platform.PlatformViewsController,boolean) -> o
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel access$1700(io.flutter.plugin.platform.PlatformViewsController) -> p
    io.flutter.plugin.editing.TextInputPlugin access$1800(io.flutter.plugin.platform.PlatformViewsController) -> q
    void access$1900(io.flutter.plugin.platform.PlatformViewsController,io.flutter.plugin.platform.VirtualDisplayController) -> r
    io.flutter.embedding.android.FlutterView access$200(io.flutter.plugin.platform.PlatformViewsController) -> s
    int access$2000(io.flutter.plugin.platform.PlatformViewsController,double,float) -> t
    java.lang.Class[] access$300() -> u
    boolean access$400(io.flutter.plugin.platform.PlatformViewsController) -> v
    android.util.SparseArray access$500(io.flutter.plugin.platform.PlatformViewsController) -> w
    android.util.SparseArray access$600(io.flutter.plugin.platform.PlatformViewsController) -> x
    int access$700(io.flutter.plugin.platform.PlatformViewsController,double) -> y
    float access$800(io.flutter.plugin.platform.PlatformViewsController) -> z
io.flutter.plugin.platform.PlatformViewsController$$ExternalSyntheticLambda0 -> io.flutter.plugin.platform.l:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.platform.PlatformViewsController io.flutter.plugin.platform.PlatformViewsController$$InternalSyntheticLambda$0$1c4a65e590ed9543af8abcd378c1f9022fd0386bd3af6bb03cac4e5c50409e6d$0.f$0 -> a
    int io.flutter.plugin.platform.PlatformViewsController$$InternalSyntheticLambda$0$1c4a65e590ed9543af8abcd378c1f9022fd0386bd3af6bb03cac4e5c50409e6d$0.f$1 -> b
    void io.flutter.plugin.platform.PlatformViewsController$$InternalSyntheticLambda$0$1c4a65e590ed9543af8abcd378c1f9022fd0386bd3af6bb03cac4e5c50409e6d$0.<init>(io.flutter.plugin.platform.PlatformViewsController,int) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugin.platform.PlatformViewsController$$InternalSyntheticLambda$0$1c4a65e590ed9543af8abcd378c1f9022fd0386bd3af6bb03cac4e5c50409e6d$0.onFocusChange(android.view.View,boolean) -> onFocusChange
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.plugin.platform.PlatformViewsController$$ExternalSyntheticLambda1 -> io.flutter.plugin.platform.m:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.platform.PlatformViewsController io.flutter.plugin.platform.PlatformViewsController$$InternalSyntheticLambda$0$c2433f7ec18a30d7a6689997dabdea3449704686993ef34df7a45e332a8d08e1$0.f$0 -> Q2
    void io.flutter.plugin.platform.PlatformViewsController$$InternalSyntheticLambda$0$c2433f7ec18a30d7a6689997dabdea3449704686993ef34df7a45e332a8d08e1$0.<init>(io.flutter.plugin.platform.PlatformViewsController) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugin.platform.PlatformViewsController$$InternalSyntheticLambda$0$c2433f7ec18a30d7a6689997dabdea3449704686993ef34df7a45e332a8d08e1$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.plugin.platform.PlatformViewsController$1 -> io.flutter.plugin.platform.q$a:
    io.flutter.plugin.platform.PlatformViewsController this$0 -> a
    void clearFocus(int) -> a
    void synchronizeToNativeViewHierarchy(boolean) -> b
    void resize(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewResizeRequest,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized) -> c
    void offset(int,double,double) -> d
    void setDirection(int,int) -> e
    void createForPlatformViewLayer(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest) -> f
    void dispose(int) -> g
    long createForTextureLayer(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest) -> h
    void onTouch(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewTouch) -> i
    void $r8$lambda$4i4--X33J1TxM6ttkjvFza3TFcY(io.flutter.plugin.platform.PlatformViewsController$1,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest,android.view.View,boolean) -> j
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$haWkiQYJm7Q0tLHMKIQUKgl4bDA(io.flutter.plugin.platform.PlatformViewsController$1,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest,android.view.View,boolean) -> k
      # {"id":"com.android.tools.r8.synthesized"}
    void $r8$lambda$s1Tgy9tT2SoAjsa1sAiyORJW1wI(io.flutter.plugin.platform.PlatformViewsController$1,io.flutter.plugin.platform.VirtualDisplayController,float,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized) -> l
      # {"id":"com.android.tools.r8.synthesized"}
    void configureForHybridComposition(io.flutter.plugin.platform.PlatformView,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest) -> m
    long configureForTextureLayerComposition(io.flutter.plugin.platform.PlatformView,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest) -> n
    long configureForVirtualDisplay(io.flutter.plugin.platform.PlatformView,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest) -> o
    io.flutter.plugin.platform.PlatformView createPlatformView(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest,boolean) -> p
    void ensureValidAndroidVersion(int) -> q
    void ensureValidRequest(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest) -> r
    void lambda$configureForTextureLayerComposition$2(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest,android.view.View,boolean) -> s
    void lambda$configureForVirtualDisplay$1(io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest,android.view.View,boolean) -> t
    void lambda$resize$0(io.flutter.plugin.platform.VirtualDisplayController,float,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized) -> u
io.flutter.plugin.platform.PlatformViewsController$1$$ExternalSyntheticLambda0 -> io.flutter.plugin.platform.n:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$1$55c253b2182f168b297da4a971f2a524794a90b51c4da54b398c9a453974d309$0.f$1 -> b
    io.flutter.plugin.platform.PlatformViewsController$1 io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$1$55c253b2182f168b297da4a971f2a524794a90b51c4da54b398c9a453974d309$0.f$0 -> a
    void io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$1$55c253b2182f168b297da4a971f2a524794a90b51c4da54b398c9a453974d309$0.<init>(io.flutter.plugin.platform.PlatformViewsController$1,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$1$55c253b2182f168b297da4a971f2a524794a90b51c4da54b398c9a453974d309$0.onFocusChange(android.view.View,boolean) -> onFocusChange
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.plugin.platform.PlatformViewsController$1$$ExternalSyntheticLambda1 -> io.flutter.plugin.platform.o:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$1$f1763aee42c7973f8bc7d2dee7eb75420d4fdac5c5ef06ee00fa8870f42205a1$0.f$1 -> b
    io.flutter.plugin.platform.PlatformViewsController$1 io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$1$f1763aee42c7973f8bc7d2dee7eb75420d4fdac5c5ef06ee00fa8870f42205a1$0.f$0 -> a
    void io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$1$f1763aee42c7973f8bc7d2dee7eb75420d4fdac5c5ef06ee00fa8870f42205a1$0.<init>(io.flutter.plugin.platform.PlatformViewsController$1,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewCreationRequest) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$1$f1763aee42c7973f8bc7d2dee7eb75420d4fdac5c5ef06ee00fa8870f42205a1$0.onFocusChange(android.view.View,boolean) -> onFocusChange
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.plugin.platform.PlatformViewsController$1$$ExternalSyntheticLambda2 -> io.flutter.plugin.platform.p:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.platform.VirtualDisplayController io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$2$706094a6c8b071e402a56a55e46fad00e66e930a8a18b2e4b7f26c2dba986503$0.f$1 -> R2
    io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$2$706094a6c8b071e402a56a55e46fad00e66e930a8a18b2e4b7f26c2dba986503$0.f$3 -> T2
    io.flutter.plugin.platform.PlatformViewsController$1 io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$2$706094a6c8b071e402a56a55e46fad00e66e930a8a18b2e4b7f26c2dba986503$0.f$0 -> Q2
    float io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$2$706094a6c8b071e402a56a55e46fad00e66e930a8a18b2e4b7f26c2dba986503$0.f$2 -> S2
    void io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$2$706094a6c8b071e402a56a55e46fad00e66e930a8a18b2e4b7f26c2dba986503$0.<init>(io.flutter.plugin.platform.PlatformViewsController$1,io.flutter.plugin.platform.VirtualDisplayController,float,io.flutter.embedding.engine.systemchannels.PlatformViewsChannel$PlatformViewBufferResized) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.plugin.platform.PlatformViewsController$1$$InternalSyntheticLambda$2$706094a6c8b071e402a56a55e46fad00e66e930a8a18b2e4b7f26c2dba986503$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.plugin.platform.SingleViewPresentation$AccessibilityDelegatingFrameLayout -> io.flutter.plugin.platform.SingleViewPresentation$a:
    android.view.View embeddedView -> b
    io.flutter.plugin.platform.AccessibilityEventsDelegate accessibilityEventsDelegate -> a
io.flutter.plugin.platform.SingleViewPresentation$FakeWindowViewGroup -> io.flutter.plugin.platform.SingleViewPresentation$b:
    android.graphics.Rect viewBounds -> a
    android.graphics.Rect childRect -> b
    int atMost(int) -> a
io.flutter.plugin.platform.SingleViewPresentation$ImmContext -> io.flutter.plugin.platform.SingleViewPresentation$c:
    android.view.inputmethod.InputMethodManager inputMethodManager -> a
io.flutter.plugin.platform.SingleViewPresentation$PresentationContext -> io.flutter.plugin.platform.SingleViewPresentation$d:
    android.content.Context flutterAppWindowContext -> c
    io.flutter.plugin.platform.SingleViewPresentation$WindowManagerHandler windowManagerHandler -> a
    android.view.WindowManager windowManager -> b
    android.view.WindowManager getWindowManager() -> a
    boolean isCalledFromAlertDialog() -> b
io.flutter.plugin.platform.SingleViewPresentation$PresentationState -> io.flutter.plugin.platform.SingleViewPresentation$e:
    io.flutter.plugin.platform.SingleViewPresentation$FakeWindowViewGroup fakeWindowViewGroup -> c
    io.flutter.plugin.platform.PlatformView platformView -> a
    io.flutter.plugin.platform.SingleViewPresentation$WindowManagerHandler windowManagerHandler -> b
    io.flutter.plugin.platform.PlatformView access$000(io.flutter.plugin.platform.SingleViewPresentation$PresentationState) -> a
    io.flutter.plugin.platform.PlatformView access$002(io.flutter.plugin.platform.SingleViewPresentation$PresentationState,io.flutter.plugin.platform.PlatformView) -> b
    io.flutter.plugin.platform.SingleViewPresentation$FakeWindowViewGroup access$100(io.flutter.plugin.platform.SingleViewPresentation$PresentationState) -> c
    io.flutter.plugin.platform.SingleViewPresentation$FakeWindowViewGroup access$102(io.flutter.plugin.platform.SingleViewPresentation$PresentationState,io.flutter.plugin.platform.SingleViewPresentation$FakeWindowViewGroup) -> d
    io.flutter.plugin.platform.SingleViewPresentation$WindowManagerHandler access$200(io.flutter.plugin.platform.SingleViewPresentation$PresentationState) -> e
    io.flutter.plugin.platform.SingleViewPresentation$WindowManagerHandler access$202(io.flutter.plugin.platform.SingleViewPresentation$PresentationState,io.flutter.plugin.platform.SingleViewPresentation$WindowManagerHandler) -> f
io.flutter.plugin.platform.SingleViewPresentation$WindowManagerHandler -> io.flutter.plugin.platform.SingleViewPresentation$f:
    android.view.WindowManager delegate -> a
    io.flutter.plugin.platform.SingleViewPresentation$FakeWindowViewGroup fakeWindowRootView -> b
    void addView(java.lang.Object[]) -> a
    android.view.WindowManager getWindowManager() -> b
    void removeView(java.lang.Object[]) -> c
    void removeViewImmediate(java.lang.Object[]) -> d
    void updateViewLayout(java.lang.Object[]) -> e
io.flutter.plugin.platform.VirtualDisplayController -> io.flutter.plugin.platform.r:
    io.flutter.plugin.platform.AccessibilityEventsDelegate accessibilityEventsDelegate -> c
    android.view.View$OnFocusChangeListener focusChangeListener -> f
    android.content.Context context -> b
    android.hardware.display.VirtualDisplay virtualDisplay -> h
    int bufferHeight -> j
    int bufferWidth -> i
    int densityDpi -> d
    android.view.Surface surface -> g
    io.flutter.view.TextureRegistry$SurfaceTextureEntry textureEntry -> e
    io.flutter.plugin.platform.SingleViewPresentation presentation -> a
    io.flutter.plugin.platform.VirtualDisplayController create(android.content.Context,io.flutter.plugin.platform.AccessibilityEventsDelegate,io.flutter.plugin.platform.PlatformView,io.flutter.view.TextureRegistry$SurfaceTextureEntry,int,int,int,java.lang.Object,android.view.View$OnFocusChangeListener) -> a
    void dispatchTouchEvent(android.view.MotionEvent) -> b
    int getBufferHeight() -> c
    int getBufferWidth() -> d
    android.view.View getView() -> e
    void onFlutterViewAttached(android.view.View) -> f
    void onInputConnectionLocked() -> g
    void onInputConnectionUnlocked() -> h
    void resize(int,int,java.lang.Runnable) -> i
io.flutter.plugin.platform.VirtualDisplayController$1 -> io.flutter.plugin.platform.r$a:
    java.lang.Runnable val$onNewSizeFrameAvailable -> b
    io.flutter.plugin.platform.VirtualDisplayController this$0 -> c
    android.view.View val$embeddedView -> a
io.flutter.plugin.platform.VirtualDisplayController$1$1 -> io.flutter.plugin.platform.r$a$a:
    io.flutter.plugin.platform.VirtualDisplayController$1 this$1 -> Q2
io.flutter.plugin.platform.VirtualDisplayController$OneTimeOnDrawListener -> io.flutter.plugin.platform.r$b:
    java.lang.Runnable mOnDrawRunnable -> b
    android.view.View mView -> a
    void schedule(android.view.View,java.lang.Runnable) -> a
io.flutter.plugin.platform.VirtualDisplayController$OneTimeOnDrawListener$1 -> io.flutter.plugin.platform.r$b$a:
    io.flutter.plugin.platform.VirtualDisplayController$OneTimeOnDrawListener this$0 -> Q2
io.flutter.plugins.flutter_plugin_android_lifecycle.FlutterAndroidLifecyclePlugin -> e3.a:
    void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> a
    void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> e
io.flutter.plugins.pathprovider.Messages -> f3.a:
    java.util.ArrayList wrapError(java.lang.Throwable) -> a
io.flutter.plugins.pathprovider.Messages$FlutterError -> f3.a$a:
    java.lang.Object details -> R2
    java.lang.String code -> Q2
io.flutter.plugins.pathprovider.Messages$PathProviderApi -> f3.a$b:
    java.util.List getExternalStoragePaths(io.flutter.plugins.pathprovider.Messages$StorageDirectory) -> b
    java.lang.String getTemporaryPath() -> c
    java.lang.String getApplicationDocumentsPath() -> d
    java.util.List getExternalCachePaths() -> f
    java.lang.String getExternalStoragePath() -> g
    java.lang.String getApplicationSupportPath() -> h
io.flutter.plugins.pathprovider.Messages$PathProviderApi$-CC -> f3.h:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MessageCodec getCodec() -> a
      # {"id":"com.android.tools.r8.synthesized"}
    void lambda$setup$0(io.flutter.plugins.pathprovider.Messages$PathProviderApi,java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void lambda$setup$1(io.flutter.plugins.pathprovider.Messages$PathProviderApi,java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    void lambda$setup$2(io.flutter.plugins.pathprovider.Messages$PathProviderApi,java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    void lambda$setup$3(io.flutter.plugins.pathprovider.Messages$PathProviderApi,java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> e
      # {"id":"com.android.tools.r8.synthesized"}
    void lambda$setup$4(io.flutter.plugins.pathprovider.Messages$PathProviderApi,java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> f
      # {"id":"com.android.tools.r8.synthesized"}
    void lambda$setup$5(io.flutter.plugins.pathprovider.Messages$PathProviderApi,java.lang.Object,io.flutter.plugin.common.BasicMessageChannel$Reply) -> g
      # {"id":"com.android.tools.r8.synthesized"}
    void setup(io.flutter.plugin.common.BinaryMessenger,io.flutter.plugins.pathprovider.Messages$PathProviderApi) -> h
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.plugins.pathprovider.Messages$StorageDirectory -> f3.a$c:
    io.flutter.plugins.pathprovider.Messages$StorageDirectory DCIM -> a3
    io.flutter.plugins.pathprovider.Messages$StorageDirectory DOCUMENTS -> b3
    int index -> Q2
    io.flutter.plugins.pathprovider.Messages$StorageDirectory DOWNLOADS -> Z2
    io.flutter.plugins.pathprovider.Messages$StorageDirectory PICTURES -> X2
    io.flutter.plugins.pathprovider.Messages$StorageDirectory MOVIES -> Y2
    io.flutter.plugins.pathprovider.Messages$StorageDirectory ALARMS -> V2
    io.flutter.plugins.pathprovider.Messages$StorageDirectory NOTIFICATIONS -> W2
    io.flutter.plugins.pathprovider.Messages$StorageDirectory PODCASTS -> T2
    io.flutter.plugins.pathprovider.Messages$StorageDirectory RINGTONES -> U2
    io.flutter.plugins.pathprovider.Messages$StorageDirectory[] $VALUES -> c3
    io.flutter.plugins.pathprovider.Messages$StorageDirectory ROOT -> R2
    io.flutter.plugins.pathprovider.Messages$StorageDirectory MUSIC -> S2
io.flutter.plugins.pathprovider.PathProviderPlugin -> f3.i:
    android.content.Context context -> a
    void onAttachedToEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> a
    java.util.List getExternalStoragePaths(io.flutter.plugins.pathprovider.Messages$StorageDirectory) -> b
    java.lang.String getTemporaryPath() -> c
    java.lang.String getApplicationDocumentsPath() -> d
    void onDetachedFromEngine(io.flutter.embedding.engine.plugins.FlutterPlugin$FlutterPluginBinding) -> e
    java.util.List getExternalCachePaths() -> f
    java.lang.String getExternalStoragePath() -> g
    java.lang.String getApplicationSupportPath() -> h
    java.lang.String getApplicationSupportDirectory() -> i
    java.lang.String getPathProviderApplicationDocumentsDirectory() -> j
    java.util.List getPathProviderExternalCacheDirectories() -> k
    java.util.List getPathProviderExternalStorageDirectories(io.flutter.plugins.pathprovider.Messages$StorageDirectory) -> l
    java.lang.String getPathProviderStorageDirectory() -> m
    java.lang.String getPathProviderTemporaryDirectory() -> n
    java.lang.String getStorageDirectoryString(io.flutter.plugins.pathprovider.Messages$StorageDirectory) -> o
    void setup(io.flutter.plugin.common.BinaryMessenger,android.content.Context) -> p
io.flutter.plugins.pathprovider.PathProviderPlugin$1 -> f3.i$a:
    int[] $SwitchMap$io$flutter$plugins$pathprovider$Messages$StorageDirectory -> a
io.flutter.util.HandlerCompat -> g3.a:
    android.os.Handler createAsyncHandler(android.os.Looper) -> a
io.flutter.util.PathUtils -> g3.b:
    java.lang.String getCacheDirectory(android.content.Context) -> a
    java.lang.String getDataDirPath(android.content.Context) -> b
    java.lang.String getDataDirectory(android.content.Context) -> c
    java.lang.String getFilesDir(android.content.Context) -> d
io.flutter.util.Preconditions -> g3.c:
    void checkState(boolean,java.lang.Object) -> a
io.flutter.util.Predicate -> g3.d:
io.flutter.util.TraceSection -> g3.e:
    void begin(java.lang.String) -> a
    void beginAsyncSection(java.lang.String,int) -> b
    java.lang.String cropSectionName(java.lang.String) -> c
    void end() -> d
    void endAsyncSection(java.lang.String,int) -> e
io.flutter.util.ViewUtils -> g3.h:
    boolean $r8$lambda$fCTTge_LdSPkmGXpjJUgJ-DuSuY(android.view.View) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    boolean $r8$lambda$nQ7Z42JgbeML5raZjvKJIT-9yhw(java.lang.Class[],android.view.View) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    boolean childHasFocus(android.view.View) -> c
    int generateViewId(int) -> d
    android.app.Activity getActivity(android.content.Context) -> e
    boolean hasChildViewOfType(android.view.View,java.lang.Class[]) -> f
    boolean lambda$childHasFocus$0(android.view.View) -> g
    boolean lambda$hasChildViewOfType$1(java.lang.Class[],android.view.View) -> h
    boolean traverseHierarchy(android.view.View,io.flutter.util.ViewUtils$ViewVisitor) -> i
io.flutter.util.ViewUtils$ViewVisitor -> g3.h$a:
    boolean run(android.view.View) -> a
io.flutter.view.AccessibilityBridge -> io.flutter.view.c:
    io.flutter.view.AccessibilityViewEmbedder accessibilityViewEmbedder -> d
    io.flutter.embedding.engine.systemchannels.AccessibilityChannel accessibilityChannel -> b
    int accessibilityFeatureFlags -> l
    java.util.List flutterNavigationStack -> p
    io.flutter.plugin.platform.PlatformViewsAccessibilityDelegate platformViewsAccessibilityDelegate -> e
    boolean isReleased -> u
    android.view.accessibility.AccessibilityManager$TouchExplorationStateChangeListener touchExplorationStateChangeListener -> x
    int FOCUSABLE_FLAGS -> A
    io.flutter.view.AccessibilityBridge$OnAccessibilityChangeListener onAccessibilityChangeListener -> s
    io.flutter.embedding.engine.systemchannels.AccessibilityChannel$AccessibilityMessageHandler accessibilityMessageHandler -> v
    io.flutter.view.AccessibilityBridge$SemanticsNode lastInputFocusedSemanticsNode -> n
    android.view.View rootAccessibilityView -> a
    android.view.accessibility.AccessibilityManager$AccessibilityStateChangeListener accessibilityStateChangeListener -> w
    android.view.accessibility.AccessibilityManager accessibilityManager -> c
    java.util.Map flutterSemanticsTree -> g
    int previousRouteId -> q
    java.lang.Integer lastLeftFrameInset -> r
    java.lang.Integer embeddedAccessibilityFocusedNodeId -> j
    int FIRST_RESOURCE_ID -> B
    boolean accessibleNavigation -> t
    io.flutter.view.AccessibilityBridge$SemanticsNode inputFocusedSemanticsNode -> m
    int SCROLLABLE_ACTIONS -> z
    io.flutter.view.AccessibilityBridge$SemanticsNode hoveredObject -> o
    android.database.ContentObserver animationScaleObserver -> y
    io.flutter.view.AccessibilityBridge$SemanticsNode accessibilityFocusedSemanticsNode -> i
    java.lang.Integer embeddedInputFocusedNodeId -> k
    android.content.ContentResolver contentResolver -> f
    java.util.Map customAccessibilityActions -> h
    io.flutter.view.AccessibilityBridge$SemanticsNode getOrCreateSemanticsNode(int) -> A
    io.flutter.view.AccessibilityBridge$SemanticsNode getRootSemanticsNode() -> B
    void handleTouchExploration(float,float,boolean) -> C
    boolean isAccessibilityEnabled() -> D
    boolean isTouchExplorationEnabled() -> E
    boolean lambda$shouldSetCollectionInfo$0(io.flutter.view.AccessibilityBridge$SemanticsNode,io.flutter.view.AccessibilityBridge$SemanticsNode) -> F
    boolean lambda$shouldSetCollectionInfo$1(io.flutter.view.AccessibilityBridge$SemanticsNode) -> G
    android.view.accessibility.AccessibilityEvent obtainAccessibilityEvent(int,int) -> H
    android.view.accessibility.AccessibilityNodeInfo obtainAccessibilityNodeInfo(android.view.View,int) -> I
    boolean onAccessibilityHoverEvent(android.view.MotionEvent) -> J
    boolean onAccessibilityHoverEvent(android.view.MotionEvent,boolean) -> K
    void onTouchExplorationExit() -> L
    void onWindowNameChange(io.flutter.view.AccessibilityBridge$SemanticsNode) -> M
    boolean performCursorMoveAction(io.flutter.view.AccessibilityBridge$SemanticsNode,int,android.os.Bundle,boolean) -> N
    boolean performSetText(io.flutter.view.AccessibilityBridge$SemanticsNode,int,android.os.Bundle) -> O
    void predictCursorMovement(io.flutter.view.AccessibilityBridge$SemanticsNode,int,boolean,boolean) -> P
    void release() -> Q
    void sendAccessibilityEvent(int,int) -> R
    void sendAccessibilityEvent(android.view.accessibility.AccessibilityEvent) -> S
    void sendLatestAccessibilityFlagsToFlutter() -> T
    void sendWindowContentChangeEvent(int) -> U
    void setAccessibilityPaneTitle(java.lang.String) -> V
    void setAccessibleNavigation(boolean) -> W
    void setBoldTextFlag() -> X
    void setOnAccessibilityChangeListener(io.flutter.view.AccessibilityBridge$OnAccessibilityChangeListener) -> Y
    boolean shouldSetCollectionInfo(io.flutter.view.AccessibilityBridge$SemanticsNode) -> Z
    boolean $r8$lambda$YZB7OHASiHhGuAwlsDaF5NL1-OU(io.flutter.view.AccessibilityBridge$SemanticsNode) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    void updateCustomAccessibilityActions(java.nio.ByteBuffer,java.lang.String[]) -> a0
    boolean $r8$lambda$rCW4KhEHJoU73TZTzdmyAQLb0vw(io.flutter.view.AccessibilityBridge$SemanticsNode,io.flutter.view.AccessibilityBridge$SemanticsNode) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    void updateSemantics(java.nio.ByteBuffer,java.lang.String[],java.nio.ByteBuffer[]) -> b0
    android.view.View access$100(io.flutter.view.AccessibilityBridge) -> c
    void willRemoveSemanticsNode(io.flutter.view.AccessibilityBridge$SemanticsNode) -> c0
    android.view.accessibility.AccessibilityManager access$1000(io.flutter.view.AccessibilityBridge) -> d
    android.content.ContentResolver access$1100(io.flutter.view.AccessibilityBridge) -> e
    int access$1272(io.flutter.view.AccessibilityBridge,int) -> f
    int access$1276(io.flutter.view.AccessibilityBridge,int) -> g
    void access$1300(io.flutter.view.AccessibilityBridge) -> h
    void access$1400(io.flutter.view.AccessibilityBridge) -> i
    void access$200(io.flutter.view.AccessibilityBridge,int,int) -> j
    android.view.accessibility.AccessibilityEvent access$300(io.flutter.view.AccessibilityBridge,int,int) -> k
    void access$400(io.flutter.view.AccessibilityBridge,android.view.accessibility.AccessibilityEvent) -> l
    boolean access$500(io.flutter.view.AccessibilityBridge) -> m
    io.flutter.embedding.engine.systemchannels.AccessibilityChannel$AccessibilityMessageHandler access$600(io.flutter.view.AccessibilityBridge) -> n
    io.flutter.view.AccessibilityBridge$SemanticsNode access$6900(io.flutter.view.AccessibilityBridge,int) -> o
    io.flutter.embedding.engine.systemchannels.AccessibilityChannel access$700(io.flutter.view.AccessibilityBridge) -> p
    io.flutter.view.AccessibilityBridge$CustomAccessibilityAction access$7000(io.flutter.view.AccessibilityBridge,int) -> q
    int access$7300() -> r
    int access$7400() -> s
    void access$800(io.flutter.view.AccessibilityBridge,boolean) -> t
    io.flutter.view.AccessibilityBridge$OnAccessibilityChangeListener access$900(io.flutter.view.AccessibilityBridge) -> u
    android.view.accessibility.AccessibilityEvent createTextChangedEvent(int,java.lang.String,java.lang.String) -> v
    boolean doesLayoutInDisplayCutoutModeRequireLeftInset() -> w
    boolean externalViewRequestSendAccessibilityEvent(android.view.View,android.view.View,android.view.accessibility.AccessibilityEvent) -> x
    android.graphics.Rect getBoundsInScreen(android.graphics.Rect) -> y
    io.flutter.view.AccessibilityBridge$CustomAccessibilityAction getOrCreateAccessibilityAction(int) -> z
io.flutter.view.AccessibilityBridge$$ExternalSyntheticLambda0 -> io.flutter.view.a:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.view.AccessibilityBridge$SemanticsNode io.flutter.view.AccessibilityBridge$$InternalSyntheticLambda$0$ab86a6a690ec9dc6f1378ff23b45b494234a02a0fc2e0e7fff7a6cc803388d3e$0.f$0 -> a
    void io.flutter.view.AccessibilityBridge$$InternalSyntheticLambda$0$ab86a6a690ec9dc6f1378ff23b45b494234a02a0fc2e0e7fff7a6cc803388d3e$0.<init>(io.flutter.view.AccessibilityBridge$SemanticsNode) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    boolean io.flutter.view.AccessibilityBridge$$InternalSyntheticLambda$0$ab86a6a690ec9dc6f1378ff23b45b494234a02a0fc2e0e7fff7a6cc803388d3e$0.test(java.lang.Object) -> test
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.view.AccessibilityBridge$$ExternalSyntheticLambda1 -> io.flutter.view.b:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.view.AccessibilityBridge$$InternalSyntheticLambda$0$ab86a6a690ec9dc6f1378ff23b45b494234a02a0fc2e0e7fff7a6cc803388d3e$1 io.flutter.view.AccessibilityBridge$$InternalSyntheticLambda$0$ab86a6a690ec9dc6f1378ff23b45b494234a02a0fc2e0e7fff7a6cc803388d3e$1.INSTANCE -> a
    void io.flutter.view.AccessibilityBridge$$InternalSyntheticLambda$0$ab86a6a690ec9dc6f1378ff23b45b494234a02a0fc2e0e7fff7a6cc803388d3e$1.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.view.AccessibilityBridge$$InternalSyntheticLambda$0$ab86a6a690ec9dc6f1378ff23b45b494234a02a0fc2e0e7fff7a6cc803388d3e$1.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    boolean io.flutter.view.AccessibilityBridge$$InternalSyntheticLambda$0$ab86a6a690ec9dc6f1378ff23b45b494234a02a0fc2e0e7fff7a6cc803388d3e$1.test(java.lang.Object) -> test
      # {"id":"com.android.tools.r8.synthesized"}
io.flutter.view.AccessibilityBridge$1 -> io.flutter.view.c$a:
    io.flutter.view.AccessibilityBridge this$0 -> a
    void updateSemantics(java.nio.ByteBuffer,java.lang.String[],java.nio.ByteBuffer[]) -> a
    void updateCustomAccessibilityActions(java.nio.ByteBuffer,java.lang.String[]) -> b
    void onTooltip(java.lang.String) -> c
    void onLongPress(int) -> d
    void announce(java.lang.String) -> e
    void onTap(int) -> f
io.flutter.view.AccessibilityBridge$2 -> io.flutter.view.c$b:
    io.flutter.view.AccessibilityBridge this$0 -> a
io.flutter.view.AccessibilityBridge$3 -> io.flutter.view.c$c:
    io.flutter.view.AccessibilityBridge this$0 -> a
io.flutter.view.AccessibilityBridge$4 -> io.flutter.view.c$d:
    android.view.accessibility.AccessibilityManager val$accessibilityManager -> a
    io.flutter.view.AccessibilityBridge this$0 -> b
io.flutter.view.AccessibilityBridge$5 -> io.flutter.view.c$e:
    int[] $SwitchMap$io$flutter$view$AccessibilityBridge$StringAttributeType -> a
io.flutter.view.AccessibilityBridge$AccessibilityFeature -> io.flutter.view.c$f:
    io.flutter.view.AccessibilityBridge$AccessibilityFeature[] $VALUES -> Y2
    io.flutter.view.AccessibilityBridge$AccessibilityFeature INVERT_COLORS -> S2
    io.flutter.view.AccessibilityBridge$AccessibilityFeature ACCESSIBLE_NAVIGATION -> R2
    io.flutter.view.AccessibilityBridge$AccessibilityFeature BOLD_TEXT -> U2
    io.flutter.view.AccessibilityBridge$AccessibilityFeature DISABLE_ANIMATIONS -> T2
    io.flutter.view.AccessibilityBridge$AccessibilityFeature HIGH_CONTRAST -> W2
    io.flutter.view.AccessibilityBridge$AccessibilityFeature REDUCE_MOTION -> V2
    io.flutter.view.AccessibilityBridge$AccessibilityFeature ON_OFF_SWITCH_LABELS -> X2
    int value -> Q2
io.flutter.view.AccessibilityBridge$Action -> io.flutter.view.c$g:
    io.flutter.view.AccessibilityBridge$Action DECREASE -> Y2
    io.flutter.view.AccessibilityBridge$Action INCREASE -> X2
    io.flutter.view.AccessibilityBridge$Action SHOW_ON_SCREEN -> Z2
    io.flutter.view.AccessibilityBridge$Action SCROLL_RIGHT -> U2
    io.flutter.view.AccessibilityBridge$Action SCROLL_LEFT -> T2
    io.flutter.view.AccessibilityBridge$Action SCROLL_DOWN -> W2
    io.flutter.view.AccessibilityBridge$Action[] $VALUES -> n3
    io.flutter.view.AccessibilityBridge$Action SCROLL_UP -> V2
    int value -> Q2
    io.flutter.view.AccessibilityBridge$Action LONG_PRESS -> S2
    io.flutter.view.AccessibilityBridge$Action TAP -> R2
    io.flutter.view.AccessibilityBridge$Action SET_TEXT -> m3
    io.flutter.view.AccessibilityBridge$Action DISMISS -> j3
    io.flutter.view.AccessibilityBridge$Action CUSTOM_ACTION -> i3
    io.flutter.view.AccessibilityBridge$Action MOVE_CURSOR_BACKWARD_BY_WORD -> l3
    io.flutter.view.AccessibilityBridge$Action MOVE_CURSOR_FORWARD_BY_WORD -> k3
    io.flutter.view.AccessibilityBridge$Action PASTE -> f3
    io.flutter.view.AccessibilityBridge$Action CUT -> e3
    io.flutter.view.AccessibilityBridge$Action DID_LOSE_ACCESSIBILITY_FOCUS -> h3
    io.flutter.view.AccessibilityBridge$Action DID_GAIN_ACCESSIBILITY_FOCUS -> g3
    io.flutter.view.AccessibilityBridge$Action MOVE_CURSOR_BACKWARD_BY_CHARACTER -> b3
    io.flutter.view.AccessibilityBridge$Action MOVE_CURSOR_FORWARD_BY_CHARACTER -> a3
    io.flutter.view.AccessibilityBridge$Action COPY -> d3
    io.flutter.view.AccessibilityBridge$Action SET_SELECTION -> c3
io.flutter.view.AccessibilityBridge$CustomAccessibilityAction -> io.flutter.view.c$h:
    int id -> b
    int overrideId -> c
    java.lang.String hint -> e
    int resourceId -> a
    java.lang.String label -> d
    java.lang.String access$3000(io.flutter.view.AccessibilityBridge$CustomAccessibilityAction) -> a
    java.lang.String access$3002(io.flutter.view.AccessibilityBridge$CustomAccessibilityAction,java.lang.String) -> b
    int access$3700(io.flutter.view.AccessibilityBridge$CustomAccessibilityAction) -> c
    int access$3702(io.flutter.view.AccessibilityBridge$CustomAccessibilityAction,int) -> d
    java.lang.String access$3800(io.flutter.view.AccessibilityBridge$CustomAccessibilityAction) -> e
    java.lang.String access$3802(io.flutter.view.AccessibilityBridge$CustomAccessibilityAction,java.lang.String) -> f
    int access$4500(io.flutter.view.AccessibilityBridge$CustomAccessibilityAction) -> g
    int access$4502(io.flutter.view.AccessibilityBridge$CustomAccessibilityAction,int) -> h
    int access$4700(io.flutter.view.AccessibilityBridge$CustomAccessibilityAction) -> i
    int access$4702(io.flutter.view.AccessibilityBridge$CustomAccessibilityAction,int) -> j
io.flutter.view.AccessibilityBridge$Flag -> io.flutter.view.c$i:
    int value -> Q2
    io.flutter.view.AccessibilityBridge$Flag IS_IN_MUTUALLY_EXCLUSIVE_GROUP -> Z2
    io.flutter.view.AccessibilityBridge$Flag IS_FOCUSED -> W2
    io.flutter.view.AccessibilityBridge$Flag IS_TEXT_FIELD -> V2
    io.flutter.view.AccessibilityBridge$Flag IS_ENABLED -> Y2
    io.flutter.view.AccessibilityBridge$Flag HAS_ENABLED_STATE -> X2
    io.flutter.view.AccessibilityBridge$Flag IS_CHECKED -> S2
    io.flutter.view.AccessibilityBridge$Flag HAS_CHECKED_STATE -> R2
    io.flutter.view.AccessibilityBridge$Flag IS_BUTTON -> U2
    io.flutter.view.AccessibilityBridge$Flag IS_SELECTED -> T2
    io.flutter.view.AccessibilityBridge$Flag IS_KEYBOARD_KEY -> p3
    io.flutter.view.AccessibilityBridge$Flag IS_SLIDER -> o3
    io.flutter.view.AccessibilityBridge$Flag IS_CHECK_STATE_MIXED -> q3
    io.flutter.view.AccessibilityBridge$Flag IS_READ_ONLY -> l3
    io.flutter.view.AccessibilityBridge$Flag IS_MULTILINE -> k3
    io.flutter.view.AccessibilityBridge$Flag IS_LINK -> n3
    io.flutter.view.AccessibilityBridge$Flag IS_FOCUSABLE -> m3
    io.flutter.view.AccessibilityBridge$Flag HAS_TOGGLED_STATE -> h3
    io.flutter.view.AccessibilityBridge$Flag IS_LIVE_REGION -> g3
    io.flutter.view.AccessibilityBridge$Flag HAS_IMPLICIT_SCROLLING -> j3
    io.flutter.view.AccessibilityBridge$Flag IS_TOGGLED -> i3
    io.flutter.view.AccessibilityBridge$Flag NAMES_ROUTE -> d3
    io.flutter.view.AccessibilityBridge$Flag SCOPES_ROUTE -> c3
    io.flutter.view.AccessibilityBridge$Flag IS_IMAGE -> f3
    io.flutter.view.AccessibilityBridge$Flag IS_HIDDEN -> e3
    io.flutter.view.AccessibilityBridge$Flag IS_OBSCURED -> b3
    io.flutter.view.AccessibilityBridge$Flag IS_HEADER -> a3
    io.flutter.view.AccessibilityBridge$Flag[] $VALUES -> r3
io.flutter.view.AccessibilityBridge$LocaleStringAttribute -> io.flutter.view.c$j:
    java.lang.String locale -> d
io.flutter.view.AccessibilityBridge$OnAccessibilityChangeListener -> io.flutter.view.c$k:
    void onAccessibilityChanged(boolean,boolean) -> a
io.flutter.view.AccessibilityBridge$SemanticsNode -> io.flutter.view.c$l:
    java.util.List labelAttributes -> p
    int textSelectionExtent -> h
    java.util.List increasedValueAttributes -> t
    java.util.List childrenInHitTestOrder -> S
    int actions -> d
    java.util.List hintAttributes -> x
    int previousFlags -> C
    io.flutter.view.AccessibilityBridge$SemanticsNode parent -> Q
    io.flutter.view.AccessibilityBridge$CustomAccessibilityAction onTapOverride -> U
    float right -> N
    float scrollPosition -> l
    java.util.List childrenInTraversalOrder -> R
    float previousScrollPosition -> G
    int platformViewId -> i
    java.lang.String value -> q
    int previousActions -> D
    int maxValueLength -> e
    java.lang.String decreasedValue -> u
    java.lang.String tooltip -> y
    int previousNodeId -> z
    boolean globalGeometryDirty -> Y
    float[] inverseTransform -> X
    float bottom -> O
    float[] transform -> P
    java.util.List valueAttributes -> r
    float left -> L
    int scrollChildren -> j
    java.util.List decreasedValueAttributes -> v
    float previousScrollExtentMax -> H
    java.lang.String previousLabel -> K
    int currentValueLength -> f
    int previousTextSelectionBase -> E
    int id -> b
    float scrollExtentMax -> m
    float previousScrollExtentMin -> I
    int scrollIndex -> k
    java.lang.String previousValue -> J
    java.util.List customAccessibilityActions -> T
    java.lang.String label -> o
    int previousTextSelectionExtent -> F
    int textSelectionBase -> g
    io.flutter.view.AccessibilityBridge accessibilityBridge -> a
    boolean inverseTransformDirty -> W
    java.lang.String increasedValue -> s
    int flags -> c
    java.lang.String hint -> w
    io.flutter.view.AccessibilityBridge$TextDirection textDirection -> A
    android.graphics.Rect globalRect -> a0
    float[] globalTransform -> Z
    io.flutter.view.AccessibilityBridge$CustomAccessibilityAction onLongPressOverride -> V
    boolean hadPreviousConfig -> B
    float scrollExtentMin -> n
    float top -> M
    java.lang.CharSequence access$3400(io.flutter.view.AccessibilityBridge$SemanticsNode) -> A
    boolean nullableHasAncestor(io.flutter.view.AccessibilityBridge$SemanticsNode,io.flutter.util.Predicate) -> A0
    java.lang.String access$3500(io.flutter.view.AccessibilityBridge$SemanticsNode) -> B
    void transformPoint(float[],float[],float[]) -> B0
    java.util.List access$3600(io.flutter.view.AccessibilityBridge$SemanticsNode) -> C
    void updateRecursively(float[],java.util.Set,boolean) -> C0
    java.util.List access$3900(io.flutter.view.AccessibilityBridge$SemanticsNode) -> D
    void updateWith(java.nio.ByteBuffer,java.lang.String[],java.nio.ByteBuffer[]) -> D0
    java.lang.String access$4000(io.flutter.view.AccessibilityBridge$SemanticsNode) -> E
    java.util.List access$4102(io.flutter.view.AccessibilityBridge$SemanticsNode,java.util.List) -> F
    java.util.List access$4200(io.flutter.view.AccessibilityBridge$SemanticsNode) -> G
    java.lang.String access$4300(io.flutter.view.AccessibilityBridge$SemanticsNode) -> H
    java.util.List access$4400(io.flutter.view.AccessibilityBridge$SemanticsNode) -> I
    io.flutter.view.AccessibilityBridge$SemanticsNode access$4600(io.flutter.view.AccessibilityBridge$SemanticsNode,float[],boolean) -> J
    void access$4800(io.flutter.view.AccessibilityBridge$SemanticsNode,java.nio.ByteBuffer,java.lang.String[],java.nio.ByteBuffer[]) -> K
    boolean access$4900(io.flutter.view.AccessibilityBridge$SemanticsNode) -> L
    boolean access$5002(io.flutter.view.AccessibilityBridge$SemanticsNode,boolean) -> M
    boolean access$5102(io.flutter.view.AccessibilityBridge$SemanticsNode,boolean) -> N
    void access$5200(io.flutter.view.AccessibilityBridge$SemanticsNode,float[],java.util.Set,boolean) -> O
    void access$5300(io.flutter.view.AccessibilityBridge$SemanticsNode,java.util.List) -> P
    boolean access$5400(io.flutter.view.AccessibilityBridge$SemanticsNode) -> Q
    float access$5500(io.flutter.view.AccessibilityBridge$SemanticsNode) -> R
    float access$5600(io.flutter.view.AccessibilityBridge$SemanticsNode) -> S
    float access$5700(io.flutter.view.AccessibilityBridge$SemanticsNode) -> T
    boolean access$5800(io.flutter.view.AccessibilityBridge$SemanticsNode,io.flutter.view.AccessibilityBridge$Action) -> U
    int access$5900(io.flutter.view.AccessibilityBridge$SemanticsNode) -> V
    java.util.List access$6000(io.flutter.view.AccessibilityBridge$SemanticsNode) -> W
    boolean access$6100(io.flutter.view.AccessibilityBridge$SemanticsNode) -> X
    boolean access$6200(io.flutter.view.AccessibilityBridge$SemanticsNode,io.flutter.view.AccessibilityBridge$Flag) -> Y
    java.lang.String access$6300(io.flutter.view.AccessibilityBridge$SemanticsNode) -> Z
    int access$000(io.flutter.view.AccessibilityBridge$SemanticsNode) -> a
    java.lang.String access$6400(io.flutter.view.AccessibilityBridge$SemanticsNode) -> a0
    int access$002(io.flutter.view.AccessibilityBridge$SemanticsNode,int) -> b
    int access$6500(io.flutter.view.AccessibilityBridge$SemanticsNode) -> b0
    int access$1500(io.flutter.view.AccessibilityBridge$SemanticsNode) -> c
    int access$6600(io.flutter.view.AccessibilityBridge$SemanticsNode) -> c0
    boolean access$1600(io.flutter.view.AccessibilityBridge$SemanticsNode,io.flutter.util.Predicate) -> d
    java.lang.String access$6700(io.flutter.view.AccessibilityBridge$SemanticsNode) -> d0
    int access$1700(io.flutter.view.AccessibilityBridge$SemanticsNode) -> e
    void collectRoutes(java.util.List) -> e0
    android.graphics.Rect access$1800(io.flutter.view.AccessibilityBridge$SemanticsNode) -> f
    android.text.SpannableString createSpannableString(java.lang.String,java.util.List) -> f0
    boolean access$1900(io.flutter.view.AccessibilityBridge$SemanticsNode) -> g
    boolean didChangeLabel() -> g0
    boolean access$2000(io.flutter.view.AccessibilityBridge$SemanticsNode,io.flutter.view.AccessibilityBridge$Flag) -> h
    boolean didScroll() -> h0
    int access$2100(io.flutter.view.AccessibilityBridge$SemanticsNode) -> i
    void ensureInverseTransform() -> i0
    int access$2102(io.flutter.view.AccessibilityBridge$SemanticsNode,int) -> j
    io.flutter.view.AccessibilityBridge$SemanticsNode getAncestor(io.flutter.util.Predicate) -> j0
    int access$2200(io.flutter.view.AccessibilityBridge$SemanticsNode) -> k
    android.graphics.Rect getGlobalRect() -> k0
    int access$2202(io.flutter.view.AccessibilityBridge$SemanticsNode,int) -> l
    java.lang.CharSequence getHint() -> l0
    int access$2212(io.flutter.view.AccessibilityBridge$SemanticsNode,int) -> m
    java.lang.CharSequence getLabel() -> m0
    int access$2220(io.flutter.view.AccessibilityBridge$SemanticsNode,int) -> n
    java.lang.String getRouteName() -> n0
    boolean access$2300(io.flutter.view.AccessibilityBridge$SemanticsNode,io.flutter.view.AccessibilityBridge$Action) -> o
    java.util.List getStringAttributesFromBuffer(java.nio.ByteBuffer,java.nio.ByteBuffer[]) -> o0
    int access$2400(io.flutter.view.AccessibilityBridge$SemanticsNode) -> p
    java.lang.CharSequence getTextFieldHint() -> p0
    java.lang.String access$2500(io.flutter.view.AccessibilityBridge$SemanticsNode) -> q
    java.lang.CharSequence getValue() -> q0
    java.lang.String access$2502(io.flutter.view.AccessibilityBridge$SemanticsNode,java.lang.String) -> r
    java.lang.CharSequence getValueLabelHint() -> r0
    int access$2600(io.flutter.view.AccessibilityBridge$SemanticsNode) -> s
    boolean hadAction(io.flutter.view.AccessibilityBridge$Action) -> s0
    io.flutter.view.AccessibilityBridge$SemanticsNode access$2700(io.flutter.view.AccessibilityBridge$SemanticsNode) -> t
    boolean hadFlag(io.flutter.view.AccessibilityBridge$Flag) -> t0
    io.flutter.view.AccessibilityBridge$SemanticsNode access$2702(io.flutter.view.AccessibilityBridge$SemanticsNode,io.flutter.view.AccessibilityBridge$SemanticsNode) -> u
    boolean hasAction(io.flutter.view.AccessibilityBridge$Action) -> u0
    int access$2800(io.flutter.view.AccessibilityBridge$SemanticsNode) -> v
    boolean hasFlag(io.flutter.view.AccessibilityBridge$Flag) -> v0
    io.flutter.view.AccessibilityBridge$CustomAccessibilityAction access$2900(io.flutter.view.AccessibilityBridge$SemanticsNode) -> w
    io.flutter.view.AccessibilityBridge$SemanticsNode hitTest(float[],boolean) -> w0
    io.flutter.view.AccessibilityBridge$CustomAccessibilityAction access$3100(io.flutter.view.AccessibilityBridge$SemanticsNode) -> x
    boolean isFocusable() -> x0
    java.lang.CharSequence access$3200(io.flutter.view.AccessibilityBridge$SemanticsNode) -> y
    float max(float,float,float,float) -> y0
    java.lang.CharSequence access$3300(io.flutter.view.AccessibilityBridge$SemanticsNode) -> z
    float min(float,float,float,float) -> z0
io.flutter.view.AccessibilityBridge$SpellOutStringAttribute -> io.flutter.view.c$m:
io.flutter.view.AccessibilityBridge$StringAttribute -> io.flutter.view.c$n:
    io.flutter.view.AccessibilityBridge$StringAttributeType type -> c
    int end -> b
    int start -> a
io.flutter.view.AccessibilityBridge$StringAttributeType -> io.flutter.view.c$o:
    io.flutter.view.AccessibilityBridge$StringAttributeType LOCALE -> R2
    io.flutter.view.AccessibilityBridge$StringAttributeType[] $VALUES -> S2
    io.flutter.view.AccessibilityBridge$StringAttributeType SPELLOUT -> Q2
io.flutter.view.AccessibilityBridge$TextDirection -> io.flutter.view.c$p:
    io.flutter.view.AccessibilityBridge$TextDirection[] $VALUES -> T2
    io.flutter.view.AccessibilityBridge$TextDirection UNKNOWN -> Q2
    io.flutter.view.AccessibilityBridge$TextDirection LTR -> R2
    io.flutter.view.AccessibilityBridge$TextDirection RTL -> S2
    io.flutter.view.AccessibilityBridge$TextDirection fromInt(int) -> a
io.flutter.view.AccessibilityViewEmbedder$1 -> io.flutter.view.AccessibilityViewEmbedder$a:
io.flutter.view.AccessibilityViewEmbedder$ReflectionAccessors -> io.flutter.view.AccessibilityViewEmbedder$b:
    java.lang.reflect.Method getRecordSourceNodeId -> c
    java.lang.reflect.Method getChildId -> d
    java.lang.reflect.Field childNodeIdsField -> e
    java.lang.reflect.Method longArrayGetIndex -> f
    java.lang.reflect.Method getSourceNodeId -> a
    java.lang.reflect.Method getParentNodeId -> b
    java.lang.Long access$100(io.flutter.view.AccessibilityViewEmbedder$ReflectionAccessors,android.view.accessibility.AccessibilityNodeInfo) -> a
    int access$200(long) -> b
    java.lang.Long access$300(io.flutter.view.AccessibilityViewEmbedder$ReflectionAccessors,android.view.accessibility.AccessibilityNodeInfo) -> c
    java.lang.Long access$500(io.flutter.view.AccessibilityViewEmbedder$ReflectionAccessors,android.view.accessibility.AccessibilityNodeInfo,int) -> d
    java.lang.Long access$600(io.flutter.view.AccessibilityViewEmbedder$ReflectionAccessors,android.view.accessibility.AccessibilityRecord) -> e
    java.lang.Long getChildId(android.view.accessibility.AccessibilityNodeInfo,int) -> f
    java.lang.Long getParentNodeId(android.view.accessibility.AccessibilityNodeInfo) -> g
    java.lang.Long getRecordSourceNodeId(android.view.accessibility.AccessibilityRecord) -> h
    java.lang.Long getSourceNodeId(android.view.accessibility.AccessibilityNodeInfo) -> i
    int getVirtualNodeId(long) -> j
    boolean isBitSet(long,int) -> k
    java.lang.Long yoinkParentIdFromParcel(android.view.accessibility.AccessibilityNodeInfo) -> l
io.flutter.view.AccessibilityViewEmbedder$ViewAndId -> io.flutter.view.AccessibilityViewEmbedder$c:
    android.view.View view -> a
    int id -> b
io.flutter.view.TextureRegistry -> io.flutter.view.d:
    io.flutter.view.TextureRegistry$SurfaceTextureEntry createSurfaceTexture() -> a
io.flutter.view.TextureRegistry$OnFrameConsumedListener -> io.flutter.view.d$a:
    void onFrameConsumed() -> a
io.flutter.view.TextureRegistry$OnTrimMemoryListener -> io.flutter.view.d$b:
io.flutter.view.TextureRegistry$SurfaceTextureEntry -> io.flutter.view.d$c:
    long id() -> a
    void setOnTrimMemoryListener(io.flutter.view.TextureRegistry$OnTrimMemoryListener) -> b
    void setOnFrameConsumedListener(io.flutter.view.TextureRegistry$OnFrameConsumedListener) -> c
    android.graphics.SurfaceTexture surfaceTexture() -> d
io.flutter.view.VsyncWaiter -> io.flutter.view.e:
    io.flutter.view.VsyncWaiter$DisplayListener listener -> f
    io.flutter.embedding.engine.FlutterJNI flutterJNI -> b
    io.flutter.view.VsyncWaiter instance -> e
    io.flutter.view.VsyncWaiter$FrameCallback frameCallback -> c
    long refreshPeriodNanos -> a
    io.flutter.embedding.engine.FlutterJNI$AsyncWaitForVsyncDelegate asyncWaitForVsyncDelegate -> d
    long access$000(io.flutter.view.VsyncWaiter) -> a
    long access$002(io.flutter.view.VsyncWaiter,long) -> b
    io.flutter.embedding.engine.FlutterJNI access$100(io.flutter.view.VsyncWaiter) -> c
    io.flutter.view.VsyncWaiter$FrameCallback access$200(io.flutter.view.VsyncWaiter) -> d
    io.flutter.view.VsyncWaiter$FrameCallback access$202(io.flutter.view.VsyncWaiter,io.flutter.view.VsyncWaiter$FrameCallback) -> e
    io.flutter.view.VsyncWaiter getInstance(android.hardware.display.DisplayManager,io.flutter.embedding.engine.FlutterJNI) -> f
    void init() -> g
io.flutter.view.VsyncWaiter$1 -> io.flutter.view.e$a:
    io.flutter.view.VsyncWaiter this$0 -> a
    void asyncWaitForVsync(long) -> a
    android.view.Choreographer$FrameCallback obtainFrameCallback(long) -> b
io.flutter.view.VsyncWaiter$DisplayListener -> io.flutter.view.e$b:
    android.hardware.display.DisplayManager displayManager -> a
    io.flutter.view.VsyncWaiter this$0 -> b
    void register() -> a
io.flutter.view.VsyncWaiter$FrameCallback -> io.flutter.view.e$c:
    long cookie -> a
    io.flutter.view.VsyncWaiter this$0 -> b
    long access$302(io.flutter.view.VsyncWaiter$FrameCallback,long) -> a
j.MethodCallHandlerImpl$$ExternalSyntheticLambda0 -> j.c:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MethodChannel$Result com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$7.f$0 -> a
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$7.<init>(io.flutter.plugin.common.MethodChannel$Result) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$7.onSuccess(boolean) -> a
      # {"id":"com.android.tools.r8.synthesized"}
j.MethodCallHandlerImpl$$ExternalSyntheticLambda1 -> j.d:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MethodChannel$Result com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$4.f$0 -> a
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$4.<init>(io.flutter.plugin.common.MethodChannel$Result) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$4.onError(java.lang.String,java.lang.String) -> a
      # {"id":"com.android.tools.r8.synthesized"}
j.MethodCallHandlerImpl$$ExternalSyntheticLambda2 -> j.e:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MethodChannel$Result com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$1.f$0 -> a
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$1.<init>(io.flutter.plugin.common.MethodChannel$Result) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$1.onError(java.lang.String,java.lang.String) -> a
      # {"id":"com.android.tools.r8.synthesized"}
j.MethodCallHandlerImpl$$ExternalSyntheticLambda3 -> j.f:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MethodChannel$Result com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$8.f$0 -> a
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$8.<init>(io.flutter.plugin.common.MethodChannel$Result) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$8.onError(java.lang.String,java.lang.String) -> a
      # {"id":"com.android.tools.r8.synthesized"}
j.MethodCallHandlerImpl$$ExternalSyntheticLambda4 -> j.g:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MethodChannel$Result com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$6.f$0 -> a
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$6.<init>(io.flutter.plugin.common.MethodChannel$Result) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$6.onError(java.lang.String,java.lang.String) -> a
      # {"id":"com.android.tools.r8.synthesized"}
j.MethodCallHandlerImpl$$ExternalSyntheticLambda5 -> j.h:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MethodChannel$Result com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$2.f$0 -> a
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$2.<init>(io.flutter.plugin.common.MethodChannel$Result) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$2.onSuccess(int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
j.MethodCallHandlerImpl$$ExternalSyntheticLambda6 -> j.i:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MethodChannel$Result com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$3.f$0 -> a
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$3.<init>(io.flutter.plugin.common.MethodChannel$Result) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$3.onSuccess(java.util.Map) -> a
      # {"id":"com.android.tools.r8.synthesized"}
j.MethodCallHandlerImpl$$ExternalSyntheticLambda7 -> j.j:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MethodChannel$Result com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$5.f$0 -> a
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$5.<init>(io.flutter.plugin.common.MethodChannel$Result) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$5.onSuccess(boolean) -> a
      # {"id":"com.android.tools.r8.synthesized"}
j.MethodCallHandlerImpl$$ExternalSyntheticLambda8 -> j.k:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.plugin.common.MethodChannel$Result com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$0.f$0 -> a
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$0.<init>(io.flutter.plugin.common.MethodChannel$Result) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.baseflow.permissionhandler.MethodCallHandlerImpl$$InternalSyntheticLambda$1$7449e28ed4fd7c67ffdc9c62498df061a71f950da20c040a72ac26e9fe19e1a4$0.onSuccess(int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
javax.xml.datatype.DatatypeFactory -> h3.a:
    java.lang.String DATATYPEFACTORY_IMPLEMENTATION_CLASS -> a
javax.xml.parsers.DocumentBuilder -> i3.a:
    org.w3c.dom.Document parse(org.xml.sax.InputSource) -> a
    void setEntityResolver(org.xml.sax.EntityResolver) -> b
    void setErrorHandler(org.xml.sax.ErrorHandler) -> c
javax.xml.parsers.DocumentBuilderFactory -> i3.b:
    boolean ignoreComments -> e
    boolean coalescing -> f
    boolean validating -> a
    boolean namespaceAware -> b
    boolean whitespace -> c
    boolean expandEntityRef -> d
    boolean isCoalescing() -> a
    boolean isExpandEntityReferences() -> b
    boolean isIgnoringComments() -> c
    boolean isIgnoringElementContentWhitespace() -> d
    boolean isNamespaceAware() -> e
    boolean isValidating() -> f
    javax.xml.parsers.DocumentBuilder newDocumentBuilder() -> g
    void setCoalescing(boolean) -> h
    void setExpandEntityReferences(boolean) -> i
    void setFeature(java.lang.String,boolean) -> j
    void setIgnoringComments(boolean) -> k
    void setIgnoringElementContentWhitespace(boolean) -> l
    void setNamespaceAware(boolean) -> m
    void setValidating(boolean) -> n
    void setXIncludeAware(boolean) -> o
javax.xml.parsers.ParserConfigurationException -> i3.c:
javax.xml.parsers.SAXParserFactory -> i3.d:
    boolean validating -> a
    boolean namespaceAware -> b
javax.xml.stream.XMLEventFactory -> j3.a:
javax.xml.validation.Schema -> k3.a:
javax.xml.validation.SchemaFactory -> k3.b:
k.PdfSplitterKt$getSplitPDFPathsByPageCount$2$$ExternalSyntheticLambda0 -> k.k:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageCount$2$$InternalSyntheticLambda$1$45616e1a0dc7c9d7b22b8433e223ef0d336db299fac8e79365adb437b9f61bc3$0 com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageCount$2$$InternalSyntheticLambda$1$45616e1a0dc7c9d7b22b8433e223ef0d336db299fac8e79365adb437b9f61bc3$0.INSTANCE -> a
    void com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageCount$2$$InternalSyntheticLambda$1$45616e1a0dc7c9d7b22b8433e223ef0d336db299fac8e79365adb437b9f61bc3$0.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageCount$2$$InternalSyntheticLambda$1$45616e1a0dc7c9d7b22b8433e223ef0d336db299fac8e79365adb437b9f61bc3$0.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageCount$2$$InternalSyntheticLambda$1$45616e1a0dc7c9d7b22b8433e223ef0d336db299fac8e79365adb437b9f61bc3$0.documentReady(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.PageRange) -> a
      # {"id":"com.android.tools.r8.synthesized"}
k.PdfSplitterKt$getSplitPDFPathsByPageNumbers$2$$ExternalSyntheticLambda0 -> k.l:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageNumbers$2$$InternalSyntheticLambda$1$e55c059d3ef28ebdeb65545ef55513fc62ae88d7476b4bd030bcc748f57915ca$0 com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageNumbers$2$$InternalSyntheticLambda$1$e55c059d3ef28ebdeb65545ef55513fc62ae88d7476b4bd030bcc748f57915ca$0.INSTANCE -> a
    void com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageNumbers$2$$InternalSyntheticLambda$1$e55c059d3ef28ebdeb65545ef55513fc62ae88d7476b4bd030bcc748f57915ca$0.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageNumbers$2$$InternalSyntheticLambda$1$e55c059d3ef28ebdeb65545ef55513fc62ae88d7476b4bd030bcc748f57915ca$0.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.deepanshuchaudhary.pdf_manipulator.PdfSplitterKt$getSplitPDFPathsByPageNumbers$2$$InternalSyntheticLambda$1$e55c059d3ef28ebdeb65545ef55513fc62ae88d7476b4bd030bcc748f57915ca$0.documentReady(com.itextpdf.kernel.pdf.PdfDocument,com.itextpdf.kernel.utils.PageRange) -> a
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.ExceptionsKt -> l3.a:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String stackTraceToString(java.lang.Throwable) -> b
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.ExceptionsKt__ExceptionsKt -> l3.b:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
    java.lang.String stackTraceToString(java.lang.Throwable) -> b
kotlin.Function -> l3.c:
kotlin.KotlinNothingValueException -> l3.d:
kotlin.Lazy -> l3.e:
kotlin.LazyKt -> l3.f:
    kotlin.Lazy lazy(kotlin.jvm.functions.Function0) -> a
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.LazyKt__LazyJVMKt -> l3.g:
    kotlin.Lazy lazy(kotlin.jvm.functions.Function0) -> a
kotlin.LazyKt__LazyKt -> l3.h:
kotlin.NoWhenBranchMatchedException -> l3.i:
kotlin.Pair -> l3.j:
    java.lang.Object first -> Q2
    java.lang.Object second -> R2
    java.lang.Object component1() -> a
    java.lang.Object component2() -> b
    java.lang.Object getFirst() -> c
    java.lang.Object getSecond() -> d
kotlin.Result -> l3.k:
    kotlin.Result$Companion Companion -> Q2
    java.lang.Object constructor-impl(java.lang.Object) -> a
    java.lang.Throwable exceptionOrNull-impl(java.lang.Object) -> b
    boolean isFailure-impl(java.lang.Object) -> c
    boolean isSuccess-impl(java.lang.Object) -> d
kotlin.Result$Companion -> l3.k$a:
kotlin.Result$Failure -> l3.k$b:
    java.lang.Throwable exception -> Q2
kotlin.ResultKt -> l3.l:
    java.lang.Object createFailure(java.lang.Throwable) -> a
    void throwOnFailure(java.lang.Object) -> b
kotlin.SynchronizedLazyImpl -> l3.m:
    java.lang.Object _value -> R2
    kotlin.jvm.functions.Function0 initializer -> Q2
    java.lang.Object lock -> S2
    boolean isInitialized() -> a
kotlin.TuplesKt -> l3.n:
    kotlin.Pair to(java.lang.Object,java.lang.Object) -> a
kotlin.UNINITIALIZED_VALUE -> l3.o:
    kotlin.UNINITIALIZED_VALUE INSTANCE -> a
kotlin.UninitializedPropertyAccessException -> l3.p:
kotlin.Unit -> l3.q:
    kotlin.Unit INSTANCE -> a
kotlin.collections.ArraysKt -> m3.a:
    java.util.List asList(java.lang.Object[]) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object[] copyInto$default(java.lang.Object[],java.lang.Object[],int,int,int,int,java.lang.Object) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    void fill(java.lang.Object[],java.lang.Object,int,int) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    void fill$default(java.lang.Object[],java.lang.Object,int,int,int,java.lang.Object) -> e
      # {"id":"com.android.tools.r8.synthesized"}
    char single(char[]) -> g
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object singleOrNull(java.lang.Object[]) -> h
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.collections.ArraysKt__ArraysJVMKt -> m3.b:
kotlin.collections.ArraysKt__ArraysKt -> m3.c:
kotlin.collections.ArraysKt___ArraysJvmKt -> m3.d:
    java.util.List asList(java.lang.Object[]) -> a
    java.lang.Object[] copyInto(java.lang.Object[],java.lang.Object[],int,int,int) -> b
    java.lang.Object[] copyInto$default(java.lang.Object[],java.lang.Object[],int,int,int,int,java.lang.Object) -> c
    void fill(java.lang.Object[],java.lang.Object,int,int) -> d
    void fill$default(java.lang.Object[],java.lang.Object,int,int,int,java.lang.Object) -> e
    void sortWith(java.lang.Object[],java.util.Comparator) -> f
kotlin.collections.ArraysKt___ArraysKt -> m3.e:
    char single(char[]) -> g
    java.lang.Object singleOrNull(java.lang.Object[]) -> h
kotlin.collections.ArraysUtilJVM -> m3.f:
    java.util.List asList(java.lang.Object[]) -> a
kotlin.collections.CollectionsKt -> m3.g:
    java.util.List listOf(java.lang.Object) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List emptyList() -> b
      # {"id":"com.android.tools.r8.synthesized"}
    kotlin.ranges.IntRange getIndices(java.util.Collection) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    int getLastIndex(java.util.List) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List listOf(java.lang.Object[]) -> e
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List optimizeReadOnlyList(java.util.List) -> f
      # {"id":"com.android.tools.r8.synthesized"}
    void throwIndexOverflow() -> g
      # {"id":"com.android.tools.r8.synthesized"}
    int collectionSizeOrDefault(java.lang.Iterable,int) -> h
      # {"id":"com.android.tools.r8.synthesized"}
    boolean addAll(java.util.Collection,java.lang.Iterable) -> j
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object first(java.util.List) -> k
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Appendable joinTo$default(java.lang.Iterable,java.lang.Appendable,java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence,int,java.lang.CharSequence,kotlin.jvm.functions.Function1,int,java.lang.Object) -> m
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String joinToString$default(java.lang.Iterable,java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence,int,java.lang.CharSequence,kotlin.jvm.functions.Function1,int,java.lang.Object) -> o
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Comparable minOrNull(java.lang.Iterable) -> p
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object single(java.lang.Iterable) -> q
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List sortedDescending(java.lang.Iterable) -> s
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List toList(java.lang.Iterable) -> v
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.Set toSet(java.lang.Iterable) -> y
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.collections.CollectionsKt__CollectionsJVMKt -> m3.h:
    java.util.List listOf(java.lang.Object) -> a
kotlin.collections.CollectionsKt__CollectionsKt -> m3.i:
    java.util.List emptyList() -> b
    kotlin.ranges.IntRange getIndices(java.util.Collection) -> c
    int getLastIndex(java.util.List) -> d
    java.util.List listOf(java.lang.Object[]) -> e
    java.util.List optimizeReadOnlyList(java.util.List) -> f
    void throwIndexOverflow() -> g
kotlin.collections.CollectionsKt__IterablesKt -> m3.j:
    int collectionSizeOrDefault(java.lang.Iterable,int) -> h
kotlin.collections.CollectionsKt__IteratorsJVMKt -> m3.k:
kotlin.collections.CollectionsKt__IteratorsKt -> m3.l:
kotlin.collections.CollectionsKt__MutableCollectionsJVMKt -> m3.m:
    void sortWith(java.util.List,java.util.Comparator) -> i
kotlin.collections.CollectionsKt__MutableCollectionsKt -> m3.n:
    boolean addAll(java.util.Collection,java.lang.Iterable) -> j
kotlin.collections.CollectionsKt__ReversedViewsKt -> m3.o:
kotlin.collections.CollectionsKt___CollectionsJvmKt -> m3.p:
kotlin.collections.CollectionsKt___CollectionsKt -> m3.q:
    java.lang.Object first(java.util.List) -> k
    java.lang.Appendable joinTo(java.lang.Iterable,java.lang.Appendable,java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence,int,java.lang.CharSequence,kotlin.jvm.functions.Function1) -> l
    java.lang.Appendable joinTo$default(java.lang.Iterable,java.lang.Appendable,java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence,int,java.lang.CharSequence,kotlin.jvm.functions.Function1,int,java.lang.Object) -> m
    java.lang.String joinToString(java.lang.Iterable,java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence,int,java.lang.CharSequence,kotlin.jvm.functions.Function1) -> n
    java.lang.String joinToString$default(java.lang.Iterable,java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence,int,java.lang.CharSequence,kotlin.jvm.functions.Function1,int,java.lang.Object) -> o
    java.lang.Comparable minOrNull(java.lang.Iterable) -> p
    java.lang.Object single(java.lang.Iterable) -> q
    java.lang.Object single(java.util.List) -> r
    java.util.List sortedDescending(java.lang.Iterable) -> s
    java.util.List sortedWith(java.lang.Iterable,java.util.Comparator) -> t
    java.util.Collection toCollection(java.lang.Iterable,java.util.Collection) -> u
    java.util.List toList(java.lang.Iterable) -> v
    java.util.List toMutableList(java.lang.Iterable) -> w
    java.util.List toMutableList(java.util.Collection) -> x
    java.util.Set toSet(java.lang.Iterable) -> y
kotlin.collections.EmptyIterator -> m3.r:
    kotlin.collections.EmptyIterator INSTANCE -> Q2
    java.lang.Void next() -> a
    java.lang.Void previous() -> b
kotlin.collections.EmptyList -> m3.s:
    kotlin.collections.EmptyList INSTANCE -> Q2
    boolean contains(java.lang.Void) -> a
    java.lang.Void get(int) -> b
    int getSize() -> e
    int indexOf(java.lang.Void) -> f
    int lastIndexOf(java.lang.Void) -> g
kotlin.collections.EmptyMap -> m3.t:
    kotlin.collections.EmptyMap INSTANCE -> Q2
    boolean containsValue(java.lang.Void) -> a
    java.lang.Void get(java.lang.Object) -> b
    java.util.Set getEntries() -> c
    java.util.Set getKeys() -> d
    int getSize() -> e
    java.util.Collection getValues() -> f
    java.lang.Void remove(java.lang.Object) -> g
kotlin.collections.EmptySet -> m3.u:
    kotlin.collections.EmptySet INSTANCE -> Q2
    boolean contains(java.lang.Void) -> a
    int getSize() -> b
kotlin.collections.IntIterator -> m3.v:
    int nextInt() -> a
kotlin.collections.MapsKt -> m3.w:
    int mapCapacity(int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.Map toMap(java.lang.Iterable) -> g
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.collections.MapsKt__MapWithDefaultKt -> m3.x:
kotlin.collections.MapsKt__MapsJVMKt -> m3.y:
    int mapCapacity(int) -> a
    java.util.Map mapOf(kotlin.Pair) -> b
    java.util.Map toSingletonMap(java.util.Map) -> c
kotlin.collections.MapsKt__MapsKt -> m3.z:
    java.util.Map emptyMap() -> d
    java.util.Map optimizeReadOnlyMap(java.util.Map) -> e
    void putAll(java.util.Map,java.lang.Iterable) -> f
    java.util.Map toMap(java.lang.Iterable) -> g
    java.util.Map toMap(java.lang.Iterable,java.util.Map) -> h
kotlin.collections.MapsKt___MapsJvmKt -> m3.a0:
kotlin.collections.MapsKt___MapsKt -> m3.b0:
kotlin.collections.SetsKt -> m3.c0:
    java.util.Set emptySet() -> b
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.collections.SetsKt__SetsJVMKt -> m3.d0:
    java.util.Set setOf(java.lang.Object) -> a
kotlin.collections.SetsKt__SetsKt -> m3.e0:
    java.util.Set emptySet() -> b
    java.util.Set optimizeReadOnlySet(java.util.Set) -> c
kotlin.collections.SetsKt___SetsKt -> m3.f0:
kotlin.comparisons.ComparisonsKt -> n3.a:
    java.util.Comparator reverseOrder() -> a
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.comparisons.ComparisonsKt__ComparisonsKt -> n3.b:
    java.util.Comparator reverseOrder() -> a
kotlin.comparisons.ComparisonsKt___ComparisonsJvmKt -> n3.c:
kotlin.comparisons.ComparisonsKt___ComparisonsKt -> n3.d:
kotlin.comparisons.NaturalOrderComparator -> n3.e:
    kotlin.comparisons.NaturalOrderComparator INSTANCE -> a
    int compare(java.lang.Comparable,java.lang.Comparable) -> a
kotlin.comparisons.ReverseOrderComparator -> n3.f:
    kotlin.comparisons.ReverseOrderComparator INSTANCE -> a
    int compare(java.lang.Comparable,java.lang.Comparable) -> a
kotlin.coroutines.AbstractCoroutineContextElement -> o3.a:
kotlin.coroutines.AbstractCoroutineContextKey -> o3.b:
    kotlin.coroutines.CoroutineContext$Key topmostKey -> R2
    kotlin.jvm.functions.Function1 safeCast -> Q2
    boolean isSubKey$kotlin_stdlib(kotlin.coroutines.CoroutineContext$Key) -> a
    kotlin.coroutines.CoroutineContext$Element tryCast$kotlin_stdlib(kotlin.coroutines.CoroutineContext$Element) -> b
kotlin.coroutines.CombinedContext -> o3.c:
    kotlin.coroutines.CoroutineContext$Element element -> R2
    kotlin.coroutines.CoroutineContext left -> Q2
    boolean contains(kotlin.coroutines.CoroutineContext$Element) -> e
    boolean containsAll(kotlin.coroutines.CombinedContext) -> h
    int size() -> l
kotlin.coroutines.CombinedContext$toString$1 -> o3.c$a:
    kotlin.coroutines.CombinedContext$toString$1 INSTANCE -> Q2
    java.lang.String invoke(java.lang.String,kotlin.coroutines.CoroutineContext$Element) -> a
kotlin.coroutines.Continuation -> o3.d:
kotlin.coroutines.ContinuationInterceptor -> o3.e:
    kotlin.coroutines.ContinuationInterceptor$Key Key -> T
    void releaseInterceptedContinuation(kotlin.coroutines.Continuation) -> c
    kotlin.coroutines.Continuation interceptContinuation(kotlin.coroutines.Continuation) -> k
kotlin.coroutines.ContinuationInterceptor$DefaultImpls -> o3.e$a:
    kotlin.coroutines.CoroutineContext$Element get(kotlin.coroutines.ContinuationInterceptor,kotlin.coroutines.CoroutineContext$Key) -> a
    kotlin.coroutines.CoroutineContext minusKey(kotlin.coroutines.ContinuationInterceptor,kotlin.coroutines.CoroutineContext$Key) -> b
kotlin.coroutines.ContinuationInterceptor$Key -> o3.e$b:
    kotlin.coroutines.ContinuationInterceptor$Key $$INSTANCE -> Q2
kotlin.coroutines.ContinuationKt -> o3.f:
    void startCoroutine(kotlin.jvm.functions.Function2,java.lang.Object,kotlin.coroutines.Continuation) -> a
kotlin.coroutines.CoroutineContext -> o3.g:
kotlin.coroutines.CoroutineContext$DefaultImpls -> o3.g$a:
    kotlin.coroutines.CoroutineContext plus(kotlin.coroutines.CoroutineContext,kotlin.coroutines.CoroutineContext) -> a
kotlin.coroutines.CoroutineContext$Element -> o3.g$b:
kotlin.coroutines.CoroutineContext$Element$DefaultImpls -> o3.g$b$a:
    java.lang.Object fold(kotlin.coroutines.CoroutineContext$Element,java.lang.Object,kotlin.jvm.functions.Function2) -> a
    kotlin.coroutines.CoroutineContext$Element get(kotlin.coroutines.CoroutineContext$Element,kotlin.coroutines.CoroutineContext$Key) -> b
    kotlin.coroutines.CoroutineContext minusKey(kotlin.coroutines.CoroutineContext$Element,kotlin.coroutines.CoroutineContext$Key) -> c
    kotlin.coroutines.CoroutineContext plus(kotlin.coroutines.CoroutineContext$Element,kotlin.coroutines.CoroutineContext) -> d
kotlin.coroutines.CoroutineContext$Key -> o3.g$c:
kotlin.coroutines.CoroutineContext$plus$1 -> o3.g$a$a:
    kotlin.coroutines.CoroutineContext$plus$1 INSTANCE -> Q2
    kotlin.coroutines.CoroutineContext invoke(kotlin.coroutines.CoroutineContext,kotlin.coroutines.CoroutineContext$Element) -> a
kotlin.coroutines.EmptyCoroutineContext -> o3.h:
    kotlin.coroutines.EmptyCoroutineContext INSTANCE -> Q2
kotlin.coroutines.intrinsics.CoroutineSingletons -> p3.a:
    kotlin.coroutines.intrinsics.CoroutineSingletons[] $VALUES -> T2
    kotlin.coroutines.intrinsics.CoroutineSingletons UNDECIDED -> R2
    kotlin.coroutines.intrinsics.CoroutineSingletons RESUMED -> S2
    kotlin.coroutines.intrinsics.CoroutineSingletons COROUTINE_SUSPENDED -> Q2
    kotlin.coroutines.intrinsics.CoroutineSingletons[] $values() -> a
kotlin.coroutines.intrinsics.IntrinsicsKt -> p3.b:
    kotlin.coroutines.Continuation createCoroutineUnintercepted(kotlin.jvm.functions.Function2,java.lang.Object,kotlin.coroutines.Continuation) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    kotlin.coroutines.Continuation intercepted(kotlin.coroutines.Continuation) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object getCOROUTINE_SUSPENDED() -> c
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt -> p3.c:
    kotlin.coroutines.Continuation createCoroutineUnintercepted(kotlin.jvm.functions.Function2,java.lang.Object,kotlin.coroutines.Continuation) -> a
    kotlin.coroutines.Continuation intercepted(kotlin.coroutines.Continuation) -> b
kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineUnintercepted$$inlined$createCoroutineFromSuspendFunction$IntrinsicsKt__IntrinsicsJvmKt$3 -> p3.c$a:
    kotlin.jvm.functions.Function2 $this_createCoroutineUnintercepted$inlined -> R2
    int label -> Q2
    java.lang.Object $receiver$inlined -> S2
kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineUnintercepted$$inlined$createCoroutineFromSuspendFunction$IntrinsicsKt__IntrinsicsJvmKt$4 -> p3.c$b:
    kotlin.jvm.functions.Function2 $this_createCoroutineUnintercepted$inlined -> R2
    int label -> Q2
    java.lang.Object $receiver$inlined -> S2
kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsKt -> p3.d:
    java.lang.Object getCOROUTINE_SUSPENDED() -> c
kotlin.coroutines.jvm.internal.BaseContinuationImpl -> kotlin.coroutines.jvm.internal.a:
kotlin.coroutines.jvm.internal.Boxing -> kotlin.coroutines.jvm.internal.b:
    java.lang.Boolean boxBoolean(boolean) -> a
    java.lang.Double boxDouble(double) -> b
    java.lang.Integer boxInt(int) -> c
kotlin.coroutines.jvm.internal.CompletedContinuation -> kotlin.coroutines.jvm.internal.c:
    kotlin.coroutines.jvm.internal.CompletedContinuation INSTANCE -> Q2
kotlin.coroutines.jvm.internal.ContinuationImpl -> kotlin.coroutines.jvm.internal.d:
kotlin.coroutines.jvm.internal.CoroutineStackFrame -> kotlin.coroutines.jvm.internal.e:
kotlin.coroutines.jvm.internal.DebugMetadata -> kotlin.coroutines.jvm.internal.f:
kotlin.coroutines.jvm.internal.DebugMetadataKt -> kotlin.coroutines.jvm.internal.g:
    void checkDebugMetadataVersion(int,int) -> a
    kotlin.coroutines.jvm.internal.DebugMetadata getDebugMetadataAnnotation(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> b
    int getLabel(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> c
    java.lang.StackTraceElement getStackTraceElement(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> d
kotlin.coroutines.jvm.internal.DebugProbesKt -> kotlin.coroutines.jvm.internal.h:
    kotlin.coroutines.Continuation probeCoroutineCreated(kotlin.coroutines.Continuation) -> a
    void probeCoroutineResumed(kotlin.coroutines.Continuation) -> b
    void probeCoroutineSuspended(kotlin.coroutines.Continuation) -> c
kotlin.coroutines.jvm.internal.ModuleNameRetriever -> kotlin.coroutines.jvm.internal.i:
    kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache notOnJava9 -> b
    kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache cache -> c
    kotlin.coroutines.jvm.internal.ModuleNameRetriever INSTANCE -> a
    kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache buildCache(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> a
    java.lang.String getModuleName(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> b
kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache -> kotlin.coroutines.jvm.internal.i$a:
    java.lang.reflect.Method nameMethod -> c
    java.lang.reflect.Method getModuleMethod -> a
    java.lang.reflect.Method getDescriptorMethod -> b
kotlin.coroutines.jvm.internal.RestrictedContinuationImpl -> kotlin.coroutines.jvm.internal.j:
kotlin.coroutines.jvm.internal.SuspendLambda -> kotlin.coroutines.jvm.internal.k:
kotlin.internal.PlatformImplementations -> q3.a:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
    kotlin.random.Random defaultPlatformRandom() -> b
kotlin.internal.PlatformImplementations$ReflectThrowable -> q3.a$a:
    kotlin.internal.PlatformImplementations$ReflectThrowable INSTANCE -> a
    java.lang.reflect.Method getSuppressed -> c
    java.lang.reflect.Method addSuppressed -> b
kotlin.internal.PlatformImplementationsKt -> q3.b:
    kotlin.internal.PlatformImplementations IMPLEMENTATIONS -> a
    int getJavaVersion() -> a
kotlin.internal.ProgressionUtilKt -> q3.c:
    int differenceModulo(int,int,int) -> a
    int getProgressionLastElement(int,int,int) -> b
    int mod(int,int) -> c
kotlin.internal.jdk7.JDK7PlatformImplementations -> r3.a:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
    boolean sdkIsNullOrAtLeast(int) -> c
kotlin.internal.jdk7.JDK7PlatformImplementations$ReflectSdkVersion -> r3.a$a:
    kotlin.internal.jdk7.JDK7PlatformImplementations$ReflectSdkVersion INSTANCE -> a
    java.lang.Integer sdkVersion -> b
kotlin.internal.jdk8.JDK8PlatformImplementations -> s3.a:
    kotlin.random.Random defaultPlatformRandom() -> b
    boolean sdkIsNullOrAtLeast(int) -> c
kotlin.internal.jdk8.JDK8PlatformImplementations$ReflectSdkVersion -> s3.a$a:
    kotlin.internal.jdk8.JDK8PlatformImplementations$ReflectSdkVersion INSTANCE -> a
    java.lang.Integer sdkVersion -> b
kotlin.io.ByteStreamsKt -> t3.a:
    long copyTo(java.io.InputStream,java.io.OutputStream,int) -> a
    long copyTo$default(java.io.InputStream,java.io.OutputStream,int,int,java.lang.Object) -> b
kotlin.io.CloseableKt -> t3.b:
    void closeFinally(java.io.Closeable,java.lang.Throwable) -> a
kotlin.io.ExceptionsKt -> t3.c:
    java.lang.String access$constructMessage(java.io.File,java.io.File,java.lang.String) -> a
    java.lang.String constructMessage(java.io.File,java.io.File,java.lang.String) -> b
kotlin.io.FileAlreadyExistsException -> t3.d:
kotlin.io.FileSystemException -> t3.e:
    java.io.File file -> Q2
    java.lang.String reason -> S2
    java.io.File other -> R2
kotlin.io.FilesKt -> t3.f:
    java.io.File copyTo$default(java.io.File,java.io.File,boolean,int,int,java.lang.Object) -> b
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.io.FilesKt__FilePathComponentsKt -> t3.g:
kotlin.io.FilesKt__FileReadWriteKt -> t3.h:
kotlin.io.FilesKt__FileTreeWalkKt -> t3.i:
kotlin.io.FilesKt__UtilsKt -> t3.j:
    java.io.File copyTo(java.io.File,java.io.File,boolean,int) -> a
    java.io.File copyTo$default(java.io.File,java.io.File,boolean,int,int,java.lang.Object) -> b
kotlin.io.NoSuchFileException -> t3.k:
kotlin.jvm.JvmClassMappingKt -> u3.a:
    java.lang.Class getJavaObjectType(kotlin.reflect.KClass) -> a
kotlin.jvm.KotlinReflectionNotSupportedError -> u3.b:
kotlin.jvm.functions.Function0 -> v3.a:
kotlin.jvm.functions.Function1 -> v3.l:
kotlin.jvm.functions.Function10 -> v3.b:
kotlin.jvm.functions.Function11 -> v3.c:
kotlin.jvm.functions.Function12 -> v3.d:
kotlin.jvm.functions.Function13 -> v3.e:
kotlin.jvm.functions.Function14 -> v3.f:
kotlin.jvm.functions.Function15 -> v3.g:
kotlin.jvm.functions.Function16 -> v3.h:
kotlin.jvm.functions.Function17 -> v3.i:
kotlin.jvm.functions.Function18 -> v3.j:
kotlin.jvm.functions.Function19 -> v3.k:
kotlin.jvm.functions.Function2 -> v3.p:
kotlin.jvm.functions.Function20 -> v3.m:
kotlin.jvm.functions.Function21 -> v3.n:
kotlin.jvm.functions.Function22 -> v3.o:
kotlin.jvm.functions.Function3 -> v3.q:
    java.lang.Object invoke(java.lang.Object,java.lang.Object,java.lang.Object) -> g
kotlin.jvm.functions.Function4 -> v3.r:
kotlin.jvm.functions.Function5 -> v3.s:
kotlin.jvm.functions.Function6 -> v3.t:
kotlin.jvm.functions.Function7 -> v3.u:
kotlin.jvm.functions.Function8 -> v3.v:
kotlin.jvm.functions.Function9 -> v3.w:
kotlin.jvm.internal.CallableReference -> kotlin.jvm.internal.a:
kotlin.jvm.internal.CallableReference$NoReceiver -> kotlin.jvm.internal.a$a:
    kotlin.jvm.internal.CallableReference$NoReceiver INSTANCE -> Q2
    kotlin.jvm.internal.CallableReference$NoReceiver access$000() -> a
kotlin.jvm.internal.ClassBasedDeclarationContainer -> kotlin.jvm.internal.b:
    java.lang.Class getJClass() -> b
kotlin.jvm.internal.ClassReference -> kotlin.jvm.internal.c:
    java.util.Map FUNCTION_CLASSES -> S2
    java.util.HashMap primitiveWrapperFqNames -> U2
    java.util.HashMap primitiveFqNames -> T2
    java.util.HashMap classFqNames -> V2
    kotlin.jvm.internal.ClassReference$Companion Companion -> R2
    java.lang.Class jClass -> Q2
    java.util.Map simpleNames -> W2
    java.lang.String getSimpleName() -> a
    java.lang.Class getJClass() -> b
    java.util.Map access$getSimpleNames$cp() -> c
kotlin.jvm.internal.ClassReference$Companion -> kotlin.jvm.internal.c$a:
    java.lang.String getClassSimpleName(java.lang.Class) -> a
kotlin.jvm.internal.CollectionToArray -> kotlin.jvm.internal.d:
    java.lang.Object[] EMPTY -> a
    java.lang.Object[] toArray(java.util.Collection) -> a
    java.lang.Object[] toArray(java.util.Collection,java.lang.Object[]) -> b
kotlin.jvm.internal.DefaultConstructorMarker -> kotlin.jvm.internal.e:
kotlin.jvm.internal.FunctionBase -> kotlin.jvm.internal.f:
kotlin.jvm.internal.FunctionReference -> kotlin.jvm.internal.g:
kotlin.jvm.internal.FunctionReferenceImpl -> kotlin.jvm.internal.h:
kotlin.jvm.internal.Intrinsics -> kotlin.jvm.internal.i:
    boolean areEqual(java.lang.Object,java.lang.Object) -> a
    void checkNotNull(java.lang.Object) -> b
    void checkNotNull(java.lang.Object,java.lang.String) -> c
    void checkNotNullExpressionValue(java.lang.Object,java.lang.String) -> d
    void checkNotNullParameter(java.lang.Object,java.lang.String) -> e
    int compare(int,int) -> f
    java.lang.String createParameterIsNullExceptionMessage(java.lang.String) -> g
    java.lang.Throwable sanitizeStackTrace(java.lang.Throwable) -> h
    java.lang.Throwable sanitizeStackTrace(java.lang.Throwable,java.lang.String) -> i
    java.lang.String stringPlus(java.lang.String,java.lang.Object) -> j
    void throwJavaNpe() -> k
    void throwJavaNpe(java.lang.String) -> l
    void throwParameterIsNullNPE(java.lang.String) -> m
    void throwUninitializedProperty(java.lang.String) -> n
    void throwUninitializedPropertyAccessException(java.lang.String) -> o
kotlin.jvm.internal.Lambda -> kotlin.jvm.internal.j:
kotlin.jvm.internal.PackageReference -> kotlin.jvm.internal.k:
    java.lang.String moduleName -> R2
    java.lang.Class jClass -> Q2
    java.lang.Class getJClass() -> b
kotlin.jvm.internal.Ref$BooleanRef -> kotlin.jvm.internal.l:
    boolean element -> Q2
kotlin.jvm.internal.Ref$ObjectRef -> kotlin.jvm.internal.m:
    java.lang.Object element -> Q2
kotlin.jvm.internal.Reflection -> kotlin.jvm.internal.n:
    kotlin.reflect.KClass[] EMPTY_K_CLASS_ARRAY -> b
    kotlin.jvm.internal.ReflectionFactory factory -> a
    kotlin.reflect.KFunction function(kotlin.jvm.internal.FunctionReference) -> a
    kotlin.reflect.KClass getOrCreateKotlinClass(java.lang.Class) -> b
    kotlin.reflect.KDeclarationContainer getOrCreateKotlinPackage(java.lang.Class) -> c
    java.lang.String renderLambdaToString(kotlin.jvm.internal.FunctionBase) -> d
    java.lang.String renderLambdaToString(kotlin.jvm.internal.Lambda) -> e
kotlin.jvm.internal.ReflectionFactory -> kotlin.jvm.internal.o:
    kotlin.reflect.KFunction function(kotlin.jvm.internal.FunctionReference) -> a
    kotlin.reflect.KClass getOrCreateKotlinClass(java.lang.Class) -> b
    kotlin.reflect.KDeclarationContainer getOrCreateKotlinPackage(java.lang.Class,java.lang.String) -> c
    java.lang.String renderLambdaToString(kotlin.jvm.internal.FunctionBase) -> d
    java.lang.String renderLambdaToString(kotlin.jvm.internal.Lambda) -> e
kotlin.jvm.internal.TypeIntrinsics -> kotlin.jvm.internal.p:
    java.lang.Object beforeCheckcastToFunctionOfArity(java.lang.Object,int) -> a
    int getFunctionArity(java.lang.Object) -> b
    boolean isFunctionOfArity(java.lang.Object,int) -> c
    java.lang.Throwable sanitizeStackTrace(java.lang.Throwable) -> d
    java.lang.ClassCastException throwCce(java.lang.ClassCastException) -> e
    void throwCce(java.lang.Object,java.lang.String) -> f
    void throwCce(java.lang.String) -> g
kotlin.random.AbstractPlatformRandom -> w3.a:
    int nextInt() -> b
    java.util.Random getImpl() -> c
kotlin.random.FallbackThreadLocalRandom -> w3.b:
    kotlin.random.FallbackThreadLocalRandom$implStorage$1 implStorage -> S2
    java.util.Random getImpl() -> c
kotlin.random.FallbackThreadLocalRandom$implStorage$1 -> w3.b$a:
    java.util.Random initialValue() -> a
kotlin.random.Random -> w3.c:
    kotlin.random.Random defaultRandom -> R2
    kotlin.random.Random$Default Default -> Q2
    kotlin.random.Random access$getDefaultRandom$cp() -> a
    int nextInt() -> b
kotlin.random.Random$Default -> w3.c$a:
    int nextInt() -> b
kotlin.random.jdk8.PlatformThreadLocalRandom -> x3.a:
    java.util.Random getImpl() -> c
kotlin.ranges.IntProgression -> y3.a:
    int step -> S2
    int first -> Q2
    int last -> R2
    kotlin.ranges.IntProgression$Companion Companion -> T2
    int getFirst() -> a
    int getLast() -> b
    int getStep() -> e
    kotlin.collections.IntIterator iterator() -> f
kotlin.ranges.IntProgression$Companion -> y3.a$a:
    kotlin.ranges.IntProgression fromClosedRange(int,int,int) -> a
kotlin.ranges.IntProgressionIterator -> y3.b:
    int next -> T2
    boolean hasNext -> S2
    int step -> Q2
    int finalElement -> R2
    int nextInt() -> a
kotlin.ranges.IntRange -> y3.c:
    kotlin.ranges.IntRange EMPTY -> V2
    kotlin.ranges.IntRange$Companion Companion -> U2
    kotlin.ranges.IntRange access$getEMPTY$cp() -> g
    boolean contains(int) -> h
    java.lang.Integer getEndInclusive() -> i
    java.lang.Integer getStart() -> j
kotlin.ranges.IntRange$Companion -> y3.c$a:
    kotlin.ranges.IntRange getEMPTY() -> a
kotlin.ranges.RangesKt -> y3.d:
    int coerceAtLeast(int,int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    long coerceAtLeast(long,long) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    int coerceAtMost(int,int) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    long coerceAtMost(long,long) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    int coerceIn(int,int,int) -> e
      # {"id":"com.android.tools.r8.synthesized"}
    kotlin.ranges.IntProgression downTo(int,int) -> f
      # {"id":"com.android.tools.r8.synthesized"}
    kotlin.ranges.IntRange until(int,int) -> g
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.ranges.RangesKt__RangesKt -> y3.e:
kotlin.ranges.RangesKt___RangesKt -> y3.f:
    int coerceAtLeast(int,int) -> a
    long coerceAtLeast(long,long) -> b
    int coerceAtMost(int,int) -> c
    long coerceAtMost(long,long) -> d
    int coerceIn(int,int,int) -> e
    kotlin.ranges.IntProgression downTo(int,int) -> f
    kotlin.ranges.IntRange until(int,int) -> g
kotlin.reflect.KAnnotatedElement -> z3.a:
kotlin.reflect.KCallable -> z3.b:
kotlin.reflect.KClass -> z3.c:
    java.lang.String getSimpleName() -> a
kotlin.reflect.KDeclarationContainer -> z3.d:
kotlin.reflect.KFunction -> z3.e:
kotlin.reflect.KType -> z3.f:
kotlin.reflect.KVisibility -> z3.g:
    kotlin.reflect.KVisibility INTERNAL -> S2
    kotlin.reflect.KVisibility PRIVATE -> T2
    kotlin.reflect.KVisibility PUBLIC -> Q2
    kotlin.reflect.KVisibility PROTECTED -> R2
    kotlin.reflect.KVisibility[] $VALUES -> U2
    kotlin.reflect.KVisibility[] $values() -> a
kotlin.sequences.ConstrainedOnceSequence -> a4.a:
    java.util.concurrent.atomic.AtomicReference sequenceRef -> a
kotlin.sequences.Sequence -> a4.b:
kotlin.sequences.SequencesKt -> a4.c:
    kotlin.sequences.Sequence asSequence(java.util.Iterator) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    kotlin.sequences.Sequence map(kotlin.sequences.Sequence,kotlin.jvm.functions.Function1) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List toList(kotlin.sequences.Sequence) -> e
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.sequences.SequencesKt__SequenceBuilderKt -> a4.d:
kotlin.sequences.SequencesKt__SequencesJVMKt -> a4.e:
kotlin.sequences.SequencesKt__SequencesKt -> a4.f:
    kotlin.sequences.Sequence asSequence(java.util.Iterator) -> a
    kotlin.sequences.Sequence constrainOnce(kotlin.sequences.Sequence) -> b
kotlin.sequences.SequencesKt__SequencesKt$asSequence$$inlined$Sequence$1 -> a4.f$a:
    java.util.Iterator $this_asSequence$inlined -> a
kotlin.sequences.SequencesKt___SequencesJvmKt -> a4.g:
kotlin.sequences.SequencesKt___SequencesKt -> a4.h:
    kotlin.sequences.Sequence map(kotlin.sequences.Sequence,kotlin.jvm.functions.Function1) -> c
    java.util.Collection toCollection(kotlin.sequences.Sequence,java.util.Collection) -> d
    java.util.List toList(kotlin.sequences.Sequence) -> e
    java.util.List toMutableList(kotlin.sequences.Sequence) -> f
kotlin.sequences.TransformingSequence -> a4.i:
    kotlin.sequences.Sequence sequence -> a
    kotlin.jvm.functions.Function1 transformer -> b
    kotlin.sequences.Sequence access$getSequence$p(kotlin.sequences.TransformingSequence) -> a
    kotlin.jvm.functions.Function1 access$getTransformer$p(kotlin.sequences.TransformingSequence) -> b
kotlin.sequences.TransformingSequence$iterator$1 -> a4.i$a:
    java.util.Iterator iterator -> Q2
    kotlin.sequences.TransformingSequence this$0 -> R2
kotlin.text.CharsKt__CharJVMKt -> b4.a:
    int checkRadix(int) -> a
    int digitOf(char,int) -> b
    boolean isWhitespace(char) -> c
kotlin.text.CharsKt__CharKt -> b4.b:
    boolean equals(char,char,boolean) -> d
kotlin.text.Charsets -> b4.c:
    java.nio.charset.Charset UTF_16BE -> d
    java.nio.charset.Charset UTF_16 -> c
    java.nio.charset.Charset UTF_8 -> b
    java.nio.charset.Charset ISO_8859_1 -> g
    kotlin.text.Charsets INSTANCE -> a
    java.nio.charset.Charset US_ASCII -> f
    java.nio.charset.Charset UTF_16LE -> e
kotlin.text.DelimitedRangesSequence -> b4.d:
    java.lang.CharSequence input -> a
    int startIndex -> b
    int limit -> c
    kotlin.jvm.functions.Function2 getNextMatch -> d
    kotlin.jvm.functions.Function2 access$getGetNextMatch$p(kotlin.text.DelimitedRangesSequence) -> a
    java.lang.CharSequence access$getInput$p(kotlin.text.DelimitedRangesSequence) -> b
    int access$getLimit$p(kotlin.text.DelimitedRangesSequence) -> c
    int access$getStartIndex$p(kotlin.text.DelimitedRangesSequence) -> d
kotlin.text.DelimitedRangesSequence$iterator$1 -> b4.d$a:
    int counter -> U2
    int nextSearchIndex -> S2
    kotlin.ranges.IntRange nextItem -> T2
    int nextState -> Q2
    int currentStartIndex -> R2
    kotlin.text.DelimitedRangesSequence this$0 -> V2
    void calcNext() -> a
    kotlin.ranges.IntRange next() -> b
kotlin.text.Regex -> b4.e:
    kotlin.text.Regex$Companion Companion -> R2
    java.util.regex.Pattern nativePattern -> Q2
    java.lang.String replace(java.lang.CharSequence,java.lang.String) -> a
kotlin.text.Regex$Companion -> b4.e$a:
kotlin.text.StringsKt -> b4.f:
    int indexOf$default(java.lang.CharSequence,java.lang.String,int,boolean,int,java.lang.Object) -> A
      # {"id":"com.android.tools.r8.synthesized"}
    int lastIndexOf$default(java.lang.CharSequence,java.lang.String,int,boolean,int,java.lang.Object) -> F
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringAfter$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> S
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringAfter$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> T
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringAfterLast(java.lang.String,char,java.lang.String) -> U
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringAfterLast$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> V
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringBefore$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> Y
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringBefore$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> Z
      # {"id":"com.android.tools.r8.synthesized"}
    void appendElement(java.lang.Appendable,java.lang.Object,kotlin.jvm.functions.Function1) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.CharSequence trim(java.lang.CharSequence) -> a0
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String trimIndent(java.lang.String) -> e
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Integer toIntOrNull(java.lang.String) -> f
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Long toLongOrNull(java.lang.String) -> h
      # {"id":"com.android.tools.r8.synthesized"}
    boolean endsWith$default(java.lang.String,java.lang.String,boolean,int,java.lang.Object) -> k
      # {"id":"com.android.tools.r8.synthesized"}
    boolean isBlank(java.lang.CharSequence) -> l
      # {"id":"com.android.tools.r8.synthesized"}
    boolean startsWith$default(java.lang.String,java.lang.String,boolean,int,java.lang.Object) -> o
      # {"id":"com.android.tools.r8.synthesized"}
    boolean contains$default(java.lang.CharSequence,java.lang.CharSequence,boolean,int,java.lang.Object) -> r
      # {"id":"com.android.tools.r8.synthesized"}
    int indexOf$default(java.lang.CharSequence,char,int,boolean,int,java.lang.Object) -> z
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.text.StringsKt__AppendableKt -> b4.g:
    void appendElement(java.lang.Appendable,java.lang.Object,kotlin.jvm.functions.Function1) -> a
kotlin.text.StringsKt__IndentKt -> b4.h:
    kotlin.jvm.functions.Function1 getIndentFunction$StringsKt__IndentKt(java.lang.String) -> b
    int indentWidth$StringsKt__IndentKt(java.lang.String) -> c
    java.lang.String replaceIndent(java.lang.String,java.lang.String) -> d
    java.lang.String trimIndent(java.lang.String) -> e
kotlin.text.StringsKt__IndentKt$getIndentFunction$1 -> b4.h$a:
    kotlin.text.StringsKt__IndentKt$getIndentFunction$1 INSTANCE -> Q2
    java.lang.String invoke(java.lang.String) -> a
kotlin.text.StringsKt__IndentKt$getIndentFunction$2 -> b4.h$b:
    java.lang.String $indent -> Q2
    java.lang.String invoke(java.lang.String) -> a
kotlin.text.StringsKt__RegexExtensionsJVMKt -> b4.i:
kotlin.text.StringsKt__RegexExtensionsKt -> b4.j:
kotlin.text.StringsKt__StringBuilderJVMKt -> b4.k:
kotlin.text.StringsKt__StringBuilderKt -> b4.l:
kotlin.text.StringsKt__StringNumberConversionsJVMKt -> b4.m:
kotlin.text.StringsKt__StringNumberConversionsKt -> b4.n:
    java.lang.Integer toIntOrNull(java.lang.String) -> f
    java.lang.Integer toIntOrNull(java.lang.String,int) -> g
    java.lang.Long toLongOrNull(java.lang.String) -> h
    java.lang.Long toLongOrNull(java.lang.String,int) -> i
kotlin.text.StringsKt__StringsJVMKt -> b4.o:
    boolean endsWith(java.lang.String,java.lang.String,boolean) -> j
    boolean endsWith$default(java.lang.String,java.lang.String,boolean,int,java.lang.Object) -> k
    boolean isBlank(java.lang.CharSequence) -> l
    boolean regionMatches(java.lang.String,int,java.lang.String,int,int,boolean) -> m
    boolean startsWith(java.lang.String,java.lang.String,boolean) -> n
    boolean startsWith$default(java.lang.String,java.lang.String,boolean,int,java.lang.Object) -> o
kotlin.text.StringsKt__StringsKt -> b4.p:
    int indexOf$default(java.lang.CharSequence,java.lang.String,int,boolean,int,java.lang.Object) -> A
    int indexOfAny(java.lang.CharSequence,char[],int,boolean) -> B
    int lastIndexOf(java.lang.CharSequence,char,int,boolean) -> C
    int lastIndexOf(java.lang.CharSequence,java.lang.String,int,boolean) -> D
    int lastIndexOf$default(java.lang.CharSequence,char,int,boolean,int,java.lang.Object) -> E
    int lastIndexOf$default(java.lang.CharSequence,java.lang.String,int,boolean,int,java.lang.Object) -> F
    int lastIndexOfAny(java.lang.CharSequence,char[],int,boolean) -> G
    kotlin.sequences.Sequence lineSequence(java.lang.CharSequence) -> H
    java.util.List lines(java.lang.CharSequence) -> I
    kotlin.sequences.Sequence rangesDelimitedBy$StringsKt__StringsKt(java.lang.CharSequence,java.lang.String[],int,boolean,int) -> J
    kotlin.sequences.Sequence rangesDelimitedBy$StringsKt__StringsKt$default(java.lang.CharSequence,java.lang.String[],int,boolean,int,int,java.lang.Object) -> K
    boolean regionMatchesImpl(java.lang.CharSequence,int,java.lang.CharSequence,int,int,boolean) -> L
    void requireNonNegativeLimit(int) -> M
    kotlin.sequences.Sequence splitToSequence(java.lang.CharSequence,java.lang.String[],boolean,int) -> N
    kotlin.sequences.Sequence splitToSequence$default(java.lang.CharSequence,java.lang.String[],boolean,int,int,java.lang.Object) -> O
    java.lang.String substring(java.lang.CharSequence,kotlin.ranges.IntRange) -> P
    java.lang.String substringAfter(java.lang.String,char,java.lang.String) -> Q
    java.lang.String substringAfter(java.lang.String,java.lang.String,java.lang.String) -> R
    java.lang.String substringAfter$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> S
    java.lang.String substringAfter$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> T
    java.lang.String substringAfterLast(java.lang.String,char,java.lang.String) -> U
    java.lang.String substringAfterLast$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> V
    java.lang.String substringBefore(java.lang.String,char,java.lang.String) -> W
    java.lang.String substringBefore(java.lang.String,java.lang.String,java.lang.String) -> X
    java.lang.String substringBefore$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> Y
    java.lang.String substringBefore$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> Z
    java.lang.CharSequence trim(java.lang.CharSequence) -> a0
    kotlin.Pair access$findAnyOf(java.lang.CharSequence,java.util.Collection,int,boolean,boolean) -> p
    boolean contains(java.lang.CharSequence,java.lang.CharSequence,boolean) -> q
    boolean contains$default(java.lang.CharSequence,java.lang.CharSequence,boolean,int,java.lang.Object) -> r
    kotlin.Pair findAnyOf$StringsKt__StringsKt(java.lang.CharSequence,java.util.Collection,int,boolean,boolean) -> s
    kotlin.ranges.IntRange getIndices(java.lang.CharSequence) -> t
    int getLastIndex(java.lang.CharSequence) -> u
    int indexOf(java.lang.CharSequence,char,int,boolean) -> v
    int indexOf(java.lang.CharSequence,java.lang.String,int,boolean) -> w
    int indexOf$StringsKt__StringsKt(java.lang.CharSequence,java.lang.CharSequence,int,int,boolean,boolean) -> x
    int indexOf$StringsKt__StringsKt$default(java.lang.CharSequence,java.lang.CharSequence,int,int,boolean,boolean,int,java.lang.Object) -> y
    int indexOf$default(java.lang.CharSequence,char,int,boolean,int,java.lang.Object) -> z
kotlin.text.StringsKt__StringsKt$rangesDelimitedBy$2 -> b4.p$a:
    java.util.List $delimitersList -> Q2
    boolean $ignoreCase -> R2
    kotlin.Pair invoke(java.lang.CharSequence,int) -> a
kotlin.text.StringsKt__StringsKt$splitToSequence$1 -> b4.p$b:
    java.lang.CharSequence $this_splitToSequence -> Q2
    java.lang.String invoke(kotlin.ranges.IntRange) -> a
kotlin.text.StringsKt___StringsJvmKt -> b4.q:
kotlin.text.StringsKt___StringsKt -> b4.r:
    java.lang.String drop(java.lang.String,int) -> b0
kotlinx.coroutines.AbstractCoroutine -> c4.a:
    kotlin.coroutines.CoroutineContext context -> R2
    java.lang.String cancellationExceptionMessage() -> C
    void handleOnCompletionException$kotlinx_coroutines_core(java.lang.Throwable) -> R
    java.lang.String nameString$kotlinx_coroutines_core() -> Y
    boolean isActive() -> b
    void onCompletionInternal(java.lang.Object) -> d0
    kotlin.coroutines.CoroutineContext getCoroutineContext() -> p
    void afterResume(java.lang.Object) -> t0
    void onCancelled(java.lang.Throwable,boolean) -> u0
    void onCompleted(java.lang.Object) -> v0
    void start(kotlinx.coroutines.CoroutineStart,java.lang.Object,kotlin.jvm.functions.Function2) -> w0
kotlinx.coroutines.AbstractTimeSource -> c4.b:
kotlinx.coroutines.AbstractTimeSourceKt -> c4.c:
    kotlinx.coroutines.AbstractTimeSource getTimeSource() -> a
kotlinx.coroutines.Active -> c4.d:
    kotlinx.coroutines.Active INSTANCE -> Q2
kotlinx.coroutines.BeforeResumeCancelHandler -> c4.e:
kotlinx.coroutines.BlockingEventLoop -> c4.f:
    java.lang.Thread thread -> W2
    java.lang.Thread getThread() -> B
kotlinx.coroutines.BuildersKt -> c4.g:
    kotlinx.coroutines.Job launch(kotlinx.coroutines.CoroutineScope,kotlin.coroutines.CoroutineContext,kotlinx.coroutines.CoroutineStart,kotlin.jvm.functions.Function2) -> a
    kotlinx.coroutines.Job launch$default(kotlinx.coroutines.CoroutineScope,kotlin.coroutines.CoroutineContext,kotlinx.coroutines.CoroutineStart,kotlin.jvm.functions.Function2,int,java.lang.Object) -> b
    java.lang.Object withContext(kotlin.coroutines.CoroutineContext,kotlin.jvm.functions.Function2,kotlin.coroutines.Continuation) -> c
kotlinx.coroutines.BuildersKt__Builders_commonKt -> c4.h:
    kotlinx.coroutines.Job launch(kotlinx.coroutines.CoroutineScope,kotlin.coroutines.CoroutineContext,kotlinx.coroutines.CoroutineStart,kotlin.jvm.functions.Function2) -> a
    kotlinx.coroutines.Job launch$default(kotlinx.coroutines.CoroutineScope,kotlin.coroutines.CoroutineContext,kotlinx.coroutines.CoroutineStart,kotlin.jvm.functions.Function2,int,java.lang.Object) -> b
    java.lang.Object withContext(kotlin.coroutines.CoroutineContext,kotlin.jvm.functions.Function2,kotlin.coroutines.Continuation) -> c
kotlinx.coroutines.CancelHandler -> c4.i:
kotlinx.coroutines.CancelHandlerBase -> c4.j:
    void invoke(java.lang.Throwable) -> a
kotlinx.coroutines.CancellableContinuation -> c4.k:
    java.lang.Object tryResume(java.lang.Object,java.lang.Object) -> e
    void invokeOnCancellation(kotlin.jvm.functions.Function1) -> h
    java.lang.Object tryResume(java.lang.Object,java.lang.Object,kotlin.jvm.functions.Function1) -> l
    void resume(java.lang.Object,kotlin.jvm.functions.Function1) -> n
    java.lang.Object tryResumeWithException(java.lang.Throwable) -> r
    void completeResume(java.lang.Object) -> s
kotlinx.coroutines.CancellableContinuation$DefaultImpls -> c4.k$a:
    java.lang.Object tryResume$default(kotlinx.coroutines.CancellableContinuation,java.lang.Object,java.lang.Object,int,java.lang.Object) -> a
kotlinx.coroutines.CancellableContinuationImpl -> c4.m:
    kotlin.coroutines.CoroutineContext context -> U2
    kotlinx.coroutines.DisposableHandle parentHandle -> V2
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _decision$FU -> W2
    kotlin.coroutines.Continuation delegate -> T2
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _state$FU -> X2
    boolean isReusable() -> A
    kotlinx.coroutines.CancelHandler makeCancelHandler(kotlin.jvm.functions.Function1) -> B
    void multipleHandlersError(kotlin.jvm.functions.Function1,java.lang.Object) -> C
    java.lang.String nameString() -> D
    void parentCancelled$kotlinx_coroutines_core(java.lang.Throwable) -> E
    void releaseClaimedReusableContinuation() -> F
    boolean resetStateReusable() -> G
    void resumeImpl(java.lang.Object,int,kotlin.jvm.functions.Function1) -> H
    void resumeImpl$default(kotlinx.coroutines.CancellableContinuationImpl,java.lang.Object,int,kotlin.jvm.functions.Function1,int,java.lang.Object) -> I
    java.lang.Object resumedState(kotlinx.coroutines.NotCompleted,java.lang.Object,int,kotlin.jvm.functions.Function1,java.lang.Object) -> J
    boolean tryResume() -> K
    kotlinx.coroutines.internal.Symbol tryResumeImpl(java.lang.Object,java.lang.Object,kotlin.jvm.functions.Function1) -> L
    boolean trySuspend() -> M
    void cancelCompletedResult$kotlinx_coroutines_core(java.lang.Object,java.lang.Throwable) -> a
    kotlin.coroutines.Continuation getDelegate$kotlinx_coroutines_core() -> b
    java.lang.Throwable getExceptionalResult$kotlinx_coroutines_core(java.lang.Object) -> c
    java.lang.Object getSuccessfulResult$kotlinx_coroutines_core(java.lang.Object) -> d
    java.lang.Object tryResume(java.lang.Object,java.lang.Object) -> e
    java.lang.Object takeState$kotlinx_coroutines_core() -> g
    void invokeOnCancellation(kotlin.jvm.functions.Function1) -> h
    java.lang.Void alreadyResumedError(java.lang.Object) -> i
    void callCancelHandler(kotlinx.coroutines.CancelHandler,java.lang.Throwable) -> j
    void callCancelHandler(kotlin.jvm.functions.Function1,java.lang.Throwable) -> k
    java.lang.Object tryResume(java.lang.Object,java.lang.Object,kotlin.jvm.functions.Function1) -> l
    void callOnCancellation(kotlin.jvm.functions.Function1,java.lang.Throwable) -> m
    void resume(java.lang.Object,kotlin.jvm.functions.Function1) -> n
    boolean cancel(java.lang.Throwable) -> o
    boolean cancelLater(java.lang.Throwable) -> p
    void detachChild$kotlinx_coroutines_core() -> q
    java.lang.Object tryResumeWithException(java.lang.Throwable) -> r
    void completeResume(java.lang.Object) -> s
    void detachChildIfNonResuable() -> t
    void dispatchResume(int) -> u
    java.lang.Throwable getContinuationCancellationCause(kotlinx.coroutines.Job) -> v
    java.lang.Object getResult() -> w
    java.lang.Object getState$kotlinx_coroutines_core() -> x
    java.lang.String getStateDebugRepresentation() -> y
    kotlinx.coroutines.DisposableHandle installParentHandle() -> z
kotlinx.coroutines.CancellableContinuationImplKt -> c4.n:
    kotlinx.coroutines.internal.Symbol RESUME_TOKEN -> a
kotlinx.coroutines.CancellableContinuationKt -> c4.o:
    kotlinx.coroutines.CancellableContinuationImpl getOrCreateCancellableContinuation(kotlin.coroutines.Continuation) -> a
kotlinx.coroutines.CancelledContinuation -> c4.p:
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _resumed$FU -> c
    boolean makeResumed() -> c
kotlinx.coroutines.ChildContinuation -> c4.q:
    kotlinx.coroutines.CancellableContinuationImpl child -> U2
    void invoke(java.lang.Throwable) -> y
kotlinx.coroutines.ChildHandle -> c4.r:
    boolean childCancelled(java.lang.Throwable) -> k
kotlinx.coroutines.ChildHandleNode -> c4.s:
    kotlinx.coroutines.ChildJob childJob -> U2
    boolean childCancelled(java.lang.Throwable) -> k
    void invoke(java.lang.Throwable) -> y
kotlinx.coroutines.ChildJob -> c4.t:
    void parentCancelled(kotlinx.coroutines.ParentJob) -> o
kotlinx.coroutines.CommonPool -> c4.w:
    int requestedParallelism -> T2
    boolean usePrivatePool -> U2
    kotlinx.coroutines.CommonPool INSTANCE -> S2
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> l
    void $r8$lambda$36bgNy4lLwRHCWOZ-fm6LcwyUbo() -> r
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Thread $r8$lambda$ERvPtt6BNpepqyLHHf5J6mHx7SQ(java.util.concurrent.atomic.AtomicInteger,java.lang.Runnable) -> s
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.concurrent.ExecutorService createPlainPool() -> t
    java.lang.Thread createPlainPool$lambda-12(java.util.concurrent.atomic.AtomicInteger,java.lang.Runnable) -> u
    java.util.concurrent.ExecutorService createPool() -> v
    java.util.concurrent.Executor getOrCreatePoolSync() -> w
    int getParallelism() -> x
    boolean isGoodCommonPool$kotlinx_coroutines_core(java.lang.Class,java.util.concurrent.ExecutorService) -> y
    void isGoodCommonPool$lambda-9() -> z
kotlinx.coroutines.CompletableJob -> c4.x:
kotlinx.coroutines.CompletedContinuation -> c4.y:
    kotlinx.coroutines.CancelHandler cancelHandler -> b
    java.lang.Object idempotentResume -> d
    java.lang.Object result -> a
    java.lang.Throwable cancelCause -> e
    kotlin.jvm.functions.Function1 onCancellation -> c
    kotlinx.coroutines.CompletedContinuation copy(java.lang.Object,kotlinx.coroutines.CancelHandler,kotlin.jvm.functions.Function1,java.lang.Object,java.lang.Throwable) -> a
    kotlinx.coroutines.CompletedContinuation copy$default(kotlinx.coroutines.CompletedContinuation,java.lang.Object,kotlinx.coroutines.CancelHandler,kotlin.jvm.functions.Function1,java.lang.Object,java.lang.Throwable,int,java.lang.Object) -> b
    boolean getCancelled() -> c
    void invokeHandlers(kotlinx.coroutines.CancellableContinuationImpl,java.lang.Throwable) -> d
kotlinx.coroutines.CompletedExceptionally -> c4.z:
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _handled$FU -> b
    java.lang.Throwable cause -> a
    boolean getHandled() -> a
    boolean makeHandled() -> b
kotlinx.coroutines.CompletedWithCancellation -> c4.a0:
    java.lang.Object result -> a
    kotlin.jvm.functions.Function1 onCancellation -> b
kotlinx.coroutines.CompletionHandlerBase -> c4.b0:
    void invoke(java.lang.Throwable) -> y
kotlinx.coroutines.CompletionHandlerException -> c4.c0:
kotlinx.coroutines.CompletionStateKt -> c4.d0:
    java.lang.Object recoverResult(java.lang.Object,kotlin.coroutines.Continuation) -> a
    java.lang.Object toState(java.lang.Object,kotlinx.coroutines.CancellableContinuation) -> b
    java.lang.Object toState(java.lang.Object,kotlin.jvm.functions.Function1) -> c
    java.lang.Object toState$default(java.lang.Object,kotlin.jvm.functions.Function1,int,java.lang.Object) -> d
kotlinx.coroutines.CoroutineContextKt -> c4.e0:
    boolean useCoroutinesScheduler -> a
    kotlinx.coroutines.CoroutineDispatcher createDefaultDispatcher() -> a
    java.lang.String getCoroutineName(kotlin.coroutines.CoroutineContext) -> b
    kotlin.coroutines.CoroutineContext newCoroutineContext(kotlinx.coroutines.CoroutineScope,kotlin.coroutines.CoroutineContext) -> c
    kotlinx.coroutines.UndispatchedCoroutine undispatchedCompletion(kotlin.coroutines.jvm.internal.CoroutineStackFrame) -> d
    kotlinx.coroutines.UndispatchedCoroutine updateUndispatchedCompletion(kotlin.coroutines.Continuation,kotlin.coroutines.CoroutineContext,java.lang.Object) -> e
kotlinx.coroutines.CoroutineDispatcher -> c4.f0:
    kotlinx.coroutines.CoroutineDispatcher$Key Key -> Q2
    void releaseInterceptedContinuation(kotlin.coroutines.Continuation) -> c
    kotlin.coroutines.Continuation interceptContinuation(kotlin.coroutines.Continuation) -> k
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> l
    void dispatchYield(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> n
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> p
kotlinx.coroutines.CoroutineDispatcher$Key -> c4.f0$a:
kotlinx.coroutines.CoroutineDispatcher$Key$1 -> c4.f0$a$a:
    kotlinx.coroutines.CoroutineDispatcher$Key$1 INSTANCE -> Q2
    kotlinx.coroutines.CoroutineDispatcher invoke(kotlin.coroutines.CoroutineContext$Element) -> a
kotlinx.coroutines.CoroutineExceptionHandler -> kotlinx.coroutines.CoroutineExceptionHandler:
    kotlinx.coroutines.CoroutineExceptionHandler$Key Key -> A
kotlinx.coroutines.CoroutineExceptionHandler$Key -> kotlinx.coroutines.CoroutineExceptionHandler$a:
    kotlinx.coroutines.CoroutineExceptionHandler$Key $$INSTANCE -> Q2
kotlinx.coroutines.CoroutineExceptionHandlerImplKt -> c4.g0:
    java.util.List handlers -> a
    void handleCoroutineExceptionImpl(kotlin.coroutines.CoroutineContext,java.lang.Throwable) -> a
kotlinx.coroutines.CoroutineExceptionHandlerKt -> c4.h0:
    void handleCoroutineException(kotlin.coroutines.CoroutineContext,java.lang.Throwable) -> a
    java.lang.Throwable handlerException(java.lang.Throwable,java.lang.Throwable) -> b
kotlinx.coroutines.CoroutineScope -> c4.i0:
    kotlin.coroutines.CoroutineContext getCoroutineContext() -> p
kotlinx.coroutines.CoroutineScopeKt -> c4.j0:
    kotlinx.coroutines.CoroutineScope CoroutineScope(kotlin.coroutines.CoroutineContext) -> a
kotlinx.coroutines.CoroutineStart -> c4.k0:
    kotlinx.coroutines.CoroutineStart DEFAULT -> Q2
    kotlinx.coroutines.CoroutineStart LAZY -> R2
    kotlinx.coroutines.CoroutineStart ATOMIC -> S2
    kotlinx.coroutines.CoroutineStart UNDISPATCHED -> T2
    kotlinx.coroutines.CoroutineStart[] $VALUES -> U2
    kotlinx.coroutines.CoroutineStart[] $values() -> a
    void invoke(kotlin.jvm.functions.Function2,java.lang.Object,kotlin.coroutines.Continuation) -> c
    boolean isLazy() -> d
kotlinx.coroutines.CoroutineStart$WhenMappings -> c4.k0$a:
    int[] $EnumSwitchMapping$0 -> a
kotlinx.coroutines.CoroutinesInternalError -> c4.l0:
kotlinx.coroutines.DebugStringsKt -> c4.m0:
    java.lang.String getClassSimpleName(java.lang.Object) -> a
    java.lang.String getHexAddress(java.lang.Object) -> b
    java.lang.String toDebugString(kotlin.coroutines.Continuation) -> c
kotlinx.coroutines.DefaultExecutor -> c4.n0:
    kotlinx.coroutines.DefaultExecutor INSTANCE -> W2
    long KEEP_ALIVE_NANOS -> X2
    java.lang.Thread getThread() -> B
    void acknowledgeShutdownIfNeeded() -> S
    java.lang.Thread createThreadSync() -> T
    boolean isShutdownRequested() -> U
    boolean notifyStartup() -> V
kotlinx.coroutines.DispatchedCoroutine -> c4.o0:
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _decision$FU -> T2
    boolean trySuspend() -> A0
    void afterResume(java.lang.Object) -> t0
    void afterCompletion(java.lang.Object) -> x
    java.lang.Object getResult() -> y0
    boolean tryResume() -> z0
kotlinx.coroutines.DispatchedTask -> c4.p0:
    int resumeMode -> S2
    void cancelCompletedResult$kotlinx_coroutines_core(java.lang.Object,java.lang.Throwable) -> a
    kotlin.coroutines.Continuation getDelegate$kotlinx_coroutines_core() -> b
    java.lang.Throwable getExceptionalResult$kotlinx_coroutines_core(java.lang.Object) -> c
    java.lang.Object getSuccessfulResult$kotlinx_coroutines_core(java.lang.Object) -> d
    void handleFatalException(java.lang.Throwable,java.lang.Throwable) -> f
    java.lang.Object takeState$kotlinx_coroutines_core() -> g
kotlinx.coroutines.DispatchedTaskKt -> c4.q0:
    void dispatch(kotlinx.coroutines.DispatchedTask,int) -> a
    boolean isCancellableMode(int) -> b
    boolean isReusableMode(int) -> c
    void resume(kotlinx.coroutines.DispatchedTask,kotlin.coroutines.Continuation,boolean) -> d
    void resumeUnconfined(kotlinx.coroutines.DispatchedTask) -> e
kotlinx.coroutines.DispatcherExecutor -> c4.r0:
    kotlinx.coroutines.CoroutineDispatcher dispatcher -> Q2
kotlinx.coroutines.Dispatchers -> c4.s0:
    kotlinx.coroutines.Dispatchers INSTANCE -> a
    kotlinx.coroutines.CoroutineDispatcher IO -> d
    kotlinx.coroutines.CoroutineDispatcher Unconfined -> c
    kotlinx.coroutines.CoroutineDispatcher Default -> b
    kotlinx.coroutines.CoroutineDispatcher getDefault() -> a
    kotlinx.coroutines.CoroutineDispatcher getIO() -> b
    kotlinx.coroutines.MainCoroutineDispatcher getMain() -> c
kotlinx.coroutines.DisposableHandle -> c4.t0:
    void dispose() -> a
kotlinx.coroutines.Empty -> c4.u0:
    boolean isActive -> Q2
    boolean isActive() -> b
    kotlinx.coroutines.NodeList getList() -> e
kotlinx.coroutines.EventLoop -> c4.v0:
    kotlinx.coroutines.internal.ArrayQueue unconfinedQueue -> T2
    boolean shared -> S2
    long useCount -> R2
    void shutdown() -> A
    void decrementUseCount(boolean) -> r
    long delta(boolean) -> s
    void dispatchUnconfined(kotlinx.coroutines.DispatchedTask) -> t
    long getNextTime() -> u
    void incrementUseCount(boolean) -> v
    void incrementUseCount$default(kotlinx.coroutines.EventLoop,boolean,int,java.lang.Object) -> w
    boolean isUnconfinedLoopActive() -> x
    boolean isUnconfinedQueueEmpty() -> y
    boolean processUnconfinedEvent() -> z
kotlinx.coroutines.EventLoopImplBase -> c4.w0:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _queue$FU -> U2
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _delayed$FU -> V2
    void shutdown() -> A
    boolean access$isCompleted(kotlinx.coroutines.EventLoopImplBase) -> E
    void closeQueue() -> F
    java.lang.Runnable dequeue() -> G
    void enqueue(java.lang.Runnable) -> H
    boolean enqueueImpl(java.lang.Runnable) -> I
    boolean isCompleted() -> J
    boolean isEmpty() -> K
    long processNextEvent() -> L
    void rescheduleAllDelayed() -> M
    void resetAll() -> N
    void schedule(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> O
    int scheduleImpl(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> P
    void setCompleted(boolean) -> Q
    boolean shouldUnpark(kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> R
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> l
    long getNextTime() -> u
kotlinx.coroutines.EventLoopImplBase$DelayedTask -> c4.w0$a:
    int index -> S2
    long nanoTime -> Q2
    java.lang.Object _heap -> R2
    int compareTo(kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> A
    int scheduleTask(long,kotlinx.coroutines.EventLoopImplBase$DelayedTaskQueue,kotlinx.coroutines.EventLoopImplBase) -> B
    boolean timeToExecute(long) -> C
    void dispose() -> a
    void setIndex(int) -> c
    void setHeap(kotlinx.coroutines.internal.ThreadSafeHeap) -> d
    kotlinx.coroutines.internal.ThreadSafeHeap getHeap() -> n
    int getIndex() -> x
kotlinx.coroutines.EventLoopImplBase$DelayedTaskQueue -> c4.w0$b:
    long timeNow -> b
kotlinx.coroutines.EventLoopImplPlatform -> c4.x0:
    java.lang.Thread getThread() -> B
    void reschedule(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> C
    void unpark() -> D
kotlinx.coroutines.EventLoopKt -> c4.y0:
    kotlinx.coroutines.EventLoop createEventLoop() -> a
kotlinx.coroutines.EventLoop_commonKt -> c4.z0:
    kotlinx.coroutines.internal.Symbol DISPOSED_TASK -> a
    kotlinx.coroutines.internal.Symbol CLOSED_EMPTY -> b
    kotlinx.coroutines.internal.Symbol access$getCLOSED_EMPTY$p() -> a
    kotlinx.coroutines.internal.Symbol access$getDISPOSED_TASK$p() -> b
kotlinx.coroutines.ExceptionsKt -> c4.a1:
    java.util.concurrent.CancellationException CancellationException(java.lang.String,java.lang.Throwable) -> a
kotlinx.coroutines.ExecutorCoroutineDispatcher -> c4.b1:
    kotlinx.coroutines.ExecutorCoroutineDispatcher$Key Key -> R2
kotlinx.coroutines.ExecutorCoroutineDispatcher$Key -> c4.b1$a:
kotlinx.coroutines.ExecutorCoroutineDispatcher$Key$1 -> c4.b1$a$a:
    kotlinx.coroutines.ExecutorCoroutineDispatcher$Key$1 INSTANCE -> Q2
    kotlinx.coroutines.ExecutorCoroutineDispatcher invoke(kotlin.coroutines.CoroutineContext$Element) -> a
kotlinx.coroutines.ExecutorCoroutineDispatcherImpl -> c4.c1:
    java.util.concurrent.Executor executor -> S2
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> l
    void cancelJobOnRejection(kotlin.coroutines.CoroutineContext,java.util.concurrent.RejectedExecutionException) -> r
    java.util.concurrent.Executor getExecutor() -> s
kotlinx.coroutines.ExecutorsKt -> c4.d1:
    kotlinx.coroutines.CoroutineDispatcher from(java.util.concurrent.Executor) -> a
kotlinx.coroutines.InactiveNodeList -> c4.e1:
    kotlinx.coroutines.NodeList list -> Q2
    boolean isActive() -> b
    kotlinx.coroutines.NodeList getList() -> e
kotlinx.coroutines.Incomplete -> c4.f1:
    boolean isActive() -> b
    kotlinx.coroutines.NodeList getList() -> e
kotlinx.coroutines.IncompleteStateBox -> c4.g1:
    kotlinx.coroutines.Incomplete state -> a
kotlinx.coroutines.InvokeOnCancel -> c4.h1:
    kotlin.jvm.functions.Function1 handler -> Q2
    void invoke(java.lang.Throwable) -> a
kotlinx.coroutines.InvokeOnCancelling -> c4.i1:
    kotlin.jvm.functions.Function1 handler -> U2
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _invoked$FU -> V2
    void invoke(java.lang.Throwable) -> y
kotlinx.coroutines.InvokeOnCompletion -> c4.j1:
    kotlin.jvm.functions.Function1 handler -> U2
    void invoke(java.lang.Throwable) -> y
kotlinx.coroutines.Job -> c4.k1:
    kotlinx.coroutines.Job$Key Key -> z
    kotlinx.coroutines.DisposableHandle invokeOnCompletion(boolean,boolean,kotlin.jvm.functions.Function1) -> a
    boolean isActive() -> b
    java.util.concurrent.CancellationException getCancellationException() -> g
    boolean start() -> i
    kotlinx.coroutines.ChildHandle attachChild(kotlinx.coroutines.ChildJob) -> j
    void cancel(java.util.concurrent.CancellationException) -> q
kotlinx.coroutines.Job$DefaultImpls -> c4.k1$a:
    void cancel$default(kotlinx.coroutines.Job,java.util.concurrent.CancellationException,int,java.lang.Object) -> a
    java.lang.Object fold(kotlinx.coroutines.Job,java.lang.Object,kotlin.jvm.functions.Function2) -> b
    kotlin.coroutines.CoroutineContext$Element get(kotlinx.coroutines.Job,kotlin.coroutines.CoroutineContext$Key) -> c
    kotlinx.coroutines.DisposableHandle invokeOnCompletion$default(kotlinx.coroutines.Job,boolean,boolean,kotlin.jvm.functions.Function1,int,java.lang.Object) -> d
    kotlin.coroutines.CoroutineContext minusKey(kotlinx.coroutines.Job,kotlin.coroutines.CoroutineContext$Key) -> e
    kotlin.coroutines.CoroutineContext plus(kotlinx.coroutines.Job,kotlin.coroutines.CoroutineContext) -> f
kotlinx.coroutines.Job$Key -> c4.k1$b:
    kotlinx.coroutines.Job$Key $$INSTANCE -> Q2
kotlinx.coroutines.JobCancellationException -> c4.l1:
    kotlinx.coroutines.Job job -> Q2
kotlinx.coroutines.JobCancellingNode -> c4.m1:
kotlinx.coroutines.JobImpl -> c4.n1:
    boolean handlesException -> R2
    boolean getHandlesException$kotlinx_coroutines_core() -> L
    boolean getOnCancelComplete$kotlinx_coroutines_core() -> M
    boolean handlesException() -> t0
kotlinx.coroutines.JobKt -> c4.o1:
    kotlinx.coroutines.CompletableJob Job(kotlinx.coroutines.Job) -> a
    kotlinx.coroutines.CompletableJob Job$default(kotlinx.coroutines.Job,int,java.lang.Object) -> b
    void cancel(kotlin.coroutines.CoroutineContext,java.util.concurrent.CancellationException) -> c
    void ensureActive(kotlinx.coroutines.Job) -> d
    void ensureActive(kotlin.coroutines.CoroutineContext) -> e
kotlinx.coroutines.JobKt__JobKt -> c4.p1:
    kotlinx.coroutines.CompletableJob Job(kotlinx.coroutines.Job) -> a
    kotlinx.coroutines.CompletableJob Job$default(kotlinx.coroutines.Job,int,java.lang.Object) -> b
    void cancel(kotlin.coroutines.CoroutineContext,java.util.concurrent.CancellationException) -> c
    void ensureActive(kotlinx.coroutines.Job) -> d
    void ensureActive(kotlin.coroutines.CoroutineContext) -> e
kotlinx.coroutines.JobNode -> c4.q1:
    kotlinx.coroutines.JobSupport job -> T2
    void setJob(kotlinx.coroutines.JobSupport) -> A
    void dispose() -> a
    boolean isActive() -> b
    kotlinx.coroutines.NodeList getList() -> e
    kotlinx.coroutines.JobSupport getJob() -> z
kotlinx.coroutines.JobSupport -> c4.r1:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _state$FU -> Q2
    java.lang.Object cancelMakeCompleting(java.lang.Object) -> A
    boolean cancelParent(java.lang.Throwable) -> B
    java.lang.String cancellationExceptionMessage() -> C
    boolean childCancelled(java.lang.Throwable) -> D
    void completeStateFinalization(kotlinx.coroutines.Incomplete,java.lang.Object) -> E
    void continueCompleting(kotlinx.coroutines.JobSupport$Finishing,kotlinx.coroutines.ChildHandleNode,java.lang.Object) -> F
    java.lang.Throwable createCauseException(java.lang.Object) -> G
    java.lang.Object finalizeFinishingState(kotlinx.coroutines.JobSupport$Finishing,java.lang.Object) -> H
    kotlinx.coroutines.ChildHandleNode firstChild(kotlinx.coroutines.Incomplete) -> I
    java.lang.Throwable getExceptionOrNull(java.lang.Object) -> J
    java.lang.Throwable getFinalRootCause(kotlinx.coroutines.JobSupport$Finishing,java.util.List) -> K
    boolean getHandlesException$kotlinx_coroutines_core() -> L
    boolean getOnCancelComplete$kotlinx_coroutines_core() -> M
    kotlinx.coroutines.NodeList getOrPromoteCancellingList(kotlinx.coroutines.Incomplete) -> N
    kotlinx.coroutines.ChildHandle getParentHandle$kotlinx_coroutines_core() -> O
    java.lang.Object getState$kotlinx_coroutines_core() -> P
    boolean handleJobException(java.lang.Throwable) -> Q
    void handleOnCompletionException$kotlinx_coroutines_core(java.lang.Throwable) -> R
    void initParentJob(kotlinx.coroutines.Job) -> S
    boolean isCompleted() -> T
    boolean isScopedCoroutine() -> U
    java.lang.Object makeCancelling(java.lang.Object) -> V
    java.lang.Object makeCompletingOnce$kotlinx_coroutines_core(java.lang.Object) -> W
    kotlinx.coroutines.JobNode makeNode(kotlin.jvm.functions.Function1,boolean) -> X
    java.lang.String nameString$kotlinx_coroutines_core() -> Y
    kotlinx.coroutines.ChildHandleNode nextChild(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> Z
    kotlinx.coroutines.DisposableHandle invokeOnCompletion(boolean,boolean,kotlin.jvm.functions.Function1) -> a
    void notifyCancelling(kotlinx.coroutines.NodeList,java.lang.Throwable) -> a0
    boolean isActive() -> b
    void notifyCompletion(kotlinx.coroutines.NodeList,java.lang.Throwable) -> b0
    void onCancelling(java.lang.Throwable) -> c0
    java.util.concurrent.CancellationException getChildJobCancellationCause() -> d
    void onCompletionInternal(java.lang.Object) -> d0
    void onStart() -> e0
    void promoteEmptyToNodeList(kotlinx.coroutines.Empty) -> f0
    java.util.concurrent.CancellationException getCancellationException() -> g
    void promoteSingleToNodeList(kotlinx.coroutines.JobNode) -> g0
    void removeNode$kotlinx_coroutines_core(kotlinx.coroutines.JobNode) -> h0
    boolean start() -> i
    void setParentHandle$kotlinx_coroutines_core(kotlinx.coroutines.ChildHandle) -> i0
    kotlinx.coroutines.ChildHandle attachChild(kotlinx.coroutines.ChildJob) -> j
    int startInternal(java.lang.Object) -> j0
    java.lang.String stateString(java.lang.Object) -> k0
    java.util.concurrent.CancellationException toCancellationException(java.lang.Throwable,java.lang.String) -> l0
    java.util.concurrent.CancellationException toCancellationException$default(kotlinx.coroutines.JobSupport,java.lang.Throwable,java.lang.String,int,java.lang.Object) -> m0
    java.lang.String toDebugString() -> n0
    void parentCancelled(kotlinx.coroutines.ParentJob) -> o
    boolean tryFinalizeSimpleState(kotlinx.coroutines.Incomplete,java.lang.Object) -> o0
    boolean tryMakeCancelling(kotlinx.coroutines.Incomplete,java.lang.Throwable) -> p0
    void cancel(java.util.concurrent.CancellationException) -> q
    java.lang.Object tryMakeCompleting(java.lang.Object,java.lang.Object) -> q0
    java.lang.Object tryMakeCompletingSlowPath(kotlinx.coroutines.Incomplete,java.lang.Object) -> r0
    boolean tryWaitForChild(kotlinx.coroutines.JobSupport$Finishing,kotlinx.coroutines.ChildHandleNode,java.lang.Object) -> s0
    java.lang.String access$cancellationExceptionMessage(kotlinx.coroutines.JobSupport) -> t
    void access$continueCompleting(kotlinx.coroutines.JobSupport,kotlinx.coroutines.JobSupport$Finishing,kotlinx.coroutines.ChildHandleNode,java.lang.Object) -> u
    boolean addLastAtomic(java.lang.Object,kotlinx.coroutines.NodeList,kotlinx.coroutines.JobNode) -> v
    void addSuppressedExceptions(java.lang.Throwable,java.util.List) -> w
    void afterCompletion(java.lang.Object) -> x
    boolean cancelImpl$kotlinx_coroutines_core(java.lang.Object) -> y
    void cancelInternal(java.lang.Throwable) -> z
kotlinx.coroutines.JobSupport$ChildCompletion -> c4.r1$a:
    kotlinx.coroutines.JobSupport$Finishing state -> V2
    java.lang.Object proposedUpdate -> X2
    kotlinx.coroutines.JobSupport parent -> U2
    kotlinx.coroutines.ChildHandleNode child -> W2
    void invoke(java.lang.Throwable) -> y
kotlinx.coroutines.JobSupport$Finishing -> c4.r1$b:
    kotlinx.coroutines.NodeList list -> Q2
    void addExceptionLocked(java.lang.Throwable) -> a
    boolean isActive() -> b
    java.util.ArrayList allocateList() -> c
    java.lang.Object getExceptionsHolder() -> d
    kotlinx.coroutines.NodeList getList() -> e
    java.lang.Throwable getRootCause() -> f
    boolean isCancelling() -> g
    boolean isCompleting() -> h
    boolean isSealed() -> i
    java.util.List sealLocked(java.lang.Throwable) -> j
    void setCompleting(boolean) -> k
    void setExceptionsHolder(java.lang.Object) -> l
    void setRootCause(java.lang.Throwable) -> m
kotlinx.coroutines.JobSupport$addLastAtomic$$inlined$addLastIf$1 -> c4.r1$c:
    kotlinx.coroutines.JobSupport this$0 -> e
    java.lang.Object $expect$inlined -> f
    kotlinx.coroutines.internal.LockFreeLinkedListNode $node -> d
    java.lang.Object prepare(java.lang.Object) -> g
    java.lang.Object prepare(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> i
kotlinx.coroutines.JobSupportKt -> c4.s1:
    kotlinx.coroutines.internal.Symbol COMPLETING_ALREADY -> a
    kotlinx.coroutines.internal.Symbol TOO_LATE_TO_CANCEL -> d
    kotlinx.coroutines.internal.Symbol SEALED -> e
    kotlinx.coroutines.internal.Symbol COMPLETING_WAITING_CHILDREN -> b
    kotlinx.coroutines.internal.Symbol COMPLETING_RETRY -> c
    kotlinx.coroutines.Empty EMPTY_NEW -> f
    kotlinx.coroutines.Empty EMPTY_ACTIVE -> g
    kotlinx.coroutines.internal.Symbol access$getCOMPLETING_ALREADY$p() -> a
    kotlinx.coroutines.internal.Symbol access$getCOMPLETING_RETRY$p() -> b
    kotlinx.coroutines.Empty access$getEMPTY_ACTIVE$p() -> c
    kotlinx.coroutines.Empty access$getEMPTY_NEW$p() -> d
    kotlinx.coroutines.internal.Symbol access$getSEALED$p() -> e
    kotlinx.coroutines.internal.Symbol access$getTOO_LATE_TO_CANCEL$p() -> f
    java.lang.Object boxIncomplete(java.lang.Object) -> g
    java.lang.Object unboxState(java.lang.Object) -> h
kotlinx.coroutines.LazyStandaloneCoroutine -> c4.t1:
    kotlin.coroutines.Continuation continuation -> S2
    void onStart() -> e0
kotlinx.coroutines.MainCoroutineDispatcher -> c4.u1:
    kotlinx.coroutines.MainCoroutineDispatcher getImmediate() -> r
    java.lang.String toStringInternalImpl() -> s
kotlinx.coroutines.NodeList -> c4.v1:
    boolean isActive() -> b
    kotlinx.coroutines.NodeList getList() -> e
kotlinx.coroutines.NonDisposableHandle -> c4.w1:
    kotlinx.coroutines.NonDisposableHandle INSTANCE -> Q2
    void dispose() -> a
    boolean childCancelled(java.lang.Throwable) -> k
kotlinx.coroutines.NotCompleted -> c4.x1:
kotlinx.coroutines.ParentJob -> c4.y1:
    java.util.concurrent.CancellationException getChildJobCancellationCause() -> d
kotlinx.coroutines.StandaloneCoroutine -> c4.z1:
    boolean handleJobException(java.lang.Throwable) -> Q
kotlinx.coroutines.ThreadContextElement -> c4.a2:
    void restoreThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> f
    java.lang.Object updateThreadContext(kotlin.coroutines.CoroutineContext) -> m
kotlinx.coroutines.ThreadLocalEventLoop -> c4.b2:
    kotlinx.coroutines.ThreadLocalEventLoop INSTANCE -> a
    java.lang.ThreadLocal ref -> b
    kotlinx.coroutines.EventLoop getEventLoop$kotlinx_coroutines_core() -> a
    void resetEventLoop$kotlinx_coroutines_core() -> b
    void setEventLoop$kotlinx_coroutines_core(kotlinx.coroutines.EventLoop) -> c
kotlinx.coroutines.Unconfined -> c4.c2:
    kotlinx.coroutines.Unconfined INSTANCE -> R2
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> l
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> p
kotlinx.coroutines.UndispatchedCoroutine -> c4.d2:
    java.lang.Object savedOldValue -> U2
    kotlin.coroutines.CoroutineContext savedContext -> T2
    void afterResume(java.lang.Object) -> t0
    boolean clearThreadContext() -> y0
    void saveThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> z0
kotlinx.coroutines.UndispatchedMarker -> c4.e2:
    kotlinx.coroutines.UndispatchedMarker INSTANCE -> Q2
kotlinx.coroutines.YieldContext -> c4.f2:
    kotlinx.coroutines.YieldContext$Key Key -> R2
    boolean dispatcherWasUnconfined -> Q2
kotlinx.coroutines.YieldContext$Key -> c4.f2$a:
kotlinx.coroutines.YieldKt -> c4.g2:
    java.lang.Object yield(kotlin.coroutines.Continuation) -> a
kotlinx.coroutines.android.HandlerContext -> d4.a:
    android.os.Handler handler -> R2
    boolean invokeImmediately -> T2
    kotlinx.coroutines.android.HandlerContext immediate -> U2
    java.lang.String name -> S2
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> l
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> p
    kotlinx.coroutines.MainCoroutineDispatcher getImmediate() -> r
    void cancelOnRejection(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> t
    kotlinx.coroutines.android.HandlerContext getImmediate() -> u
kotlinx.coroutines.android.HandlerDispatcher -> d4.b:
kotlinx.coroutines.android.HandlerDispatcherKt -> d4.c:
    kotlinx.coroutines.android.HandlerDispatcher Main -> a
    android.os.Handler asHandler(android.os.Looper,boolean) -> a
kotlinx.coroutines.channels.AbstractChannel -> e4.a:
    kotlinx.coroutines.channels.ReceiveOrClosed takeFirstReceiveOrPeekClosed() -> l
    boolean access$enqueueReceive(kotlinx.coroutines.channels.AbstractChannel,kotlinx.coroutines.channels.Receive) -> n
    void access$removeReceiveOnCancel(kotlinx.coroutines.channels.AbstractChannel,kotlinx.coroutines.CancellableContinuation,kotlinx.coroutines.channels.Receive) -> o
    boolean enqueueReceive(kotlinx.coroutines.channels.Receive) -> p
    boolean enqueueReceiveInternal(kotlinx.coroutines.channels.Receive) -> q
    boolean isBufferAlwaysEmpty() -> r
    boolean isBufferEmpty() -> s
    void onReceiveDequeued() -> t
    void onReceiveEnqueued() -> u
    java.lang.Object pollInternal() -> v
    void removeReceiveOnCancel(kotlinx.coroutines.CancellableContinuation,kotlinx.coroutines.channels.Receive) -> w
kotlinx.coroutines.channels.AbstractChannel$Itr -> e4.a$a:
    java.lang.Object result -> b
    kotlinx.coroutines.channels.AbstractChannel channel -> a
    java.lang.Object hasNext(kotlin.coroutines.Continuation) -> a
    java.lang.Object getResult() -> b
    boolean hasNextResult(java.lang.Object) -> c
    java.lang.Object hasNextSuspend(kotlin.coroutines.Continuation) -> d
    void setResult(java.lang.Object) -> e
kotlinx.coroutines.channels.AbstractChannel$ReceiveHasNext -> e4.a$b:
    kotlinx.coroutines.channels.AbstractChannel$Itr iterator -> T2
    kotlinx.coroutines.CancellableContinuation cont -> U2
    kotlin.jvm.functions.Function1 resumeOnCancellationFun(java.lang.Object) -> A
    kotlinx.coroutines.internal.Symbol tryResumeReceive(java.lang.Object,kotlinx.coroutines.internal.LockFreeLinkedListNode$PrepareOp) -> d
    void completeResumeReceive(java.lang.Object) -> f
    void resumeReceiveClosed(kotlinx.coroutines.channels.Closed) -> z
kotlinx.coroutines.channels.AbstractChannel$RemoveReceiveOnCancel -> e4.a$c:
    kotlinx.coroutines.channels.Receive receive -> Q2
    kotlinx.coroutines.channels.AbstractChannel this$0 -> R2
    void invoke(java.lang.Throwable) -> a
kotlinx.coroutines.channels.AbstractChannel$enqueueReceiveInternal$$inlined$addLastIfPrevAndIf$1 -> e4.a$d:
    kotlinx.coroutines.channels.AbstractChannel this$0 -> e
    kotlinx.coroutines.internal.LockFreeLinkedListNode $node -> d
    java.lang.Object prepare(java.lang.Object) -> g
    java.lang.Object prepare(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> i
kotlinx.coroutines.channels.AbstractChannelKt -> e4.b:
    kotlinx.coroutines.internal.Symbol EMPTY -> a
    kotlinx.coroutines.internal.Symbol POLL_FAILED -> d
    kotlinx.coroutines.internal.Symbol ENQUEUE_FAILED -> e
    kotlinx.coroutines.internal.Symbol OFFER_SUCCESS -> b
    kotlinx.coroutines.internal.Symbol OFFER_FAILED -> c
    kotlinx.coroutines.internal.Symbol HANDLER_INVOKED -> f
kotlinx.coroutines.channels.AbstractSendChannel -> e4.c:
    kotlinx.coroutines.internal.LockFreeLinkedListHead queue -> c
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater onCloseHandler$FU -> d
    kotlin.jvm.functions.Function1 onUndeliveredElement -> b
    java.lang.Object trySend-JP2dKIU(java.lang.Object) -> a
    int countQueueSize() -> b
    java.lang.String getBufferDebugString() -> c
    kotlinx.coroutines.channels.Closed getClosedForSend() -> d
    kotlinx.coroutines.internal.LockFreeLinkedListHead getQueue() -> e
    java.lang.String getQueueDebugStateString() -> f
    void helpClose(kotlinx.coroutines.channels.Closed) -> g
    java.lang.Throwable helpCloseAndGetSendException(kotlinx.coroutines.channels.Closed) -> h
    java.lang.Object offerInternal(java.lang.Object) -> i
    void onClosedIdempotent(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> j
    kotlinx.coroutines.channels.ReceiveOrClosed sendBuffered(java.lang.Object) -> k
    kotlinx.coroutines.channels.ReceiveOrClosed takeFirstReceiveOrPeekClosed() -> l
    kotlinx.coroutines.channels.Send takeFirstSendOrPeekClosed() -> m
kotlinx.coroutines.channels.AbstractSendChannel$SendBuffered -> e4.c$a:
    java.lang.Object element -> T2
    kotlinx.coroutines.internal.Symbol tryResumeSend(kotlinx.coroutines.internal.LockFreeLinkedListNode$PrepareOp) -> A
    void completeResumeSend() -> y
    java.lang.Object getPollResult() -> z
kotlinx.coroutines.channels.ArrayChannel -> e4.d:
    kotlinx.coroutines.channels.BufferOverflow onBufferOverflow -> f
    int head -> i
    int capacity -> e
    java.util.concurrent.locks.ReentrantLock lock -> g
    java.lang.Object[] buffer -> h
    java.lang.String getBufferDebugString() -> c
    java.lang.Object offerInternal(java.lang.Object) -> i
    boolean enqueueReceiveInternal(kotlinx.coroutines.channels.Receive) -> q
    boolean isBufferAlwaysEmpty() -> r
    boolean isBufferEmpty() -> s
    java.lang.Object pollInternal() -> v
    void enqueueElement(int,java.lang.Object) -> x
    void ensureCapacity(int) -> y
    kotlinx.coroutines.internal.Symbol updateBufferSize(int) -> z
kotlinx.coroutines.channels.ArrayChannel$WhenMappings -> e4.d$a:
    int[] $EnumSwitchMapping$0 -> a
kotlinx.coroutines.channels.BufferOverflow -> e4.e:
    kotlinx.coroutines.channels.BufferOverflow[] $VALUES -> T2
    kotlinx.coroutines.channels.BufferOverflow DROP_LATEST -> S2
    kotlinx.coroutines.channels.BufferOverflow DROP_OLDEST -> R2
    kotlinx.coroutines.channels.BufferOverflow SUSPEND -> Q2
    kotlinx.coroutines.channels.BufferOverflow[] $values() -> a
kotlinx.coroutines.channels.Channel -> e4.f:
    kotlinx.coroutines.channels.Channel$Factory Factory -> a
kotlinx.coroutines.channels.Channel$Factory -> e4.f$a:
    int CHANNEL_DEFAULT_CAPACITY -> b
    kotlinx.coroutines.channels.Channel$Factory $$INSTANCE -> a
    int getCHANNEL_DEFAULT_CAPACITY$kotlinx_coroutines_core() -> a
kotlinx.coroutines.channels.ChannelIterator -> e4.g:
    java.lang.Object hasNext(kotlin.coroutines.Continuation) -> a
kotlinx.coroutines.channels.ChannelKt -> e4.h:
    kotlinx.coroutines.channels.Channel Channel(int,kotlinx.coroutines.channels.BufferOverflow,kotlin.jvm.functions.Function1) -> a
    kotlinx.coroutines.channels.Channel Channel$default(int,kotlinx.coroutines.channels.BufferOverflow,kotlin.jvm.functions.Function1,int,java.lang.Object) -> b
kotlinx.coroutines.channels.ChannelResult -> e4.i:
    kotlinx.coroutines.channels.ChannelResult$Failed failed -> b
    kotlinx.coroutines.channels.ChannelResult$Companion Companion -> a
    kotlinx.coroutines.channels.ChannelResult$Failed access$getFailed$cp() -> a
    java.lang.Object constructor-impl(java.lang.Object) -> b
kotlinx.coroutines.channels.ChannelResult$Closed -> e4.i$a:
    java.lang.Throwable cause -> a
kotlinx.coroutines.channels.ChannelResult$Companion -> e4.i$b:
    java.lang.Object closed-JP2dKIU(java.lang.Throwable) -> a
    java.lang.Object failure-PtdJZtk() -> b
    java.lang.Object success-JP2dKIU(java.lang.Object) -> c
kotlinx.coroutines.channels.ChannelResult$Failed -> e4.i$c:
kotlinx.coroutines.channels.Closed -> e4.j:
    java.lang.Throwable closeCause -> T2
    kotlinx.coroutines.internal.Symbol tryResumeSend(kotlinx.coroutines.internal.LockFreeLinkedListNode$PrepareOp) -> A
    kotlinx.coroutines.channels.Closed getOfferResult() -> C
    kotlinx.coroutines.channels.Closed getPollResult() -> D
    java.lang.Throwable getReceiveException() -> E
    java.lang.Throwable getSendException() -> F
    java.lang.Object getOfferResult() -> c
    kotlinx.coroutines.internal.Symbol tryResumeReceive(java.lang.Object,kotlinx.coroutines.internal.LockFreeLinkedListNode$PrepareOp) -> d
    void completeResumeReceive(java.lang.Object) -> f
    void completeResumeSend() -> y
    java.lang.Object getPollResult() -> z
kotlinx.coroutines.channels.ClosedReceiveChannelException -> e4.k:
kotlinx.coroutines.channels.ClosedSendChannelException -> e4.l:
kotlinx.coroutines.channels.ConflatedChannel -> e4.m:
    java.lang.Object value -> f
    java.util.concurrent.locks.ReentrantLock lock -> e
    java.lang.String getBufferDebugString() -> c
    java.lang.Object offerInternal(java.lang.Object) -> i
    boolean enqueueReceiveInternal(kotlinx.coroutines.channels.Receive) -> q
    boolean isBufferAlwaysEmpty() -> r
    boolean isBufferEmpty() -> s
    java.lang.Object pollInternal() -> v
    kotlinx.coroutines.internal.UndeliveredElementException updateValueLocked(java.lang.Object) -> x
kotlinx.coroutines.channels.LinkedListChannel -> e4.n:
    java.lang.Object offerInternal(java.lang.Object) -> i
    boolean isBufferAlwaysEmpty() -> r
    boolean isBufferEmpty() -> s
kotlinx.coroutines.channels.Receive -> e4.o:
    java.lang.Object getOfferResult() -> c
    kotlinx.coroutines.internal.Symbol getOfferResult() -> y
    void resumeReceiveClosed(kotlinx.coroutines.channels.Closed) -> z
kotlinx.coroutines.channels.ReceiveChannel -> e4.p:
kotlinx.coroutines.channels.ReceiveOrClosed -> e4.q:
    java.lang.Object getOfferResult() -> c
    kotlinx.coroutines.internal.Symbol tryResumeReceive(java.lang.Object,kotlinx.coroutines.internal.LockFreeLinkedListNode$PrepareOp) -> d
    void completeResumeReceive(java.lang.Object) -> f
kotlinx.coroutines.channels.RendezvousChannel -> e4.r:
    boolean isBufferAlwaysEmpty() -> r
    boolean isBufferEmpty() -> s
kotlinx.coroutines.channels.Send -> e4.s:
    kotlinx.coroutines.internal.Symbol tryResumeSend(kotlinx.coroutines.internal.LockFreeLinkedListNode$PrepareOp) -> A
    void undeliveredElement() -> B
    void completeResumeSend() -> y
    java.lang.Object getPollResult() -> z
kotlinx.coroutines.channels.SendChannel -> e4.t:
    java.lang.Object trySend-JP2dKIU(java.lang.Object) -> a
kotlinx.coroutines.flow.AbstractFlow -> f4.a:
    java.lang.Object collect(kotlinx.coroutines.flow.FlowCollector,kotlin.coroutines.Continuation) -> a
    java.lang.Object collectSafely(kotlinx.coroutines.flow.FlowCollector,kotlin.coroutines.Continuation) -> b
kotlinx.coroutines.flow.AbstractFlow$collect$1 -> f4.a$a:
    int label -> T2
    java.lang.Object L$0 -> Q2
    java.lang.Object result -> R2
    kotlinx.coroutines.flow.AbstractFlow this$0 -> S2
kotlinx.coroutines.flow.Flow -> f4.b:
    java.lang.Object collect(kotlinx.coroutines.flow.FlowCollector,kotlin.coroutines.Continuation) -> a
kotlinx.coroutines.flow.FlowCollector -> f4.c:
kotlinx.coroutines.flow.FlowKt -> f4.d:
    kotlinx.coroutines.flow.Flow flow(kotlin.jvm.functions.Function2) -> a
kotlinx.coroutines.flow.FlowKt__BuildersKt -> f4.e:
    kotlinx.coroutines.flow.Flow flow(kotlin.jvm.functions.Function2) -> a
kotlinx.coroutines.flow.SafeFlow -> f4.f:
    kotlin.jvm.functions.Function2 block -> a
    java.lang.Object collectSafely(kotlinx.coroutines.flow.FlowCollector,kotlin.coroutines.Continuation) -> b
kotlinx.coroutines.flow.internal.DownstreamExceptionElement -> g4.a:
    kotlinx.coroutines.flow.internal.DownstreamExceptionElement$Key Key -> S2
    java.lang.Throwable e -> Q2
    kotlin.coroutines.CoroutineContext$Key key -> R2
kotlinx.coroutines.flow.internal.DownstreamExceptionElement$Key -> g4.a$a:
kotlinx.coroutines.flow.internal.NoOpContinuation -> g4.b:
    kotlinx.coroutines.flow.internal.NoOpContinuation INSTANCE -> Q2
    kotlin.coroutines.CoroutineContext context -> R2
kotlinx.coroutines.flow.internal.SafeCollector -> g4.c:
    kotlin.coroutines.Continuation completion -> U2
    int collectContextSize -> S2
    kotlinx.coroutines.flow.FlowCollector collector -> Q2
    kotlin.coroutines.CoroutineContext lastEmissionContext -> T2
    kotlin.coroutines.CoroutineContext collectContext -> R2
    void checkContext(kotlin.coroutines.CoroutineContext,kotlin.coroutines.CoroutineContext,java.lang.Object) -> a
    java.lang.Object emit(kotlin.coroutines.Continuation,java.lang.Object) -> b
    void exceptionTransparencyViolated(kotlinx.coroutines.flow.internal.DownstreamExceptionElement,java.lang.Object) -> c
kotlinx.coroutines.flow.internal.SafeCollector$collectContextSize$1 -> g4.c$a:
    kotlinx.coroutines.flow.internal.SafeCollector$collectContextSize$1 INSTANCE -> Q2
    java.lang.Integer invoke(int,kotlin.coroutines.CoroutineContext$Element) -> a
kotlinx.coroutines.flow.internal.SafeCollectorKt -> g4.d:
    kotlin.jvm.functions.Function3 emitFun -> a
    kotlin.jvm.functions.Function3 access$getEmitFun$p() -> a
kotlinx.coroutines.flow.internal.SafeCollectorKt$emitFun$1 -> g4.d$a:
    kotlinx.coroutines.flow.internal.SafeCollectorKt$emitFun$1 INSTANCE -> Q2
    java.lang.Object invoke(kotlinx.coroutines.flow.FlowCollector,java.lang.Object,kotlin.coroutines.Continuation) -> b
    java.lang.Object invoke(java.lang.Object,java.lang.Object,java.lang.Object) -> g
kotlinx.coroutines.flow.internal.SafeCollector_commonKt -> g4.e:
    void checkContext(kotlinx.coroutines.flow.internal.SafeCollector,kotlin.coroutines.CoroutineContext) -> a
    kotlinx.coroutines.Job transitiveCoroutineParent(kotlinx.coroutines.Job,kotlinx.coroutines.Job) -> b
kotlinx.coroutines.flow.internal.SafeCollector_commonKt$checkContext$result$1 -> g4.e$a:
    kotlinx.coroutines.flow.internal.SafeCollector $this_checkContext -> Q2
    java.lang.Integer invoke(int,kotlin.coroutines.CoroutineContext$Element) -> a
kotlinx.coroutines.internal.ArrayQueue -> kotlinx.coroutines.internal.a:
    java.lang.Object[] elements -> a
    int head -> b
    int tail -> c
    void addLast(java.lang.Object) -> a
    void ensureCapacity() -> b
    boolean isEmpty() -> c
    java.lang.Object removeFirstOrNull() -> d
kotlinx.coroutines.internal.AtomicKt -> kotlinx.coroutines.internal.b:
    java.lang.Object RETRY_ATOMIC -> b
    java.lang.Object NO_DECISION -> a
kotlinx.coroutines.internal.AtomicOp -> kotlinx.coroutines.internal.c:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _consensus$FU -> a
    kotlinx.coroutines.internal.AtomicOp getAtomicOp() -> a
    java.lang.Object perform(java.lang.Object) -> c
    void complete(java.lang.Object,java.lang.Object) -> d
    java.lang.Object decide(java.lang.Object) -> e
    long getOpSequence() -> f
    java.lang.Object prepare(java.lang.Object) -> g
kotlinx.coroutines.internal.ConcurrentKt -> kotlinx.coroutines.internal.d:
    java.lang.reflect.Method REMOVE_FUTURE_ON_CANCEL -> a
    boolean removeFutureOnCancel(java.util.concurrent.Executor) -> a
kotlinx.coroutines.internal.ContextScope -> kotlinx.coroutines.internal.e:
    kotlin.coroutines.CoroutineContext coroutineContext -> Q2
    kotlin.coroutines.CoroutineContext getCoroutineContext() -> p
kotlinx.coroutines.internal.DispatchedContinuation -> kotlinx.coroutines.internal.f:
    kotlin.coroutines.Continuation continuation -> U2
    java.lang.Object countOrElement -> W2
    kotlinx.coroutines.CoroutineDispatcher dispatcher -> T2
    java.lang.Object _state -> V2
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _reusableCancellableContinuation$FU -> X2
    void cancelCompletedResult$kotlinx_coroutines_core(java.lang.Object,java.lang.Throwable) -> a
    kotlin.coroutines.Continuation getDelegate$kotlinx_coroutines_core() -> b
    java.lang.Object takeState$kotlinx_coroutines_core() -> g
    void awaitReusability() -> i
    kotlinx.coroutines.CancellableContinuationImpl claimReusableCancellableContinuation() -> j
    void dispatchYield$kotlinx_coroutines_core(kotlin.coroutines.CoroutineContext,java.lang.Object) -> k
    kotlinx.coroutines.CancellableContinuationImpl getReusableCancellableContinuation() -> m
    boolean isReusable() -> o
    boolean postponeCancellation(java.lang.Throwable) -> p
    void release() -> q
    java.lang.Throwable tryReleaseClaimedContinuation(kotlinx.coroutines.CancellableContinuation) -> t
kotlinx.coroutines.internal.DispatchedContinuationKt -> kotlinx.coroutines.internal.g:
    kotlinx.coroutines.internal.Symbol UNDEFINED -> a
    kotlinx.coroutines.internal.Symbol REUSABLE_CLAIMED -> b
    kotlinx.coroutines.internal.Symbol access$getUNDEFINED$p() -> a
    void resumeCancellableWith(kotlin.coroutines.Continuation,java.lang.Object,kotlin.jvm.functions.Function1) -> b
    void resumeCancellableWith$default(kotlin.coroutines.Continuation,java.lang.Object,kotlin.jvm.functions.Function1,int,java.lang.Object) -> c
    boolean yieldUndispatched(kotlinx.coroutines.internal.DispatchedContinuation) -> d
kotlinx.coroutines.internal.FastServiceLoader -> kotlinx.coroutines.internal.h:
    kotlinx.coroutines.internal.FastServiceLoader INSTANCE -> a
    java.lang.Object getProviderInstance(java.lang.String,java.lang.ClassLoader,java.lang.Class) -> a
    java.util.List load(java.lang.Class,java.lang.ClassLoader) -> b
    java.util.List loadMainDispatcherFactory$kotlinx_coroutines_core() -> c
    java.util.List loadProviders$kotlinx_coroutines_core(java.lang.Class,java.lang.ClassLoader) -> d
    java.util.List parse(java.net.URL) -> e
    java.util.List parseFile(java.io.BufferedReader) -> f
kotlinx.coroutines.internal.FastServiceLoaderKt -> kotlinx.coroutines.internal.i:
    boolean ANDROID_DETECTED -> a
    boolean getANDROID_DETECTED() -> a
kotlinx.coroutines.internal.InlineList -> kotlinx.coroutines.internal.j:
    java.lang.Object constructor-impl(java.lang.Object) -> a
    java.lang.Object constructor-impl$default(java.lang.Object,int,kotlin.jvm.internal.DefaultConstructorMarker) -> b
    java.lang.Object plus-FjFbRPM(java.lang.Object,java.lang.Object) -> c
kotlinx.coroutines.internal.LockFreeLinkedListHead -> kotlinx.coroutines.internal.k:
    boolean isRemoved() -> t
kotlinx.coroutines.internal.LockFreeLinkedListKt -> kotlinx.coroutines.internal.l:
    java.lang.Object LIST_EMPTY -> b
    java.lang.Object CONDITION_FALSE -> a
    java.lang.Object getCONDITION_FALSE() -> a
    kotlinx.coroutines.internal.LockFreeLinkedListNode unwrap(java.lang.Object) -> b
kotlinx.coroutines.internal.LockFreeLinkedListNode -> kotlinx.coroutines.internal.m:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _removedRef$FU -> S2
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _next$FU -> Q2
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _prev$FU -> R2
    void access$finishAdd(kotlinx.coroutines.internal.LockFreeLinkedListNode,kotlinx.coroutines.internal.LockFreeLinkedListNode) -> h
    boolean addNext(kotlinx.coroutines.internal.LockFreeLinkedListNode,kotlinx.coroutines.internal.LockFreeLinkedListNode) -> i
    boolean addOneIfEmpty(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> j
    kotlinx.coroutines.internal.LockFreeLinkedListNode correctPrev(kotlinx.coroutines.internal.OpDescriptor) -> l
    kotlinx.coroutines.internal.LockFreeLinkedListNode findPrevNonRemoved(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> m
    void finishAdd(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> n
    java.lang.Object getNext() -> o
    kotlinx.coroutines.internal.LockFreeLinkedListNode getNextNode() -> p
    kotlinx.coroutines.internal.LockFreeLinkedListNode getPrevNode() -> q
    void helpRemove() -> r
    void helpRemovePrev() -> s
    boolean isRemoved() -> t
    boolean remove() -> u
    kotlinx.coroutines.internal.LockFreeLinkedListNode removeOrNext() -> v
    kotlinx.coroutines.internal.Removed removed() -> w
    int tryCondAddNext(kotlinx.coroutines.internal.LockFreeLinkedListNode,kotlinx.coroutines.internal.LockFreeLinkedListNode,kotlinx.coroutines.internal.LockFreeLinkedListNode$CondAddOp) -> x
kotlinx.coroutines.internal.LockFreeLinkedListNode$CondAddOp -> kotlinx.coroutines.internal.m$a:
    kotlinx.coroutines.internal.LockFreeLinkedListNode oldNext -> c
    kotlinx.coroutines.internal.LockFreeLinkedListNode newNode -> b
    void complete(java.lang.Object,java.lang.Object) -> d
    void complete(kotlinx.coroutines.internal.LockFreeLinkedListNode,java.lang.Object) -> h
kotlinx.coroutines.internal.LockFreeLinkedListNode$PrepareOp -> kotlinx.coroutines.internal.m$b:
kotlinx.coroutines.internal.LockFreeTaskQueue -> kotlinx.coroutines.internal.n:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _cur$FU -> a
    boolean addLast(java.lang.Object) -> a
    void close() -> b
    int getSize() -> c
    java.lang.Object removeFirstOrNull() -> d
kotlinx.coroutines.internal.LockFreeTaskQueueCore -> kotlinx.coroutines.internal.o:
    java.util.concurrent.atomic.AtomicLongFieldUpdater _state$FU -> g
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _next$FU -> f
    kotlinx.coroutines.internal.Symbol REMOVE_FROZEN -> h
    kotlinx.coroutines.internal.LockFreeTaskQueueCore$Companion Companion -> e
    java.util.concurrent.atomic.AtomicReferenceArray array -> d
    boolean singleConsumer -> b
    int mask -> c
    int capacity -> a
    int addLast(java.lang.Object) -> a
    kotlinx.coroutines.internal.LockFreeTaskQueueCore allocateNextCopy(long) -> b
    kotlinx.coroutines.internal.LockFreeTaskQueueCore allocateOrGetNextCopy(long) -> c
    boolean close() -> d
    kotlinx.coroutines.internal.LockFreeTaskQueueCore fillPlaceholder(int,java.lang.Object) -> e
    int getSize() -> f
    boolean isEmpty() -> g
    long markFrozen() -> h
    kotlinx.coroutines.internal.LockFreeTaskQueueCore next() -> i
    java.lang.Object removeFirstOrNull() -> j
    kotlinx.coroutines.internal.LockFreeTaskQueueCore removeSlowPath(int,int) -> k
kotlinx.coroutines.internal.LockFreeTaskQueueCore$Companion -> kotlinx.coroutines.internal.o$a:
    int addFailReason(long) -> a
    long updateHead(long,int) -> b
    long updateTail(long,int) -> c
    long wo(long,long) -> d
kotlinx.coroutines.internal.LockFreeTaskQueueCore$Placeholder -> kotlinx.coroutines.internal.o$b:
    int index -> a
kotlinx.coroutines.internal.MainDispatcherLoader -> kotlinx.coroutines.internal.p:
    kotlinx.coroutines.internal.MainDispatcherLoader INSTANCE -> a
    kotlinx.coroutines.MainCoroutineDispatcher dispatcher -> c
    boolean FAST_SERVICE_LOADER_ENABLED -> b
    kotlinx.coroutines.MainCoroutineDispatcher loadMainDispatcher() -> a
kotlinx.coroutines.internal.MainDispatchersKt -> kotlinx.coroutines.internal.q:
    boolean SUPPORT_MISSING -> a
    kotlinx.coroutines.internal.MissingMainCoroutineDispatcher createMissingDispatcher(java.lang.Throwable,java.lang.String) -> a
    kotlinx.coroutines.internal.MissingMainCoroutineDispatcher createMissingDispatcher$default(java.lang.Throwable,java.lang.String,int,java.lang.Object) -> b
    java.lang.Void throwMissingMainDispatcherException() -> c
    kotlinx.coroutines.MainCoroutineDispatcher tryCreateDispatcher(kotlinx.coroutines.internal.MainDispatcherFactory,java.util.List) -> d
kotlinx.coroutines.internal.MissingMainCoroutineDispatcher -> kotlinx.coroutines.internal.r:
    java.lang.Throwable cause -> R2
    java.lang.String errorHint -> S2
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> l
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> p
    kotlinx.coroutines.MainCoroutineDispatcher getImmediate() -> r
    java.lang.Void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> t
    java.lang.Void missing() -> u
kotlinx.coroutines.internal.OnUndeliveredElementKt -> kotlinx.coroutines.internal.s:
    kotlin.jvm.functions.Function1 bindCancellationFun(kotlin.jvm.functions.Function1,java.lang.Object,kotlin.coroutines.CoroutineContext) -> a
    void callUndeliveredElement(kotlin.jvm.functions.Function1,java.lang.Object,kotlin.coroutines.CoroutineContext) -> b
    kotlinx.coroutines.internal.UndeliveredElementException callUndeliveredElementCatchingException(kotlin.jvm.functions.Function1,java.lang.Object,kotlinx.coroutines.internal.UndeliveredElementException) -> c
    kotlinx.coroutines.internal.UndeliveredElementException callUndeliveredElementCatchingException$default(kotlin.jvm.functions.Function1,java.lang.Object,kotlinx.coroutines.internal.UndeliveredElementException,int,java.lang.Object) -> d
kotlinx.coroutines.internal.OnUndeliveredElementKt$bindCancellationFun$1 -> kotlinx.coroutines.internal.s$a:
    java.lang.Object $element -> R2
    kotlin.jvm.functions.Function1 $this_bindCancellationFun -> Q2
    kotlin.coroutines.CoroutineContext $context -> S2
    void invoke(java.lang.Throwable) -> a
kotlinx.coroutines.internal.OpDescriptor -> kotlinx.coroutines.internal.t:
    kotlinx.coroutines.internal.AtomicOp getAtomicOp() -> a
    boolean isEarlierThan(kotlinx.coroutines.internal.OpDescriptor) -> b
    java.lang.Object perform(java.lang.Object) -> c
kotlinx.coroutines.internal.Removed -> kotlinx.coroutines.internal.u:
    kotlinx.coroutines.internal.LockFreeLinkedListNode ref -> a
kotlinx.coroutines.internal.ScopeCoroutine -> kotlinx.coroutines.internal.v:
    kotlin.coroutines.Continuation uCont -> S2
    boolean isScopedCoroutine() -> U
    void afterResume(java.lang.Object) -> t0
    void afterCompletion(java.lang.Object) -> x
    kotlinx.coroutines.Job getParent$kotlinx_coroutines_core() -> x0
kotlinx.coroutines.internal.StackTraceRecoveryKt -> kotlinx.coroutines.internal.w:
    java.lang.String baseContinuationImplClassName -> a
    java.lang.String stackTraceRecoveryClassName -> b
    java.lang.Throwable recoverStackTrace(java.lang.Throwable) -> a
kotlinx.coroutines.internal.Symbol -> kotlinx.coroutines.internal.x:
    java.lang.String symbol -> a
kotlinx.coroutines.internal.SystemPropsKt -> kotlinx.coroutines.internal.y:
    int getAVAILABLE_PROCESSORS() -> a
    int systemProp(java.lang.String,int,int,int) -> b
    long systemProp(java.lang.String,long,long,long) -> c
    java.lang.String systemProp(java.lang.String) -> d
    boolean systemProp(java.lang.String,boolean) -> e
    int systemProp$default(java.lang.String,int,int,int,int,java.lang.Object) -> f
    long systemProp$default(java.lang.String,long,long,long,int,java.lang.Object) -> g
kotlinx.coroutines.internal.SystemPropsKt__SystemPropsKt -> kotlinx.coroutines.internal.z:
    int AVAILABLE_PROCESSORS -> a
    int getAVAILABLE_PROCESSORS() -> a
    java.lang.String systemProp(java.lang.String) -> b
kotlinx.coroutines.internal.SystemPropsKt__SystemProps_commonKt -> kotlinx.coroutines.internal.a0:
    int systemProp(java.lang.String,int,int,int) -> a
    long systemProp(java.lang.String,long,long,long) -> b
    boolean systemProp(java.lang.String,boolean) -> c
    int systemProp$default(java.lang.String,int,int,int,int,java.lang.Object) -> d
    long systemProp$default(java.lang.String,long,long,long,int,java.lang.Object) -> e
kotlinx.coroutines.internal.ThreadContextKt -> kotlinx.coroutines.internal.b0:
    kotlinx.coroutines.internal.Symbol NO_THREAD_ELEMENTS -> a
    kotlin.jvm.functions.Function2 findOne -> c
    kotlin.jvm.functions.Function2 countAll -> b
    kotlin.jvm.functions.Function2 updateState -> d
    void restoreThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> a
    java.lang.Object threadContextElements(kotlin.coroutines.CoroutineContext) -> b
    java.lang.Object updateThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> c
kotlinx.coroutines.internal.ThreadContextKt$countAll$1 -> kotlinx.coroutines.internal.b0$a:
    kotlinx.coroutines.internal.ThreadContextKt$countAll$1 INSTANCE -> Q2
    java.lang.Object invoke(java.lang.Object,kotlin.coroutines.CoroutineContext$Element) -> a
kotlinx.coroutines.internal.ThreadContextKt$findOne$1 -> kotlinx.coroutines.internal.b0$b:
    kotlinx.coroutines.internal.ThreadContextKt$findOne$1 INSTANCE -> Q2
    kotlinx.coroutines.ThreadContextElement invoke(kotlinx.coroutines.ThreadContextElement,kotlin.coroutines.CoroutineContext$Element) -> a
kotlinx.coroutines.internal.ThreadContextKt$updateState$1 -> kotlinx.coroutines.internal.b0$c:
    kotlinx.coroutines.internal.ThreadContextKt$updateState$1 INSTANCE -> Q2
    kotlinx.coroutines.internal.ThreadState invoke(kotlinx.coroutines.internal.ThreadState,kotlin.coroutines.CoroutineContext$Element) -> a
kotlinx.coroutines.internal.ThreadSafeHeap -> kotlinx.coroutines.internal.c0:
    void addImpl(kotlinx.coroutines.internal.ThreadSafeHeapNode) -> a
    kotlinx.coroutines.internal.ThreadSafeHeapNode firstImpl() -> b
    int getSize() -> c
    boolean isEmpty() -> d
    kotlinx.coroutines.internal.ThreadSafeHeapNode peek() -> e
    kotlinx.coroutines.internal.ThreadSafeHeapNode[] realloc() -> f
    boolean remove(kotlinx.coroutines.internal.ThreadSafeHeapNode) -> g
    kotlinx.coroutines.internal.ThreadSafeHeapNode removeAtImpl(int) -> h
    kotlinx.coroutines.internal.ThreadSafeHeapNode removeFirstOrNull() -> i
    void setSize(int) -> j
    void siftDownFrom(int) -> k
    void siftUpFrom(int) -> l
    void swap(int,int) -> m
kotlinx.coroutines.internal.ThreadSafeHeapNode -> kotlinx.coroutines.internal.d0:
    void setIndex(int) -> c
    void setHeap(kotlinx.coroutines.internal.ThreadSafeHeap) -> d
    kotlinx.coroutines.internal.ThreadSafeHeap getHeap() -> n
    int getIndex() -> x
kotlinx.coroutines.internal.ThreadState -> kotlinx.coroutines.internal.e0:
    java.lang.Object[] values -> b
    kotlinx.coroutines.ThreadContextElement[] elements -> c
    int i -> d
    kotlin.coroutines.CoroutineContext context -> a
    void append(kotlinx.coroutines.ThreadContextElement,java.lang.Object) -> a
    void restore(kotlin.coroutines.CoroutineContext) -> b
kotlinx.coroutines.internal.UndeliveredElementException -> kotlinx.coroutines.internal.f0:
kotlinx.coroutines.intrinsics.CancellableKt -> h4.a:
    void access$dispatcherFailure(kotlin.coroutines.Continuation,java.lang.Throwable) -> a
    void dispatcherFailure(kotlin.coroutines.Continuation,java.lang.Throwable) -> b
    void startCoroutineCancellable(kotlin.coroutines.Continuation,kotlin.coroutines.Continuation) -> c
    void startCoroutineCancellable(kotlin.jvm.functions.Function2,java.lang.Object,kotlin.coroutines.Continuation,kotlin.jvm.functions.Function1) -> d
    void startCoroutineCancellable$default(kotlin.jvm.functions.Function2,java.lang.Object,kotlin.coroutines.Continuation,kotlin.jvm.functions.Function1,int,java.lang.Object) -> e
kotlinx.coroutines.intrinsics.UndispatchedKt -> h4.b:
    void startCoroutineUndispatched(kotlin.jvm.functions.Function2,java.lang.Object,kotlin.coroutines.Continuation) -> a
    java.lang.Object startUndispatchedOrReturn(kotlinx.coroutines.internal.ScopeCoroutine,java.lang.Object,kotlin.jvm.functions.Function2) -> b
kotlinx.coroutines.scheduling.CoroutineScheduler -> kotlinx.coroutines.scheduling.a:
    java.util.concurrent.atomic.AtomicLongFieldUpdater controlState$FU -> Z2
    kotlinx.coroutines.scheduling.GlobalQueue globalBlockingQueue -> V2
    java.util.concurrent.atomic.AtomicReferenceArray workers -> W2
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _isTerminated$FU -> a3
    kotlinx.coroutines.internal.Symbol NOT_IN_STACK -> b3
    java.util.concurrent.atomic.AtomicLongFieldUpdater parkedWorkersStack$FU -> Y2
    kotlinx.coroutines.scheduling.GlobalQueue globalCpuQueue -> U2
    java.lang.String schedulerName -> T2
    long idleWorkerKeepAliveNs -> S2
    int corePoolSize -> Q2
    kotlinx.coroutines.scheduling.CoroutineScheduler$Companion Companion -> X2
    int maxPoolSize -> R2
    boolean addToGlobalQueue(kotlinx.coroutines.scheduling.Task) -> a
    int createNewWorker() -> b
    kotlinx.coroutines.scheduling.Task createTask(java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext) -> c
    kotlinx.coroutines.scheduling.CoroutineScheduler$Worker currentWorker() -> d
    void dispatch(java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext,boolean) -> e
    void dispatch$default(kotlinx.coroutines.scheduling.CoroutineScheduler,java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext,boolean,int,java.lang.Object) -> f
    boolean isTerminated() -> g
    int parkedWorkersStackNextIndex(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker) -> h
    kotlinx.coroutines.scheduling.CoroutineScheduler$Worker parkedWorkersStackPop() -> i
    boolean parkedWorkersStackPush(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker) -> j
    void parkedWorkersStackTopUpdate(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker,int,int) -> k
    void runSafely(kotlinx.coroutines.scheduling.Task) -> l
    void shutdown(long) -> m
    void signalBlockingWork(boolean) -> n
    void signalCpuWork() -> o
    kotlinx.coroutines.scheduling.Task submitToLocalQueue(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker,kotlinx.coroutines.scheduling.Task,boolean) -> p
    boolean tryCreateWorker(long) -> q
    boolean tryCreateWorker$default(kotlinx.coroutines.scheduling.CoroutineScheduler,long,int,java.lang.Object) -> r
    boolean tryUnpark() -> s
kotlinx.coroutines.scheduling.CoroutineScheduler$Companion -> kotlinx.coroutines.scheduling.a$a:
kotlinx.coroutines.scheduling.CoroutineScheduler$WhenMappings -> kotlinx.coroutines.scheduling.a$b:
    int[] $EnumSwitchMapping$0 -> a
kotlinx.coroutines.scheduling.CoroutineScheduler$Worker -> kotlinx.coroutines.scheduling.a$c:
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState state -> R2
    int rngState -> U2
    boolean mayHaveLocalTasks -> V2
    kotlinx.coroutines.scheduling.CoroutineScheduler this$0 -> W2
    long terminationDeadline -> S2
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater workerCtl$FU -> X2
    long minDelayUntilStealableTaskNs -> T2
    kotlinx.coroutines.scheduling.WorkQueue localQueue -> Q2
    void afterTask(int) -> a
    void beforeTask(int) -> b
    void executeTask(kotlinx.coroutines.scheduling.Task) -> c
    kotlinx.coroutines.scheduling.Task findAnyTask(boolean) -> d
    kotlinx.coroutines.scheduling.Task findTask(boolean) -> e
    int getIndexInArray() -> f
    java.lang.Object getNextParkedWorker() -> g
    void idleReset(int) -> h
    boolean inStack() -> i
    int nextInt(int) -> j
    void park() -> k
    kotlinx.coroutines.scheduling.Task pollGlobalQueues() -> l
    void runWorker() -> m
    void setIndexInArray(int) -> n
    void setNextParkedWorker(java.lang.Object) -> o
    boolean tryAcquireCpuPermit() -> p
    void tryPark() -> q
    boolean tryReleaseCpu(kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState) -> r
    kotlinx.coroutines.scheduling.Task trySteal(boolean) -> s
    void tryTerminateWorker() -> t
kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState -> kotlinx.coroutines.scheduling.a$d:
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState BLOCKING -> R2
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState[] $VALUES -> V2
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState PARKING -> S2
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState DORMANT -> T2
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState TERMINATED -> U2
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState CPU_ACQUIRED -> Q2
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState[] $values() -> a
kotlinx.coroutines.scheduling.DefaultScheduler -> kotlinx.coroutines.scheduling.b:
    kotlinx.coroutines.CoroutineDispatcher IO -> Y2
    kotlinx.coroutines.scheduling.DefaultScheduler INSTANCE -> X2
    kotlinx.coroutines.CoroutineDispatcher getIO() -> t
kotlinx.coroutines.scheduling.ExperimentalCoroutineDispatcher -> kotlinx.coroutines.scheduling.c:
    int corePoolSize -> S2
    int maxPoolSize -> T2
    kotlinx.coroutines.scheduling.CoroutineScheduler coroutineScheduler -> W2
    java.lang.String schedulerName -> V2
    long idleWorkerKeepAliveNs -> U2
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> l
    void dispatchYield(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> n
    kotlinx.coroutines.scheduling.CoroutineScheduler createScheduler() -> r
    void dispatchWithContext$kotlinx_coroutines_core(java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext,boolean) -> s
kotlinx.coroutines.scheduling.GlobalQueue -> kotlinx.coroutines.scheduling.d:
kotlinx.coroutines.scheduling.LimitingDispatcher -> kotlinx.coroutines.scheduling.e:
    int taskMode -> V2
    int parallelism -> T2
    java.lang.String name -> U2
    java.util.concurrent.ConcurrentLinkedQueue queue -> W2
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater inFlightTasks$FU -> X2
    kotlinx.coroutines.scheduling.ExperimentalCoroutineDispatcher dispatcher -> S2
    int getTaskMode() -> e
    void afterTask() -> h
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> l
    void dispatchYield(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> n
    void dispatch(java.lang.Runnable,boolean) -> r
kotlinx.coroutines.scheduling.NanoTimeSource -> kotlinx.coroutines.scheduling.f:
    kotlinx.coroutines.scheduling.NanoTimeSource INSTANCE -> a
    long nanoTime() -> a
kotlinx.coroutines.scheduling.NonBlockingContext -> kotlinx.coroutines.scheduling.g:
    kotlinx.coroutines.scheduling.NonBlockingContext INSTANCE -> Q2
    int taskMode -> R2
    int getTaskMode() -> e
    void afterTask() -> h
kotlinx.coroutines.scheduling.SchedulerTimeSource -> kotlinx.coroutines.scheduling.h:
    long nanoTime() -> a
kotlinx.coroutines.scheduling.Task -> kotlinx.coroutines.scheduling.i:
    long submissionTime -> Q2
    kotlinx.coroutines.scheduling.TaskContext taskContext -> R2
kotlinx.coroutines.scheduling.TaskContext -> kotlinx.coroutines.scheduling.j:
    int getTaskMode() -> e
    void afterTask() -> h
kotlinx.coroutines.scheduling.TaskImpl -> kotlinx.coroutines.scheduling.k:
    java.lang.Runnable block -> S2
kotlinx.coroutines.scheduling.TasksKt -> kotlinx.coroutines.scheduling.l:
    long IDLE_WORKER_KEEP_ALIVE_NS -> e
    kotlinx.coroutines.scheduling.SchedulerTimeSource schedulerTimeSource -> f
    long WORK_STEALING_TIME_RESOLUTION_NS -> a
    int MAX_POOL_SIZE -> d
    int BLOCKING_DEFAULT_PARALLELISM -> b
    int CORE_POOL_SIZE -> c
kotlinx.coroutines.scheduling.WorkQueue -> kotlinx.coroutines.scheduling.m:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater lastScheduledTask$FU -> b
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater blockingTasksInBuffer$FU -> e
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater consumerIndex$FU -> d
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater producerIndex$FU -> c
    java.util.concurrent.atomic.AtomicReferenceArray buffer -> a
    kotlinx.coroutines.scheduling.Task add(kotlinx.coroutines.scheduling.Task,boolean) -> a
    kotlinx.coroutines.scheduling.Task add$default(kotlinx.coroutines.scheduling.WorkQueue,kotlinx.coroutines.scheduling.Task,boolean,int,java.lang.Object) -> b
    kotlinx.coroutines.scheduling.Task addLast(kotlinx.coroutines.scheduling.Task) -> c
    void decrementIfBlocking(kotlinx.coroutines.scheduling.Task) -> d
    int getBufferSize$kotlinx_coroutines_core() -> e
    int getSize$kotlinx_coroutines_core() -> f
    void offloadAllWorkTo(kotlinx.coroutines.scheduling.GlobalQueue) -> g
    kotlinx.coroutines.scheduling.Task poll() -> h
    kotlinx.coroutines.scheduling.Task pollBuffer() -> i
    boolean pollTo(kotlinx.coroutines.scheduling.GlobalQueue) -> j
    long tryStealBlockingFrom(kotlinx.coroutines.scheduling.WorkQueue) -> k
    long tryStealFrom(kotlinx.coroutines.scheduling.WorkQueue) -> l
    long tryStealLastScheduled(kotlinx.coroutines.scheduling.WorkQueue,boolean) -> m
o2.DartMessenger$$ExternalSyntheticLambda0 -> o2.b:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    java.nio.ByteBuffer io.flutter.embedding.engine.dart.DartMessenger$$InternalSyntheticLambda$0$5dd8b6f7959f08bc8717eff7469e77e06ef5aed51cc0cee17f1e13794798223f$0.f$4 -> U2
    int io.flutter.embedding.engine.dart.DartMessenger$$InternalSyntheticLambda$0$5dd8b6f7959f08bc8717eff7469e77e06ef5aed51cc0cee17f1e13794798223f$0.f$2 -> S2
    long io.flutter.embedding.engine.dart.DartMessenger$$InternalSyntheticLambda$0$5dd8b6f7959f08bc8717eff7469e77e06ef5aed51cc0cee17f1e13794798223f$0.f$5 -> V2
    io.flutter.embedding.engine.dart.DartMessenger$HandlerInfo io.flutter.embedding.engine.dart.DartMessenger$$InternalSyntheticLambda$0$5dd8b6f7959f08bc8717eff7469e77e06ef5aed51cc0cee17f1e13794798223f$0.f$3 -> T2
    java.lang.String io.flutter.embedding.engine.dart.DartMessenger$$InternalSyntheticLambda$0$5dd8b6f7959f08bc8717eff7469e77e06ef5aed51cc0cee17f1e13794798223f$0.f$1 -> R2
    io.flutter.embedding.engine.dart.DartMessenger io.flutter.embedding.engine.dart.DartMessenger$$InternalSyntheticLambda$0$5dd8b6f7959f08bc8717eff7469e77e06ef5aed51cc0cee17f1e13794798223f$0.f$0 -> Q2
    void io.flutter.embedding.engine.dart.DartMessenger$$InternalSyntheticLambda$0$5dd8b6f7959f08bc8717eff7469e77e06ef5aed51cc0cee17f1e13794798223f$0.<init>(io.flutter.embedding.engine.dart.DartMessenger,java.lang.String,int,io.flutter.embedding.engine.dart.DartMessenger$HandlerInfo,java.nio.ByteBuffer,long) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.engine.dart.DartMessenger$$InternalSyntheticLambda$0$5dd8b6f7959f08bc8717eff7469e77e06ef5aed51cc0cee17f1e13794798223f$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
o2.DartMessenger$SerialTaskQueue$$ExternalSyntheticLambda0 -> o2.d:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue$$InternalSyntheticLambda$3$87f003a9f337bebdd0ba7a08cc7e573e8bd1ce25d26d2f3d3923593655f1df5b$0.f$0 -> Q2
    void io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue$$InternalSyntheticLambda$3$87f003a9f337bebdd0ba7a08cc7e573e8bd1ce25d26d2f3d3923593655f1df5b$0.<init>(io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue$$InternalSyntheticLambda$3$87f003a9f337bebdd0ba7a08cc7e573e8bd1ce25d26d2f3d3923593655f1df5b$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
o2.DartMessenger$SerialTaskQueue$$ExternalSyntheticLambda1 -> o2.e:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue$$InternalSyntheticLambda$4$3ee6262ba64b1eee4936869951254b05afe91be0eb2ccc94cd0abcb4f0e09adb$0.f$0 -> Q2
    void io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue$$InternalSyntheticLambda$4$3ee6262ba64b1eee4936869951254b05afe91be0eb2ccc94cd0abcb4f0e09adb$0.<init>(io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.engine.dart.DartMessenger$SerialTaskQueue$$InternalSyntheticLambda$4$3ee6262ba64b1eee4936869951254b05afe91be0eb2ccc94cd0abcb4f0e09adb$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
org.apache.xerces.dom.AttrImpl -> i4.a:
    java.lang.String name -> T2
    java.lang.Object type -> U2
    java.lang.Object value -> S2
    java.lang.String getNodeName() -> B
    org.w3c.dom.Node getLastChild() -> C
    void setValue(java.lang.String) -> F
    org.w3c.dom.Node getFirstChild() -> N
    org.w3c.dom.Node removeChild(org.w3c.dom.Node) -> R
    void setNodeValue(java.lang.String) -> T
    org.w3c.dom.NodeList getChildNodes() -> W
    org.w3c.dom.Element getOwnerElement() -> Z
    void setReadOnly(boolean,boolean) -> a1
    int getLength() -> c
    void checkNormalizationAfterInsert(org.apache.xerces.dom.ChildNode) -> c1
    org.w3c.dom.Node item(int) -> d
    boolean getSpecified() -> d0
    void checkNormalizationAfterRemove(org.apache.xerces.dom.ChildNode) -> d1
    java.lang.String getName() -> e
    org.w3c.dom.Node internalInsertBefore(org.w3c.dom.Node,org.w3c.dom.Node,boolean) -> e1
    org.w3c.dom.Node internalRemoveChild(org.w3c.dom.Node,boolean) -> f1
    org.apache.xerces.dom.ChildNode lastChild() -> g1
    void lastChild(org.apache.xerces.dom.ChildNode) -> h1
    void makeChildNode() -> i1
    org.w3c.dom.Node insertBefore(org.w3c.dom.Node,org.w3c.dom.Node) -> j
    void setIdAttribute(boolean) -> j1
    void setSpecified(boolean) -> k1
    void setType(java.lang.Object) -> l1
    void synchronizeChildren() -> m1
    short getNodeType() -> n0
    org.w3c.dom.Node cloneNode(boolean) -> p
    boolean hasChildNodes() -> w0
    java.lang.String getNodeValue() -> x
org.apache.xerces.dom.AttrNSImpl -> i4.b:
    java.lang.String localName -> W2
    java.lang.String namespaceURI -> V2
    java.lang.String getNamespaceURI() -> B0
    java.lang.String getPrefix() -> g
    void setName(java.lang.String,java.lang.String) -> n1
    java.lang.String getLocalName() -> r
org.apache.xerces.dom.AttributeMap -> i4.c:
    org.w3c.dom.Node setNamedItemNS(org.w3c.dom.Node) -> a
    org.w3c.dom.Node removeNamedItem(java.lang.String) -> b
    org.w3c.dom.Node setNamedItem(org.w3c.dom.Node) -> f
    void cloneContent(org.apache.xerces.dom.NamedNodeMapImpl) -> g
    org.apache.xerces.dom.NamedNodeMapImpl cloneMap(org.apache.xerces.dom.NodeImpl) -> h
    org.w3c.dom.Node internalRemoveNamedItem(java.lang.String,boolean) -> q
    org.w3c.dom.Node remove(org.apache.xerces.dom.AttrImpl,int,boolean) -> r
org.apache.xerces.dom.CDATASectionImpl -> i4.d:
    java.lang.String getNodeName() -> B
    short getNodeType() -> n0
org.apache.xerces.dom.CharacterDataImpl -> i4.e:
    java.lang.String data -> U2
    org.w3c.dom.NodeList singletonNodeList -> V2
    void setData(java.lang.String) -> D
    void setNodeValue(java.lang.String) -> T
    org.w3c.dom.NodeList getChildNodes() -> W
    int getLength() -> c
    void setNodeValueInternal(java.lang.String) -> d1
    void setNodeValueInternal(java.lang.String,boolean) -> e1
    java.lang.String getData() -> h
    void appendData(java.lang.String) -> o0
    java.lang.String getNodeValue() -> x
org.apache.xerces.dom.CharacterDataImpl$1 -> i4.e$a:
    int getLength() -> c
    org.w3c.dom.Node item(int) -> d
org.apache.xerces.dom.ChildNode -> i4.f:
    org.apache.xerces.dom.ChildNode nextSibling -> T2
    org.apache.xerces.dom.ChildNode previousSibling -> S2
    org.apache.xerces.dom.NodeImpl parentNode() -> Z0
    org.apache.xerces.dom.ChildNode previousSibling() -> c1
    org.w3c.dom.Node cloneNode(boolean) -> p
    org.w3c.dom.Node getPreviousSibling() -> t
    org.w3c.dom.Node getParentNode() -> u0
    org.w3c.dom.Node getNextSibling() -> y
org.apache.xerces.dom.CommentImpl -> i4.g:
    java.lang.String getNodeName() -> B
    short getNodeType() -> n0
org.apache.xerces.dom.CoreDOMImplementationImpl -> i4.h:
    int xml10DTDLoaderCurrentSize -> n
    int xml11DTDLoaderCurrentSize -> o
    int freeXML10DTDLoaderIndex -> l
    int freeXML11DTDLoaderIndex -> m
    int xml10DTDValidatorsCurrentSize -> h
    int xml11DTDValidatorsCurrentSize -> i
    java.lang.ref.SoftReference[] schemaValidators -> a
    int freeXML11DTDValidatorIndex -> f
    java.lang.ref.SoftReference[] xml10DTDValidators -> b
    int schemaValidatorsCurrentSize -> g
    java.lang.ref.SoftReference[] xml11DTDValidators -> c
    int freeSchemaValidatorIndex -> d
    int freeXML10DTDValidatorIndex -> e
    java.lang.ref.SoftReference[] xml10DTDLoaders -> j
    java.lang.ref.SoftReference[] xml11DTDLoaders -> k
    int docAndDoctypeCounter -> p
    org.apache.xerces.dom.CoreDOMImplementationImpl singleton -> q
    boolean hasFeature(java.lang.String,java.lang.String) -> a
    org.w3c.dom.DOMImplementation getDOMImplementation() -> b
org.apache.xerces.dom.CoreDocumentImpl -> i4.i:
    java.util.Map userData -> f3
    boolean allowGrammarAccess -> j3
    java.lang.Object fXPathEvaluator -> h3
    org.apache.xerces.dom.ElementImpl docElement -> Y2
    boolean standalone -> d3
    org.apache.xerces.dom.NodeListCache fFreeNLCache -> Z2
    int changes -> i3
    java.lang.String fDocumentURI -> e3
    int nodeCounter -> n3
    java.lang.String version -> c3
    int documentNumber -> m3
    org.apache.xerces.dom.DocumentTypeImpl docType -> X2
    java.lang.String actualEncoding -> b3
    java.util.Hashtable identifiers -> g3
    java.lang.String encoding -> a3
    int[] kidOK -> p3
    boolean xml11Version -> o3
    boolean xmlVersionChanged -> l3
    boolean errorChecking -> k3
    org.w3c.dom.Element createElement(java.lang.String) -> A0
    void freeNodeListCache(org.apache.xerces.dom.NodeListCache) -> A1
    java.lang.String getNodeName() -> B
    java.lang.String getBaseURI() -> B1
    void changed() -> C0
    java.lang.String getDocumentURI() -> C1
    boolean getMutationEvents() -> D1
    org.apache.xerces.dom.NodeListCache getNodeListCache(org.apache.xerces.dom.ParentNode) -> E1
    java.util.Hashtable getUserDataRecord(org.w3c.dom.Node) -> F1
    org.w3c.dom.Attr createAttributeNS(java.lang.String,java.lang.String) -> G
    java.lang.String getXmlVersion() -> G1
    org.w3c.dom.Node importNode(org.w3c.dom.Node,boolean,boolean,java.util.HashMap) -> H1
    void insertedNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean) -> I1
    void insertingNode(org.apache.xerces.dom.NodeImpl,boolean) -> J1
    org.w3c.dom.ProcessingInstruction createProcessingInstruction(java.lang.String,java.lang.String) -> K
    boolean isKidOK(org.w3c.dom.Node,org.w3c.dom.Node) -> K1
    boolean isXMLName(java.lang.String,boolean) -> L1
    void modifiedAttrValue(org.apache.xerces.dom.AttrImpl,java.lang.String) -> M1
    void modifiedCharacterData(org.apache.xerces.dom.NodeImpl,java.lang.String,java.lang.String,boolean) -> N1
    void modifyingCharacterData(org.apache.xerces.dom.NodeImpl,boolean) -> O1
    void putIdentifier(java.lang.String,org.w3c.dom.Element) -> P1
    void removeIdentifier(java.lang.String) -> Q1
    org.w3c.dom.Node removeChild(org.w3c.dom.Node) -> R
    void removedAttrNode(org.apache.xerces.dom.AttrImpl,org.apache.xerces.dom.NodeImpl,java.lang.String) -> R1
    void removedNode(org.apache.xerces.dom.NodeImpl,boolean) -> S1
    void removingNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean) -> T1
    void replacedText(org.apache.xerces.dom.CharacterDataImpl) -> U1
    void setAttrNode(org.apache.xerces.dom.AttrImpl,org.apache.xerces.dom.AttrImpl) -> V1
    void setDocumentURI(java.lang.String) -> W1
    void setInputEncoding(java.lang.String) -> X1
    void setMutationEvents(boolean) -> Y1
    void setStrictErrorChecking(boolean) -> Z1
    void setXmlEncoding(java.lang.String) -> a2
    void setXmlStandalone(boolean) -> b2
    void setXmlVersion(java.lang.String) -> c2
    org.w3c.dom.Attr createAttribute(java.lang.String) -> f0
    org.w3c.dom.Comment createComment(java.lang.String) -> h0
    org.w3c.dom.Node insertBefore(org.w3c.dom.Node,org.w3c.dom.Node) -> j
    org.w3c.dom.Document getOwnerDocument() -> j0
    org.w3c.dom.Element createElementNS(java.lang.String,java.lang.String) -> k0
    org.w3c.dom.CDATASection createCDATASection(java.lang.String) -> m
    org.w3c.dom.Text createTextNode(java.lang.String) -> m0
    void callUserDataHandlers(org.w3c.dom.Node,org.w3c.dom.Node,short) -> m1
    short getNodeType() -> n0
    void callUserDataHandlers(org.w3c.dom.Node,org.w3c.dom.Node,short,java.util.Hashtable) -> n1
    void checkDOMNSErr(java.lang.String,java.lang.String) -> o1
    org.w3c.dom.Node cloneNode(boolean) -> p
    void checkNamespaceWF(java.lang.String,int,int) -> p1
    org.w3c.dom.DOMImplementation getImplementation() -> q0
    void checkQName(java.lang.String,java.lang.String) -> q1
    void cloneNode(org.apache.xerces.dom.CoreDocumentImpl,boolean) -> r1
    org.w3c.dom.Attr createAttributeNS(java.lang.String,java.lang.String,java.lang.String) -> s1
    org.w3c.dom.DocumentFragment createDocumentFragment() -> t1
    org.w3c.dom.DocumentType getDoctype() -> u
    org.w3c.dom.DocumentType createDocumentType(java.lang.String,java.lang.String,java.lang.String) -> u1
    org.w3c.dom.EntityReference createEntityReference(java.lang.String) -> v0
    org.apache.xerces.dom.ElementDefinitionImpl createElementDefinition(java.lang.String) -> v1
    org.w3c.dom.Element createElementNS(java.lang.String,java.lang.String,java.lang.String) -> w1
    org.w3c.dom.Entity createEntity(java.lang.String) -> x1
    org.w3c.dom.Notation createNotation(java.lang.String) -> y1
    boolean dispatchEvent(org.apache.xerces.dom.NodeImpl,org.w3c.dom.events.Event) -> z1
org.apache.xerces.dom.DOMImplementationImpl -> i4.j:
    org.apache.xerces.dom.DOMImplementationImpl singleton -> r
    boolean hasFeature(java.lang.String,java.lang.String) -> a
    org.w3c.dom.DOMImplementation getDOMImplementation() -> b
org.apache.xerces.dom.DOMImplementationSourceImpl -> i4.k:
org.apache.xerces.dom.DOMMessageFormatter -> i4.l:
    java.util.ResourceBundle serResourceBundle -> c
    java.util.ResourceBundle xmlResourceBundle -> b
    java.util.Locale locale -> d
    java.util.ResourceBundle domResourceBundle -> a
    java.lang.String formatMessage(java.lang.String,java.lang.String,java.lang.Object[]) -> a
    java.util.ResourceBundle getResourceBundle(java.lang.String) -> b
    void init() -> c
org.apache.xerces.dom.DOMXSImplementationSourceImpl -> i4.m:
org.apache.xerces.dom.DeferredAttrImpl -> i4.n:
    int fNodeIndex -> V2
    int getNodeIndex() -> X
    void synchronizeData() -> b1
    void synchronizeChildren() -> m1
org.apache.xerces.dom.DeferredAttrNSImpl -> i4.o:
    int fNodeIndex -> X2
    int getNodeIndex() -> X
    void synchronizeData() -> b1
    void synchronizeChildren() -> m1
org.apache.xerces.dom.DeferredCDATASectionImpl -> i4.p:
    int fNodeIndex -> W2
    int getNodeIndex() -> X
    void synchronizeData() -> b1
org.apache.xerces.dom.DeferredCommentImpl -> i4.q:
    int fNodeIndex -> W2
    int getNodeIndex() -> X
    void synchronizeData() -> b1
org.apache.xerces.dom.DeferredDOMImplementationImpl -> i4.r:
    org.apache.xerces.dom.DeferredDOMImplementationImpl singleton -> s
    org.w3c.dom.DOMImplementation getDOMImplementation() -> b
org.apache.xerces.dom.DeferredDocumentImpl -> i4.s:
    java.lang.Object[][] fNodeURI -> E3
    int fIdCount -> G3
    boolean fNamespacesEnabled -> J3
    java.lang.StringBuffer fBufferStr -> K3
    java.util.ArrayList fStrChunks -> L3
    int[][] fNodeType -> y3
    java.lang.Object[][] fNodeValue -> A3
    int[][] fNodeLastChild -> C3
    int[][] fNodeParent -> B3
    int[][] fNodePrevSib -> D3
    int fNodeCount -> x3
    java.lang.Object[][] fNodeName -> z3
    int[][] fNodeExtra -> F3
    java.lang.String[] fIdName -> H3
    int[] INIT_ARRAY -> M3
    int[] fIdElement -> I3
    void createChunk(java.lang.Object[][],int) -> A2
    void setTypeInfo(int,java.lang.Object) -> A3
    int createDeferredAttribute(java.lang.String,java.lang.String,java.lang.String,boolean) -> B2
    void synchronizeChildren(org.apache.xerces.dom.AttrImpl,int) -> B3
    int createDeferredCDATASection(java.lang.String) -> C2
    void synchronizeChildren(org.apache.xerces.dom.ParentNode,int) -> C3
    int createDeferredComment(java.lang.String) -> D2
    int createDeferredDocument() -> E2
    int createDeferredDocumentType(java.lang.String,java.lang.String,java.lang.String) -> F2
    int createDeferredElement(java.lang.String,java.lang.String) -> G2
    int createDeferredElementDefinition(java.lang.String) -> H2
    int createDeferredEntity(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> I2
    int createDeferredEntityReference(java.lang.String,java.lang.String) -> J2
    int createDeferredNotation(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> K2
    int createDeferredProcessingInstruction(java.lang.String,java.lang.String) -> L2
    int createDeferredTextNode(java.lang.String,boolean) -> M2
    int createNode(short) -> N2
    void ensureCapacity(int) -> O2
    int getChunkIndex(int[][],int,int) -> P2
    java.lang.String getChunkValue(java.lang.Object[][],int,int) -> Q2
    java.lang.String getDeferredEntityBaseURI(int) -> R2
    int getLastChild(int) -> S2
    int getLastChild(int,boolean) -> T2
    int getNodeExtra(int) -> U2
    int getNodeExtra(int,boolean) -> V2
    java.lang.String getNodeName(int) -> W2
    int getNodeIndex() -> X
    java.lang.String getNodeName(int,boolean) -> X2
    org.apache.xerces.dom.DeferredNode getNodeObject(int) -> Y2
    short getNodeType(int) -> Z2
    short getNodeType(int,boolean) -> a3
    void synchronizeData() -> b1
    java.lang.String getNodeURI(int) -> b3
    java.lang.String getNodeURI(int,boolean) -> c3
    java.lang.String getNodeValue(int) -> d3
    java.lang.String getNodeValue(int,boolean) -> e3
    java.lang.String getNodeValueString(int) -> f3
    java.lang.String getNodeValueString(int,boolean) -> g3
    int getParentNode(int,boolean) -> h3
    int getPrevSibling(int) -> i3
    int getPrevSibling(int,boolean) -> j3
    int getRealPrevSibling(int) -> k3
    void synchronizeChildren() -> l1
    int getRealPrevSibling(int,boolean) -> l3
    java.lang.Object getTypeInfo(int) -> m3
    int insertBefore(int,int,int) -> n3
    int lookupElementDefinition(java.lang.String) -> o3
    void putIdentifier(java.lang.String,int) -> p3
    org.w3c.dom.DOMImplementation getImplementation() -> q0
    void putIdentifier0(java.lang.String,org.w3c.dom.Element) -> q3
    void setAsLastChild(int,int) -> r3
    int setChunkIndex(int[][],int,int,int) -> s3
    java.lang.String setChunkValue(java.lang.Object[][],java.lang.Object,int,int) -> t3
    void appendChild(int,int) -> u2
    int setDeferredAttribute(int,java.lang.String,java.lang.String,java.lang.String,boolean) -> u3
    int binarySearch(int[],int,int,int) -> v2
    int setDeferredAttribute(int,java.lang.String,java.lang.String,java.lang.String,boolean,boolean,java.lang.Object) -> v3
    int clearChunkIndex(int[][],int,int) -> w2
    void setEntityInfo(int,java.lang.String,java.lang.String) -> w3
    java.lang.String clearChunkValue(java.lang.Object[][],int,int) -> x2
    void setIdAttribute(int) -> x3
    int cloneNode(int,boolean) -> y2
    void setInputEncoding(int,java.lang.String) -> y3
    void createChunk(int[][],int) -> z2
    void setInternalSubset(int,java.lang.String) -> z3
org.apache.xerces.dom.DeferredDocumentImpl$IntVector -> i4.s$a:
    int[] data -> a
    int size -> b
    void addElement(int) -> a
    int elementAt(int) -> b
    void ensureCapacity(int) -> c
    void removeAllElements() -> d
    int size() -> e
org.apache.xerces.dom.DeferredDocumentImpl$RefCount -> i4.s$b:
    int fCount -> a
org.apache.xerces.dom.DeferredDocumentTypeImpl -> i4.t:
    int fNodeIndex -> g3
    int getNodeIndex() -> X
    void synchronizeData() -> b1
    void synchronizeChildren() -> l1
org.apache.xerces.dom.DeferredElementDefinitionImpl -> i4.u:
    int fNodeIndex -> Z2
    int getNodeIndex() -> X
    void synchronizeData() -> b1
    void synchronizeChildren() -> l1
org.apache.xerces.dom.DeferredElementImpl -> i4.v:
    int fNodeIndex -> Z2
    int getNodeIndex() -> X
    void synchronizeData() -> b1
    void synchronizeChildren() -> l1
org.apache.xerces.dom.DeferredElementNSImpl -> i4.w:
    int fNodeIndex -> c3
    int getNodeIndex() -> X
    void synchronizeData() -> b1
    void synchronizeChildren() -> l1
org.apache.xerces.dom.DeferredEntityImpl -> i4.x:
    int fNodeIndex -> f3
    int getNodeIndex() -> X
    void synchronizeData() -> b1
    void synchronizeChildren() -> l1
org.apache.xerces.dom.DeferredEntityReferenceImpl -> i4.y:
    int fNodeIndex -> Z2
    int getNodeIndex() -> X
    void synchronizeData() -> b1
    void synchronizeChildren() -> l1
org.apache.xerces.dom.DeferredNode -> i4.z:
    int getNodeIndex() -> X
org.apache.xerces.dom.DeferredNotationImpl -> i4.a0:
    int fNodeIndex -> W2
    int getNodeIndex() -> X
    void synchronizeData() -> b1
org.apache.xerces.dom.DeferredProcessingInstructionImpl -> i4.b0:
    int fNodeIndex -> X2
    int getNodeIndex() -> X
    void synchronizeData() -> b1
org.apache.xerces.dom.DeferredTextImpl -> i4.c0:
    int fNodeIndex -> W2
    int getNodeIndex() -> X
    void synchronizeData() -> b1
org.apache.xerces.dom.DocumentFragmentImpl -> i4.d0:
    java.lang.String getNodeName() -> B
    short getNodeType() -> n0
org.apache.xerces.dom.DocumentImpl -> i4.e0:
    java.util.List ranges -> s3
    java.util.List iterators -> q3
    java.util.Hashtable eventListeners -> u3
    boolean mutationEvents -> v3
    java.lang.ref.ReferenceQueue iteratorReferenceQueue -> r3
    java.lang.ref.ReferenceQueue rangeReferenceQueue -> t3
    org.apache.xerces.dom.DocumentImpl$EnclosingAttr savedEnclosingAttr -> w3
    boolean getMutationEvents() -> D1
    void insertedNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean) -> I1
    void insertingNode(org.apache.xerces.dom.NodeImpl,boolean) -> J1
    void modifiedAttrValue(org.apache.xerces.dom.AttrImpl,java.lang.String) -> M1
    void modifiedCharacterData(org.apache.xerces.dom.NodeImpl,java.lang.String,java.lang.String,boolean) -> N1
    void modifyingCharacterData(org.apache.xerces.dom.NodeImpl,boolean) -> O1
    void removedAttrNode(org.apache.xerces.dom.AttrImpl,org.apache.xerces.dom.NodeImpl,java.lang.String) -> R1
    void removedNode(org.apache.xerces.dom.NodeImpl,boolean) -> S1
    void removingNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean) -> T1
    void replacedText(org.apache.xerces.dom.CharacterDataImpl) -> U1
    void setAttrNode(org.apache.xerces.dom.AttrImpl,org.apache.xerces.dom.AttrImpl) -> V1
    void setMutationEvents(boolean) -> Y1
    void dispatchAggregateEvents(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.AttrImpl,java.lang.String,short) -> d2
    void dispatchAggregateEvents(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.DocumentImpl$EnclosingAttr) -> e2
    void dispatchEventToSubtree(org.w3c.dom.Node,org.w3c.dom.events.Event) -> f2
    void dispatchingEventToSubtree(org.w3c.dom.Node,org.w3c.dom.events.Event) -> g2
    java.util.Vector getEventListeners(org.apache.xerces.dom.NodeImpl) -> h2
    void mutationEventsInsertedNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean) -> i2
    void mutationEventsModifiedCharacterData(org.apache.xerces.dom.NodeImpl,java.lang.String,java.lang.String,boolean) -> j2
    void mutationEventsRemovedAttrNode(org.apache.xerces.dom.AttrImpl,org.apache.xerces.dom.NodeImpl,java.lang.String) -> k2
    void mutationEventsRemovingNode(org.apache.xerces.dom.NodeImpl,org.apache.xerces.dom.NodeImpl,boolean) -> l2
    void notifyIteratorsRemovingNode(org.apache.xerces.dom.NodeImpl) -> m2
    void notifyRangesInsertedNode(org.apache.xerces.dom.NodeImpl) -> n2
    void notifyRangesRemovingNode(org.apache.xerces.dom.NodeImpl) -> o2
    org.w3c.dom.Node cloneNode(boolean) -> p
    void notifyRangesReplacedText(org.apache.xerces.dom.CharacterDataImpl) -> p2
    org.w3c.dom.DOMImplementation getImplementation() -> q0
    void removeStaleIteratorReferences() -> q2
    void removeStaleRangeReferences() -> r2
    void removeStaleReferences(java.lang.ref.ReferenceQueue,java.util.List) -> s2
    void saveEnclosingAttr(org.apache.xerces.dom.NodeImpl) -> t2
    boolean dispatchEvent(org.apache.xerces.dom.NodeImpl,org.w3c.dom.events.Event) -> z1
org.apache.xerces.dom.DocumentImpl$EnclosingAttr -> i4.e0$a:
    org.apache.xerces.dom.DocumentImpl this$0 -> S2
    org.apache.xerces.dom.AttrImpl node -> Q2
    java.lang.String oldvalue -> R2
org.apache.xerces.dom.DocumentImpl$LEntry -> i4.e0$b:
    org.w3c.dom.events.EventListener listener -> R2
    boolean useCapture -> S2
    java.lang.String type -> Q2
org.apache.xerces.dom.DocumentTypeImpl -> i4.f0:
    org.apache.xerces.dom.NamedNodeMapImpl entities -> Y2
    org.apache.xerces.dom.NamedNodeMapImpl notations -> Z2
    int doctypeNumber -> e3
    java.lang.String name -> X2
    org.apache.xerces.dom.NamedNodeMapImpl elements -> a3
    java.lang.String internalSubset -> d3
    java.lang.String systemID -> c3
    java.lang.String publicID -> b3
    java.util.Hashtable userData -> f3
    java.lang.String getNodeName() -> B
    java.util.Hashtable getUserDataRecord() -> E0
    java.lang.String getPublicId() -> a
    void setReadOnly(boolean,boolean) -> a1
    java.lang.String getSystemId() -> b
    java.lang.String getInternalSubset() -> k
    org.w3c.dom.NamedNodeMap getElements() -> m1
    short getNodeType() -> n0
    void setInternalSubset(java.lang.String) -> n1
    org.w3c.dom.NamedNodeMap getEntities() -> o
    org.w3c.dom.Node cloneNode(boolean) -> p
    org.w3c.dom.NamedNodeMap getNotations() -> w
org.apache.xerces.dom.ElementDefinitionImpl -> i4.g0:
    org.apache.xerces.dom.NamedNodeMapImpl attributes -> Y2
    java.lang.String name -> X2
    java.lang.String getNodeName() -> B
    short getNodeType() -> n0
    org.w3c.dom.Node cloneNode(boolean) -> p
    org.w3c.dom.NamedNodeMap getAttributes() -> t0
org.apache.xerces.dom.ElementImpl -> i4.h0:
    org.apache.xerces.dom.AttributeMap attributes -> Y2
    java.lang.String name -> X2
    org.w3c.dom.Attr setAttributeNode(org.w3c.dom.Attr) -> A
    java.lang.String getNodeName() -> B
    boolean hasAttributes() -> E
    org.w3c.dom.Attr setAttributeNodeNS(org.w3c.dom.Attr) -> H
    org.w3c.dom.Attr getAttributeNode(java.lang.String) -> U
    void setAttribute(java.lang.String,java.lang.String) -> Y
    void setReadOnly(boolean,boolean) -> a1
    void synchronizeData() -> b1
    org.apache.xerces.dom.NamedNodeMapImpl getDefaultAttributes() -> m1
    short getNodeType() -> n0
    void setIdAttributeNode(org.w3c.dom.Attr,boolean) -> n1
    void setupDefaultAttributes() -> o1
    org.w3c.dom.Node cloneNode(boolean) -> p
    org.w3c.dom.Attr getAttributeNodeNS(java.lang.String,java.lang.String) -> p0
    void setAttributeNS(java.lang.String,java.lang.String,java.lang.String) -> s
    org.w3c.dom.NamedNodeMap getAttributes() -> t0
org.apache.xerces.dom.ElementNSImpl -> i4.i0:
    java.lang.String namespaceURI -> Z2
    org.apache.xerces.xs.XSTypeDefinition type -> b3
    java.lang.String localName -> a3
    java.lang.String getNamespaceURI() -> B0
    java.lang.String getPrefix() -> g
    void setName(java.lang.String,java.lang.String) -> p1
    void setType(org.apache.xerces.xs.XSTypeDefinition) -> q1
    java.lang.String getLocalName() -> r
org.apache.xerces.dom.EntityImpl -> i4.j0:
    java.lang.String systemId -> Z2
    java.lang.String publicId -> Y2
    java.lang.String name -> X2
    java.lang.String baseURI -> e3
    java.lang.String notationName -> d3
    java.lang.String version -> c3
    java.lang.String inputEncoding -> b3
    java.lang.String encoding -> a3
    java.lang.String getNodeName() -> B
    java.lang.String getPublicId() -> a
    java.lang.String getSystemId() -> b
    java.lang.String getNotationName() -> l0
    java.lang.String getBaseURI() -> m1
    short getNodeType() -> n0
    void setBaseURI(java.lang.String) -> n1
    void setInputEncoding(java.lang.String) -> o1
    org.w3c.dom.Node cloneNode(boolean) -> p
    void setNotationName(java.lang.String) -> p1
    void setPublicId(java.lang.String) -> q1
    void setSystemId(java.lang.String) -> r1
    void setXmlEncoding(java.lang.String) -> s1
    void setXmlVersion(java.lang.String) -> t1
org.apache.xerces.dom.EntityReferenceImpl -> i4.k0:
    java.lang.String baseURI -> Y2
    java.lang.String name -> X2
    java.lang.String getNodeName() -> B
    void setReadOnly(boolean,boolean) -> a1
    void synchronizeChildren() -> l1
    java.lang.String getBaseURI() -> m1
    short getNodeType() -> n0
    java.lang.String getEntityRefValue() -> n1
    void setBaseURI(java.lang.String) -> o1
    org.w3c.dom.Node cloneNode(boolean) -> p
org.apache.xerces.dom.LCount -> i4.l0:
    java.util.Hashtable lCounts -> d
    int bubbles -> b
    int total -> c
    int captures -> a
    org.apache.xerces.dom.LCount lookup(java.lang.String) -> a
org.apache.xerces.dom.NamedNodeMapImpl -> i4.m0:
    org.apache.xerces.dom.NodeImpl ownerNode -> S2
    java.util.List nodes -> R2
    short flags -> Q2
    org.w3c.dom.Node setNamedItemNS(org.w3c.dom.Node) -> a
    org.w3c.dom.Node removeNamedItem(java.lang.String) -> b
    int getLength() -> c
    org.w3c.dom.Node item(int) -> d
    org.w3c.dom.Node getNamedItem(java.lang.String) -> e
    org.w3c.dom.Node setNamedItem(org.w3c.dom.Node) -> f
    void cloneContent(org.apache.xerces.dom.NamedNodeMapImpl) -> g
    org.apache.xerces.dom.NamedNodeMapImpl cloneMap(org.apache.xerces.dom.NodeImpl) -> h
    int findNamePoint(java.lang.String,int) -> i
    int findNamePoint(java.lang.String,java.lang.String) -> j
    org.w3c.dom.Node getNamedItemNS(java.lang.String,java.lang.String) -> k
    void hasDefaults(boolean) -> l
    boolean hasDefaults() -> m
    void isReadOnly(boolean) -> n
    boolean isReadOnly() -> o
    void setReadOnly(boolean,boolean) -> p
org.apache.xerces.dom.NodeImpl -> i4.n0:
    org.apache.xerces.dom.NodeImpl ownerNode -> Q2
    short flags -> R2
    java.lang.String getNodeName() -> B
    java.lang.String getNamespaceURI() -> B0
    org.w3c.dom.Node getLastChild() -> C
    void changed() -> C0
    boolean dispatchEvent(org.w3c.dom.events.Event) -> D0
    boolean hasAttributes() -> E
    java.util.Hashtable getUserDataRecord() -> E0
    void hasStringValue(boolean) -> F0
    boolean hasStringValue() -> G0
    void isFirstChild(boolean) -> H0
    boolean isFirstChild() -> I0
    void isIdAttribute(boolean) -> J0
    boolean isIdAttribute() -> K0
    void isIgnorableWhitespace(boolean) -> L0
    void isNormalized(boolean) -> M0
    org.w3c.dom.Node getFirstChild() -> N
    boolean isNormalized() -> N0
    void isOwned(boolean) -> O0
    boolean isOwned() -> P0
    void isReadOnly(boolean) -> Q0
    org.w3c.dom.Node removeChild(org.w3c.dom.Node) -> R
    boolean isReadOnly() -> R0
    void isSpecified(boolean) -> S0
    void setNodeValue(java.lang.String) -> T
    boolean isSpecified() -> T0
    void needsSyncChildren(boolean) -> U0
    boolean needsSyncChildren() -> V0
    org.w3c.dom.NodeList getChildNodes() -> W
    void needsSyncData(boolean) -> W0
    boolean needsSyncData() -> X0
    org.apache.xerces.dom.CoreDocumentImpl ownerDocument() -> Y0
    org.apache.xerces.dom.NodeImpl parentNode() -> Z0
    void setReadOnly(boolean,boolean) -> a1
    void synchronizeData() -> b1
    int getLength() -> c
    org.w3c.dom.Node item(int) -> d
    java.lang.String getPrefix() -> g
    org.w3c.dom.Node insertBefore(org.w3c.dom.Node,org.w3c.dom.Node) -> j
    org.w3c.dom.Document getOwnerDocument() -> j0
    short getNodeType() -> n0
    org.w3c.dom.Node cloneNode(boolean) -> p
    java.lang.String getLocalName() -> r
    org.w3c.dom.Node appendChild(org.w3c.dom.Node) -> r0
    org.w3c.dom.Node getPreviousSibling() -> t
    org.w3c.dom.NamedNodeMap getAttributes() -> t0
    org.w3c.dom.Node getParentNode() -> u0
    boolean hasChildNodes() -> w0
    java.lang.String getNodeValue() -> x
    org.w3c.dom.Node getNextSibling() -> y
org.apache.xerces.dom.NodeIteratorImpl -> i4.o0:
    org.w3c.dom.Node fCurrentNode -> b
    org.w3c.dom.Node fRoot -> a
    boolean fForward -> c
    boolean fEntityReferenceExpansion -> d
    org.w3c.dom.Node matchNodeOrParent(org.w3c.dom.Node) -> a
    org.w3c.dom.Node nextNode(org.w3c.dom.Node,boolean) -> b
    org.w3c.dom.Node previousNode(org.w3c.dom.Node) -> c
    void removeNode(org.w3c.dom.Node) -> d
org.apache.xerces.dom.NodeListCache -> i4.p0:
    org.apache.xerces.dom.ChildNode fChild -> S2
    org.apache.xerces.dom.NodeListCache next -> U2
    org.apache.xerces.dom.ParentNode fOwner -> T2
    int fLength -> Q2
    int fChildIndex -> R2
org.apache.xerces.dom.NotationImpl -> i4.q0:
    java.lang.String baseURI -> V2
    java.lang.String systemId -> U2
    java.lang.String publicId -> T2
    java.lang.String name -> S2
    java.lang.String getNodeName() -> B
    java.lang.String getPublicId() -> a
    java.lang.String getSystemId() -> b
    void setBaseURI(java.lang.String) -> c1
    void setPublicId(java.lang.String) -> d1
    void setSystemId(java.lang.String) -> e1
    short getNodeType() -> n0
org.apache.xerces.dom.ObjectFactory -> i4.r0:
    java.util.Properties fXercesProperties -> b
    long fLastModified -> c
    boolean DEBUG -> a
    java.lang.ClassLoader findClassLoader() -> a
    java.lang.Class findProviderClass(java.lang.String,java.lang.ClassLoader,boolean) -> b
    boolean isDebugEnabled() -> c
org.apache.xerces.dom.PSVIAttrNSImpl -> i4.s0:
    org.apache.xerces.impl.dv.ValidatedInfo fValue -> a3
    org.apache.xerces.xs.StringList fErrorCodes -> d3
    java.lang.String fValidationContext -> f3
    org.apache.xerces.xs.StringList fErrorMessages -> e3
    short fValidity -> c3
    org.apache.xerces.xs.XSAttributeDeclaration fDeclaration -> X2
    org.apache.xerces.xs.XSTypeDefinition fTypeDecl -> Y2
    boolean fSpecified -> Z2
    short fValidationAttempted -> b3
    org.apache.xerces.xs.XSValue getSchemaValue() -> I
    boolean getIsSchemaSpecified() -> J
    java.lang.String getValidationContext() -> O
    short getValidationAttempted() -> Q
    org.apache.xerces.xs.XSTypeDefinition getTypeDefinition() -> f
    org.apache.xerces.xs.XSSimpleTypeDefinition getMemberTypeDefinition() -> i
    org.apache.xerces.xs.StringList getErrorMessages() -> i0
    short getValidity() -> l
    org.apache.xerces.xs.XSAttributeDeclaration getAttributeDeclaration() -> n
    void setPSVI(org.apache.xerces.xs.AttributePSVI) -> o1
    org.apache.xerces.xs.StringList getErrorCodes() -> z0
org.apache.xerces.dom.PSVIDOMImplementationImpl -> i4.t0:
    org.apache.xerces.dom.PSVIDOMImplementationImpl singleton -> s
    boolean hasFeature(java.lang.String,java.lang.String) -> a
    org.w3c.dom.DOMImplementation getDOMImplementation() -> b
org.apache.xerces.dom.PSVIDocumentImpl -> i4.u0:
    org.w3c.dom.Attr createAttributeNS(java.lang.String,java.lang.String) -> G
    org.w3c.dom.Element createElementNS(java.lang.String,java.lang.String) -> k0
    org.w3c.dom.Node cloneNode(boolean) -> p
    org.w3c.dom.DOMImplementation getImplementation() -> q0
    org.w3c.dom.Attr createAttributeNS(java.lang.String,java.lang.String,java.lang.String) -> s1
    org.w3c.dom.Element createElementNS(java.lang.String,java.lang.String,java.lang.String) -> w1
org.apache.xerces.dom.PSVIElementNSImpl -> i4.v0:
    java.lang.String fValidationContext -> m3
    org.apache.xerces.xs.XSNotationDeclaration fNotation -> h3
    short fValidity -> j3
    short fValidationAttempted -> i3
    boolean fNil -> e3
    org.apache.xerces.impl.dv.ValidatedInfo fValue -> g3
    boolean fSpecified -> f3
    org.apache.xerces.xs.XSTypeDefinition fTypeDecl -> d3
    org.apache.xerces.xs.XSElementDeclaration fDeclaration -> c3
    org.apache.xerces.xs.StringList fErrorCodes -> k3
    org.apache.xerces.xs.StringList fErrorMessages -> l3
    org.apache.xerces.xs.XSModel fSchemaInformation -> n3
    org.apache.xerces.xs.XSValue getSchemaValue() -> I
    boolean getIsSchemaSpecified() -> J
    java.lang.String getValidationContext() -> O
    short getValidationAttempted() -> Q
    org.apache.xerces.xs.XSNotationDeclaration getNotation() -> a0
    boolean getNil() -> e0
    org.apache.xerces.xs.XSTypeDefinition getTypeDefinition() -> f
    org.apache.xerces.xs.XSSimpleTypeDefinition getMemberTypeDefinition() -> i
    org.apache.xerces.xs.StringList getErrorMessages() -> i0
    short getValidity() -> l
    void setPSVI(org.apache.xerces.xs.ElementPSVI) -> r1
    org.apache.xerces.xs.XSElementDeclaration getElementDeclaration() -> s0
    org.apache.xerces.xs.XSModel getSchemaInformation() -> y0
    org.apache.xerces.xs.StringList getErrorCodes() -> z0
org.apache.xerces.dom.ParentNode -> i4.w0:
    org.apache.xerces.dom.CoreDocumentImpl ownerDocument -> U2
    org.apache.xerces.dom.ChildNode firstChild -> V2
    org.apache.xerces.dom.NodeListCache fNodeListCache -> W2
    org.w3c.dom.Node getLastChild() -> C
    org.w3c.dom.Node getFirstChild() -> N
    org.w3c.dom.Node removeChild(org.w3c.dom.Node) -> R
    org.w3c.dom.NodeList getChildNodes() -> W
    org.apache.xerces.dom.CoreDocumentImpl ownerDocument() -> Y0
    void setReadOnly(boolean,boolean) -> a1
    int getLength() -> c
    org.w3c.dom.Node item(int) -> d
    void checkNormalizationAfterInsert(org.apache.xerces.dom.ChildNode) -> d1
    void checkNormalizationAfterRemove(org.apache.xerces.dom.ChildNode) -> e1
    org.w3c.dom.Node internalInsertBefore(org.w3c.dom.Node,org.w3c.dom.Node,boolean) -> f1
    org.w3c.dom.Node internalRemoveChild(org.w3c.dom.Node,boolean) -> g1
    org.apache.xerces.dom.ChildNode lastChild() -> h1
    void lastChild(org.apache.xerces.dom.ChildNode) -> i1
    org.w3c.dom.Node insertBefore(org.w3c.dom.Node,org.w3c.dom.Node) -> j
    org.w3c.dom.Document getOwnerDocument() -> j0
    int nodeListGetLength() -> j1
    org.w3c.dom.Node nodeListItem(int) -> k1
    void synchronizeChildren() -> l1
    org.w3c.dom.Node cloneNode(boolean) -> p
    boolean hasChildNodes() -> w0
org.apache.xerces.dom.ParentNode$UserDataRecord -> i4.w0$a:
    java.lang.Object fData -> Q2
    org.w3c.dom.UserDataHandler fHandler -> R2
org.apache.xerces.dom.ProcessingInstructionImpl -> i4.x0:
    java.lang.String target -> W2
    java.lang.String getNodeName() -> B
    java.lang.String getTarget() -> P
    short getNodeType() -> n0
org.apache.xerces.dom.RangeImpl -> i4.y0:
    org.w3c.dom.Node fInsertNode -> g
    org.w3c.dom.Node fEndContainer -> c
    org.w3c.dom.Node fStartContainer -> b
    boolean fDetach -> f
    int fStartOffset -> d
    int fEndOffset -> e
    boolean fInsertedFromRange -> h
    org.apache.xerces.dom.DocumentImpl fDocument -> a
    org.w3c.dom.Node fRemoveChild -> i
    int indexOf(org.w3c.dom.Node,org.w3c.dom.Node) -> a
    void insertedNodeFromDOM(org.w3c.dom.Node) -> b
    boolean isAncestorOf(org.w3c.dom.Node,org.w3c.dom.Node) -> c
    org.w3c.dom.Node nextNode(org.w3c.dom.Node,boolean) -> d
    void receiveReplacedText(org.apache.xerces.dom.CharacterDataImpl) -> e
    void removeNode(org.w3c.dom.Node) -> f
org.apache.xerces.dom.SecuritySupport -> i4.z0:
    java.lang.ClassLoader getContextClassLoader() -> a
    java.lang.ClassLoader getParentClassLoader(java.lang.ClassLoader) -> b
    java.lang.ClassLoader getSystemClassLoader() -> c
    java.lang.String getSystemProperty(java.lang.String) -> d
org.apache.xerces.dom.SecuritySupport$1 -> i4.z0$a:
org.apache.xerces.dom.SecuritySupport$2 -> i4.z0$b:
org.apache.xerces.dom.SecuritySupport$3 -> i4.z0$c:
    java.lang.ClassLoader val$cl -> a
org.apache.xerces.dom.SecuritySupport$4 -> i4.z0$d:
    java.lang.String val$propName -> a
org.apache.xerces.dom.TextImpl -> i4.a1:
    java.lang.String getNodeName() -> B
    java.lang.String removeData() -> f1
    void replaceData(java.lang.String) -> g1
    short getNodeType() -> n0
org.apache.xerces.dom.events.EventImpl -> j4.a:
    long timeStamp -> j
    boolean preventDefault -> i
    org.w3c.dom.events.EventTarget currentTarget -> c
    org.w3c.dom.events.EventTarget target -> b
    boolean initialized -> e
    boolean bubbles -> f
    java.lang.String type -> a
    boolean cancelable -> g
    boolean stopPropagation -> h
    short eventPhase -> d
    java.lang.String getType() -> b
    void initEvent(java.lang.String,boolean,boolean) -> c
org.apache.xerces.dom.events.MutationEventImpl -> j4.b:
    java.lang.String newValue -> m
    java.lang.String prevValue -> l
    short attrChange -> o
    java.lang.String attrName -> n
    org.w3c.dom.Node relatedNode -> k
    void initMutationEvent(java.lang.String,boolean,boolean,org.w3c.dom.Node,java.lang.String,java.lang.String,java.lang.String,short) -> a
org.apache.xerces.impl.ExternalSubsetResolver -> k4.a:
    org.apache.xerces.xni.parser.XMLInputSource getExternalSubset(org.apache.xerces.xni.grammars.XMLDTDDescription) -> b
org.apache.xerces.impl.XML11DTDScannerImpl -> k4.b:
    org.apache.xerces.util.XMLStringBuffer fStringBuffer -> b0
    void normalizeWhitespace(org.apache.xerces.xni.XMLString,int) -> A
    boolean scanPubidLiteral(org.apache.xerces.xni.XMLString) -> K
    boolean versionSupported(java.lang.String) -> N
    java.lang.String getVersionNotSupportedKey() -> p
    boolean isInvalid(int) -> s
    boolean isInvalidLiteral(int) -> t
    int isUnchangedByNormalization(org.apache.xerces.xni.XMLString) -> u
    boolean isValidNCName(int) -> v
    boolean isValidNameChar(int) -> w
    void normalizeWhitespace(org.apache.xerces.xni.XMLString) -> z
org.apache.xerces.impl.XML11DocumentScannerImpl -> k4.c:
    org.apache.xerces.util.XMLStringBuffer fStringBuffer3 -> C0
    org.apache.xerces.util.XMLStringBuffer fStringBuffer2 -> B0
    org.apache.xerces.xni.XMLString fString -> z0
    org.apache.xerces.util.XMLStringBuffer fStringBuffer -> A0
    void normalizeWhitespace(org.apache.xerces.xni.XMLString,int) -> A
    boolean scanAttributeValue(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,java.lang.String,boolean,java.lang.String) -> C
    boolean scanPubidLiteral(org.apache.xerces.xni.XMLString) -> K
    boolean versionSupported(java.lang.String) -> N
    int scanContent() -> W
    java.lang.String getVersionNotSupportedKey() -> p
    boolean isInvalid(int) -> s
    boolean isInvalidLiteral(int) -> t
    int isUnchangedByNormalization(org.apache.xerces.xni.XMLString) -> u
    boolean isValidNCName(int) -> v
    boolean isValidNameChar(int) -> w
    boolean isValidNameStartChar(int) -> x
    boolean isValidNameStartHighSurrogate(int) -> y
    void normalizeWhitespace(org.apache.xerces.xni.XMLString) -> z
org.apache.xerces.impl.XML11EntityScanner -> k4.d:
    boolean skipSpaces() -> B
    boolean skipString(java.lang.String) -> C
    int peekChar() -> k
    int scanChar() -> n
    int scanContent(org.apache.xerces.xni.XMLString) -> o
    boolean scanData(java.lang.String,org.apache.xerces.util.XMLStringBuffer) -> p
    int scanLiteral(int,org.apache.xerces.xni.XMLString) -> q
    java.lang.String scanNCName() -> r
    java.lang.String scanName() -> s
    java.lang.String scanNmtoken() -> t
    boolean scanQName(org.apache.xerces.xni.QName) -> u
    boolean skipChar(int) -> z
org.apache.xerces.impl.XML11NSDocumentScannerImpl -> k4.e:
    boolean fBindNamespaces -> D0
    boolean fPerformValidation -> E0
    org.apache.xerces.impl.dtd.XMLDTDValidatorFilter fDTDValidator -> F0
    boolean fSawSpace -> G0
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher createContentDispatcher() -> P
    int scanEndElement() -> X
    boolean scanStartElement() -> Z
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> h
    org.apache.xerces.impl.dtd.XMLDTDValidatorFilter access$000(org.apache.xerces.impl.XML11NSDocumentScannerImpl) -> j0
    void scanAttribute(org.apache.xerces.util.XMLAttributesImpl) -> k0
    boolean scanStartElementAfterName() -> l0
    void scanStartElementName() -> m0
org.apache.xerces.impl.XML11NSDocumentScannerImpl$NS11ContentDispatcher -> k4.e$a:
    org.apache.xerces.impl.XML11NSDocumentScannerImpl this$0 -> c
    boolean scanRootElementHook() -> e
    void reconfigurePipeline() -> g
org.apache.xerces.impl.XMLDTDScannerImpl -> k4.f:
    int fExtEntityDepth -> M
    int fPEDepth -> K
    org.apache.xerces.xni.XMLString fLiteral -> S
    java.lang.Boolean[] FEATURE_DEFAULTS -> Y
    org.apache.xerces.xni.XMLDTDContentModelHandler fDTDContentModelHandler -> A
    int[] fContentStack -> G
    java.lang.String[] fStrings -> O
    int[] fPEStack -> I
    java.lang.Object[] PROPERTY_DEFAULTS -> a0
    boolean fSeenPEReferences -> E
    java.lang.String[] fEnumeration -> U
    int fEnumerationCount -> V
    org.apache.xerces.xni.XMLDTDHandler fDTDHandler -> z
    org.apache.xerces.util.XMLStringBuffer fIgnoreConditionalBuffer -> W
    org.apache.xerces.util.XMLStringBuffer fStringBuffer -> Q
    boolean fStandalone -> C
    int fIncludeSectDepth -> N
    int fMarkUpDepth -> L
    org.apache.xerces.xni.XMLString fLiteral2 -> T
    java.lang.String[] RECOGNIZED_FEATURES -> X
    int fContentDepth -> H
    java.lang.String[] RECOGNIZED_PROPERTIES -> Z
    int fScannerState -> B
    boolean[] fPEReport -> J
    boolean fStartDTDCalled -> F
    org.apache.xerces.xni.XMLString fString -> P
    org.apache.xerces.util.XMLStringBuffer fStringBuffer2 -> R
    boolean fSeenExternalDTD -> D
    void scanPIData(java.lang.String,org.apache.xerces.xni.XMLString) -> H
    void ensureEnumerationSize(int) -> O
    boolean peekReportEntity() -> P
    int popContentStack() -> Q
    int popPEStack() -> S
    void pushContentStack(int) -> T
    void pushPEStack(int,boolean) -> U
    java.lang.String scanAttDefaultDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString) -> V
    java.lang.String scanAttType(java.lang.String,java.lang.String) -> W
    void scanAttlistDecl() -> X
    void scanChildren(java.lang.String) -> Y
    void scanComment() -> Z
    void startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> a
    void scanConditionalSect(int) -> a0
    boolean scanDecls(boolean) -> b0
    void scanElementDecl() -> c0
    void scanEntityDecl() -> d0
    boolean scanDTDExternalSubset(boolean) -> e
    int scanEntityValue(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString) -> e0
    void scanMixed(java.lang.String) -> f0
    java.lang.Object getPropertyDefault(java.lang.String) -> g
    void scanNotationDecl() -> g0
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> h
    boolean scanTextDecl() -> h0
    java.lang.Boolean getFeatureDefault(java.lang.String) -> i
    boolean scanningInternalSubset() -> i0
    boolean scanDTDInternalSubset(boolean,boolean,boolean) -> j
    void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler) -> j0
    java.lang.String[] getRecognizedProperties() -> k
    void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler) -> k0
    void setScannerState(int) -> l0
    int skipInvalidEnumerationValue() -> m0
    java.lang.String[] getRecognizedFeatures() -> n
    boolean skipSeparator(boolean,boolean) -> n0
    void endEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> o
    java.lang.String startPE(java.lang.String,boolean) -> o0
    void init() -> q
    void setInputSource(org.apache.xerces.xni.parser.XMLInputSource) -> r
org.apache.xerces.impl.XMLDocumentFragmentScannerImpl -> k4.g:
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher fContentDispatcher -> M
    java.lang.String[] RECOGNIZED_FEATURES -> Y
    org.apache.xerces.xni.QName fCurrentElement -> I
    org.apache.xerces.xni.Augmentations fTempAugmentations -> X
    int[] fEntityStack -> A
    int fScannerState -> C
    org.apache.xerces.util.XMLAttributesImpl fAttributes -> P
    org.apache.xerces.xni.QName fAttributeQName -> O
    java.lang.Object[] PROPERTY_DEFAULTS -> b0
    org.apache.xerces.xni.QName fQName -> V
    char[] fSingleChar -> W
    boolean fHasExternalDTD -> E
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack fElementStack -> J
    org.apache.xerces.xni.XMLString fTempString -> Q
    org.apache.xerces.util.XMLStringBuffer fStringBuffer2 -> U
    boolean fIsEntityDeclaredVC -> G
    org.apache.xerces.impl.ExternalSubsetResolver fExternalSubsetResolver -> H
    java.lang.String[] fStrings -> S
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher fDispatcher -> L
    boolean fNotifyBuiltInRefs -> K
    org.apache.xerces.xni.XMLString fTempString2 -> R
    org.apache.xerces.xni.XMLDocumentHandler fDocumentHandler -> z
    java.lang.Boolean[] FEATURE_DEFAULTS -> Z
    int fMarkupDepth -> B
    org.apache.xerces.xni.QName fElementQName -> N
    java.lang.String[] RECOGNIZED_PROPERTIES -> a0
    boolean fStandalone -> F
    org.apache.xerces.util.XMLStringBuffer fStringBuffer -> T
    boolean fInScanContent -> D
    void scanPIData(java.lang.String,org.apache.xerces.xni.XMLString) -> H
    org.apache.xerces.util.XMLStringBuffer access$000(org.apache.xerces.impl.XMLDocumentFragmentScannerImpl) -> O
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher createContentDispatcher() -> P
    java.lang.String getScannerStateName(int) -> Q
    void handleCharacter(char,java.lang.String) -> S
    boolean scanCDATASection(boolean) -> T
    void scanCharReference() -> U
    void scanComment() -> V
    int scanContent() -> W
    int scanEndElement() -> X
    void scanEntityReference() -> Y
    boolean scanStartElement() -> Z
    void startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> a
    void scanXMLDeclOrTextDecl(boolean) -> a0
    void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler) -> b
    void setDispatcher(org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher) -> b0
    boolean scanDocument(boolean) -> c
    void setScannerState(int) -> c0
    void setFeature(java.lang.String,boolean) -> d
    void setProperty(java.lang.String,java.lang.Object) -> f
    java.lang.Object getPropertyDefault(java.lang.String) -> g
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> h
    java.lang.Boolean getFeatureDefault(java.lang.String) -> i
    java.lang.String[] getRecognizedProperties() -> k
    java.lang.String[] getRecognizedFeatures() -> n
    void endEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> o
org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher -> k4.g$a:
    boolean dispatch(boolean) -> a
org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack -> k4.g$b:
    org.apache.xerces.xni.QName[] fElements -> a
    int fSize -> b
    void clear() -> a
    void popElement(org.apache.xerces.xni.QName) -> b
    org.apache.xerces.xni.QName pushElement(org.apache.xerces.xni.QName) -> c
org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher -> k4.g$c:
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl this$0 -> a
    boolean dispatch(boolean) -> a
    boolean elementDepthIsZeroHook() -> b
    void endOfFileHook(java.io.EOFException) -> c
    boolean scanForDoctypeHook() -> d
    boolean scanRootElementHook() -> e
org.apache.xerces.impl.XMLDocumentScannerImpl -> k4.h:
    org.apache.xerces.util.XMLStringBuffer fStringBuffer -> s0
    boolean fScanningDTD -> e0
    java.lang.String fDoctypeSystemId -> h0
    java.lang.String fDoctypePublicId -> g0
    java.lang.String[] fStrings -> q0
    org.apache.xerces.impl.dtd.XMLDTDDescription fDTDDescription -> u0
    java.lang.String[] RECOGNIZED_PROPERTIES -> x0
    java.lang.String fDoctypeName -> f0
    org.apache.xerces.xni.parser.XMLInputSource fExternalSubsetSource -> t0
    java.lang.Boolean[] FEATURE_DEFAULTS -> w0
    java.lang.String[] RECOGNIZED_FEATURES -> v0
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher fPrologDispatcher -> n0
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher fXMLDeclDispatcher -> m0
    org.apache.xerces.xni.XMLString fString -> r0
    org.apache.xerces.impl.validation.ValidationManager fValidationManager -> d0
    java.lang.Object[] PROPERTY_DEFAULTS -> y0
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher fTrailingMiscDispatcher -> p0
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher fDTDDispatcher -> o0
    boolean fSeenDoctypeDecl -> l0
    org.apache.xerces.xni.NamespaceContext fNamespaceContext -> i0
    boolean fLoadExternalDTD -> j0
    boolean fDisallowDoctype -> k0
    org.apache.xerces.xni.parser.XMLDTDScanner fDTDScanner -> c0
    java.lang.String getScannerStateName(int) -> Q
    void startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> a
    void setFeature(java.lang.String,boolean) -> d
    org.apache.xerces.util.XMLStringBuffer access$000(org.apache.xerces.impl.XMLDocumentScannerImpl) -> d0
    org.apache.xerces.xni.XMLString access$100(org.apache.xerces.impl.XMLDocumentScannerImpl) -> e0
    void setProperty(java.lang.String,java.lang.Object) -> f
    org.apache.xerces.xni.parser.XMLInputSource access$200(org.apache.xerces.impl.XMLDocumentScannerImpl) -> f0
    java.lang.Object getPropertyDefault(java.lang.String) -> g
    org.apache.xerces.xni.parser.XMLInputSource access$202(org.apache.xerces.impl.XMLDocumentScannerImpl,org.apache.xerces.xni.parser.XMLInputSource) -> g0
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> h
    org.apache.xerces.impl.dtd.XMLDTDDescription access$300(org.apache.xerces.impl.XMLDocumentScannerImpl) -> h0
    java.lang.Boolean getFeatureDefault(java.lang.String) -> i
    boolean scanDoctypeDecl() -> i0
    java.lang.String[] getRecognizedProperties() -> k
    java.lang.String[] getRecognizedFeatures() -> n
    void endEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> o
org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher -> k4.h$a:
    org.apache.xerces.impl.XMLDocumentScannerImpl this$0 -> b
    boolean elementDepthIsZeroHook() -> b
    void endOfFileHook(java.io.EOFException) -> c
    boolean scanForDoctypeHook() -> d
    void resolveExternalSubsetAndRead() -> f
org.apache.xerces.impl.XMLDocumentScannerImpl$DTDDispatcher -> k4.h$b:
    org.apache.xerces.impl.XMLDocumentScannerImpl this$0 -> a
    boolean dispatch(boolean) -> a
org.apache.xerces.impl.XMLDocumentScannerImpl$PrologDispatcher -> k4.h$c:
    org.apache.xerces.impl.XMLDocumentScannerImpl this$0 -> a
    boolean dispatch(boolean) -> a
org.apache.xerces.impl.XMLDocumentScannerImpl$TrailingMiscDispatcher -> k4.h$d:
    org.apache.xerces.impl.XMLDocumentScannerImpl this$0 -> a
    boolean dispatch(boolean) -> a
org.apache.xerces.impl.XMLDocumentScannerImpl$XMLDeclDispatcher -> k4.h$e:
    org.apache.xerces.impl.XMLDocumentScannerImpl this$0 -> a
    boolean dispatch(boolean) -> a
org.apache.xerces.impl.XMLEntityDescription -> k4.i:
    java.lang.String getEntityName() -> i
org.apache.xerces.impl.XMLEntityHandler -> k4.j:
    void startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> a
    void endEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> o
org.apache.xerces.impl.XMLEntityManager -> k4.k:
    boolean fStandalone -> m
    boolean fInExternalSubset -> o
    org.apache.xerces.impl.XMLEntityHandler fEntityHandler -> p
    org.apache.xerces.xni.parser.XMLEntityResolver fEntityResolver -> i
    java.util.Stack fReaderStack -> F
    java.lang.String XMLEntity -> K
    java.lang.String gUserDir -> M
    org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool fCharacterBufferPool -> E
    org.apache.xerces.impl.XMLEntityScanner fXML11EntityScanner -> s
    org.apache.xerces.util.SecurityManager fSecurityManager -> l
    org.apache.xerces.impl.validation.ValidationManager fValidationManager -> j
    org.apache.xerces.impl.XMLEntityManager$ByteBufferPool fSmallByteBufferPool -> B
    org.apache.xerces.impl.XMLErrorReporter fErrorReporter -> h
    org.apache.xerces.impl.XMLEntityScanner fEntityScanner -> q
    org.apache.xerces.util.SymbolTable fSymbolTable -> g
    char[] gAfterEscaping2 -> Q
    java.util.Hashtable fEntities -> v
    java.lang.String[] RECOGNIZED_PROPERTIES -> I
    java.lang.Boolean[] FEATURE_DEFAULTS -> H
    boolean fStrictURI -> f
    java.lang.Object[] PROPERTY_DEFAULTS -> J
    int fEntityExpansionCount -> u
    boolean fExternalGeneralEntities -> b
    org.apache.xerces.xni.Augmentations fEntityAugs -> A
    boolean fAllowJavaEncodings -> d
    boolean fHasPEReferences -> n
    int fBufferSize -> k
    java.lang.String DTDEntity -> L
    org.apache.xerces.impl.XMLEntityManager$ByteBufferPool fLargeByteBufferPool -> C
    java.lang.String[] RECOGNIZED_FEATURES -> G
    boolean[] gNeedEscaping -> O
    org.apache.xerces.impl.XMLEntityScanner fXML10EntityScanner -> r
    org.apache.xerces.util.URI gUserDirURI -> N
    org.apache.xerces.util.XMLResourceIdentifierImpl fResourceIdentifier -> z
    char[] gHexChs -> R
    org.apache.xerces.impl.XMLEntityManager$ScannedEntity fCurrentEntity -> x
    java.util.Stack fEntityStack -> w
    boolean fWarnDuplicateEntityDef -> e
    java.util.Hashtable fDeclaredEntities -> y
    int fEntityExpansionLimit -> t
    boolean fValidation -> a
    byte[] fTempByteBuffer -> D
    boolean fExternalParameterEntities -> c
    char[] gAfterEscaping1 -> P
    java.security.PrivilegedAction GET_USER_DIR_SYSTEM_PROPERTY -> S
    java.lang.String fixURI(java.lang.String) -> A
    org.apache.xerces.impl.XMLEntityManager$ScannedEntity getCurrentEntity() -> B
    org.apache.xerces.xni.XMLResourceIdentifier getCurrentResourceIdentifier() -> C
    java.util.Hashtable getDeclaredEntities() -> D
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo getEncodingInfo(byte[],int) -> E
    org.apache.xerces.impl.XMLEntityScanner getEntityScanner() -> F
    int getParamEntityRefCount(java.lang.String) -> G
    org.apache.xerces.util.URI getUserDir() -> H
    boolean hasPEReferences() -> I
    boolean isDeclaredEntity(java.lang.String) -> J
    boolean isEntityDeclInExternalSubset(java.lang.String) -> K
    boolean isExternalEntity(java.lang.String) -> L
    boolean isUnparsedEntity(java.lang.String) -> M
    void notifyHasPEReferences() -> N
    void print(org.apache.xerces.impl.XMLEntityManager$ScannedEntity) -> O
    void reset() -> P
    void setEntityHandler(org.apache.xerces.impl.XMLEntityHandler) -> Q
    void setScannerVersion(short) -> R
    void setStandalone(boolean) -> S
    java.lang.String setupCurrentEntity(java.lang.String,org.apache.xerces.xni.parser.XMLInputSource,boolean,boolean) -> T
    void startDTDEntity(org.apache.xerces.xni.parser.XMLInputSource) -> U
    void startEntity(java.lang.String,org.apache.xerces.xni.parser.XMLInputSource,boolean,boolean) -> V
    void startEntity(java.lang.String,boolean) -> W
    void startExternalSubset() -> X
    org.apache.xerces.xni.parser.XMLInputSource resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier) -> a
    org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool access$200(org.apache.xerces.impl.XMLEntityManager) -> c
    void setFeature(java.lang.String,boolean) -> d
    byte[] access$400(org.apache.xerces.impl.XMLEntityManager) -> e
    void setProperty(java.lang.String,java.lang.Object) -> f
    java.lang.Object getPropertyDefault(java.lang.String) -> g
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> h
    java.lang.Boolean getFeatureDefault(java.lang.String) -> i
    byte[] access$402(org.apache.xerces.impl.XMLEntityManager,byte[]) -> j
    java.lang.String[] getRecognizedProperties() -> k
    void addExternalEntity(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> l
    void addInternalEntity(java.lang.String,java.lang.String,int) -> m
    java.lang.String[] getRecognizedFeatures() -> n
    void addUnparsedEntity(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> o
    void closeReaders() -> p
    java.io.Reader createASCIIReader(java.io.InputStream) -> q
    java.io.Reader createLatin1Reader(java.io.InputStream) -> r
    java.io.Reader createReader(java.io.InputStream,java.lang.String,java.lang.Boolean) -> s
    java.io.Reader createUTF16Reader(java.io.InputStream,boolean) -> t
    java.io.Reader createUTF8Reader(java.io.InputStream) -> u
    void endEntity() -> v
    void endExternalSubset() -> w
    java.lang.String expandSystemId(java.lang.String,java.lang.String,boolean) -> x
    java.lang.String expandSystemIdStrictOff(java.lang.String,java.lang.String) -> y
    java.lang.String expandSystemIdStrictOn(java.lang.String,java.lang.String) -> z
org.apache.xerces.impl.XMLEntityManager$1 -> k4.k$a:
org.apache.xerces.impl.XMLEntityManager$ByteBufferPool -> k4.k$b:
    byte[][] fByteBufferPool -> c
    int fDepth -> d
    int fBufferSize -> b
    int fPoolSize -> a
    byte[] getBuffer() -> a
    void returnBuffer(byte[]) -> b
    void setBufferSize(int) -> c
org.apache.xerces.impl.XMLEntityManager$CharacterBuffer -> k4.k$c:
    char[] ch -> a
    boolean isExternal -> b
    char[] access$300(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer) -> a
    boolean access$500(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer) -> b
org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool -> k4.k$d:
    org.apache.xerces.impl.XMLEntityManager$CharacterBuffer[] fExternalBufferPool -> b
    org.apache.xerces.impl.XMLEntityManager$CharacterBuffer[] fInternalBufferPool -> a
    int fInternalTop -> f
    int fExternalTop -> g
    int fInternalBufferSize -> d
    int fPoolSize -> e
    int fExternalBufferSize -> c
    org.apache.xerces.impl.XMLEntityManager$CharacterBuffer getBuffer(boolean) -> a
    void init() -> b
    void returnBuffer(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer) -> c
    void setExternalBufferSize(int) -> d
org.apache.xerces.impl.XMLEntityManager$EncodingInfo -> k4.k$e:
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo UTF_8_WITH_BOM -> f
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo UTF_8 -> e
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo UTF_16_BIG_ENDIAN_WITH_BOM -> h
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo UTF_16_BIG_ENDIAN -> g
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo EBCDIC -> n
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo UCS_4_UNUSUAL_BYTE_ORDER -> m
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo UTF_16_LITTLE_ENDIAN_WITH_BOM -> j
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo UTF_16_LITTLE_ENDIAN -> i
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo UCS_4_LITTLE_ENDIAN -> l
    org.apache.xerces.impl.XMLEntityManager$EncodingInfo UCS_4_BIG_ENDIAN -> k
    java.lang.String autoDetectedEncoding -> a
    java.lang.Boolean isBigEndian -> c
    java.lang.String readerEncoding -> b
    boolean hasBOM -> d
org.apache.xerces.impl.XMLEntityManager$Entity -> k4.k$f:
    java.lang.String name -> a
    boolean inExternalSubset -> b
    void clear() -> a
    boolean isEntityDeclInExternalSubset() -> b
    boolean isExternal() -> c
    boolean isUnparsed() -> d
org.apache.xerces.impl.XMLEntityManager$ExternalEntity -> k4.k$g:
    org.apache.xerces.xni.XMLResourceIdentifier entityLocation -> c
    java.lang.String notation -> d
    void clear() -> a
    boolean isExternal() -> c
    boolean isUnparsed() -> d
org.apache.xerces.impl.XMLEntityManager$InternalEntity -> k4.k$h:
    int paramEntityRefs -> d
    java.lang.String text -> c
    void clear() -> a
    boolean isExternal() -> c
    boolean isUnparsed() -> d
org.apache.xerces.impl.XMLEntityManager$RewindableInputStream -> k4.k$i:
    int fOffset -> U2
    byte[] fData -> R2
    int fLength -> V2
    int fStartOffset -> S2
    int fEndOffset -> T2
    org.apache.xerces.impl.XMLEntityManager this$0 -> X2
    int fMark -> W2
    java.io.InputStream fInputStream -> Q2
    int readAndBuffer() -> a
org.apache.xerces.impl.XMLEntityManager$ScannedEntity -> k4.k$j:
    int position -> n
    int baseCharOffset -> o
    java.lang.String encoding -> h
    boolean externallySpecifiedEncoding -> i
    java.lang.String xmlVersion -> j
    org.apache.xerces.xni.XMLResourceIdentifier entityLocation -> e
    boolean literal -> k
    boolean isExternal -> l
    org.apache.xerces.impl.XMLEntityManager$CharacterBuffer fCharacterBuffer -> s
    int lineNumber -> f
    int columnNumber -> g
    byte[] fByteBuffer -> t
    boolean mayReadChunks -> r
    java.io.Reader reader -> d
    java.io.InputStream stream -> c
    char[] ch -> m
    org.apache.xerces.impl.XMLEntityManager this$0 -> u
    int startPosition -> p
    int count -> q
    boolean isExternal() -> c
    boolean isUnparsed() -> d
    org.apache.xerces.impl.XMLEntityManager$CharacterBuffer access$000(org.apache.xerces.impl.XMLEntityManager$ScannedEntity) -> e
    byte[] access$100(org.apache.xerces.impl.XMLEntityManager$ScannedEntity) -> f
    int getCharacterOffset() -> g
    int getColumnNumber() -> h
    java.lang.String getEncoding() -> i
    java.lang.String getExpandedSystemId() -> j
    int getLineNumber() -> k
    java.lang.String getLiteralSystemId() -> l
    boolean isEncodingExternallySpecified() -> m
    void setEncodingExternallySpecified(boolean) -> n
    void setReader(java.io.InputStream,java.lang.String,java.lang.Boolean) -> o
org.apache.xerces.impl.XMLEntityScanner -> k4.l:
    org.apache.xerces.util.SymbolTable fSymbolTable -> c
    org.apache.xerces.impl.XMLEntityManager fEntityManager -> a
    int fBufferSize -> d
    java.io.EOFException END_OF_DOCUMENT_ENTITY -> f
    org.apache.xerces.impl.XMLEntityManager$ScannedEntity fCurrentEntity -> b
    org.apache.xerces.impl.XMLErrorReporter fErrorReporter -> e
    boolean skipDeclSpaces() -> A
    boolean skipSpaces() -> B
    boolean skipString(java.lang.String) -> C
    java.lang.String getPublicId() -> a
    boolean isExternal() -> b
    java.lang.String getExpandedSystemId() -> c
    int getColumnNumber() -> d
    java.lang.String getEncoding() -> e
    java.lang.String getLiteralSystemId() -> f
    int getLineNumber() -> g
    java.lang.String getBaseSystemId() -> h
    int getCharacterOffset() -> i
    boolean load(int,boolean) -> j
    int peekChar() -> k
    void reset(org.apache.xerces.util.SymbolTable,org.apache.xerces.impl.XMLEntityManager,org.apache.xerces.impl.XMLErrorReporter) -> l
    void resizeBuffer(int,int) -> m
    int scanChar() -> n
    int scanContent(org.apache.xerces.xni.XMLString) -> o
    boolean scanData(java.lang.String,org.apache.xerces.util.XMLStringBuffer) -> p
    int scanLiteral(int,org.apache.xerces.xni.XMLString) -> q
    java.lang.String scanNCName() -> r
    java.lang.String scanName() -> s
    java.lang.String scanNmtoken() -> t
    boolean scanQName(org.apache.xerces.xni.QName) -> u
    void setBufferSize(int) -> v
    void setCurrentEntity(org.apache.xerces.impl.XMLEntityManager$ScannedEntity) -> w
    void setEncoding(java.lang.String) -> x
    void setXMLVersion(java.lang.String) -> y
    boolean skipChar(int) -> z
org.apache.xerces.impl.XMLEntityScanner$1 -> k4.l$a:
org.apache.xerces.impl.XMLErrorReporter -> k4.m:
    java.util.Hashtable fMessageFormatters -> b
    org.apache.xerces.xni.parser.XMLErrorHandler fErrorHandler -> c
    java.util.Locale fLocale -> a
    org.apache.xerces.xni.parser.XMLErrorHandler fDefaultErrorHandler -> f
    java.lang.String[] RECOGNIZED_FEATURES -> h
    org.xml.sax.ErrorHandler fSaxProxy -> g
    java.lang.String[] RECOGNIZED_PROPERTIES -> j
    boolean fContinueAfterFatalError -> e
    java.lang.Boolean[] FEATURE_DEFAULTS -> i
    java.lang.Object[] PROPERTY_DEFAULTS -> k
    org.apache.xerces.xni.XMLLocator fLocator -> d
    org.apache.xerces.xni.parser.XMLErrorHandler getErrorHandler() -> a
    boolean getFeature(java.lang.String) -> b
    java.util.Locale getLocale() -> c
    void setFeature(java.lang.String,boolean) -> d
    org.apache.xerces.util.MessageFormatter getMessageFormatter(java.lang.String) -> e
    void setProperty(java.lang.String,java.lang.Object) -> f
    java.lang.Object getPropertyDefault(java.lang.String) -> g
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> h
    java.lang.Boolean getFeatureDefault(java.lang.String) -> i
    void putMessageFormatter(java.lang.String,org.apache.xerces.util.MessageFormatter) -> j
    java.lang.String[] getRecognizedProperties() -> k
    java.lang.String reportError(org.apache.xerces.xni.XMLLocator,java.lang.String,java.lang.String,java.lang.Object[],short) -> l
    java.lang.String reportError(org.apache.xerces.xni.XMLLocator,java.lang.String,java.lang.String,java.lang.Object[],short,java.lang.Exception) -> m
    java.lang.String[] getRecognizedFeatures() -> n
    java.lang.String reportError(java.lang.String,java.lang.String,java.lang.Object[],short) -> o
    java.lang.String reportError(java.lang.String,java.lang.String,java.lang.Object[],short,java.lang.Exception) -> p
    void setDocumentLocator(org.apache.xerces.xni.XMLLocator) -> q
    void setLocale(java.util.Locale) -> r
org.apache.xerces.impl.XMLNSDocumentScannerImpl -> k4.n:
    boolean fPerformValidation -> A0
    org.apache.xerces.impl.dtd.XMLDTDValidatorFilter fDTDValidator -> B0
    boolean fSawSpace -> C0
    boolean fBindNamespaces -> z0
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher createContentDispatcher() -> P
    int scanEndElement() -> X
    boolean scanStartElement() -> Z
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> h
    org.apache.xerces.impl.dtd.XMLDTDValidatorFilter access$000(org.apache.xerces.impl.XMLNSDocumentScannerImpl) -> j0
    void scanAttribute(org.apache.xerces.util.XMLAttributesImpl) -> k0
    boolean scanStartElementAfterName() -> l0
    void scanStartElementName() -> m0
org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher -> k4.n$a:
    org.apache.xerces.impl.XMLNSDocumentScannerImpl this$0 -> c
    boolean scanRootElementHook() -> e
    void reconfigurePipeline() -> g
org.apache.xerces.impl.XMLScanner -> k4.o:
    java.lang.String fCharRefLiteral -> j
    boolean fScanningAttribute -> k
    java.lang.String fVersionSymbol -> r
    org.apache.xerces.impl.XMLErrorReporter fErrorReporter -> f
    java.lang.String fStandaloneSymbol -> t
    org.apache.xerces.util.XMLStringBuffer fStringBuffer -> n
    org.apache.xerces.util.SymbolTable fSymbolTable -> e
    java.lang.String fLtSymbol -> v
    org.apache.xerces.util.XMLStringBuffer fStringBuffer3 -> p
    java.lang.String fQuotSymbol -> x
    org.apache.xerces.util.XMLResourceIdentifierImpl fResourceIdentifier -> q
    boolean fNamespaces -> b
    boolean fParserSettings -> d
    org.apache.xerces.impl.XMLEntityScanner fEntityScanner -> h
    int fEntityDepth -> i
    boolean fReportEntity -> l
    java.lang.String fEncodingSymbol -> s
    java.lang.String fAmpSymbol -> u
    java.lang.String fGtSymbol -> w
    java.lang.String fAposSymbol -> y
    org.apache.xerces.impl.XMLEntityManager fEntityManager -> g
    org.apache.xerces.util.XMLStringBuffer fStringBuffer2 -> o
    boolean fValidation -> a
    org.apache.xerces.xni.XMLString fString -> m
    boolean fNotifyCharRefs -> c
    void normalizeWhitespace(org.apache.xerces.xni.XMLString,int) -> A
    void reportFatalError(java.lang.String,java.lang.Object[]) -> B
    boolean scanAttributeValue(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,java.lang.String,boolean,java.lang.String) -> C
    int scanCharReferenceValue(org.apache.xerces.util.XMLStringBuffer,org.apache.xerces.util.XMLStringBuffer) -> D
    void scanComment(org.apache.xerces.util.XMLStringBuffer) -> E
    void scanExternalID(java.lang.String[],boolean) -> F
    void scanPI() -> G
    void scanPIData(java.lang.String,org.apache.xerces.xni.XMLString) -> H
    java.lang.String scanPseudoAttribute(boolean,org.apache.xerces.xni.XMLString) -> I
    java.lang.String scanPseudoAttributeName() -> J
    boolean scanPubidLiteral(org.apache.xerces.xni.XMLString) -> K
    boolean scanSurrogates(org.apache.xerces.util.XMLStringBuffer) -> L
    void scanXMLDeclOrTextDecl(boolean,java.lang.String[]) -> M
    boolean versionSupported(java.lang.String) -> N
    void startEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> a
    void setFeature(java.lang.String,boolean) -> d
    void setProperty(java.lang.String,java.lang.Object) -> f
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> h
    void endEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> o
    java.lang.String getVersionNotSupportedKey() -> p
    void init() -> q
    boolean isInvalid(int) -> s
    boolean isInvalidLiteral(int) -> t
    int isUnchangedByNormalization(org.apache.xerces.xni.XMLString) -> u
    boolean isValidNCName(int) -> v
    boolean isValidNameChar(int) -> w
    boolean isValidNameStartChar(int) -> x
    boolean isValidNameStartHighSurrogate(int) -> y
    void normalizeWhitespace(org.apache.xerces.xni.XMLString) -> z
org.apache.xerces.impl.XMLVersionDetector -> k4.p:
    java.lang.String fVersionSymbol -> g
    org.apache.xerces.impl.XMLErrorReporter fErrorReporter -> b
    java.lang.String fXMLSymbol -> h
    char[] fExpectedVersionString -> e
    org.apache.xerces.util.SymbolTable fSymbolTable -> a
    char[] XML11_VERSION -> f
    org.apache.xerces.impl.XMLEntityManager fEntityManager -> c
    java.lang.String fEncoding -> d
    short determineDocVersion(org.apache.xerces.xni.parser.XMLInputSource) -> a
    void fixupCurrentEntity(org.apache.xerces.impl.XMLEntityManager,char[],int) -> b
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> c
    void startDocumentParsing(org.apache.xerces.impl.XMLEntityHandler,short) -> d
org.apache.xerces.impl.dtd.XMLDTDDescription -> l4.a:
    java.lang.String fRootName -> f
    java.util.ArrayList fPossibleRoots -> g
    java.lang.String getGrammarType() -> d
    java.lang.String getRootName() -> g
    void setRootName(java.lang.String) -> p
org.apache.xerces.impl.dtd.XMLDTDValidatorFilter -> l4.b:
    boolean validate() -> R
    boolean hasGrammar() -> l
org.apache.xerces.impl.dv.DTDDVFactory -> m4.a:
    org.apache.xerces.impl.dv.DTDDVFactory getInstance() -> a
    org.apache.xerces.impl.dv.DTDDVFactory getInstance(java.lang.String) -> b
org.apache.xerces.impl.dv.DVFactoryException -> m4.b:
org.apache.xerces.impl.dv.DatatypeException -> m4.c:
    java.lang.Object[] args -> R2
    java.lang.String key -> Q2
    java.lang.Object[] getArgs() -> a
    java.lang.String getKey() -> b
org.apache.xerces.impl.dv.InvalidDatatypeFacetException -> m4.d:
org.apache.xerces.impl.dv.InvalidDatatypeValueException -> m4.e:
org.apache.xerces.impl.dv.ObjectFactory -> m4.f:
    java.util.Properties fXercesProperties -> b
    long fLastModified -> c
    boolean DEBUG -> a
    void debugPrintln(java.lang.String) -> a
    java.lang.ClassLoader findClassLoader() -> b
    java.lang.Class findProviderClass(java.lang.String,java.lang.ClassLoader,boolean) -> c
    boolean isDebugEnabled() -> d
    java.lang.Object newInstance(java.lang.String,java.lang.ClassLoader,boolean) -> e
org.apache.xerces.impl.dv.ObjectFactory$ConfigurationError -> m4.f$a:
    java.lang.Exception exception -> Q2
org.apache.xerces.impl.dv.SchemaDVFactory -> m4.g:
    org.apache.xerces.impl.dv.XSSimpleType createTypeList(java.lang.String,java.lang.String,short,org.apache.xerces.impl.dv.XSSimpleType,org.apache.xerces.xs.XSObjectList) -> a
    org.apache.xerces.impl.dv.XSSimpleType getBuiltInType(java.lang.String) -> b
    org.apache.xerces.util.SymbolHash getBuiltInTypes() -> c
    org.apache.xerces.impl.dv.SchemaDVFactory getInstance() -> d
    org.apache.xerces.impl.dv.SchemaDVFactory getInstance(java.lang.String) -> e
org.apache.xerces.impl.dv.SecuritySupport -> m4.h:
    java.lang.ClassLoader getContextClassLoader() -> a
    java.lang.ClassLoader getParentClassLoader(java.lang.ClassLoader) -> b
    java.lang.ClassLoader getSystemClassLoader() -> c
    java.lang.String getSystemProperty(java.lang.String) -> d
org.apache.xerces.impl.dv.SecuritySupport$1 -> m4.h$a:
org.apache.xerces.impl.dv.SecuritySupport$2 -> m4.h$b:
org.apache.xerces.impl.dv.SecuritySupport$3 -> m4.h$c:
    java.lang.ClassLoader val$cl -> a
org.apache.xerces.impl.dv.SecuritySupport$4 -> m4.h$d:
    java.lang.String val$propName -> a
org.apache.xerces.impl.dv.ValidatedInfo -> m4.i:
    org.apache.xerces.impl.dv.XSSimpleType actualType -> d
    org.apache.xerces.impl.dv.XSSimpleType memberType -> e
    java.lang.Object actualValue -> b
    java.lang.String normalizedValue -> a
    org.apache.xerces.xs.ShortList itemValueTypes -> g
    short actualValueType -> c
    org.apache.xerces.impl.dv.XSSimpleType[] memberTypes -> f
    org.apache.xerces.xs.XSObjectList getMemberTypeDefinitions() -> a
    org.apache.xerces.xs.ShortList getListValueTypes() -> b
    java.lang.String getNormalizedValue() -> c
    short getActualValueType() -> d
    java.lang.Object getActualValue() -> e
    org.apache.xerces.xs.XSSimpleTypeDefinition getTypeDefinition() -> f
    void copyFrom(org.apache.xerces.xs.XSValue) -> g
    void reset() -> h
    org.apache.xerces.xs.XSSimpleTypeDefinition getMemberTypeDefinition() -> i
org.apache.xerces.impl.dv.ValidationContext -> m4.j:
    java.lang.String getURI(java.lang.String) -> a
    boolean needExtraChecking() -> b
    boolean isEntityUnparsed(java.lang.String) -> c
    java.lang.String getSymbol(java.lang.String) -> d
    java.util.Locale getLocale() -> e
    boolean needFacetChecking() -> f
    void addId(java.lang.String) -> g
    void addIdRef(java.lang.String) -> h
    boolean isIdDeclared(java.lang.String) -> i
    boolean needToNormalize() -> j
org.apache.xerces.impl.dv.XSFacets -> m4.k:
    org.apache.xerces.xs.XSObjectList enumAnnotations -> u
    java.lang.String maxInclusive -> j
    org.apache.xerces.xs.XSAnnotation minLengthAnnotation -> o
    java.lang.String minInclusive -> l
    org.apache.xerces.xs.XSAnnotation whiteSpaceAnnotation -> q
    int fractionDigits -> f
    java.util.Vector enumeration -> h
    int minLength -> b
    org.apache.xerces.xs.XSAnnotation totalDigitsAnnotation -> r
    org.apache.xerces.xs.XSAnnotation maxInclusiveAnnotation -> v
    short whiteSpace -> d
    org.apache.xerces.xs.XSAnnotation minInclusiveAnnotation -> x
    java.lang.String pattern -> g
    java.lang.String maxExclusive -> k
    org.apache.xerces.xs.XSAnnotation lengthAnnotation -> n
    java.lang.String minExclusive -> m
    org.apache.xerces.xs.XSAnnotation maxLengthAnnotation -> p
    java.util.Vector enumNSDecls -> i
    int totalDigits -> e
    int maxLength -> c
    int length -> a
    org.apache.xerces.xs.XSAnnotation fractionDigitsAnnotation -> s
    org.apache.xerces.impl.xs.util.XSObjectListImpl patternAnnotations -> t
    org.apache.xerces.xs.XSAnnotation maxExclusiveAnnotation -> w
    org.apache.xerces.xs.XSAnnotation minExclusiveAnnotation -> y
org.apache.xerces.impl.dv.XSSimpleType -> m4.l:
    boolean isIDType() -> f
org.apache.xerces.impl.dv.util.Base64 -> n4.a:
    char[] lookUpBase64Alphabet -> b
    byte[] base64Alphabet -> a
    byte[] decode(java.lang.String) -> a
    java.lang.String encode(byte[]) -> b
    boolean isData(char) -> c
    boolean isPad(char) -> d
    boolean isWhiteSpace(char) -> e
    int removeWhiteSpace(char[]) -> f
org.apache.xerces.impl.dv.util.ByteListImpl -> n4.b:
    byte[] data -> Q2
    java.lang.String canonical -> R2
    int getLength() -> c
org.apache.xerces.impl.dv.util.HexBin -> n4.c:
    char[] lookUpHexAlphabet -> b
    byte[] hexNumberTable -> a
    byte[] decode(java.lang.String) -> a
    java.lang.String encode(byte[]) -> b
org.apache.xerces.impl.dv.xs.AbstractDateTimeDV -> o4.a:
    javax.xml.datatype.DatatypeFactory datatypeFactory -> b
    boolean isLeapYear(int) -> A
    boolean isNextCharUTCSign(java.lang.String,int,int) -> B
    int maxDayInMonthFor(int,int) -> C
    int mod(int,int,int) -> D
    int modulo(int,int,int) -> E
    void normalize(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> F
    int parseInt(java.lang.String,int,int) -> G
    int parseIntYear(java.lang.String,int) -> H
    double parseSecond(java.lang.String,int,int) -> I
    void parseTimeZone(java.lang.String,int,int,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> J
    void resetDateObj(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> K
    void saveUnnormalized(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> L
    void validateDateTime(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> M
    int compare(java.lang.Object,java.lang.Object) -> b
    short getAllowedFacets() -> d
    void append(java.lang.StringBuffer,double) -> k
    void append(java.lang.StringBuffer,int,int) -> l
    void append2(java.lang.StringBuffer,double) -> m
    void append3(java.lang.StringBuffer,double) -> n
    void cloneDate(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> o
    short compareDates(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData,boolean) -> p
    short compareOrder(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> q
    java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> r
    int fQuotient(int,int) -> s
    int fQuotient(int,int,int) -> t
    int findUTCSign(java.lang.String,int,int) -> u
    int getDate(java.lang.String,int,int,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> v
    void getTime(java.lang.String,int,int,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> w
    void getTimeZone(java.lang.String,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData,int,int) -> x
    int getYearMonth(java.lang.String,int,int,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> y
    int indexOf(java.lang.String,int,int,char) -> z
org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData -> o4.a$a:
    int unNormDay -> n
    int unNormHour -> o
    int unNormYear -> l
    int unNormMonth -> m
    java.lang.String originalValue -> j
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV type -> s
    int timezoneHr -> h
    boolean normalized -> k
    int timezoneMin -> i
    int utc -> f
    int hour -> d
    int minute -> e
    int month -> b
    int day -> c
    int year -> a
    java.lang.String canonical -> t
    double unNormSecond -> q
    int position -> r
    double second -> g
    int unNormMinute -> p
org.apache.xerces.impl.dv.xs.AnyAtomicDV -> o4.b:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
org.apache.xerces.impl.dv.xs.AnySimpleDV -> o4.c:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
org.apache.xerces.impl.dv.xs.AnyURIDV -> o4.d:
    char[] gAfterEscaping1 -> d
    org.apache.xerces.util.URI BASE_URI -> b
    char[] gAfterEscaping2 -> e
    char[] gHexChs -> f
    boolean[] gNeedEscaping -> c
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
    java.lang.String encode(java.lang.String) -> k
org.apache.xerces.impl.dv.xs.Base64BinaryDV -> o4.e:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
    int getDataLength(java.lang.Object) -> f
org.apache.xerces.impl.dv.xs.Base64BinaryDV$XBase64 -> o4.e$a:
org.apache.xerces.impl.dv.xs.BaseSchemaDVFactory -> o4.f:
    org.apache.xerces.impl.dv.XSSimpleType createTypeList(java.lang.String,java.lang.String,short,org.apache.xerces.impl.dv.XSSimpleType,org.apache.xerces.xs.XSObjectList) -> a
    void createBuiltInTypes(org.apache.xerces.util.SymbolHash,org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl) -> f
    void setDeclPool(org.apache.xerces.impl.xs.XSDeclarationPool) -> g
org.apache.xerces.impl.dv.xs.BooleanDV -> o4.g:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
org.apache.xerces.impl.dv.xs.DateDV -> o4.h:
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String) -> N
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> r
org.apache.xerces.impl.dv.xs.DateTimeDV -> o4.i:
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String) -> N
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
org.apache.xerces.impl.dv.xs.DayDV -> o4.j:
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String) -> N
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> r
org.apache.xerces.impl.dv.xs.DayTimeDurationDV -> o4.k:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
org.apache.xerces.impl.dv.xs.DecimalDV -> o4.l:
    int compare(java.lang.Object,java.lang.Object) -> b
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
    int getFractionDigits(java.lang.Object) -> h
    int getTotalDigits(java.lang.Object) -> i
org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal -> o4.l$a:
    java.lang.String fvalue -> f
    java.lang.String canonical -> h
    int fracDigits -> d
    boolean integer -> g
    int totalDigits -> b
    int intDigits -> c
    java.lang.String ivalue -> e
    int sign -> a
    int compareTo(org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal) -> a
    void initD(java.lang.String) -> b
    void initI(java.lang.String) -> c
    int intComp(org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal) -> d
    void makeCanonical() -> e
org.apache.xerces.impl.dv.xs.DoubleDV -> o4.m:
    int compare(java.lang.Object,java.lang.Object) -> b
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
    boolean isPossibleFP(java.lang.String) -> k
org.apache.xerces.impl.dv.xs.DoubleDV$XDouble -> o4.m$a:
    double value -> a
    java.lang.String canonical -> b
    int access$000(org.apache.xerces.impl.dv.xs.DoubleDV$XDouble,org.apache.xerces.impl.dv.xs.DoubleDV$XDouble) -> a
    int compareTo(org.apache.xerces.impl.dv.xs.DoubleDV$XDouble) -> b
org.apache.xerces.impl.dv.xs.DurationDV -> o4.n:
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData[] DATETIMES -> c
    double parseSecond(java.lang.String,int,int) -> I
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData addDuration(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> N
    short compareResults(short,short,boolean) -> O
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String,int) -> P
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short compareDates(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData,org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData,boolean) -> p
    java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> r
org.apache.xerces.impl.dv.xs.EntityDV -> o4.o:
    void checkExtraRules(java.lang.Object,org.apache.xerces.impl.dv.ValidationContext) -> a
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
org.apache.xerces.impl.dv.xs.FloatDV -> o4.p:
    int compare(java.lang.Object,java.lang.Object) -> b
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
org.apache.xerces.impl.dv.xs.FloatDV$XFloat -> o4.p$a:
    float value -> a
    java.lang.String canonical -> b
    int access$000(org.apache.xerces.impl.dv.xs.FloatDV$XFloat,org.apache.xerces.impl.dv.xs.FloatDV$XFloat) -> a
    int compareTo(org.apache.xerces.impl.dv.xs.FloatDV$XFloat) -> b
org.apache.xerces.impl.dv.xs.HexBinaryDV -> o4.q:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
    int getDataLength(java.lang.Object) -> f
org.apache.xerces.impl.dv.xs.HexBinaryDV$XHex -> o4.q$a:
org.apache.xerces.impl.dv.xs.IDDV -> o4.r:
    void checkExtraRules(java.lang.Object,org.apache.xerces.impl.dv.ValidationContext) -> a
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
org.apache.xerces.impl.dv.xs.IDREFDV -> o4.s:
    void checkExtraRules(java.lang.Object,org.apache.xerces.impl.dv.ValidationContext) -> a
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
org.apache.xerces.impl.dv.xs.IntegerDV -> o4.t:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
org.apache.xerces.impl.dv.xs.ListDV -> o4.u:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
    int getDataLength(java.lang.Object) -> f
org.apache.xerces.impl.dv.xs.ListDV$ListData -> o4.u$a:
    java.lang.Object[] data -> Q2
    java.lang.String canonical -> R2
    java.lang.Object item(int) -> a
    int getLength() -> c
org.apache.xerces.impl.dv.xs.MonthDV -> o4.v:
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String) -> N
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> r
org.apache.xerces.impl.dv.xs.MonthDayDV -> o4.w:
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String) -> N
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> r
org.apache.xerces.impl.dv.xs.PrecisionDecimalDV -> o4.x:
    int compare(java.lang.Object,java.lang.Object) -> b
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
    int getFractionDigits(java.lang.Object) -> h
    int getTotalDigits(java.lang.Object) -> i
org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal -> o4.x$a:
    java.lang.String fvalue -> f
    java.lang.String canonical -> h
    int pvalue -> g
    int fracDigits -> d
    int totalDigits -> b
    int intDigits -> c
    java.lang.String ivalue -> e
    int sign -> a
    int compare(org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal) -> a
    int compareDecimal(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> b
    int compareTo(org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal) -> c
    void initD(java.lang.String) -> d
    int intComp(org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal) -> e
    void makeCanonical() -> f
    void truncateTrailingZeros(java.lang.StringBuffer,java.lang.StringBuffer) -> g
org.apache.xerces.impl.dv.xs.QNameDV -> o4.y:
    java.lang.String EMPTY_STRING -> b
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
    int getDataLength(java.lang.Object) -> f
org.apache.xerces.impl.dv.xs.QNameDV$XQName -> o4.y$a:
org.apache.xerces.impl.dv.xs.SchemaDVFactoryImpl -> o4.z:
    org.apache.xerces.util.SymbolHash fBuiltInTypes -> a
    org.apache.xerces.impl.dv.XSSimpleType getBuiltInType(java.lang.String) -> b
    org.apache.xerces.util.SymbolHash getBuiltInTypes() -> c
    void createBuiltInTypes() -> h
org.apache.xerces.impl.dv.xs.SchemaDateTimeException -> o4.a0:
org.apache.xerces.impl.dv.xs.StringDV -> o4.b0:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
org.apache.xerces.impl.dv.xs.TimeDV -> o4.c0:
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String) -> N
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> r
org.apache.xerces.impl.dv.xs.TypeValidator -> o4.d0:
    boolean USE_CODE_POINT_COUNT_FOR_STRING_LENGTH -> a
    void checkExtraRules(java.lang.Object,org.apache.xerces.impl.dv.ValidationContext) -> a
    int compare(java.lang.Object,java.lang.Object) -> b
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
    int getCodePointLength(java.lang.String) -> e
    int getDataLength(java.lang.Object) -> f
    int getDigit(char) -> g
    int getFractionDigits(java.lang.Object) -> h
    int getTotalDigits(java.lang.Object) -> i
    boolean isDigit(char) -> j
org.apache.xerces.impl.dv.xs.TypeValidator$1 -> o4.d0$a:
org.apache.xerces.impl.dv.xs.UnionDV -> o4.e0:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    short getAllowedFacets() -> d
org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl -> o4.f0:
    org.apache.xerces.xs.XSAnnotation maxInclusiveAnnotation -> J
    java.lang.String fTypeName -> f
    org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl fAnySimpleType -> a0
    org.apache.xerces.xs.XSAnnotation lengthAnnotation -> B
    short fPatternType -> O
    org.apache.xerces.xs.XSAnnotation totalDigitsAnnotation -> F
    short fFinalSet -> h
    short fFacetsDefined -> l
    java.lang.Object fMinInclusive -> A
    org.apache.xerces.xs.XSObjectList fAnnotations -> N
    int fMaxLength -> q
    java.util.Vector fPattern -> t
    org.apache.xerces.xs.XSAnnotation maxExclusiveAnnotation -> K
    java.lang.String[] SPECIAL_PATTERN_STRING -> X
    boolean fAnonymous -> U
    org.apache.xerces.xs.XSAnnotation minLengthAnnotation -> C
    short fOrdered -> P
    short fFixedFacet -> m
    boolean fFinite -> Q
    org.apache.xerces.xs.XSAnnotation fractionDigitsAnnotation -> G
    java.lang.Object fMinExclusive -> z
    short fBuiltInKind -> e
    org.apache.xerces.impl.dv.xs.TypeValidator[] gDVs -> V
    int fTotalDigits -> r
    java.util.Vector fPatternStr -> u
    org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl fItemType -> c
    org.apache.xerces.xs.XSAnnotation minInclusiveAnnotation -> L
    java.lang.String[] WS_FACET_STRING -> Y
    org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl fAnyAtomicType -> b0
    org.apache.xerces.xs.XSAnnotation maxLengthAnnotation -> D
    short fWhiteSpace -> n
    org.apache.xerces.impl.dv.ValidatedInfo[] fEnumeration -> v
    boolean fBounded -> R
    org.apache.xerces.xs.XSNamespaceItem fNamespaceItem -> T
    short[] fDVNormalizeType -> W
    java.lang.Object fMaxExclusive -> y
    short fVariety -> j
    org.apache.xerces.impl.dv.xs.TypeValidator[] fDVs -> a
    int fEnumerationSize -> w
    boolean fIsImmutable -> b
    int fFractionDigits -> s
    java.lang.String fTargetNamespace -> g
    int fLength -> o
    org.apache.xerces.xs.XSAnnotation minExclusiveAnnotation -> M
    org.apache.xerces.xs.XSAnnotation whiteSpaceAnnotation -> E
    boolean fNumeric -> S
    org.apache.xerces.impl.xs.util.XSObjectListImpl patternAnnotations -> H
    java.lang.Object fMaxInclusive -> x
    org.apache.xerces.impl.dv.ValidationContext fDummyContext -> c0
    short fValidationDV -> k
    org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl fBase -> i
    org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl[] fMemberTypes -> d
    org.apache.xerces.xs.XSObjectList enumerationAnnotations -> I
    int fMinLength -> p
    org.apache.xerces.impl.dv.ValidationContext fEmptyContext -> Z
    void setCardinality() -> A
    void setNamespaceItem(org.apache.xerces.xs.XSNamespaceItem) -> B
    void setNumeric() -> C
    void setOrdered() -> D
    boolean specialCardinalityCheck() -> E
    void validate(org.apache.xerces.impl.dv.ValidationContext,org.apache.xerces.impl.dv.ValidatedInfo) -> F
    org.apache.xerces.impl.dv.ValidatedInfo validateWithInfo(java.lang.String,org.apache.xerces.impl.dv.ValidationContext,org.apache.xerces.impl.dv.ValidatedInfo) -> G
    java.lang.String whiteSpaceValue(short) -> H
    boolean getNumeric() -> a
    short getBuiltInKind() -> c
    boolean getFinite() -> d
    java.lang.String getName() -> e
    boolean isIDType() -> f
    void appendEnumString(java.lang.StringBuffer) -> g
    void applyFacets(org.apache.xerces.impl.dv.XSFacets,short,short,short,org.apache.xerces.impl.dv.ValidationContext) -> h
    void applyFacets1(org.apache.xerces.impl.dv.XSFacets,short,short) -> i
    void applyFacets1(org.apache.xerces.impl.dv.XSFacets,short,short,short) -> j
    void calcFundamentalFacets() -> k
    void checkExtraRules(org.apache.xerces.impl.dv.ValidationContext,org.apache.xerces.impl.dv.ValidatedInfo) -> l
    void checkFacets(org.apache.xerces.impl.dv.ValidatedInfo) -> m
    short convertToPrimitiveKind(short) -> n
    org.apache.xerces.impl.dv.ValidatedInfo getActualEnumValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext,org.apache.xerces.impl.dv.ValidatedInfo) -> o
    java.lang.Object getActualValue(java.lang.Object,org.apache.xerces.impl.dv.ValidationContext,org.apache.xerces.impl.dv.ValidatedInfo,boolean) -> p
    boolean getAnonymous() -> q
    org.apache.xerces.xs.XSTypeDefinition getBaseType() -> r
    boolean getBounded() -> s
    short getPrimitiveDV(short) -> t
    short getVariety() -> u
    java.lang.String normalize(java.lang.Object,short) -> v
    java.lang.String normalize(java.lang.String,short) -> w
    void reportError(java.lang.String,java.lang.Object[]) -> x
    void setAnonymous(boolean) -> y
    void setBounded() -> z
org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1 -> o4.f0$a:
    java.lang.String getURI(java.lang.String) -> a
    boolean needExtraChecking() -> b
    boolean isEntityUnparsed(java.lang.String) -> c
    java.lang.String getSymbol(java.lang.String) -> d
    java.util.Locale getLocale() -> e
    boolean needFacetChecking() -> f
    void addId(java.lang.String) -> g
    void addIdRef(java.lang.String) -> h
    boolean isIdDeclared(java.lang.String) -> i
    boolean needToNormalize() -> j
org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$4 -> o4.f0$b:
    java.lang.String getURI(java.lang.String) -> a
    boolean needExtraChecking() -> b
    boolean isEntityUnparsed(java.lang.String) -> c
    java.lang.String getSymbol(java.lang.String) -> d
    java.util.Locale getLocale() -> e
    boolean needFacetChecking() -> f
    void addId(java.lang.String) -> g
    void addIdRef(java.lang.String) -> h
    boolean isIdDeclared(java.lang.String) -> i
    boolean needToNormalize() -> j
org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl -> o4.f0$c:
    org.apache.xerces.impl.dv.ValidationContext fExternal -> a
    org.apache.xerces.xni.NamespaceContext fNSContext -> b
    java.lang.String getURI(java.lang.String) -> a
    boolean needExtraChecking() -> b
    boolean isEntityUnparsed(java.lang.String) -> c
    java.lang.String getSymbol(java.lang.String) -> d
    java.util.Locale getLocale() -> e
    boolean needFacetChecking() -> f
    void addId(java.lang.String) -> g
    void addIdRef(java.lang.String) -> h
    boolean isIdDeclared(java.lang.String) -> i
    boolean needToNormalize() -> j
    void setNSContext(org.apache.xerces.xni.NamespaceContext) -> k
org.apache.xerces.impl.dv.xs.YearDV -> o4.g0:
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String) -> N
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> r
org.apache.xerces.impl.dv.xs.YearMonthDV -> o4.h0:
    org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String) -> N
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
    java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData) -> r
org.apache.xerces.impl.dv.xs.YearMonthDurationDV -> o4.i0:
    java.lang.Object getActualValue(java.lang.String,org.apache.xerces.impl.dv.ValidationContext) -> c
org.apache.xerces.impl.io.ASCIIReader -> p4.a:
    byte[] fBuffer -> R2
    java.util.Locale fLocale -> T2
    org.apache.xerces.util.MessageFormatter fFormatter -> S2
    java.io.InputStream fInputStream -> Q2
org.apache.xerces.impl.io.Latin1Reader -> p4.b:
    byte[] fBuffer -> R2
    java.io.InputStream fInputStream -> Q2
org.apache.xerces.impl.io.MalformedByteSequenceException -> p4.c:
    org.apache.xerces.util.MessageFormatter fFormatter -> Q2
    java.lang.String fMessage -> V2
    java.util.Locale fLocale -> R2
    java.lang.String fKey -> T2
    java.lang.String fDomain -> S2
    java.lang.Object[] fArguments -> U2
    java.lang.Object[] getArguments() -> a
    java.lang.String getDomain() -> b
    java.lang.String getKey() -> c
org.apache.xerces.impl.io.UCSReader -> p4.d:
    byte[] fBuffer -> R2
    short fEncoding -> S2
    java.io.InputStream fInputStream -> Q2
org.apache.xerces.impl.io.UTF16Reader -> p4.e:
    java.util.Locale fLocale -> U2
    byte[] fBuffer -> R2
    boolean fIsBigEndian -> S2
    org.apache.xerces.util.MessageFormatter fFormatter -> T2
    java.io.InputStream fInputStream -> Q2
    void expectedTwoBytes() -> a
    void processBE(char[],int,int) -> b
    void processLE(char[],int,int) -> c
org.apache.xerces.impl.io.UTF8Reader -> p4.f:
    byte[] fBuffer -> R2
    int fOffset -> S2
    int fSurrogate -> T2
    java.util.Locale fLocale -> V2
    org.apache.xerces.util.MessageFormatter fFormatter -> U2
    java.io.InputStream fInputStream -> Q2
    void expectedByte(int,int) -> a
    void invalidByte(int,int,int) -> b
    void invalidSurrogate(int) -> c
org.apache.xerces.impl.msg.XMLMessageFormatter -> q4.a:
    java.util.Locale fLocale -> a
    java.util.ResourceBundle fResourceBundle -> b
    java.lang.String formatMessage(java.util.Locale,java.lang.String,java.lang.Object[]) -> a
org.apache.xerces.impl.validation.ValidationManager -> r4.a:
    boolean fGrammarFound -> b
    java.util.ArrayList fVSs -> a
    boolean fCachedDTD -> c
    boolean isCachedDTD() -> a
    void reset() -> b
org.apache.xerces.impl.xpath.regex.BMPattern -> s4.a:
    char[] pattern -> a
    int[] shiftTable -> b
    boolean ignoreCase -> c
    int matches(java.lang.String,int,int) -> a
    int matchesIgnoreCase(java.lang.String,int,int) -> b
org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap -> s4.b:
    int[][][] caseInsensitiveMap -> e
    int LOWER_CASE_MATCH -> f
    int UPPER_CASE_MATCH -> g
    int INITIAL_CHUNK_COUNT -> d
    int CHUNK_SIZE -> b
    int CHUNK_MASK -> c
    int CHUNK_SHIFT -> a
    void buildCaseInsensitiveMap() -> a
    boolean contains(int[],int) -> b
    boolean contains(int[],int,int) -> c
    int[] expandAndAdd(int[],int,int) -> d
    int[] expandMap(int[],int) -> e
    int[] get(int) -> f
    int[] getMapping(int) -> g
    void set(int,int[]) -> h
    int[] updateMap(int,int[],int,int[],int) -> i
org.apache.xerces.impl.xpath.regex.Match -> s4.c:
    int nofgroups -> S2
    char[] charSource -> V2
    java.lang.String strSource -> U2
    int[] beginpos -> Q2
    java.text.CharacterIterator ciSource -> T2
    int[] endpos -> R2
    int getBeginning(int) -> a
    int getEnd(int) -> b
    void setBeginning(int,int) -> c
    void setEnd(int,int) -> d
    void setNumberOfGroups(int) -> e
    void setSource(java.lang.String) -> f
    void setSource(java.text.CharacterIterator) -> g
org.apache.xerces.impl.xpath.regex.Op -> s4.d:
    org.apache.xerces.impl.xpath.regex.Op next -> b
    int type -> a
    org.apache.xerces.impl.xpath.regex.Op$CharOp createAnchor(int) -> a
    org.apache.xerces.impl.xpath.regex.Op$CharOp createBackReference(int) -> b
    org.apache.xerces.impl.xpath.regex.Op$CharOp createCapture(int,org.apache.xerces.impl.xpath.regex.Op) -> c
    org.apache.xerces.impl.xpath.regex.Op$CharOp createChar(int) -> d
    org.apache.xerces.impl.xpath.regex.Op$ChildOp createClosure(int) -> e
    org.apache.xerces.impl.xpath.regex.Op$ConditionOp createCondition(org.apache.xerces.impl.xpath.regex.Op,int,org.apache.xerces.impl.xpath.regex.Op,org.apache.xerces.impl.xpath.regex.Op,org.apache.xerces.impl.xpath.regex.Op) -> f
    org.apache.xerces.impl.xpath.regex.Op createDot() -> g
    org.apache.xerces.impl.xpath.regex.Op$ChildOp createIndependent(org.apache.xerces.impl.xpath.regex.Op,org.apache.xerces.impl.xpath.regex.Op) -> h
    org.apache.xerces.impl.xpath.regex.Op$ChildOp createLook(int,org.apache.xerces.impl.xpath.regex.Op,org.apache.xerces.impl.xpath.regex.Op) -> i
    org.apache.xerces.impl.xpath.regex.Op$ModifierOp createModifier(org.apache.xerces.impl.xpath.regex.Op,org.apache.xerces.impl.xpath.regex.Op,int,int) -> j
    org.apache.xerces.impl.xpath.regex.Op$ChildOp createNonGreedyClosure() -> k
    org.apache.xerces.impl.xpath.regex.Op$ChildOp createQuestion(boolean) -> l
    org.apache.xerces.impl.xpath.regex.Op$RangeOp createRange(org.apache.xerces.impl.xpath.regex.Token) -> m
    org.apache.xerces.impl.xpath.regex.Op$StringOp createString(java.lang.String) -> n
    org.apache.xerces.impl.xpath.regex.Op$UnionOp createUnion(int) -> o
    org.apache.xerces.impl.xpath.regex.Op elementAt(int) -> p
    org.apache.xerces.impl.xpath.regex.Op getChild() -> q
    int getData() -> r
    int getData2() -> s
    java.lang.String getString() -> t
    org.apache.xerces.impl.xpath.regex.RangeToken getToken() -> u
    int size() -> v
org.apache.xerces.impl.xpath.regex.Op$CharOp -> s4.d$a:
    int charData -> c
    int getData() -> r
org.apache.xerces.impl.xpath.regex.Op$ChildOp -> s4.d$b:
    org.apache.xerces.impl.xpath.regex.Op child -> c
    org.apache.xerces.impl.xpath.regex.Op getChild() -> q
    void setChild(org.apache.xerces.impl.xpath.regex.Op) -> w
org.apache.xerces.impl.xpath.regex.Op$ConditionOp -> s4.d$c:
    org.apache.xerces.impl.xpath.regex.Op condition -> d
    int refNumber -> c
    org.apache.xerces.impl.xpath.regex.Op yes -> e
    org.apache.xerces.impl.xpath.regex.Op no -> f
org.apache.xerces.impl.xpath.regex.Op$ModifierOp -> s4.d$d:
    int v1 -> d
    int v2 -> e
    int getData() -> r
    int getData2() -> s
org.apache.xerces.impl.xpath.regex.Op$RangeOp -> s4.d$e:
    org.apache.xerces.impl.xpath.regex.Token tok -> c
    org.apache.xerces.impl.xpath.regex.RangeToken getToken() -> u
org.apache.xerces.impl.xpath.regex.Op$StringOp -> s4.d$f:
    java.lang.String string -> c
    java.lang.String getString() -> t
org.apache.xerces.impl.xpath.regex.Op$UnionOp -> s4.d$g:
    java.util.Vector branches -> c
    org.apache.xerces.impl.xpath.regex.Op elementAt(int) -> p
    int size() -> v
    void addElement(org.apache.xerces.impl.xpath.regex.Op) -> w
org.apache.xerces.impl.xpath.regex.ParseException -> s4.e:
    int location -> Q2
org.apache.xerces.impl.xpath.regex.ParserForXMLSchema -> s4.f:
    int[] DIGITS_INTS -> o
    java.util.Hashtable ranges2 -> n
    java.util.Hashtable ranges -> m
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_gt() -> A
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_i() -> B
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_lt() -> C
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_z() -> E
    int processCIinCharacterClass(org.apache.xerces.impl.xpath.regex.RangeToken,int) -> F
    org.apache.xerces.impl.xpath.regex.Token processCaret() -> G
    org.apache.xerces.impl.xpath.regex.Token processCondition() -> H
    org.apache.xerces.impl.xpath.regex.Token processDollar() -> I
    org.apache.xerces.impl.xpath.regex.Token processIndependent() -> J
    org.apache.xerces.impl.xpath.regex.Token processLookahead() -> K
    org.apache.xerces.impl.xpath.regex.Token processLookbehind() -> L
    org.apache.xerces.impl.xpath.regex.Token processModifiers() -> M
    org.apache.xerces.impl.xpath.regex.Token processNegativelookahead() -> N
    org.apache.xerces.impl.xpath.regex.Token processNegativelookbehind() -> O
    org.apache.xerces.impl.xpath.regex.Token processParen() -> P
    org.apache.xerces.impl.xpath.regex.Token processParen2() -> Q
    org.apache.xerces.impl.xpath.regex.Token processPlus(org.apache.xerces.impl.xpath.regex.Token) -> R
    org.apache.xerces.impl.xpath.regex.Token processQuestion(org.apache.xerces.impl.xpath.regex.Token) -> S
    org.apache.xerces.impl.xpath.regex.Token processStar(org.apache.xerces.impl.xpath.regex.Token) -> T
    org.apache.xerces.impl.xpath.regex.RangeToken getRange(java.lang.String,boolean) -> X
    void setupRange(org.apache.xerces.impl.xpath.regex.Token,java.lang.String) -> Y
    void setupRange(org.apache.xerces.impl.xpath.regex.Token,int[]) -> Z
    boolean checkQuestion(int) -> c
    int decodeEscaped() -> d
    org.apache.xerces.impl.xpath.regex.Token getTokenForShorthand(int) -> f
    org.apache.xerces.impl.xpath.regex.RangeToken parseCharacterClass(boolean) -> l
    org.apache.xerces.impl.xpath.regex.RangeToken parseSetOperations() -> o
    org.apache.xerces.impl.xpath.regex.Token processBackreference() -> q
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_A() -> r
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_B() -> s
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_C() -> t
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_I() -> u
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_X() -> v
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_Z() -> w
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_b() -> x
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_c() -> y
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_g() -> z
org.apache.xerces.impl.xpath.regex.REUtil -> s4.g:
    org.apache.xerces.impl.xpath.regex.RegularExpression[] regexCache -> a
    int composeFromSurrogates(int,int) -> a
    java.lang.String createOptionString(int) -> b
    java.lang.String decomposeToSurrogates(int) -> c
    int getOptionValue(int) -> d
    boolean isHighSurrogate(int) -> e
    boolean isLowSurrogate(int) -> f
    int parseOptions(java.lang.String) -> g
    java.lang.String quoteMeta(java.lang.String) -> h
    java.lang.String stripExtendedComment(java.lang.String) -> i
org.apache.xerces.impl.xpath.regex.RangeToken -> s4.h:
    boolean sorted -> t3
    org.apache.xerces.impl.xpath.regex.RangeToken icaseCache -> v3
    boolean compacted -> u3
    int nonMapIndex -> x3
    int[] map -> w3
    int[] ranges -> s3
    void mergeRanges(org.apache.xerces.impl.xpath.regex.Token) -> K
    void subtractRanges(org.apache.xerces.impl.xpath.regex.Token) -> Q
    java.lang.String toString(int) -> R
    void compactRanges() -> S
    void createMap() -> T
    java.lang.String escapeCharInCharClass(int) -> U
    void intersectRanges(org.apache.xerces.impl.xpath.regex.Token) -> V
    boolean isCompacted() -> W
    boolean isSorted() -> X
    boolean match(int) -> Y
    void setCompacted() -> Z
    void setSorted(boolean) -> a0
    void addRange(int,int) -> b
    void sortRanges() -> b0
    org.apache.xerces.impl.xpath.regex.Token complementRanges(org.apache.xerces.impl.xpath.regex.Token) -> d
org.apache.xerces.impl.xpath.regex.RegexParser -> s4.i:
    int parennumber -> j
    int context -> h
    boolean hasBackReferences -> k
    int parenOpened -> i
    java.util.Vector references -> l
    int chardata -> f
    int nexttoken -> g
    int options -> d
    java.lang.String regex -> b
    int regexlen -> c
    int offset -> a
    java.util.ResourceBundle resources -> e
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_gt() -> A
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_i() -> B
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_lt() -> C
    org.apache.xerces.impl.xpath.regex.RangeToken processBacksolidus_pP(int) -> D
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_z() -> E
    int processCIinCharacterClass(org.apache.xerces.impl.xpath.regex.RangeToken,int) -> F
    org.apache.xerces.impl.xpath.regex.Token processCaret() -> G
    org.apache.xerces.impl.xpath.regex.Token processCondition() -> H
    org.apache.xerces.impl.xpath.regex.Token processDollar() -> I
    org.apache.xerces.impl.xpath.regex.Token processIndependent() -> J
    org.apache.xerces.impl.xpath.regex.Token processLookahead() -> K
    org.apache.xerces.impl.xpath.regex.Token processLookbehind() -> L
    org.apache.xerces.impl.xpath.regex.Token processModifiers() -> M
    org.apache.xerces.impl.xpath.regex.Token processNegativelookahead() -> N
    org.apache.xerces.impl.xpath.regex.Token processNegativelookbehind() -> O
    org.apache.xerces.impl.xpath.regex.Token processParen() -> P
    org.apache.xerces.impl.xpath.regex.Token processParen2() -> Q
    org.apache.xerces.impl.xpath.regex.Token processPlus(org.apache.xerces.impl.xpath.regex.Token) -> R
    org.apache.xerces.impl.xpath.regex.Token processQuestion(org.apache.xerces.impl.xpath.regex.Token) -> S
    org.apache.xerces.impl.xpath.regex.Token processStar(org.apache.xerces.impl.xpath.regex.Token) -> T
    int read() -> U
    void setContext(int) -> V
    void setLocale(java.util.Locale) -> W
    void addCaseInsensitiveChar(org.apache.xerces.impl.xpath.regex.RangeToken,int) -> a
    void addCaseInsensitiveCharRange(org.apache.xerces.impl.xpath.regex.RangeToken,int,int) -> b
    boolean checkQuestion(int) -> c
    int decodeEscaped() -> d
    org.apache.xerces.impl.xpath.regex.ParseException ex(java.lang.String,int) -> e
    org.apache.xerces.impl.xpath.regex.Token getTokenForShorthand(int) -> f
    int hexChar(int) -> g
    boolean isSet(int) -> h
    void next() -> i
    org.apache.xerces.impl.xpath.regex.Token parse(java.lang.String,int) -> j
    org.apache.xerces.impl.xpath.regex.Token parseAtom() -> k
    org.apache.xerces.impl.xpath.regex.RangeToken parseCharacterClass(boolean) -> l
    org.apache.xerces.impl.xpath.regex.Token parseFactor() -> m
    org.apache.xerces.impl.xpath.regex.Token parseRegex() -> n
    org.apache.xerces.impl.xpath.regex.RangeToken parseSetOperations() -> o
    org.apache.xerces.impl.xpath.regex.Token parseTerm() -> p
    org.apache.xerces.impl.xpath.regex.Token processBackreference() -> q
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_A() -> r
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_B() -> s
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_C() -> t
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_I() -> u
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_X() -> v
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_Z() -> w
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_b() -> x
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_c() -> y
    org.apache.xerces.impl.xpath.regex.Token processBacksolidus_g() -> z
org.apache.xerces.impl.xpath.regex.RegexParser$ReferencePosition -> s4.i$a:
    int position -> b
    int refNumber -> a
org.apache.xerces.impl.xpath.regex.RegularExpression -> s4.j:
    org.apache.xerces.impl.xpath.regex.RangeToken firstChar -> Z2
    boolean fixedStringOnly -> d3
    org.apache.xerces.impl.xpath.regex.Token tokentree -> T2
    org.apache.xerces.impl.xpath.regex.Op operations -> W2
    java.lang.String fixedString -> a3
    int options -> R2
    int minlength -> V2
    int nofparen -> S2
    org.apache.xerces.impl.xpath.regex.BMPattern fixedStringTable -> c3
    org.apache.xerces.impl.xpath.regex.RegularExpression$Context context -> Y2
    boolean hasBackReferences -> U2
    int numberOfClosures -> X2
    java.lang.String regex -> Q2
    int fixedStringOptions -> b3
    org.apache.xerces.impl.xpath.regex.Op compile(org.apache.xerces.impl.xpath.regex.Token,org.apache.xerces.impl.xpath.regex.Op,boolean) -> a
    void compile(org.apache.xerces.impl.xpath.regex.Token) -> b
    java.lang.String getOptions() -> c
    int getPreviousWordType(org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget,int,int,int,int) -> d
    int getWordType(org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget,int,int,int,int) -> e
    int getWordType0(char,int) -> f
    boolean isEOLChar(int) -> g
    boolean isSet(int,int) -> h
    boolean isWordChar(int) -> i
    int match(org.apache.xerces.impl.xpath.regex.RegularExpression$Context,org.apache.xerces.impl.xpath.regex.Op,int,int,int) -> j
    boolean matchAnchor(org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget,org.apache.xerces.impl.xpath.regex.Op,org.apache.xerces.impl.xpath.regex.RegularExpression$Context,int,int) -> k
    boolean matchChar(int,int,boolean) -> l
    boolean matchIgnoreCase(int,int) -> m
    boolean matches(java.lang.String) -> n
    boolean matches(java.lang.String,int,int,org.apache.xerces.impl.xpath.regex.Match) -> o
    void prepare() -> p
    void setPattern(java.lang.String,int,java.util.Locale) -> q
    void setPattern(java.lang.String,java.lang.String,java.util.Locale) -> r
org.apache.xerces.impl.xpath.regex.RegularExpression$ClosureContext -> s4.j$a:
    int[] offsets -> a
    int currentIndex -> b
    void addOffset(int) -> a
    boolean contains(int) -> b
    int[] expandOffsets() -> c
    void reset() -> d
org.apache.xerces.impl.xpath.regex.RegularExpression$Context -> s4.j$b:
    org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget target -> h
    org.apache.xerces.impl.xpath.regex.Match match -> d
    boolean inuse -> e
    org.apache.xerces.impl.xpath.regex.RegularExpression$StringTarget stringTarget -> g
    int limit -> b
    org.apache.xerces.impl.xpath.regex.RegularExpression$ClosureContext[] closureContexts -> f
    int length -> c
    int start -> a
    void reset(java.lang.String,int,int,int) -> a
    void resetCommon(int) -> b
    void setInUse(boolean) -> c
org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget -> s4.j$c:
    char charAt(int) -> a
    boolean regionMatches(boolean,int,int,int,int) -> b
    boolean regionMatches(boolean,int,int,java.lang.String,int) -> c
org.apache.xerces.impl.xpath.regex.RegularExpression$StringTarget -> s4.j$d:
    java.lang.String target -> a
    char charAt(int) -> a
    boolean regionMatches(boolean,int,int,int,int) -> b
    boolean regionMatches(boolean,int,int,java.lang.String,int) -> c
    void resetTarget(java.lang.String) -> d
org.apache.xerces.impl.xpath.regex.Token -> s4.k:
    java.util.Hashtable categories2 -> l3
    java.util.Hashtable categories -> k3
    org.apache.xerces.impl.xpath.regex.Token token_wordchars -> U2
    org.apache.xerces.impl.xpath.regex.Token token_not_0to9 -> V2
    org.apache.xerces.impl.xpath.regex.Token token_dot -> S2
    org.apache.xerces.impl.xpath.regex.Token token_0to9 -> T2
    int type -> Q2
    org.apache.xerces.impl.xpath.regex.Token token_not_spaces -> Y2
    int tokens -> R2
    org.apache.xerces.impl.xpath.regex.Token token_empty -> Z2
    org.apache.xerces.impl.xpath.regex.Token token_not_wordchars -> W2
    org.apache.xerces.impl.xpath.regex.Token token_spaces -> X2
    int[] nonBMPBlockRanges -> o3
    org.apache.xerces.impl.xpath.regex.Token token_linebeginning2 -> b3
    org.apache.xerces.impl.xpath.regex.Token token_lineend -> c3
    org.apache.xerces.impl.xpath.regex.Token token_linebeginning -> a3
    java.lang.String[] blockNames -> n3
    java.lang.String[] categoryNames -> m3
    org.apache.xerces.impl.xpath.regex.Token token_ccs -> r3
    org.apache.xerces.impl.xpath.regex.Token token_grapheme -> q3
    org.apache.xerces.impl.xpath.regex.Token token_stringend2 -> f3
    org.apache.xerces.impl.xpath.regex.Token token_wordedge -> g3
    org.apache.xerces.impl.xpath.regex.Token token_stringbeginning -> d3
    org.apache.xerces.impl.xpath.regex.Token token_stringend -> e3
    org.apache.xerces.impl.xpath.regex.Token token_wordend -> j3
    java.util.Hashtable nonxs -> p3
    org.apache.xerces.impl.xpath.regex.Token token_not_wordedge -> h3
    org.apache.xerces.impl.xpath.regex.Token token_wordbeginning -> i3
    int getMin() -> A
    int getMinLength() -> B
    int getParenNumber() -> C
    org.apache.xerces.impl.xpath.regex.RangeToken getRange(java.lang.String,boolean) -> D
    org.apache.xerces.impl.xpath.regex.RangeToken getRange(java.lang.String,boolean,boolean) -> E
    int getReferenceNumber() -> F
    java.lang.String getString() -> G
    boolean isRegisterNonXS(java.lang.String) -> H
    boolean isSet(int,int) -> I
    boolean isShorterThan(org.apache.xerces.impl.xpath.regex.Token) -> J
    void mergeRanges(org.apache.xerces.impl.xpath.regex.Token) -> K
    void registerNonXS(java.lang.String) -> L
    void setAlias(java.lang.String,java.lang.String,boolean) -> M
    void setMax(int) -> N
    void setMin(int) -> O
    int size() -> P
    void subtractRanges(org.apache.xerces.impl.xpath.regex.Token) -> Q
    java.lang.String toString(int) -> R
    void addChild(org.apache.xerces.impl.xpath.regex.Token) -> a
    void addRange(int,int) -> b
    int analyzeFirstCharacter(org.apache.xerces.impl.xpath.regex.RangeToken,int) -> c
    org.apache.xerces.impl.xpath.regex.Token complementRanges(org.apache.xerces.impl.xpath.regex.Token) -> d
    org.apache.xerces.impl.xpath.regex.Token$CharToken createAnchor(int) -> e
    org.apache.xerces.impl.xpath.regex.Token$StringToken createBackReference(int) -> f
    org.apache.xerces.impl.xpath.regex.Token$CharToken createChar(int) -> g
    org.apache.xerces.impl.xpath.regex.Token$ClosureToken createClosure(org.apache.xerces.impl.xpath.regex.Token) -> h
    org.apache.xerces.impl.xpath.regex.Token$ConcatToken createConcat(org.apache.xerces.impl.xpath.regex.Token,org.apache.xerces.impl.xpath.regex.Token) -> i
    org.apache.xerces.impl.xpath.regex.Token$UnionToken createConcat() -> j
    org.apache.xerces.impl.xpath.regex.Token$ConditionToken createCondition(int,org.apache.xerces.impl.xpath.regex.Token,org.apache.xerces.impl.xpath.regex.Token,org.apache.xerces.impl.xpath.regex.Token) -> k
    org.apache.xerces.impl.xpath.regex.Token createEmpty() -> l
    org.apache.xerces.impl.xpath.regex.Token$ParenToken createLook(int,org.apache.xerces.impl.xpath.regex.Token) -> m
    org.apache.xerces.impl.xpath.regex.Token$ModifierToken createModifierGroup(org.apache.xerces.impl.xpath.regex.Token,int,int) -> n
    org.apache.xerces.impl.xpath.regex.Token$ClosureToken createNGClosure(org.apache.xerces.impl.xpath.regex.Token) -> o
    org.apache.xerces.impl.xpath.regex.RangeToken createNRange() -> p
    org.apache.xerces.impl.xpath.regex.Token$ParenToken createParen(org.apache.xerces.impl.xpath.regex.Token,int) -> q
    org.apache.xerces.impl.xpath.regex.RangeToken createRange() -> r
    org.apache.xerces.impl.xpath.regex.Token$StringToken createString(java.lang.String) -> s
    org.apache.xerces.impl.xpath.regex.Token$UnionToken createUnion() -> t
    void findFixedString(org.apache.xerces.impl.xpath.regex.Token$FixedStringContainer,int) -> u
    int getChar() -> v
    org.apache.xerces.impl.xpath.regex.Token getChild(int) -> w
    org.apache.xerces.impl.xpath.regex.Token getCombiningCharacterSequence() -> x
    org.apache.xerces.impl.xpath.regex.Token getGraphemePattern() -> y
    int getMax() -> z
org.apache.xerces.impl.xpath.regex.Token$CharToken -> s4.k$a:
    int chardata -> s3
    java.lang.String toString(int) -> R
    int getChar() -> v
org.apache.xerces.impl.xpath.regex.Token$ClosureToken -> s4.k$b:
    int max -> t3
    org.apache.xerces.impl.xpath.regex.Token child -> u3
    int min -> s3
    int getMin() -> A
    void setMax(int) -> N
    void setMin(int) -> O
    int size() -> P
    java.lang.String toString(int) -> R
    org.apache.xerces.impl.xpath.regex.Token getChild(int) -> w
    int getMax() -> z
org.apache.xerces.impl.xpath.regex.Token$ConcatToken -> s4.k$c:
    org.apache.xerces.impl.xpath.regex.Token child -> s3
    org.apache.xerces.impl.xpath.regex.Token child2 -> t3
    int size() -> P
    java.lang.String toString(int) -> R
    org.apache.xerces.impl.xpath.regex.Token getChild(int) -> w
org.apache.xerces.impl.xpath.regex.Token$ConditionToken -> s4.k$d:
    org.apache.xerces.impl.xpath.regex.Token no -> v3
    org.apache.xerces.impl.xpath.regex.Token yes -> u3
    org.apache.xerces.impl.xpath.regex.Token condition -> t3
    int refNumber -> s3
    int size() -> P
    java.lang.String toString(int) -> R
    org.apache.xerces.impl.xpath.regex.Token getChild(int) -> w
org.apache.xerces.impl.xpath.regex.Token$FixedStringContainer -> s4.k$e:
    org.apache.xerces.impl.xpath.regex.Token token -> a
    int options -> b
org.apache.xerces.impl.xpath.regex.Token$ModifierToken -> s4.k$f:
    int mask -> u3
    int add -> t3
    org.apache.xerces.impl.xpath.regex.Token child -> s3
    int size() -> P
    java.lang.String toString(int) -> R
    int getOptions() -> S
    int getOptionsMask() -> T
    org.apache.xerces.impl.xpath.regex.Token getChild(int) -> w
org.apache.xerces.impl.xpath.regex.Token$ParenToken -> s4.k$g:
    int parennumber -> t3
    org.apache.xerces.impl.xpath.regex.Token child -> s3
    int getParenNumber() -> C
    int size() -> P
    java.lang.String toString(int) -> R
    org.apache.xerces.impl.xpath.regex.Token getChild(int) -> w
org.apache.xerces.impl.xpath.regex.Token$StringToken -> s4.k$h:
    int refNumber -> t3
    java.lang.String string -> s3
    int getReferenceNumber() -> F
    java.lang.String getString() -> G
    java.lang.String toString(int) -> R
org.apache.xerces.impl.xpath.regex.Token$UnionToken -> s4.k$i:
    java.util.Vector children -> s3
    int size() -> P
    java.lang.String toString(int) -> R
    void addChild(org.apache.xerces.impl.xpath.regex.Token) -> a
    org.apache.xerces.impl.xpath.regex.Token getChild(int) -> w
org.apache.xerces.impl.xs.SchemaGrammar -> t4.a:
    org.apache.xerces.xs.datatypes.ObjectList[] fComponentsExt -> H
    org.apache.xerces.util.SymbolHash fGlobalTypeDecls -> h
    org.apache.xerces.impl.xs.util.SimpleLocator[] fRGLocators -> C
    org.apache.xerces.util.SymbolHash fGlobalAttrGrpDeclsExt -> j
    org.apache.xerces.util.SymbolTable fSymbolTable -> s
    org.apache.xerces.util.SymbolHash fGlobalGroupDeclsExt -> l
    org.apache.xerces.util.SymbolHash fGlobalIDConstraintDeclsExt -> n
    org.apache.xerces.util.SymbolHash fAllGlobalElemDecls -> p
    java.util.Vector fDocuments -> I
    int fSubGroupCount -> E
    boolean[] GLOBAL_COMP -> P
    org.apache.xerces.impl.xs.XSElementDecl[] fSubGroups -> F
    int fRGCount -> A
    java.lang.ref.SoftReference fSAXParser -> t
    java.lang.String fTargetNamespace -> a
    org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar SG_XSI -> O
    org.apache.xerces.util.SymbolHash fGlobalAttrGrpDecls -> c
    org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar SG_SchemaNSExtended -> M
    org.apache.xerces.util.SymbolHash fGlobalGroupDecls -> e
    org.apache.xerces.impl.dv.XSSimpleType fAnySimpleType -> N
    org.apache.xerces.util.SymbolHash fGlobalIDConstraintDecls -> g
    org.apache.xerces.impl.xs.XSComplexTypeDecl fAnyType -> K
    org.apache.xerces.util.SymbolHash fGlobalAttrDeclsExt -> i
    org.apache.xerces.util.SymbolHash fGlobalElemDeclsExt -> k
    org.apache.xerces.util.SymbolHash fGlobalNotationDeclsExt -> m
    org.apache.xerces.util.SymbolHash fGlobalTypeDeclsExt -> o
    org.apache.xerces.impl.xs.XSDDescription fGrammarDescription -> q
    boolean fIsImmutable -> v
    java.util.Vector fLocations -> J
    org.apache.xerces.impl.xs.XSGroupDecl[] fRedefinedGroupDecls -> B
    org.apache.xerces.impl.xs.XSComplexTypeDecl[] fComplexTypeDecls -> y
    java.lang.ref.SoftReference fDOMParser -> u
    int fCTCount -> x
    org.apache.xerces.xs.XSNamedMap[] fComponents -> G
    org.apache.xerces.impl.xs.XSAnnotationImpl[] fAnnotations -> r
    org.apache.xerces.util.SymbolHash fGlobalAttrDecls -> b
    org.apache.xerces.impl.xs.util.SimpleLocator[] fCTLocators -> z
    java.util.Vector fImported -> w
    org.apache.xerces.util.SymbolHash fGlobalElemDecls -> d
    org.apache.xerces.util.SymbolHash fGlobalNotationDecls -> f
    boolean fFullChecked -> D
    org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar SG_SchemaNS -> L
    org.apache.xerces.xs.XSTypeDefinition getGlobalTypeDecl(java.lang.String) -> a
    java.util.Vector getImportedGrammars() -> b
    java.lang.String getTargetNamespace() -> c
org.apache.xerces.impl.xs.SchemaGrammar$BuiltinAttrDecl -> t4.a$a:
org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar -> t4.a$b:
org.apache.xerces.impl.xs.SchemaGrammar$XSAnyType -> t4.a$c:
    org.apache.xerces.impl.xs.XSAttributeGroupDecl createAttrGrp() -> l
    org.apache.xerces.impl.xs.XSParticleDecl createParticle() -> m
org.apache.xerces.impl.xs.SchemaSymbols -> t4.b:
    java.lang.String URI_SCHEMAFORSCHEMA -> f
    java.lang.String ELT_MINLENGTH -> I
    java.lang.String ELT_ANYATTRIBUTE -> j
    java.lang.String ATT_XPATH -> E0
    java.lang.String ELT_RESTRICTION -> M
    java.lang.String ATT_VERSION -> C0
    java.lang.String ELT_CHOICE -> n
    java.lang.String ATT_USE -> A0
    java.lang.String ELT_SIMPLECONTENT -> Q
    java.lang.String ELT_ELEMENT -> r
    java.lang.String ELT_UNIQUE -> U
    java.lang.String ELT_FRACTIONDIGITS -> v
    java.lang.String ATT_BASE -> Y
    java.lang.String ATT_PUBLIC -> x0
    java.lang.String ATT_SUBSTITUTIONGROUP -> v0
    java.lang.String ELT_KEY -> z
    java.lang.String ATT_SCHEMALOCATION -> t0
    java.lang.String ATT_REF -> r0
    java.lang.String URI_XSI -> a
    java.lang.String ATT_NILLABLE -> p0
    java.lang.String ATT_NAME -> n0
    java.lang.String XSI_NIL -> e
    java.lang.String ATT_MINOCCURS -> l0
    java.lang.String ELT_MAXEXCLUSIVE -> D
    java.lang.String ATT_MAXOCCURS -> j0
    java.lang.String ELT_ANY -> i
    java.lang.String ATT_ID -> h0
    java.lang.String ELT_MININCLUSIVE -> H
    java.lang.String ATT_FIXED -> f0
    java.lang.String ELT_ATTRIBUTEGROUP -> m
    java.lang.String ATT_FINAL -> d0
    java.lang.String ELT_REDEFINE -> L
    java.lang.String ATT_DEFAULT -> b0
    java.lang.String ELT_DOCUMENTATION -> q
    java.lang.String ELT_SEQUENCE -> P
    java.lang.String ELT_FIELD -> u
    java.lang.String ATT_TARGETNAMESPACE -> y0
    java.lang.String ELT_UNION -> T
    java.lang.String ELT_INCLUDE -> y
    java.lang.String ATT_ATTRIBUTEFORMDEFAULT -> X
    java.lang.String ELT_LIST -> C
    java.lang.String XSI_TYPE -> d
    java.lang.String ELT_MINEXCLUSIVE -> G
    java.lang.String ELT_ANNOTATION -> h
    java.lang.String ELT_PATTERN -> K
    java.lang.String ATT_XML_LANG -> D0
    java.lang.String ELT_ATTRIBUTE -> l
    java.lang.String ELT_SELECTOR -> O
    java.lang.String ATT_VALUE -> B0
    java.lang.String ELT_COMPLEXTYPE -> p
    java.lang.String ELT_TOTALDIGITS -> S
    java.lang.String ELT_EXTENSION -> t
    java.lang.String ATT_ABSTRACT -> W
    java.lang.String ELT_IMPORT -> x
    java.lang.String ATT_SYSTEM -> w0
    java.lang.String ATT_SOURCE -> u0
    java.lang.String ATT_REFER -> s0
    java.lang.String ATT_PROCESSCONTENTS -> q0
    java.lang.String ATT_NAMESPACE -> o0
    java.lang.String XSI_NONAMESPACESCHEMALOCATION -> c
    java.lang.String ELT_LENGTH -> B
    java.lang.String ATT_MIXED -> m0
    java.lang.String ATT_MEMBERTYPES -> k0
    java.lang.String ELT_ALL -> g
    java.lang.String ELT_MAXLENGTH -> F
    java.lang.String ATT_ITEMTYPE -> i0
    java.lang.String ATT_FORM -> g0
    java.lang.String ELT_APPINFO -> k
    java.lang.String ELT_NOTATION -> J
    java.lang.String ATT_FINALDEFAULT -> e0
    java.lang.String ATT_ELEMENTFORMDEFAULT -> c0
    java.lang.String ELT_COMPLEXCONTENT -> o
    java.lang.String ELT_SCHEMA -> N
    java.lang.String ATT_BLOCKDEFAULT -> a0
    java.lang.String ELT_ENUMERATION -> s
    java.lang.String ELT_SIMPLETYPE -> R
    java.lang.String ATT_TYPE -> z0
    java.lang.String ELT_GROUP -> w
    java.lang.String ELT_WHITESPACE -> V
    java.lang.String ATT_BLOCK -> Z
    java.lang.String ELT_KEYREF -> A
    java.lang.String XSI_SCHEMALOCATION -> b
    java.lang.String ELT_MAXINCLUSIVE -> E
org.apache.xerces.impl.xs.SubstitutionGroupHandler -> t4.c:
    java.util.Hashtable fSubGroupsB -> b
    java.util.Hashtable fSubGroups -> c
    org.apache.xerces.impl.xs.XSElementDecl[] EMPTY_GROUP -> d
    org.apache.xerces.impl.xs.XSElementDeclHelper fXSElementDeclHelper -> a
    org.apache.xerces.impl.xs.SubstitutionGroupHandler$OneSubGroup[] EMPTY_VECTOR -> e
    void reset() -> a
org.apache.xerces.impl.xs.SubstitutionGroupHandler$OneSubGroup -> t4.c$a:
org.apache.xerces.impl.xs.XMLSchemaLoader -> t4.d:
    java.lang.String fExternalNoNSSchema -> g
    org.apache.xerces.impl.xs.XSGrammarBucket fGrammarBucket -> m
    java.lang.String fExternalSchemas -> f
    org.apache.xerces.impl.xs.models.CMBuilder fCMBuilder -> o
    java.lang.Object fJAXPSource -> h
    boolean fIsCheckedFully -> i
    boolean fJAXPProcessed -> j
    boolean fSettingsChanged -> k
    org.w3c.dom.DOMStringList fRecognizedParameters -> t
    org.apache.xerces.impl.dv.SchemaDVFactory fDefaultSchemaDVFactory -> q
    java.util.Locale fLocale -> s
    org.apache.xerces.impl.xs.SubstitutionGroupHandler fSubGroupHandler -> n
    java.util.WeakHashMap fJAXPCache -> r
    org.apache.xerces.xni.grammars.XMLGrammarPool fGrammarPool -> e
    org.apache.xerces.impl.XMLEntityManager fEntityManager -> c
    org.apache.xerces.impl.xs.traversers.XSDHandler fSchemaHandler -> l
    org.apache.xerces.impl.xs.XSDDescription fXSDDescription -> p
    org.apache.xerces.util.ParserConfigurationSettings fLoaderConfig -> a
    org.apache.xerces.impl.XMLErrorReporter fErrorReporter -> b
    java.lang.String[] RECOGNIZED_PROPERTIES -> w
    java.lang.String[] RECOGNIZED_FEATURES -> v
    org.apache.xerces.util.DOMEntityResolverWrapper fResourceResolver -> u
    org.apache.xerces.xni.parser.XMLEntityResolver fUserEntityResolver -> d
    void initGrammarBucket() -> a
    boolean parserSettingsUpdated(org.apache.xerces.xni.parser.XMLComponentManager) -> b
    void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver) -> c
    void setFeature(java.lang.String,boolean) -> d
    void setErrorHandler(org.apache.xerces.xni.parser.XMLErrorHandler) -> e
    void setProperty(java.lang.String,java.lang.Object) -> f
    java.lang.Object getPropertyDefault(java.lang.String) -> g
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> h
    java.lang.Boolean getFeatureDefault(java.lang.String) -> i
    void setLocale(java.util.Locale) -> j
    java.lang.String[] getRecognizedProperties() -> k
    java.lang.String[] getRecognizedFeatures() -> n
org.apache.xerces.impl.xs.XSAnnotationImpl -> t4.e:
org.apache.xerces.impl.xs.XSAttributeDecl -> t4.f:
    short fConstraintType -> e
    org.apache.xerces.impl.dv.XSSimpleType fType -> c
    short fScope -> f
    org.apache.xerces.impl.dv.ValidatedInfo fDefault -> i
    org.apache.xerces.xni.QName fUnresolvedTypeName -> d
    java.lang.String fName -> a
    org.apache.xerces.xs.XSNamespaceItem fNamespaceItem -> j
    java.lang.String fTargetNamespace -> b
    org.apache.xerces.impl.xs.XSComplexTypeDecl fEnclosingCT -> g
    org.apache.xerces.xs.XSObjectList fAnnotations -> h
    java.lang.String getName() -> e
org.apache.xerces.impl.xs.XSAttributeGroupDecl -> t4.g:
    org.apache.xerces.impl.xs.XSWildcardDecl fAttributeWC -> e
    java.lang.String fIDAttrName -> f
    org.apache.xerces.impl.xs.XSAttributeUseImpl[] fAttributeUses -> d
    org.apache.xerces.impl.xs.util.XSObjectListImpl fAttrUses -> g
    java.lang.String fName -> a
    java.lang.String fTargetNamespace -> b
    int fAttrUseNum -> c
    org.apache.xerces.xs.XSNamespaceItem fNamespaceItem -> h
    java.lang.String getName() -> e
org.apache.xerces.impl.xs.XSAttributeUseImpl -> t4.h:
org.apache.xerces.impl.xs.XSComplexTypeDecl -> t4.i:
    org.apache.xerces.impl.xs.util.XSObjectListImpl fAnnotations -> n
    short fMiscFlags -> g
    org.apache.xerces.impl.xs.models.XSCMValidator fUPACMValidator -> m
    org.apache.xerces.impl.xs.XSAttributeGroupDecl fAttrGrp -> h
    short fFinal -> e
    short fBlock -> f
    org.apache.xerces.impl.xs.models.XSCMValidator fCMValidator -> l
    org.apache.xerces.xs.XSNamespaceItem fNamespaceItem -> o
    org.apache.xerces.xs.XSTypeDefinition fBaseType -> c
    short fContentType -> i
    java.lang.String fName -> a
    org.apache.xerces.impl.dv.XSSimpleType fXSSimpleType -> j
    org.apache.xerces.impl.xs.XSParticleDecl fParticle -> k
    java.lang.String fTargetNamespace -> b
    short fDerivedBy -> d
    short getContentType() -> b
    java.lang.String getName() -> e
    void appendTypeInfo(java.lang.StringBuffer) -> g
    boolean containsTypeID() -> h
    boolean getAbstract() -> i
    boolean getAnonymous() -> j
    java.lang.String getTypeName() -> k
org.apache.xerces.impl.xs.XSDDescription -> t4.j:
    short fContextType -> f
    java.lang.String getGrammarType() -> d
    java.lang.String getTargetNamespace() -> e
org.apache.xerces.impl.xs.XSDeclarationPool -> t4.k:
org.apache.xerces.impl.xs.XSElementDecl -> t4.l:
org.apache.xerces.impl.xs.XSElementDeclHelper -> t4.m:
org.apache.xerces.impl.xs.XSGrammarBucket -> t4.n:
    java.util.Hashtable fGrammarRegistry -> a
    org.apache.xerces.impl.xs.SchemaGrammar fNoNSGrammar -> b
    org.apache.xerces.impl.xs.SchemaGrammar getGrammar(java.lang.String) -> a
    void putGrammar(org.apache.xerces.impl.xs.SchemaGrammar) -> b
    boolean putGrammar(org.apache.xerces.impl.xs.SchemaGrammar,boolean) -> c
    void reset() -> d
org.apache.xerces.impl.xs.XSGroupDecl -> t4.o:
org.apache.xerces.impl.xs.XSMessageFormatter -> t4.p:
    java.util.Locale fLocale -> a
    java.util.ResourceBundle fResourceBundle -> b
    java.lang.String formatMessage(java.util.Locale,java.lang.String,java.lang.Object[]) -> a
org.apache.xerces.impl.xs.XSModelGroupImpl -> t4.q:
    org.apache.xerces.xs.XSObjectList fAnnotations -> d
    org.apache.xerces.impl.xs.XSParticleDecl[] fParticles -> b
    int fParticleCount -> c
    short fCompositor -> a
    java.lang.String fDescription -> e
    java.lang.String getName() -> e
org.apache.xerces.impl.xs.XSParticleDecl -> t4.r:
    org.apache.xerces.xs.XSObjectList fAnnotations -> e
    java.lang.String fDescription -> f
    org.apache.xerces.xs.XSTerm fValue -> b
    int fMaxOccurs -> d
    int fMinOccurs -> c
    short fType -> a
    java.lang.String getName() -> e
    void appendParticle(java.lang.StringBuffer) -> g
org.apache.xerces.impl.xs.XSWildcardDecl -> t4.s:
    org.apache.xerces.xs.XSObjectList fAnnotations -> d
    short fType -> a
    java.lang.String[] fNamespaceList -> c
    java.lang.String fDescription -> e
    short fProcessContents -> b
    java.lang.String getName() -> e
org.apache.xerces.impl.xs.models.CMBuilder -> u4.a:
    org.apache.xerces.impl.xs.models.XSEmptyCM fEmptyCM -> b
    org.apache.xerces.impl.xs.models.CMNodeFactory fNodeFactory -> a
    void setDeclPool(org.apache.xerces.impl.xs.XSDeclarationPool) -> a
org.apache.xerces.impl.xs.models.CMNodeFactory -> u4.b:
    org.apache.xerces.util.SecurityManager fSecurityManager -> b
    int nodeCount -> a
org.apache.xerces.impl.xs.models.XSCMValidator -> u4.c:
org.apache.xerces.impl.xs.models.XSEmptyCM -> u4.d:
    java.util.Vector EMPTY -> a
org.apache.xerces.impl.xs.opti.AttrImpl -> v4.a:
    java.lang.String value -> W2
    org.w3c.dom.Element element -> V2
    void setValue(java.lang.String) -> F
    org.w3c.dom.Element getOwnerElement() -> Z
    boolean getSpecified() -> d0
    java.lang.String getName() -> e
    org.w3c.dom.Document getOwnerDocument() -> j0
    java.lang.String getNodeValue() -> x
org.apache.xerces.impl.xs.opti.DefaultDocument -> v4.b:
    java.lang.String fDocumentURI -> V2
    org.w3c.dom.Element createElement(java.lang.String) -> A0
    java.lang.String getNodeName() -> B
    org.w3c.dom.Attr createAttributeNS(java.lang.String,java.lang.String) -> G
    org.w3c.dom.ProcessingInstruction createProcessingInstruction(java.lang.String,java.lang.String) -> K
    void setDocumentURI(java.lang.String) -> c
    org.w3c.dom.Attr createAttribute(java.lang.String) -> f0
    org.w3c.dom.Comment createComment(java.lang.String) -> h0
    org.w3c.dom.Element createElementNS(java.lang.String,java.lang.String) -> k0
    org.w3c.dom.CDATASection createCDATASection(java.lang.String) -> m
    org.w3c.dom.Text createTextNode(java.lang.String) -> m0
    org.w3c.dom.DocumentType getDoctype() -> u
    org.w3c.dom.EntityReference createEntityReference(java.lang.String) -> v0
org.apache.xerces.impl.xs.opti.DefaultElement -> v4.c:
    org.w3c.dom.Attr setAttributeNode(org.w3c.dom.Attr) -> A
    org.w3c.dom.Attr setAttributeNodeNS(org.w3c.dom.Attr) -> H
    void setAttributeNS(java.lang.String,java.lang.String,java.lang.String) -> s
org.apache.xerces.impl.xs.opti.DefaultNode -> v4.d:
    org.w3c.dom.Node getLastChild() -> C
    boolean hasAttributes() -> E
    org.w3c.dom.Node getFirstChild() -> N
    org.w3c.dom.Node removeChild(org.w3c.dom.Node) -> R
    void setNodeValue(java.lang.String) -> T
    org.w3c.dom.NodeList getChildNodes() -> W
    org.w3c.dom.Node insertBefore(org.w3c.dom.Node,org.w3c.dom.Node) -> j
    org.w3c.dom.Document getOwnerDocument() -> j0
    org.w3c.dom.Node cloneNode(boolean) -> p
    org.w3c.dom.Node appendChild(org.w3c.dom.Node) -> r0
    org.w3c.dom.Node getPreviousSibling() -> t
    org.w3c.dom.NamedNodeMap getAttributes() -> t0
    org.w3c.dom.Node getParentNode() -> u0
    boolean hasChildNodes() -> w0
    java.lang.String getNodeValue() -> x
    org.w3c.dom.Node getNextSibling() -> y
org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler -> v4.e:
    org.apache.xerces.xni.parser.XMLDTDSource fDTDSource -> b
    org.apache.xerces.xni.parser.XMLDTDContentModelSource fCMSource -> c
    org.apache.xerces.xni.parser.XMLDocumentSource fDocumentSource -> a
    void endConditional(org.apache.xerces.xni.Augmentations) -> B
    void endParameterEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> D
    void endGeneralEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> E
    void separator(short,org.apache.xerces.xni.Augmentations) -> F
    void any(org.apache.xerces.xni.Augmentations) -> G
    void endGroup(org.apache.xerces.xni.Augmentations) -> H
    void startGroup(org.apache.xerces.xni.Augmentations) -> I
    void externalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> J
    void ignoredCharacters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> K
    void startAttlist(java.lang.String,org.apache.xerces.xni.Augmentations) -> L
    void doctypeDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> M
    void element(java.lang.String,org.apache.xerces.xni.Augmentations) -> N
    void startGeneralEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> O
    void empty(org.apache.xerces.xni.Augmentations) -> P
    void startConditional(short,org.apache.xerces.xni.Augmentations) -> S
    void endExternalSubset(org.apache.xerces.xni.Augmentations) -> T
    void attributeDecl(java.lang.String,java.lang.String,java.lang.String,java.lang.String[],java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> U
    void setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource) -> V
    void endContentModel(org.apache.xerces.xni.Augmentations) -> b
    void textDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> c
    void startContentModel(java.lang.String,org.apache.xerces.xni.Augmentations) -> f
    void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource) -> g
    void startDTD(org.apache.xerces.xni.XMLLocator,org.apache.xerces.xni.Augmentations) -> h
    void internalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> i
    void endAttlist(org.apache.xerces.xni.Augmentations) -> m
    void startParameterEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> n
    void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> p
    void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource) -> q
    void elementDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> t
    void notationDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> u
    void pcdata(org.apache.xerces.xni.Augmentations) -> v
    void occurrence(short,org.apache.xerces.xni.Augmentations) -> w
    void endDTD(org.apache.xerces.xni.Augmentations) -> x
    void xmlDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> y
    void unparsedEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> z
org.apache.xerces.impl.xs.opti.ElementImpl -> v4.f:
    org.w3c.dom.Attr[] attrs -> W2
    int col -> Y2
    int parentRow -> Z2
    int row -> X2
    java.lang.String fSyntheticAnnotation -> e3
    java.lang.String fAnnotation -> d3
    org.apache.xerces.impl.xs.opti.SchemaDOM schemaDOM -> V2
    int charOffset -> c3
    int column -> b3
    int line -> a3
    org.w3c.dom.Node getLastChild() -> C
    boolean hasAttributes() -> E
    org.w3c.dom.Node getFirstChild() -> N
    org.w3c.dom.Attr getAttributeNode(java.lang.String) -> U
    void setAttribute(java.lang.String,java.lang.String) -> Y
    boolean nsEquals(java.lang.String,java.lang.String) -> c
    org.w3c.dom.Document getOwnerDocument() -> j0
    org.w3c.dom.Attr getAttributeNodeNS(java.lang.String,java.lang.String) -> p0
    org.w3c.dom.Node getPreviousSibling() -> t
    org.w3c.dom.NamedNodeMap getAttributes() -> t0
    org.w3c.dom.Node getParentNode() -> u0
    boolean hasChildNodes() -> w0
    org.w3c.dom.Node getNextSibling() -> y
org.apache.xerces.impl.xs.opti.NamedNodeMapImpl -> v4.g:
    org.w3c.dom.Attr[] attrs -> Q2
    org.w3c.dom.Node setNamedItemNS(org.w3c.dom.Node) -> a
    org.w3c.dom.Node removeNamedItem(java.lang.String) -> b
    int getLength() -> c
    org.w3c.dom.Node item(int) -> d
    org.w3c.dom.Node getNamedItem(java.lang.String) -> e
    org.w3c.dom.Node setNamedItem(org.w3c.dom.Node) -> f
org.apache.xerces.impl.xs.opti.NodeImpl -> v4.h:
    java.lang.String uri -> T2
    java.lang.String rawname -> S2
    short nodeType -> U2
    java.lang.String localpart -> R2
    java.lang.String prefix -> Q2
    java.lang.String getNodeName() -> B
    java.lang.String getNamespaceURI() -> B0
    java.lang.String getPrefix() -> g
    short getNodeType() -> n0
    java.lang.String getLocalName() -> r
org.apache.xerces.impl.xs.opti.SchemaDOM -> v4.i:
    org.apache.xerces.impl.xs.opti.NodeImpl[][] relations -> W2
    java.lang.StringBuffer fAnnotationBuffer -> b3
    int currLoc -> Y2
    int nextFreeLoc -> Z2
    org.apache.xerces.impl.xs.opti.ElementImpl parent -> X2
    boolean inCDATA -> a3
    void endElement() -> I
    void endSyntheticAnnotationElement(java.lang.String,boolean) -> J
    java.lang.String escapeAttValue(java.lang.String,int) -> L
    java.lang.String processAttValue(java.lang.String) -> M
    void processElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.impl.xs.opti.ElementImpl) -> O
    void processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString) -> Q
    void reset() -> S
    void resizeRelations() -> V
    void resizeRelations(int) -> a0
    void startAnnotation(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.NamespaceContext) -> b0
    void startAnnotation(java.lang.String,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.NamespaceContext) -> c0
    void characters(org.apache.xerces.xni.XMLString) -> d
    void startAnnotationCDATA() -> e0
    void charactersRaw(java.lang.String) -> f
    void startAnnotationElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes) -> g0
    void comment(org.apache.xerces.xni.XMLString) -> i
    void startAnnotationElement(java.lang.String,org.apache.xerces.xni.XMLAttributes) -> i0
    org.apache.xerces.impl.xs.opti.ElementImpl emptyElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,int,int,int) -> l
    void endAnnotation(org.apache.xerces.xni.QName,org.apache.xerces.impl.xs.opti.ElementImpl) -> n
    void endAnnotationCDATA() -> q
    org.w3c.dom.DOMImplementation getImplementation() -> q0
    org.apache.xerces.impl.xs.opti.ElementImpl startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,int,int,int) -> s0
    void endAnnotationElement(org.apache.xerces.xni.QName) -> v
    void endAnnotationElement(java.lang.String) -> z
org.apache.xerces.impl.xs.opti.SchemaDOMImplementation -> v4.j:
    org.apache.xerces.impl.xs.opti.SchemaDOMImplementation singleton -> a
    boolean hasFeature(java.lang.String,java.lang.String) -> a
    org.w3c.dom.DOMImplementation getDOMImplementation() -> b
org.apache.xerces.impl.xs.opti.SchemaDOMParser -> v4.k:
    boolean fGenerateSyntheticAnnotation -> m
    org.apache.xerces.xni.parser.XMLParserConfiguration config -> g
    int fInnerAnnotationDepth -> j
    org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack fSawAnnotation -> o
    int fDepth -> k
    org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack fHasNonSchemaAttributes -> n
    int fAnnotationDepth -> i
    org.apache.xerces.impl.XMLErrorReporter fErrorReporter -> l
    org.apache.xerces.xni.XMLLocator fLocator -> d
    org.apache.xerces.impl.xs.opti.SchemaDOM schemaDOM -> f
    org.apache.xerces.xni.NamespaceContext fNamespaceContext -> e
    org.apache.xerces.impl.xs.opti.ElementImpl fCurrentAnnotationElement -> h
    org.apache.xerces.xni.XMLAttributes fEmptyAttr -> p
    void endDocument(org.apache.xerces.xni.Augmentations) -> A
    void emptyElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations) -> C
    java.lang.Object getProperty(java.lang.String) -> W
    boolean hasNonSchemaAttributes(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes) -> X
    void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver) -> Y
    void setFeature(java.lang.String,boolean) -> Z
    void processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> a
    void setProperty(java.lang.String,java.lang.Object) -> a0
    void comment(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> d
    void startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations) -> e
    void endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations) -> j
    void startDocument(org.apache.xerces.xni.XMLLocator,java.lang.String,org.apache.xerces.xni.NamespaceContext,org.apache.xerces.xni.Augmentations) -> k
    void characters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> o
    void startCDATA(org.apache.xerces.xni.Augmentations) -> r
    void endCDATA(org.apache.xerces.xni.Augmentations) -> s
org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack -> v4.k$a:
    boolean[] fData -> b
    int fDepth -> a
    void clear() -> a
    void ensureCapacity(int) -> b
    boolean pop() -> c
    void push(boolean) -> d
    int size() -> e
org.apache.xerces.impl.xs.opti.SchemaParsingConfig -> v4.l:
    org.apache.xerces.impl.dv.DTDDVFactory fCurrentDVFactory -> s
    org.apache.xerces.impl.XMLEntityManager fEntityManager -> y
    org.apache.xerces.xni.parser.XMLInputSource fInputSource -> z
    org.apache.xerces.impl.dv.DTDDVFactory fXML11DatatypeFactory -> p
    org.apache.xerces.impl.XML11NSDocumentScannerImpl fXML11NSDocScanner -> q
    org.apache.xerces.xni.parser.XMLDocumentScanner fCurrentScanner -> t
    org.apache.xerces.impl.XMLNSDocumentScannerImpl fNamespaceScanner -> n
    org.apache.xerces.impl.XML11DTDScannerImpl fXML11DTDScanner -> r
    org.apache.xerces.xni.parser.XMLDTDScanner fCurrentDTDScanner -> u
    org.apache.xerces.impl.dv.DTDDVFactory fDatatypeValidatorFactory -> m
    org.apache.xerces.impl.XMLDTDScannerImpl fDTDScanner -> o
    org.apache.xerces.impl.XMLErrorReporter fErrorReporter -> x
    org.apache.xerces.impl.validation.ValidationManager fValidationManager -> A
    boolean fParseInProgress -> B
    org.apache.xerces.xni.grammars.XMLGrammarPool fGrammarPool -> v
    org.apache.xerces.impl.XMLVersionDetector fVersionDetector -> w
    boolean fConfigUpdated -> C
    boolean f11Initialized -> D
    java.lang.Object getProperty(java.lang.String) -> a
    boolean getFeature(java.lang.String) -> c
    void setFeature(java.lang.String,boolean) -> d
    void setProperty(java.lang.String,java.lang.Object) -> f
    void parse(org.apache.xerces.xni.parser.XMLInputSource) -> k
    void checkFeature(java.lang.String) -> m
    void checkProperty(java.lang.String) -> n
    void reset() -> p
    void setLocale(java.util.Locale) -> q
    void addRecognizedParamsAndSetDefaults(org.apache.xerces.xni.parser.XMLComponent) -> r
    void cleanup() -> s
    void configurePipeline() -> t
    void configureXML11Pipeline() -> u
    void initXML11Components() -> v
    boolean parse(boolean) -> w
    void resetXML10() -> x
    void resetXML11() -> y
    void setInputSource(org.apache.xerces.xni.parser.XMLInputSource) -> z
org.apache.xerces.impl.xs.traversers.XSDHandler -> w4.a:
    java.util.Hashtable fUnparsedAttributeRegistry -> b
    int[] fAllContext -> V
    java.util.Hashtable fRedefine2XSDMap -> A
    org.apache.xerces.impl.xs.XSGrammarBucket fGrammarBucket -> L
    org.apache.xerces.parsers.XML11Configuration fAnnotationValidator -> Q
    java.lang.String[] CIRCULAR_CODES -> q0
    java.util.Hashtable fUnparsedIdentityConstraintRegistry -> f
    org.apache.xerces.xni.parser.XMLEntityResolver fEntityResolver -> J
    java.util.Hashtable fUnparsedAttributeGroupRegistrySub -> j
    java.lang.String[][] NS_ERROR_CODES -> n0
    java.util.Hashtable fUnparsedNotationRegistrySub -> n
    org.apache.xerces.impl.xs.XSDDescription fSchemaGrammarDescription -> M
    java.lang.String[] ELE_ERROR_CODES -> o0
    java.util.Hashtable fDependencyMap -> r
    java.util.Hashtable fHiddenNodes -> v
    org.apache.xerces.xni.grammars.XMLGrammarPool fGrammarPool -> N
    java.util.Hashtable fDoc2XSDocumentMap -> z
    boolean fNamespaceGrowth -> G
    org.apache.xerces.impl.xs.traversers.XSDocumentInfo fRoot -> y
    org.apache.xerces.impl.xs.traversers.XSDocumentInfo[] fKeyrefsMapXSDocumentInfo -> a0
    org.apache.xerces.util.SymbolHash fGlobalAttrDecls -> d0
    org.apache.xerces.util.SymbolHash fGlobalElemDecls -> f0
    java.util.Hashtable EMPTY_TABLE -> m0
    java.util.Vector fAllTNSs -> t
    org.apache.xerces.util.SymbolHash fGlobalNotationDecls -> h0
    java.util.Hashtable fRedefine2NSSupport -> B
    java.util.Hashtable fUnparsedAttributeGroupRegistry -> c
    java.util.Hashtable fUnparsedNotationRegistry -> g
    org.apache.xerces.impl.dv.SchemaDVFactory fDVFactory -> O
    java.util.Hashtable fUnparsedElementRegistrySub -> k
    org.apache.xerces.impl.xs.XSParticleDecl[] fParticle -> S
    java.util.Hashtable fUnparsedTypeRegistrySub -> o
    org.apache.xerces.impl.xs.opti.SchemaDOMParser fSchemaParser -> P
    java.util.Hashtable fImportMap -> s
    org.w3c.dom.Element[] fKeyrefs -> Z
    java.util.Hashtable fTraversed -> w
    int fKeyrefStackPos -> Y
    boolean fTolerateDuplicates -> H
    java.lang.String[][] fLocalElemNamespaceContext -> X
    java.util.Hashtable[] fUnparsedRegistriesExt -> p
    java.util.Hashtable fUnparsedElementRegistry -> d
    java.util.Hashtable fRedefinedRestrictedAttributeGroupRegistry -> C
    org.apache.xerces.impl.xs.traversers.XSDocumentInfo[] fLocalElementDecl_schema -> U
    java.util.Hashtable fUnparsedTypeRegistry -> h
    java.util.Hashtable fUnparsedGroupRegistrySub -> l
    org.apache.xerces.impl.XMLErrorReporter fErrorReporter -> I
    org.apache.xerces.impl.xs.util.SimpleLocator xl -> l0
    java.lang.String[] COMP_TYPE -> p0
    org.apache.xerces.impl.xs.XSElementDecl[] fKeyrefElems -> b0
    java.util.Hashtable fDoc2SystemId -> x
    boolean fValidateAnnotations -> E
    org.apache.xerces.util.SymbolHash fGlobalAttrGrpDecls -> e0
    int fLocalElemStackPos -> R
    org.apache.xerces.util.SymbolHash fGlobalGroupDecls -> g0
    org.apache.xerces.xs.XSObject[] fParent -> W
    org.apache.xerces.util.SymbolHash fGlobalIDConstraintDecls -> i0
    java.util.Hashtable fNotationRegistry -> a
    org.apache.xerces.util.SymbolHash fGlobalTypeDecls -> j0
    java.util.Hashtable fRedefinedRestrictedGroupRegistry -> D
    java.util.Hashtable fUnparsedGroupRegistry -> e
    java.util.Hashtable fUnparsedAttributeRegistrySub -> i
    org.apache.xerces.util.SymbolTable fSymbolTable -> K
    java.util.Hashtable fUnparsedIdentityConstraintRegistrySub -> m
    java.util.Vector fReportedTNS -> k0
    java.util.Hashtable fXSDocumentInfoRegistry -> q
    java.lang.String[][] fKeyrefNamespaceContext -> c0
    java.util.Hashtable fLocationPairs -> u
    boolean fHonourAllSchemaLocations -> F
    org.w3c.dom.Element[] fLocalElementDecl -> T
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> a
    void setDVFactory(org.apache.xerces.impl.dv.SchemaDVFactory) -> b
    void setDeclPool(org.apache.xerces.impl.xs.XSDeclarationPool) -> c
    void setGenerateSyntheticAnnotations(boolean) -> d
org.apache.xerces.impl.xs.traversers.XSDocumentInfo -> w4.b:
org.apache.xerces.impl.xs.util.ShortListImpl -> x4.a:
    short[] fArray -> Q2
    org.apache.xerces.impl.xs.util.ShortListImpl EMPTY_LIST -> S2
    int fLength -> R2
    int getLength() -> c
    short item(int) -> d
org.apache.xerces.impl.xs.util.SimpleLocator -> x4.b:
    java.lang.String lsid -> a
    int column -> d
    int charOffset -> e
    java.lang.String esid -> b
    int line -> c
    java.lang.String getPublicId() -> a
    java.lang.String getExpandedSystemId() -> c
    int getColumnNumber() -> d
    java.lang.String getEncoding() -> e
    java.lang.String getLiteralSystemId() -> f
    int getLineNumber() -> g
    java.lang.String getBaseSystemId() -> h
    int getCharacterOffset() -> i
org.apache.xerces.impl.xs.util.StringListImpl -> x4.c:
    java.util.Vector fVector -> S2
    org.apache.xerces.impl.xs.util.StringListImpl EMPTY_LIST -> T2
    java.lang.String[] fArray -> Q2
    int fLength -> R2
    void toArray0(java.lang.Object[]) -> a
    int getLength() -> c
org.apache.xerces.impl.xs.util.XSObjectListImpl -> x4.d:
    org.apache.xerces.xs.XSObject[] fArray -> Q2
    org.apache.xerces.impl.xs.util.XSObjectListImpl EMPTY_LIST -> S2
    java.util.ListIterator EMPTY_ITERATOR -> T2
    int fLength -> R2
    int access$000(org.apache.xerces.impl.xs.util.XSObjectListImpl) -> a
    org.apache.xerces.xs.XSObject[] access$100(org.apache.xerces.impl.xs.util.XSObjectListImpl) -> b
    int getLength() -> c
    void addXSObject(org.apache.xerces.xs.XSObject) -> e
    boolean containsNull() -> f
    boolean containsObject(java.lang.Object) -> g
    org.apache.xerces.xs.XSObject item(int) -> h
    java.util.ListIterator listIterator0(int) -> i
    void toArray0(java.lang.Object[]) -> j
org.apache.xerces.impl.xs.util.XSObjectListImpl$1 -> x4.d$a:
org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator -> x4.d$b:
    org.apache.xerces.impl.xs.util.XSObjectListImpl this$0 -> R2
    int index -> Q2
org.apache.xerces.jaxp.DefaultValidationErrorHandler -> y4.a:
    int ERROR_COUNT_LIMIT -> b
    int errorCount -> a
    void error(org.xml.sax.SAXParseException) -> q
org.apache.xerces.jaxp.DocumentBuilderFactoryImpl -> y4.b:
    boolean isXIncludeAware -> i
    boolean fSecureProcess -> j
    java.util.Hashtable features -> h
    java.util.Hashtable attributes -> g
    javax.xml.parsers.DocumentBuilder newDocumentBuilder() -> g
    void setFeature(java.lang.String,boolean) -> j
    void setXIncludeAware(boolean) -> o
    javax.xml.validation.Schema getSchema() -> p
    boolean isXIncludeAware() -> q
org.apache.xerces.jaxp.DocumentBuilderImpl -> y4.c:
    org.apache.xerces.impl.validation.ValidationManager fSchemaValidationManager -> d
    org.apache.xerces.parsers.DOMParser domParser -> a
    org.apache.xerces.xni.parser.XMLComponent fSchemaValidator -> b
    org.xml.sax.ErrorHandler fInitErrorHandler -> f
    org.xml.sax.EntityResolver fInitEntityResolver -> g
    org.apache.xerces.jaxp.UnparsedEntityHandler fUnparsedEntityHandler -> e
    org.apache.xerces.xni.parser.XMLComponentManager fSchemaValidatorComponentManager -> c
    org.w3c.dom.Document parse(org.xml.sax.InputSource) -> a
    void setEntityResolver(org.xml.sax.EntityResolver) -> b
    void setErrorHandler(org.xml.sax.ErrorHandler) -> c
    boolean isValidating() -> d
    void resetSchemaValidator() -> e
    void setDocumentBuilderFactoryAttributes(java.util.Hashtable) -> f
    void setFeatures(java.util.Hashtable) -> g
org.apache.xerces.jaxp.SAXParserFactoryImpl -> y4.d:
    boolean fSecureProcess -> c
org.apache.xerces.jaxp.UnparsedEntityHandler -> y4.e:
    void reset() -> b
org.apache.xerces.jaxp.datatype.DatatypeFactoryImpl -> z4.a:
org.apache.xerces.jaxp.validation.DraconianErrorHandler -> a5.a:
    org.apache.xerces.jaxp.validation.DraconianErrorHandler ERROR_HANDLER_INSTANCE -> a
    org.apache.xerces.jaxp.validation.DraconianErrorHandler getInstance() -> a
    void fatalError(org.xml.sax.SAXParseException) -> g
    void warning(org.xml.sax.SAXParseException) -> h
    void error(org.xml.sax.SAXParseException) -> q
org.apache.xerces.jaxp.validation.XMLSchemaFactory -> a5.b:
    org.apache.xerces.jaxp.validation.XMLSchemaFactory$XMLGrammarPoolWrapper fXMLGrammarPoolWrapper -> d
    boolean fUseGrammarPoolOnly -> e
    org.apache.xerces.util.DOMEntityResolverWrapper fDOMEntityResolverWrapper -> b
    org.apache.xerces.util.ErrorHandlerWrapper fErrorHandlerWrapper -> c
    org.apache.xerces.impl.xs.XMLSchemaLoader fXMLSchemaLoader -> a
org.apache.xerces.jaxp.validation.XMLSchemaFactory$XMLGrammarPoolWrapper -> a5.b$a:
    org.apache.xerces.xni.grammars.XMLGrammarPool fGrammarPool -> a
    org.apache.xerces.xni.grammars.Grammar[] retrieveInitialGrammarSet(java.lang.String) -> a
org.apache.xerces.parsers.AbstractDOMParser -> b5.a:
    org.apache.xerces.xni.QName fAttrQName -> M
    boolean fIncludeIgnorableWhitespace -> i
    boolean fCreateCDATANodes -> k
    org.w3c.dom.Node fCurrentNode -> q
    boolean fInEntityRef -> L
    boolean fDeferNodeExpansion -> w
    int fCurrentCDATASectionIndex -> C
    int fDocumentTypeIndex -> A
    org.apache.xerces.dom.EntityImpl fCurrentEntityDecl -> s
    org.apache.xerces.xni.XMLLocator fLocator -> N
    java.util.Stack fBaseURIStack -> I
    org.apache.xerces.dom.DeferredDocumentImpl fDeferredDocumentImpl -> y
    boolean fFirstChunk -> G
    boolean fCreateEntityRefNodes -> h
    java.util.Stack fSkippedElemStack -> K
    java.lang.StringBuffer fInternalSubset -> v
    java.lang.String[] RECOGNIZED_PROPERTIES -> Q
    org.w3c.dom.DocumentType fDocumentType -> p
    boolean fStorePSVI -> n
    org.w3c.dom.Document fDocument -> l
    java.lang.StringBuffer fStringBuffer -> u
    int fRejectedElementDepth -> J
    boolean fIncludeComments -> j
    java.lang.String fDocumentClassName -> o
    boolean fNamespaceAware -> x
    int fCurrentNodeIndex -> B
    org.w3c.dom.CDATASection fCurrentCDATASection -> r
    org.w3c.dom.Node fRoot -> E
    org.apache.xerces.dom.CoreDocumentImpl fDocumentImpl -> m
    int fDocumentIndex -> z
    boolean fInCDATASection -> F
    boolean fInDTD -> g
    int fDeferredEntityDecl -> t
    boolean fFilterReject -> H
    org.w3c.dom.ls.LSParserFilter fDOMFilter -> O
    java.lang.String[] RECOGNIZED_FEATURES -> P
    boolean fInDTDExternalSubset -> D
    void endDocument(org.apache.xerces.xni.Augmentations) -> A
    void endConditional(org.apache.xerces.xni.Augmentations) -> B
    void emptyElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations) -> C
    void endParameterEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> D
    void endGeneralEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> E
    void externalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> J
    void ignoredCharacters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> K
    void startAttlist(java.lang.String,org.apache.xerces.xni.Augmentations) -> L
    void doctypeDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> M
    void startGeneralEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> O
    void startConditional(short,org.apache.xerces.xni.Augmentations) -> S
    void endExternalSubset(org.apache.xerces.xni.Augmentations) -> T
    void attributeDecl(java.lang.String,java.lang.String,java.lang.String,java.lang.String[],java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> U
    void reset() -> X
    org.w3c.dom.Attr createAttrNode(org.apache.xerces.xni.QName) -> Y
    org.w3c.dom.Element createElementNode(org.apache.xerces.xni.QName) -> Z
    void processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> a
    void dropDocumentReferences() -> a0
    org.w3c.dom.Document getDocument() -> b0
    void textDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> c
    void handleBaseURI(int) -> c0
    void comment(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> d
    void handleBaseURI(org.w3c.dom.Node) -> d0
    void startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations) -> e
    void setCharacterData(boolean) -> e0
    void setDocumentClassName(java.lang.String) -> f0
    void startDTD(org.apache.xerces.xni.XMLLocator,org.apache.xerces.xni.Augmentations) -> h
    void internalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> i
    void endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations) -> j
    void startDocument(org.apache.xerces.xni.XMLLocator,java.lang.String,org.apache.xerces.xni.NamespaceContext,org.apache.xerces.xni.Augmentations) -> k
    void endAttlist(org.apache.xerces.xni.Augmentations) -> m
    void startParameterEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> n
    void characters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> o
    void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> p
    void startCDATA(org.apache.xerces.xni.Augmentations) -> r
    void endCDATA(org.apache.xerces.xni.Augmentations) -> s
    void elementDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> t
    void notationDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> u
    void endDTD(org.apache.xerces.xni.Augmentations) -> x
    void xmlDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> y
    void unparsedEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> z
org.apache.xerces.parsers.AbstractDOMParser$Abort -> b5.a$a:
    org.apache.xerces.parsers.AbstractDOMParser$Abort INSTANCE -> Q2
org.apache.xerces.parsers.AbstractSAXParser -> b5.b:
    boolean fXMLNSURIs -> m
    boolean fLexicalHandlerParameterEntities -> i
    boolean fStandalone -> j
    org.xml.sax.ContentHandler fContentHandler -> n
    org.apache.xerces.xni.NamespaceContext fNamespaceContext -> p
    org.xml.sax.DTDHandler fDTDHandler -> q
    boolean fResolveDTDURIs -> k
    boolean fUseEntityResolver2 -> l
    org.xml.sax.ext.DeclHandler fDeclHandler -> r
    java.lang.String[] RECOGNIZED_FEATURES -> z
    org.xml.sax.DocumentHandler fDocumentHandler -> o
    org.apache.xerces.xni.QName fQName -> t
    boolean fParseInProgress -> u
    org.apache.xerces.xni.Augmentations fAugmentations -> x
    java.lang.String[] RECOGNIZED_PROPERTIES -> A
    org.xml.sax.ext.LexicalHandler fLexicalHandler -> s
    java.lang.String fVersion -> v
    org.apache.xerces.util.SymbolHash fDeclaredAttrs -> y
    boolean fNamespaces -> g
    org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy fAttributesProxy -> w
    boolean fNamespacePrefixes -> h
    void endDocument(org.apache.xerces.xni.Augmentations) -> A
    void endParameterEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> D
    void endGeneralEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> E
    void externalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> J
    void doctypeDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> M
    void startGeneralEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> O
    void endExternalSubset(org.apache.xerces.xni.Augmentations) -> T
    void attributeDecl(java.lang.String,java.lang.String,java.lang.String,java.lang.String[],java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> U
    void reset() -> X
    void endNamespaceMapping() -> Y
    void startNamespaceMapping() -> Z
    void processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> a
    void comment(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> d
    void startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations) -> e
    void internalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> i
    void endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations) -> j
    void startDocument(org.apache.xerces.xni.XMLLocator,java.lang.String,org.apache.xerces.xni.NamespaceContext,org.apache.xerces.xni.Augmentations) -> k
    void startParameterEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> n
    void characters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> o
    void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> p
    void startCDATA(org.apache.xerces.xni.Augmentations) -> r
    void endCDATA(org.apache.xerces.xni.Augmentations) -> s
    void elementDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> t
    void notationDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> u
    void endDTD(org.apache.xerces.xni.Augmentations) -> x
    void xmlDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> y
    void unparsedEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> z
org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy -> b5.b$a:
    org.apache.xerces.xni.XMLAttributes fAttributes -> a
    void setAttributes(org.apache.xerces.xni.XMLAttributes) -> a
org.apache.xerces.parsers.AbstractSAXParser$LocatorProxy -> b5.b$b:
    org.apache.xerces.xni.XMLLocator fLocator -> a
    java.lang.String getPublicId() -> a
    java.lang.String getSystemId() -> b
    int getColumnNumber() -> d
    int getLineNumber() -> g
org.apache.xerces.parsers.AbstractXMLDocumentParser -> b5.c:
    org.apache.xerces.xni.parser.XMLDocumentSource fDocumentSource -> d
    org.apache.xerces.xni.parser.XMLDTDContentModelSource fDTDContentModelSource -> f
    boolean fInDTD -> c
    org.apache.xerces.xni.parser.XMLDTDSource fDTDSource -> e
    void endConditional(org.apache.xerces.xni.Augmentations) -> B
    void emptyElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations) -> C
    void separator(short,org.apache.xerces.xni.Augmentations) -> F
    void any(org.apache.xerces.xni.Augmentations) -> G
    void endGroup(org.apache.xerces.xni.Augmentations) -> H
    void startGroup(org.apache.xerces.xni.Augmentations) -> I
    void ignoredCharacters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> K
    void startAttlist(java.lang.String,org.apache.xerces.xni.Augmentations) -> L
    void element(java.lang.String,org.apache.xerces.xni.Augmentations) -> N
    void empty(org.apache.xerces.xni.Augmentations) -> P
    void startConditional(short,org.apache.xerces.xni.Augmentations) -> S
    void setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource) -> V
    void reset() -> X
    void endContentModel(org.apache.xerces.xni.Augmentations) -> b
    void textDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> c
    void startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations) -> e
    void startContentModel(java.lang.String,org.apache.xerces.xni.Augmentations) -> f
    void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource) -> g
    void startDTD(org.apache.xerces.xni.XMLLocator,org.apache.xerces.xni.Augmentations) -> h
    void endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations) -> j
    void endAttlist(org.apache.xerces.xni.Augmentations) -> m
    void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource) -> q
    void pcdata(org.apache.xerces.xni.Augmentations) -> v
    void occurrence(short,org.apache.xerces.xni.Augmentations) -> w
org.apache.xerces.parsers.BasicParserConfiguration -> b5.d:
    org.apache.xerces.util.SymbolTable fSymbolTable -> f
    org.apache.xerces.xni.parser.XMLDocumentSource fLastComponent -> l
    org.apache.xerces.xni.XMLDTDContentModelHandler fDTDContentModelHandler -> k
    java.util.ArrayList fComponents -> h
    org.apache.xerces.xni.XMLDocumentHandler fDocumentHandler -> i
    org.apache.xerces.xni.XMLDTDHandler fDTDHandler -> j
    java.util.Locale fLocale -> g
    void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler) -> b
    void setFeature(java.lang.String,boolean) -> d
    java.util.Locale getLocale() -> e
    void setProperty(java.lang.String,java.lang.Object) -> f
    void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler) -> g
    void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler) -> h
    void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver) -> i
    void checkFeature(java.lang.String) -> m
    void checkProperty(java.lang.String) -> n
    void addComponent(org.apache.xerces.xni.parser.XMLComponent) -> o
    void reset() -> p
    void setLocale(java.util.Locale) -> q
org.apache.xerces.parsers.DOMParser -> b5.e:
    boolean fUseEntityResolver2 -> R
    java.lang.String[] RECOGNIZED_PROPERTIES -> S
    org.xml.sax.EntityResolver getEntityResolver() -> g0
    org.xml.sax.ErrorHandler getErrorHandler() -> h0
    boolean getFeature(java.lang.String) -> i0
    void parse(org.xml.sax.InputSource) -> j0
    void setEntityResolver(org.xml.sax.EntityResolver) -> k0
    void setErrorHandler(org.xml.sax.ErrorHandler) -> l0
    void setFeature(java.lang.String,boolean) -> m0
    void setProperty(java.lang.String,java.lang.Object) -> n0
org.apache.xerces.parsers.ObjectFactory -> b5.f:
    java.util.Properties fXercesProperties -> b
    long fLastModified -> c
    boolean DEBUG -> a
    java.lang.Object createObject(java.lang.String,java.lang.String) -> a
    java.lang.Object createObject(java.lang.String,java.lang.String,java.lang.String) -> b
    void debugPrintln(java.lang.String) -> c
    java.lang.ClassLoader findClassLoader() -> d
    java.lang.Object findJarServiceProvider(java.lang.String) -> e
    java.lang.Class findProviderClass(java.lang.String,java.lang.ClassLoader,boolean) -> f
    boolean isDebugEnabled() -> g
    java.lang.Object newInstance(java.lang.String,java.lang.ClassLoader,boolean) -> h
org.apache.xerces.parsers.ObjectFactory$ConfigurationError -> b5.f$a:
    java.lang.Exception exception -> Q2
org.apache.xerces.parsers.SAXParser -> b5.g:
    java.lang.String[] RECOGNIZED_PROPERTIES -> C
    java.lang.String[] RECOGNIZED_FEATURES -> B
org.apache.xerces.parsers.SecuritySupport -> b5.h:
    java.lang.ClassLoader getContextClassLoader() -> a
    boolean getFileExists(java.io.File) -> b
    java.io.FileInputStream getFileInputStream(java.io.File) -> c
    long getLastModified(java.io.File) -> d
    java.lang.ClassLoader getParentClassLoader(java.lang.ClassLoader) -> e
    java.io.InputStream getResourceAsStream(java.lang.ClassLoader,java.lang.String) -> f
    java.lang.ClassLoader getSystemClassLoader() -> g
    java.lang.String getSystemProperty(java.lang.String) -> h
org.apache.xerces.parsers.SecuritySupport$1 -> b5.h$a:
org.apache.xerces.parsers.SecuritySupport$2 -> b5.h$b:
org.apache.xerces.parsers.SecuritySupport$3 -> b5.h$c:
    java.lang.ClassLoader val$cl -> a
org.apache.xerces.parsers.SecuritySupport$4 -> b5.h$d:
    java.lang.String val$propName -> a
org.apache.xerces.parsers.SecuritySupport$5 -> b5.h$e:
    java.io.File val$file -> a
org.apache.xerces.parsers.SecuritySupport$6 -> b5.h$f:
    java.lang.ClassLoader val$cl -> a
    java.lang.String val$name -> b
org.apache.xerces.parsers.SecuritySupport$7 -> b5.h$g:
    java.io.File val$f -> a
org.apache.xerces.parsers.SecuritySupport$8 -> b5.h$h:
    java.io.File val$f -> a
org.apache.xerces.parsers.XML11Configuration -> b5.i:
    void setProperty(java.lang.String,java.lang.Object) -> f
org.apache.xerces.parsers.XMLParser -> b5.j:
    org.apache.xerces.xni.parser.XMLParserConfiguration fConfiguration -> a
    java.lang.String[] RECOGNIZED_PROPERTIES -> b
    void parse(org.apache.xerces.xni.parser.XMLInputSource) -> W
    void reset() -> X
org.apache.xerces.stax.XMLEventFactoryImpl -> c5.a:
org.apache.xerces.util.AugmentationsImpl -> d5.a:
    org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer fAugmentationsContainer -> a
    java.lang.Object putItem(java.lang.String,java.lang.Object) -> a
    java.lang.Object getItem(java.lang.String) -> b
    void removeAllItems() -> c
org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer -> d5.a$a:
    void clear() -> a
    org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer expand() -> b
    java.lang.Object getItem(java.lang.Object) -> c
    boolean isFull() -> d
    java.lang.Object putItem(java.lang.Object,java.lang.Object) -> e
org.apache.xerces.util.AugmentationsImpl$LargeContainer -> d5.a$b:
    java.util.HashMap fAugmentations -> a
    void clear() -> a
    org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer expand() -> b
    java.lang.Object getItem(java.lang.Object) -> c
    boolean isFull() -> d
    java.lang.Object putItem(java.lang.Object,java.lang.Object) -> e
org.apache.xerces.util.AugmentationsImpl$SmallContainer -> d5.a$c:
    java.lang.Object[] fAugmentations -> a
    int fNumEntries -> b
    void clear() -> a
    org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer expand() -> b
    java.lang.Object getItem(java.lang.Object) -> c
    boolean isFull() -> d
    java.lang.Object putItem(java.lang.Object,java.lang.Object) -> e
org.apache.xerces.util.DOMEntityResolverWrapper -> d5.b:
    org.w3c.dom.ls.LSResourceResolver fEntityResolver -> a
    org.apache.xerces.xni.parser.XMLInputSource resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier) -> a
    java.lang.String getType(org.apache.xerces.xni.XMLResourceIdentifier) -> c
org.apache.xerces.util.DefaultErrorHandler -> d5.c:
    java.io.PrintWriter fOut -> a
    void warning(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException) -> a
    void error(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException) -> b
    void fatalError(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException) -> c
    void printError(java.lang.String,org.apache.xerces.xni.parser.XMLParseException) -> d
org.apache.xerces.util.EncodingMap -> d5.d:
    java.util.Hashtable fJava2IANAMap -> b
    java.util.Hashtable fIANA2JavaMap -> a
    java.lang.String getIANA2JavaMapping(java.lang.String) -> a
org.apache.xerces.util.EntityResolver2Wrapper -> d5.e:
    org.xml.sax.ext.EntityResolver2 fEntityResolver -> a
    org.apache.xerces.xni.parser.XMLInputSource resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier) -> a
    org.apache.xerces.xni.parser.XMLInputSource getExternalSubset(org.apache.xerces.xni.grammars.XMLDTDDescription) -> b
    org.apache.xerces.xni.parser.XMLInputSource createXMLInputSource(org.xml.sax.InputSource,java.lang.String) -> c
    org.xml.sax.ext.EntityResolver2 getEntityResolver() -> d
    void setEntityResolver(org.xml.sax.ext.EntityResolver2) -> e
org.apache.xerces.util.EntityResolverWrapper -> d5.f:
    org.xml.sax.EntityResolver fEntityResolver -> a
    org.apache.xerces.xni.parser.XMLInputSource resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier) -> a
    org.xml.sax.EntityResolver getEntityResolver() -> c
    void setEntityResolver(org.xml.sax.EntityResolver) -> d
org.apache.xerces.util.ErrorHandlerWrapper -> d5.g:
    org.xml.sax.ErrorHandler fErrorHandler -> a
    void warning(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException) -> a
    void error(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException) -> b
    void fatalError(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException) -> c
    org.xml.sax.SAXParseException createSAXParseException(org.apache.xerces.xni.parser.XMLParseException) -> d
    org.apache.xerces.xni.parser.XMLParseException createXMLParseException(org.xml.sax.SAXParseException) -> e
    org.apache.xerces.xni.XNIException createXNIException(org.xml.sax.SAXException) -> f
    org.xml.sax.ErrorHandler getErrorHandler() -> g
    void setErrorHandler(org.xml.sax.ErrorHandler) -> h
org.apache.xerces.util.ErrorHandlerWrapper$1 -> d5.g$a:
    java.lang.String val$fPublicId -> a
    int val$fLineNumber -> d
    java.lang.String val$fExpandedSystemId -> b
    int val$fColumnNumber -> c
    java.lang.String getPublicId() -> a
    java.lang.String getExpandedSystemId() -> c
    int getColumnNumber() -> d
    java.lang.String getEncoding() -> e
    java.lang.String getLiteralSystemId() -> f
    int getLineNumber() -> g
    java.lang.String getBaseSystemId() -> h
    int getCharacterOffset() -> i
org.apache.xerces.util.HTTPInputSource -> d5.h:
    boolean fFollowRedirects -> g
    java.util.Map fHTTPRequestProperties -> h
    boolean getFollowHTTPRedirects() -> j
    java.util.Iterator getHTTPRequestProperties() -> k
org.apache.xerces.util.IntStack -> d5.i:
    int[] fData -> b
    int fDepth -> a
    void ensureCapacity(int) -> a
    int pop() -> b
    void push(int) -> c
org.apache.xerces.util.MessageFormatter -> d5.j:
    java.lang.String formatMessage(java.util.Locale,java.lang.String,java.lang.Object[]) -> a
org.apache.xerces.util.NamespaceSupport -> d5.k:
    int[] fContext -> e
    int fCurrentContext -> f
    int fNamespaceSize -> d
    java.lang.String[] fPrefixes -> g
    java.lang.String[] fNamespace -> c
    java.lang.String getURI(java.lang.String) -> a
    void reset() -> b
    java.lang.String getDeclaredPrefixAt(int) -> c
    void pushContext() -> d
    int getDeclaredPrefixCount() -> e
    java.util.Enumeration getAllPrefixes() -> f
    boolean declarePrefix(java.lang.String,java.lang.String) -> g
    java.lang.String getPrefix(java.lang.String) -> h
    void popContext() -> i
org.apache.xerces.util.NamespaceSupport$Prefixes -> d5.k$a:
    org.apache.xerces.util.NamespaceSupport this$0 -> d
    java.lang.String[] prefixes -> a
    int counter -> b
    int size -> c
org.apache.xerces.util.ParserConfigurationSettings -> d5.l:
    java.util.HashMap fProperties -> b
    org.apache.xerces.xni.parser.XMLComponentManager fParentSettings -> e
    java.util.ArrayList fRecognizedFeatures -> c
    java.util.ArrayList fRecognizedProperties -> a
    java.util.HashMap fFeatures -> d
    java.lang.Object getProperty(java.lang.String) -> a
    boolean getFeature(java.lang.String) -> c
    void setFeature(java.lang.String,boolean) -> d
    void setProperty(java.lang.String,java.lang.Object) -> f
    void addRecognizedProperties(java.lang.String[]) -> j
    void addRecognizedFeatures(java.lang.String[]) -> l
    void checkFeature(java.lang.String) -> m
    void checkProperty(java.lang.String) -> n
org.apache.xerces.util.PrimeNumberSequenceGenerator -> d5.m:
    int[] PRIMES -> a
    void generateSequence(int[]) -> a
org.apache.xerces.util.SAXMessageFormatter -> d5.n:
    java.lang.String formatMessage(java.util.Locale,java.lang.String,java.lang.Object[]) -> a
org.apache.xerces.util.SecurityManager -> d5.o:
    int maxOccurLimit -> b
    int entityExpansionLimit -> a
    int getEntityExpansionLimit() -> a
org.apache.xerces.util.SymbolHash -> d5.p:
    int[] fHashMultipliers -> d
    org.apache.xerces.util.SymbolHash$Entry[] fBuckets -> b
    int fNum -> c
    int fTableSize -> a
    void clear() -> a
    java.lang.Object get(java.lang.Object) -> b
    int getLength() -> c
    int getValues(java.lang.Object[],int) -> d
    int hash(java.lang.Object) -> e
    int hash0(java.lang.String) -> f
    org.apache.xerces.util.SymbolHash makeClone() -> g
    void put(java.lang.Object,java.lang.Object) -> h
    void rebalance() -> i
    void rehash() -> j
    void rehashCommon(int) -> k
    org.apache.xerces.util.SymbolHash$Entry search(java.lang.Object,int) -> l
org.apache.xerces.util.SymbolHash$Entry -> d5.p$a:
    org.apache.xerces.util.SymbolHash$Entry next -> c
    java.lang.Object value -> b
    java.lang.Object key -> a
    org.apache.xerces.util.SymbolHash$Entry makeClone() -> a
org.apache.xerces.util.SymbolTable -> d5.q:
    int[] fHashMultipliers -> g
    org.apache.xerces.util.SymbolTable$Entry[] fBuckets -> a
    float fLoadFactor -> e
    int fCollisionThreshold -> f
    int fThreshold -> d
    int fTableSize -> b
    int fCount -> c
    java.lang.String addSymbol(java.lang.String) -> a
    java.lang.String addSymbol(char[],int,int) -> b
    java.lang.String addSymbol0(java.lang.String,int,int) -> c
    java.lang.String addSymbol0(char[],int,int,int,int) -> d
    int hash(java.lang.String) -> e
    int hash(char[],int,int) -> f
    int hash0(java.lang.String) -> g
    int hash0(char[],int,int) -> h
    void rebalance() -> i
    void rehash() -> j
    void rehashCommon(int) -> k
org.apache.xerces.util.SymbolTable$Entry -> d5.q$a:
    char[] characters -> b
    org.apache.xerces.util.SymbolTable$Entry next -> c
    java.lang.String symbol -> a
org.apache.xerces.util.URI -> d5.r:
    int m_port -> T2
    java.lang.String m_fragment -> X2
    java.lang.String m_queryString -> W2
    java.lang.String m_path -> V2
    java.lang.String m_regAuthority -> U2
    java.lang.String m_host -> S2
    java.lang.String m_userinfo -> R2
    byte[] fgLookupTable -> Y2
    java.lang.String m_scheme -> Q2
    boolean isURIString(java.lang.String) -> A
    boolean isUserinfoCharacter(char) -> B
    boolean isValidRegistryBasedAuthority(java.lang.String) -> C
    boolean isValidServerBasedAuthority(java.lang.String,int,java.lang.String) -> D
    boolean isWellFormedAddress(java.lang.String) -> E
    boolean isWellFormedIPv4Address(java.lang.String) -> F
    boolean isWellFormedIPv6Reference(java.lang.String) -> G
    int scanHexSequence(java.lang.String,int,int,int[]) -> H
    void setFragment(java.lang.String) -> I
    void setHost(java.lang.String) -> J
    void setPath(java.lang.String) -> K
    void setPort(int) -> L
    void setQueryString(java.lang.String) -> M
    void setScheme(java.lang.String) -> N
    void setUserinfo(java.lang.String) -> O
    void absolutize(org.apache.xerces.util.URI) -> a
    java.lang.String getFragment() -> b
    java.lang.String getHost() -> c
    java.lang.String getPath() -> d
    int getPort() -> e
    java.lang.String getQueryString() -> f
    java.lang.String getRegBasedAuthority() -> g
    java.lang.String getScheme() -> h
    java.lang.String getSchemeSpecificPart() -> i
    java.lang.String getUserinfo() -> j
    void initialize(org.apache.xerces.util.URI) -> k
    void initialize(org.apache.xerces.util.URI,java.lang.String) -> l
    void initialize(org.apache.xerces.util.URI,java.lang.String,boolean) -> m
    boolean initializeAuthority(java.lang.String) -> n
    void initializePath(java.lang.String,int) -> o
    void initializeScheme(java.lang.String) -> p
    boolean isAbsoluteURI() -> q
    boolean isAlpha(char) -> r
    boolean isAlphanum(char) -> s
    boolean isConformantSchemeName(java.lang.String) -> t
    boolean isDigit(char) -> u
    boolean isGenericURI() -> v
    boolean isHex(char) -> w
    boolean isPathCharacter(char) -> x
    boolean isSchemeCharacter(char) -> y
    boolean isURICharacter(char) -> z
org.apache.xerces.util.URI$MalformedURIException -> d5.r$a:
org.apache.xerces.util.XML11Char -> d5.s:
    byte[] XML11CHARS -> a
    boolean isXML11Content(int) -> a
    boolean isXML11InternalEntityContent(int) -> b
    boolean isXML11Invalid(int) -> c
    boolean isXML11NCName(int) -> d
    boolean isXML11NCNameStart(int) -> e
    boolean isXML11Name(int) -> f
    boolean isXML11NameHighSurrogate(int) -> g
    boolean isXML11NameStart(int) -> h
    boolean isXML11Space(int) -> i
    boolean isXML11Valid(int) -> j
    boolean isXML11ValidLiteral(int) -> k
    boolean isXML11ValidNCName(java.lang.String) -> l
    boolean isXML11ValidName(java.lang.String) -> m
org.apache.xerces.util.XMLAttributesImpl -> d5.t:
    int[] fAttributeTableViewChainState -> f
    org.apache.xerces.util.XMLAttributesImpl$Attribute[] fAttributes -> d
    int[] fHashMultipliers -> i
    org.apache.xerces.util.XMLAttributesImpl$Attribute[] fAttributeTableView -> e
    int fTableViewBuckets -> g
    boolean fIsTableViewConsistent -> h
    boolean fNamespaces -> a
    int fLargeCount -> b
    int fLength -> c
    int hash0(java.lang.String) -> A
    void prepareAndPopulateTableView() -> B
    void prepareAndPopulateTableView(int) -> C
    void prepareAndPopulateTableViewNS(int) -> D
    void prepareTableView() -> E
    void rebalanceTableView(int) -> F
    void rebalanceTableViewNS(int) -> G
    void setNamespaces(boolean) -> H
    void setNonNormalizedValue(int,java.lang.String) -> I
    void setSpecified(int,boolean) -> J
    void setURI(int,java.lang.String) -> K
    void setValue(int,java.lang.String) -> L
    int addAttribute(org.apache.xerces.xni.QName,java.lang.String,java.lang.String) -> a
    void addAttributeNS(org.apache.xerces.xni.QName,java.lang.String,java.lang.String) -> b
    int getLength() -> c
    void removeAllAttributes() -> d
    org.apache.xerces.xni.Augmentations getAugmentations(int) -> e
    java.lang.String getType(int) -> f
    void removeAttributeAt(int) -> g
    java.lang.String getValue(int) -> h
    java.lang.String getPrefix(int) -> i
    java.lang.String getURI(int) -> j
    void getName(int,org.apache.xerces.xni.QName) -> k
    java.lang.String getLocalName(int) -> l
    void setName(int,org.apache.xerces.xni.QName) -> m
    java.lang.String getQName(int) -> n
    boolean isSpecified(int) -> o
    org.apache.xerces.xni.QName checkDuplicatesNS() -> p
    org.apache.xerces.xni.QName checkManyDuplicatesNS() -> q
    void cleanTableView() -> r
    int getIndexFast(java.lang.String) -> s
    int getIndexFast(java.lang.String,java.lang.String) -> t
    java.lang.String getReportableType(java.lang.String) -> u
    int getTableViewBucket(java.lang.String) -> v
    int getTableViewBucket(java.lang.String,java.lang.String) -> w
    void growTableView() -> x
    int hash(java.lang.String) -> y
    int hash(java.lang.String,java.lang.String) -> z
org.apache.xerces.util.XMLAttributesImpl$Attribute -> d5.t$a:
    boolean specified -> e
    org.apache.xerces.xni.Augmentations augs -> f
    org.apache.xerces.util.XMLAttributesImpl$Attribute next -> g
    java.lang.String value -> c
    org.apache.xerces.xni.QName name -> a
    java.lang.String type -> b
    java.lang.String nonNormalizedValue -> d
org.apache.xerces.util.XMLChar -> d5.u:
    byte[] CHARS -> a
    char highSurrogate(int) -> a
    boolean isContent(int) -> b
    boolean isHighSurrogate(int) -> c
    boolean isInvalid(int) -> d
    boolean isLowSurrogate(int) -> e
    boolean isMarkup(int) -> f
    boolean isNCName(int) -> g
    boolean isNCNameStart(int) -> h
    boolean isName(int) -> i
    boolean isNameStart(int) -> j
    boolean isPubid(int) -> k
    boolean isSpace(int) -> l
    boolean isSupplemental(int) -> m
    boolean isValid(int) -> n
    boolean isValidIANAEncoding(java.lang.String) -> o
    boolean isValidJavaEncoding(java.lang.String) -> p
    boolean isValidNCName(java.lang.String) -> q
    boolean isValidName(java.lang.String) -> r
    boolean isValidNmtoken(java.lang.String) -> s
    char lowSurrogate(int) -> t
    int supplemental(char,char) -> u
    java.lang.String trim(java.lang.String) -> v
org.apache.xerces.util.XMLEntityDescriptionImpl -> d5.v:
    java.lang.String fEntityName -> f
    java.lang.String getEntityName() -> i
    void clear() -> l
    void setDescription(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> p
    void setDescription(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> q
org.apache.xerces.util.XMLResourceIdentifierImpl -> d5.w:
    java.lang.String fPublicId -> a
    java.lang.String fBaseSystemId -> c
    java.lang.String fLiteralSystemId -> b
    java.lang.String fNamespace -> e
    java.lang.String fExpandedSystemId -> d
    java.lang.String getPublicId() -> a
    java.lang.String getNamespace() -> b
    java.lang.String getExpandedSystemId() -> c
    java.lang.String getLiteralSystemId() -> f
    java.lang.String getBaseSystemId() -> h
    void setBaseSystemId(java.lang.String) -> j
    void setExpandedSystemId(java.lang.String) -> k
    void clear() -> l
    void setNamespace(java.lang.String) -> m
    void setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> n
    void setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> o
org.apache.xerces.util.XMLStringBuffer -> d5.x:
    void clear() -> a
    void append(char) -> e
    void append(org.apache.xerces.xni.XMLString) -> f
    void append(java.lang.String) -> g
    void append(char[],int,int) -> h
org.apache.xerces.util.XMLSymbols -> d5.y:
    java.lang.String fIDREFSymbol -> g
    java.lang.String fIDSymbol -> f
    java.lang.String fENTITYSymbol -> i
    java.lang.String fIDREFSSymbol -> h
    java.lang.String fNMTOKENSymbol -> k
    java.lang.String fENTITIESSymbol -> j
    java.lang.String fNOTATIONSymbol -> m
    java.lang.String fNMTOKENSSymbol -> l
    java.lang.String fIMPLIEDSymbol -> o
    java.lang.String fENUMERATIONSymbol -> n
    java.lang.String fFIXEDSymbol -> q
    java.lang.String fREQUIREDSymbol -> p
    java.lang.String EMPTY_STRING -> a
    java.lang.String PREFIX_XMLNS -> c
    java.lang.String PREFIX_XML -> b
    java.lang.String fCDATASymbol -> e
    java.lang.String fANYSymbol -> d
org.apache.xerces.xni.Augmentations -> e5.a:
    java.lang.Object putItem(java.lang.String,java.lang.Object) -> a
    java.lang.Object getItem(java.lang.String) -> b
    void removeAllItems() -> c
org.apache.xerces.xni.NamespaceContext -> e5.b:
    java.lang.String XML_URI -> a
    java.lang.String XMLNS_URI -> b
    java.lang.String getURI(java.lang.String) -> a
    void reset() -> b
    java.lang.String getDeclaredPrefixAt(int) -> c
    void pushContext() -> d
    int getDeclaredPrefixCount() -> e
    java.util.Enumeration getAllPrefixes() -> f
    boolean declarePrefix(java.lang.String,java.lang.String) -> g
    java.lang.String getPrefix(java.lang.String) -> h
    void popContext() -> i
org.apache.xerces.xni.QName -> e5.c:
    java.lang.String uri -> T2
    java.lang.String rawname -> S2
    java.lang.String localpart -> R2
    java.lang.String prefix -> Q2
    void clear() -> a
    void setValues(org.apache.xerces.xni.QName) -> b
    void setValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> c
org.apache.xerces.xni.XMLAttributes -> e5.d:
    int getLength() -> c
    void removeAllAttributes() -> d
    org.apache.xerces.xni.Augmentations getAugmentations(int) -> e
    java.lang.String getType(int) -> f
    void removeAttributeAt(int) -> g
    java.lang.String getValue(int) -> h
    java.lang.String getPrefix(int) -> i
    java.lang.String getURI(int) -> j
    void getName(int,org.apache.xerces.xni.QName) -> k
    java.lang.String getLocalName(int) -> l
    void setName(int,org.apache.xerces.xni.QName) -> m
    java.lang.String getQName(int) -> n
    boolean isSpecified(int) -> o
org.apache.xerces.xni.XMLDTDContentModelHandler -> e5.e:
    void separator(short,org.apache.xerces.xni.Augmentations) -> F
    void any(org.apache.xerces.xni.Augmentations) -> G
    void endGroup(org.apache.xerces.xni.Augmentations) -> H
    void startGroup(org.apache.xerces.xni.Augmentations) -> I
    void element(java.lang.String,org.apache.xerces.xni.Augmentations) -> N
    void empty(org.apache.xerces.xni.Augmentations) -> P
    void setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource) -> V
    void endContentModel(org.apache.xerces.xni.Augmentations) -> b
    void startContentModel(java.lang.String,org.apache.xerces.xni.Augmentations) -> f
    void pcdata(org.apache.xerces.xni.Augmentations) -> v
    void occurrence(short,org.apache.xerces.xni.Augmentations) -> w
org.apache.xerces.xni.XMLDTDHandler -> e5.f:
    void endConditional(org.apache.xerces.xni.Augmentations) -> B
    void endParameterEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> D
    void externalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> J
    void ignoredCharacters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> K
    void startAttlist(java.lang.String,org.apache.xerces.xni.Augmentations) -> L
    void startConditional(short,org.apache.xerces.xni.Augmentations) -> S
    void endExternalSubset(org.apache.xerces.xni.Augmentations) -> T
    void attributeDecl(java.lang.String,java.lang.String,java.lang.String,java.lang.String[],java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> U
    void processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> a
    void textDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> c
    void comment(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> d
    void startDTD(org.apache.xerces.xni.XMLLocator,org.apache.xerces.xni.Augmentations) -> h
    void internalEntityDecl(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> i
    void endAttlist(org.apache.xerces.xni.Augmentations) -> m
    void startParameterEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> n
    void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> p
    void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource) -> q
    void elementDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> t
    void notationDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,org.apache.xerces.xni.Augmentations) -> u
    void endDTD(org.apache.xerces.xni.Augmentations) -> x
    void unparsedEntityDecl(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> z
org.apache.xerces.xni.XMLDocumentHandler -> e5.g:
    void endDocument(org.apache.xerces.xni.Augmentations) -> A
    void emptyElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations) -> C
    void endGeneralEntity(java.lang.String,org.apache.xerces.xni.Augmentations) -> E
    void doctypeDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> M
    void startGeneralEntity(java.lang.String,org.apache.xerces.xni.XMLResourceIdentifier,java.lang.String,org.apache.xerces.xni.Augmentations) -> O
    org.apache.xerces.xni.parser.XMLDocumentSource getDocumentSource() -> Q
    void processingInstruction(java.lang.String,org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> a
    void textDecl(java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> c
    void comment(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> d
    void startElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.XMLAttributes,org.apache.xerces.xni.Augmentations) -> e
    void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource) -> g
    void endElement(org.apache.xerces.xni.QName,org.apache.xerces.xni.Augmentations) -> j
    void startDocument(org.apache.xerces.xni.XMLLocator,java.lang.String,org.apache.xerces.xni.NamespaceContext,org.apache.xerces.xni.Augmentations) -> k
    void characters(org.apache.xerces.xni.XMLString,org.apache.xerces.xni.Augmentations) -> o
    void startCDATA(org.apache.xerces.xni.Augmentations) -> r
    void endCDATA(org.apache.xerces.xni.Augmentations) -> s
    void xmlDecl(java.lang.String,java.lang.String,java.lang.String,org.apache.xerces.xni.Augmentations) -> y
org.apache.xerces.xni.XMLLocator -> e5.h:
    java.lang.String getPublicId() -> a
    java.lang.String getExpandedSystemId() -> c
    int getColumnNumber() -> d
    java.lang.String getEncoding() -> e
    java.lang.String getLiteralSystemId() -> f
    int getLineNumber() -> g
    java.lang.String getBaseSystemId() -> h
    int getCharacterOffset() -> i
org.apache.xerces.xni.XMLResourceIdentifier -> e5.i:
    java.lang.String getPublicId() -> a
    java.lang.String getNamespace() -> b
    java.lang.String getExpandedSystemId() -> c
    java.lang.String getLiteralSystemId() -> f
    java.lang.String getBaseSystemId() -> h
    void setBaseSystemId(java.lang.String) -> j
    void setExpandedSystemId(java.lang.String) -> k
org.apache.xerces.xni.XMLString -> e5.j:
    char[] ch -> a
    int offset -> b
    int length -> c
    void clear() -> a
    boolean equals(char[],int,int) -> b
    void setValues(org.apache.xerces.xni.XMLString) -> c
    void setValues(char[],int,int) -> d
org.apache.xerces.xni.XNIException -> e5.k:
    java.lang.Exception fException -> Q2
    java.lang.Exception getException() -> a
org.apache.xerces.xni.grammars.Grammar -> f5.a:
org.apache.xerces.xni.grammars.XMLDTDDescription -> f5.b:
    java.lang.String getRootName() -> g
org.apache.xerces.xni.grammars.XMLGrammarDescription -> f5.c:
    java.lang.String getGrammarType() -> d
org.apache.xerces.xni.grammars.XMLGrammarPool -> f5.d:
    org.apache.xerces.xni.grammars.Grammar[] retrieveInitialGrammarSet(java.lang.String) -> a
org.apache.xerces.xni.grammars.XMLSchemaDescription -> f5.e:
    java.lang.String getTargetNamespace() -> e
org.apache.xerces.xni.parser.XMLComponent -> g5.a:
    void setFeature(java.lang.String,boolean) -> d
    void setProperty(java.lang.String,java.lang.Object) -> f
    java.lang.Object getPropertyDefault(java.lang.String) -> g
    void reset(org.apache.xerces.xni.parser.XMLComponentManager) -> h
    java.lang.Boolean getFeatureDefault(java.lang.String) -> i
    java.lang.String[] getRecognizedProperties() -> k
    java.lang.String[] getRecognizedFeatures() -> n
org.apache.xerces.xni.parser.XMLComponentManager -> g5.b:
    java.lang.Object getProperty(java.lang.String) -> a
    boolean getFeature(java.lang.String) -> c
org.apache.xerces.xni.parser.XMLConfigurationException -> g5.c:
    java.lang.String fIdentifier -> S2
    short fType -> R2
    java.lang.String getIdentifier() -> b
    short getType() -> c
org.apache.xerces.xni.parser.XMLDTDContentModelSource -> g5.d:
org.apache.xerces.xni.parser.XMLDTDScanner -> g5.e:
    boolean scanDTDExternalSubset(boolean) -> e
    boolean scanDTDInternalSubset(boolean,boolean,boolean) -> j
    void setInputSource(org.apache.xerces.xni.parser.XMLInputSource) -> r
org.apache.xerces.xni.parser.XMLDTDSource -> g5.f:
org.apache.xerces.xni.parser.XMLDocumentScanner -> g5.g:
    boolean scanDocument(boolean) -> c
org.apache.xerces.xni.parser.XMLDocumentSource -> g5.h:
    void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler) -> b
    org.apache.xerces.xni.XMLDocumentHandler getDocumentHandler() -> m
org.apache.xerces.xni.parser.XMLEntityResolver -> g5.i:
    org.apache.xerces.xni.parser.XMLInputSource resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier) -> a
org.apache.xerces.xni.parser.XMLErrorHandler -> g5.j:
    void warning(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException) -> a
    void error(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException) -> b
    void fatalError(java.lang.String,java.lang.String,org.apache.xerces.xni.parser.XMLParseException) -> c
org.apache.xerces.xni.parser.XMLInputSource -> g5.k:
    java.lang.String fEncoding -> f
    java.lang.String fPublicId -> a
    java.io.InputStream fByteStream -> d
    java.lang.String fBaseSystemId -> c
    java.lang.String fSystemId -> b
    java.io.Reader fCharStream -> e
    java.lang.String getBaseSystemId() -> a
    java.io.InputStream getByteStream() -> b
    java.io.Reader getCharacterStream() -> c
    java.lang.String getEncoding() -> d
    java.lang.String getPublicId() -> e
    java.lang.String getSystemId() -> f
    void setByteStream(java.io.InputStream) -> g
    void setCharacterStream(java.io.Reader) -> h
    void setEncoding(java.lang.String) -> i
org.apache.xerces.xni.parser.XMLParseException -> g5.l:
    int fLineNumber -> V2
    int fColumnNumber -> W2
    java.lang.String fBaseSystemId -> U2
    int fCharacterOffset -> X2
    java.lang.String fExpandedSystemId -> T2
    java.lang.String fLiteralSystemId -> S2
    java.lang.String fPublicId -> R2
    int getColumnNumber() -> b
    java.lang.String getExpandedSystemId() -> c
    int getLineNumber() -> d
    java.lang.String getPublicId() -> e
org.apache.xerces.xni.parser.XMLParserConfiguration -> g5.m:
    java.lang.Object getProperty(java.lang.String) -> a
    void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler) -> b
    boolean getFeature(java.lang.String) -> c
    void setFeature(java.lang.String,boolean) -> d
    java.util.Locale getLocale() -> e
    void setProperty(java.lang.String,java.lang.Object) -> f
    void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler) -> g
    void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler) -> h
    void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver) -> i
    void addRecognizedProperties(java.lang.String[]) -> j
    void parse(org.apache.xerces.xni.parser.XMLInputSource) -> k
    void addRecognizedFeatures(java.lang.String[]) -> l
org.apache.xerces.xs.AttributePSVI -> h5.a:
    org.apache.xerces.xs.XSAttributeDeclaration getAttributeDeclaration() -> n
org.apache.xerces.xs.ElementPSVI -> h5.b:
    org.apache.xerces.xs.XSNotationDeclaration getNotation() -> a0
    boolean getNil() -> e0
    org.apache.xerces.xs.XSElementDeclaration getElementDeclaration() -> s0
    org.apache.xerces.xs.XSModel getSchemaInformation() -> y0
org.apache.xerces.xs.ItemPSVI -> h5.c:
    org.apache.xerces.xs.XSValue getSchemaValue() -> I
    boolean getIsSchemaSpecified() -> J
    java.lang.String getValidationContext() -> O
    short getValidationAttempted() -> Q
    org.apache.xerces.xs.XSTypeDefinition getTypeDefinition() -> f
    org.apache.xerces.xs.XSSimpleTypeDefinition getMemberTypeDefinition() -> i
    org.apache.xerces.xs.StringList getErrorMessages() -> i0
    short getValidity() -> l
    org.apache.xerces.xs.StringList getErrorCodes() -> z0
org.apache.xerces.xs.ShortList -> h5.d:
    int getLength() -> c
    short item(int) -> d
org.apache.xerces.xs.StringList -> h5.e:
org.apache.xerces.xs.XSAnnotation -> h5.f:
org.apache.xerces.xs.XSAttributeDeclaration -> h5.g:
org.apache.xerces.xs.XSComplexTypeDefinition -> h5.h:
    short getContentType() -> b
org.apache.xerces.xs.XSElementDeclaration -> h5.i:
org.apache.xerces.xs.XSException -> h5.j:
    short code -> Q2
org.apache.xerces.xs.XSModel -> h5.k:
org.apache.xerces.xs.XSNamedMap -> h5.l:
org.apache.xerces.xs.XSNamespaceItem -> h5.m:
org.apache.xerces.xs.XSNotationDeclaration -> h5.n:
org.apache.xerces.xs.XSObject -> h5.o:
    java.lang.String getName() -> e
org.apache.xerces.xs.XSObjectList -> h5.p:
    int getLength() -> c
org.apache.xerces.xs.XSSimpleTypeDefinition -> h5.q:
    boolean getNumeric() -> a
    short getBuiltInKind() -> c
    boolean getFinite() -> d
org.apache.xerces.xs.XSTerm -> h5.r:
org.apache.xerces.xs.XSTypeDefinition -> h5.s:
org.apache.xerces.xs.XSValue -> h5.t:
    org.apache.xerces.xs.XSObjectList getMemberTypeDefinitions() -> a
    org.apache.xerces.xs.ShortList getListValueTypes() -> b
    java.lang.String getNormalizedValue() -> c
    short getActualValueType() -> d
    java.lang.Object getActualValue() -> e
    org.apache.xerces.xs.XSSimpleTypeDefinition getTypeDefinition() -> f
    org.apache.xerces.xs.XSSimpleTypeDefinition getMemberTypeDefinition() -> i
org.apache.xerces.xs.datatypes.ObjectList -> i5.a:
org.bouncycastle.asn1.ASN1ApplicationSpecific -> j5.a:
    org.bouncycastle.asn1.ASN1TaggedObject taggedObject -> Q2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    int checkTagClass(int) -> t
org.bouncycastle.asn1.ASN1BMPString -> j5.b:
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    char[] string -> Q2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1BMPString createPrimitive(byte[]) -> t
    org.bouncycastle.asn1.ASN1BMPString createPrimitive(char[]) -> u
org.bouncycastle.asn1.ASN1BMPString$1 -> j5.b$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1BitString -> j5.c:
    char[] table -> S2
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    java.io.InputStream getBitStream() -> b
    java.lang.String getString() -> g
    int getPadBits() -> h
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1BitString createPrimitive(byte[]) -> t
    byte[] getBytes() -> u
    org.bouncycastle.asn1.ASN1BitString getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> v
    org.bouncycastle.asn1.ASN1BitString getInstance(java.lang.Object) -> w
    byte[] getOctets() -> x
org.bouncycastle.asn1.ASN1BitString$1 -> j5.c$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitConstructed(org.bouncycastle.asn1.ASN1Sequence) -> c
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1BitStringParser -> j5.d:
    java.io.InputStream getBitStream() -> b
    int getPadBits() -> h
org.bouncycastle.asn1.ASN1Boolean -> j5.e:
    org.bouncycastle.asn1.ASN1Boolean TRUE -> T2
    org.bouncycastle.asn1.ASN1Boolean FALSE -> S2
    byte value -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Boolean createPrimitive(byte[]) -> t
    org.bouncycastle.asn1.ASN1Boolean getInstance(java.lang.Object) -> u
    org.bouncycastle.asn1.ASN1Boolean getInstance(boolean) -> v
    boolean isTrue() -> w
org.bouncycastle.asn1.ASN1Boolean$1 -> j5.e$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1Choice -> j5.f:
org.bouncycastle.asn1.ASN1Encodable -> j5.g:
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
org.bouncycastle.asn1.ASN1EncodableVector -> j5.h:
    org.bouncycastle.asn1.ASN1Encodable[] elements -> a
    org.bouncycastle.asn1.ASN1Encodable[] EMPTY_ELEMENTS -> d
    int elementCount -> b
    boolean copyOnWrite -> c
    void add(org.bouncycastle.asn1.ASN1Encodable) -> a
    org.bouncycastle.asn1.ASN1Encodable[] cloneElements(org.bouncycastle.asn1.ASN1Encodable[]) -> b
    org.bouncycastle.asn1.ASN1Encodable[] copyElements() -> c
    org.bouncycastle.asn1.ASN1Encodable get(int) -> d
    void reallocate(int) -> e
    int size() -> f
    org.bouncycastle.asn1.ASN1Encodable[] takeElements() -> g
org.bouncycastle.asn1.ASN1Enumerated -> j5.i:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> S2
    org.bouncycastle.asn1.ASN1Enumerated[] cache -> T2
    int start -> R2
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Enumerated createPrimitive(byte[],boolean) -> t
org.bouncycastle.asn1.ASN1Enumerated$1 -> j5.i$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1Exception -> j5.j:
    java.lang.Throwable cause -> Q2
org.bouncycastle.asn1.ASN1External -> j5.k:
    org.bouncycastle.asn1.ASN1Primitive dataValueDescriptor -> S2
    int encoding -> T2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> V2
    org.bouncycastle.asn1.ASN1Integer indirectReference -> R2
    org.bouncycastle.asn1.ASN1Primitive externalContent -> U2
    org.bouncycastle.asn1.ASN1ObjectIdentifier directReference -> Q2
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1Sequence buildSequence() -> t
    int checkEncoding(int) -> u
    org.bouncycastle.asn1.ASN1Primitive checkExternalContent(int,org.bouncycastle.asn1.ASN1Primitive) -> v
    org.bouncycastle.asn1.ASN1Primitive getExternalContent(org.bouncycastle.asn1.ASN1TaggedObject) -> w
    org.bouncycastle.asn1.ASN1Primitive getObjFromSequence(org.bouncycastle.asn1.ASN1Sequence,int) -> x
org.bouncycastle.asn1.ASN1External$1 -> j5.k$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitConstructed(org.bouncycastle.asn1.ASN1Sequence) -> c
org.bouncycastle.asn1.ASN1GeneralString -> j5.l:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1GeneralString createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1GeneralString$1 -> j5.l$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1GeneralizedTime -> j5.m:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    boolean hasMinutes() -> A
    boolean hasSeconds() -> B
    boolean isDigit(int) -> C
    java.lang.String pruneFractionalSeconds(java.lang.String) -> D
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    java.text.SimpleDateFormat calculateGMTDateFormat() -> t
    java.lang.String calculateGMTOffset(java.lang.String) -> u
    java.lang.String convert(int) -> v
    org.bouncycastle.asn1.ASN1GeneralizedTime createPrimitive(byte[]) -> w
    org.bouncycastle.asn1.ASN1GeneralizedTime getInstance(java.lang.Object) -> x
    java.lang.String getTime() -> y
    boolean hasFractionalSeconds() -> z
org.bouncycastle.asn1.ASN1GeneralizedTime$1 -> j5.m$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1GraphicString -> j5.n:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1GraphicString createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1GraphicString$1 -> j5.n$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1IA5String -> j5.o:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1IA5String createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1IA5String$1 -> j5.o$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1InputStream -> j5.p:
    boolean lazyEvaluate -> R2
    int limit -> Q2
    byte[][] tmpBuffers -> S2
    org.bouncycastle.asn1.ASN1BitString buildConstructedBitString(org.bouncycastle.asn1.ASN1EncodableVector) -> a
    org.bouncycastle.asn1.ASN1OctetString buildConstructedOctetString(org.bouncycastle.asn1.ASN1EncodableVector) -> b
    org.bouncycastle.asn1.ASN1Primitive buildObject(int,int,int) -> c
    org.bouncycastle.asn1.ASN1Primitive createPrimitiveDERObject(int,org.bouncycastle.asn1.DefiniteLengthInputStream,byte[][]) -> d
    char[] getBMPCharBuffer(org.bouncycastle.asn1.DefiniteLengthInputStream) -> e
    byte[] getBuffer(org.bouncycastle.asn1.DefiniteLengthInputStream,byte[][]) -> f
    int getLimit() -> g
    int readLength() -> h
    int readLength(java.io.InputStream,int,boolean) -> i
    org.bouncycastle.asn1.ASN1Primitive readObject() -> j
    int readTagNumber(java.io.InputStream,int) -> k
    org.bouncycastle.asn1.ASN1Primitive readTaggedObjectDL(int,int,boolean,org.bouncycastle.asn1.DefiniteLengthInputStream) -> l
    org.bouncycastle.asn1.ASN1EncodableVector readVector() -> m
    org.bouncycastle.asn1.ASN1EncodableVector readVector(org.bouncycastle.asn1.DefiniteLengthInputStream) -> n
org.bouncycastle.asn1.ASN1Integer -> j5.q:
    byte[] bytes -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> S2
    int start -> R2
    int intValueExact() -> A
    boolean isMalformed(byte[]) -> B
    long longValue(byte[],int,int) -> C
    long longValueExact() -> D
    int signBytesToSkip(byte[]) -> E
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Integer createPrimitive(byte[]) -> t
    org.bouncycastle.asn1.ASN1Integer getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> u
    org.bouncycastle.asn1.ASN1Integer getInstance(java.lang.Object) -> v
    java.math.BigInteger getValue() -> w
    boolean hasValue(int) -> x
    boolean hasValue(java.math.BigInteger) -> y
    int intValue(byte[],int,int) -> z
org.bouncycastle.asn1.ASN1Integer$1 -> j5.q$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1Null -> j5.r:
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> Q2
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    org.bouncycastle.asn1.ASN1Null createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1Null$1 -> j5.r$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1NumericString -> j5.s:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1NumericString createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1NumericString$1 -> j5.s$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1Object -> j5.t:
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    byte[] getEncoded(java.lang.String) -> i
org.bouncycastle.asn1.ASN1ObjectDescriptor -> j5.u:
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    org.bouncycastle.asn1.ASN1GraphicString baseGraphicString -> Q2
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1ObjectDescriptor createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1ObjectDescriptor$1 -> j5.u$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitConstructed(org.bouncycastle.asn1.ASN1Sequence) -> c
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1ObjectIdentifier -> j5.v:
    byte[] contents -> R2
    java.util.concurrent.ConcurrentMap pool -> T2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> S2
    java.lang.String identifier -> Q2
    boolean isValidIdentifier(java.lang.String) -> A
    boolean on(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> B
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier branch(java.lang.String) -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier createPrimitive(byte[],boolean) -> u
    void doOutput(java.io.ByteArrayOutputStream) -> v
    byte[] getContents() -> w
    java.lang.String getId() -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier getInstance(java.lang.Object) -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier intern() -> z
org.bouncycastle.asn1.ASN1ObjectIdentifier$1 -> j5.v$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1ObjectIdentifier$OidHandle -> j5.v$b:
    byte[] contents -> b
    int key -> a
org.bouncycastle.asn1.ASN1OctetString -> j5.w:
    byte[] EMPTY_OCTETS -> S2
    byte[] string -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    java.io.InputStream getOctetStream() -> e
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1OctetString createPrimitive(byte[]) -> t
    org.bouncycastle.asn1.ASN1OctetString getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> u
    org.bouncycastle.asn1.ASN1OctetString getInstance(java.lang.Object) -> v
    byte[] getOctets() -> w
org.bouncycastle.asn1.ASN1OctetString$1 -> j5.w$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitConstructed(org.bouncycastle.asn1.ASN1Sequence) -> c
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1OctetStringParser -> j5.x:
    java.io.InputStream getOctetStream() -> e
org.bouncycastle.asn1.ASN1OutputStream -> j5.y:
    java.io.OutputStream os -> a
    org.bouncycastle.asn1.ASN1OutputStream create(java.io.OutputStream) -> a
    org.bouncycastle.asn1.ASN1OutputStream create(java.io.OutputStream,java.lang.String) -> b
    void flushInternal() -> c
    org.bouncycastle.asn1.DEROutputStream getDERSubStream() -> d
    org.bouncycastle.asn1.DLOutputStream getDLSubStream() -> e
    int getLengthOfDL(int) -> f
    int getLengthOfEncodingDL(boolean,int) -> g
    int getLengthOfIdentifier(int) -> h
    void write(int) -> i
    void write(byte[],int,int) -> j
    void writeDL(int) -> k
    void writeElements(org.bouncycastle.asn1.ASN1Encodable[]) -> l
    void writeEncodingDL(boolean,int,byte) -> m
    void writeEncodingDL(boolean,int,byte,byte[],int,int) -> n
    void writeEncodingDL(boolean,int,byte[]) -> o
    void writeEncodingDL(boolean,int,byte[],int,int) -> p
    void writeEncodingDL(boolean,int,byte[],int,int,byte) -> q
    void writeEncodingIL(boolean,int,org.bouncycastle.asn1.ASN1Encodable[]) -> r
    void writeIdentifier(boolean,int) -> s
    void writeIdentifier(boolean,int,int) -> t
    void writeObject(org.bouncycastle.asn1.ASN1Primitive) -> u
    void writePrimitive(org.bouncycastle.asn1.ASN1Primitive,boolean) -> v
    void writePrimitives(org.bouncycastle.asn1.ASN1Primitive[]) -> w
org.bouncycastle.asn1.ASN1ParsingException -> j5.z:
    java.lang.Throwable cause -> Q2
org.bouncycastle.asn1.ASN1Primitive -> j5.a0:
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    void encodeTo(java.io.OutputStream) -> m
    void encodeTo(java.io.OutputStream,java.lang.String) -> n
    int encodedLength(boolean) -> o
    boolean equals(org.bouncycastle.asn1.ASN1Primitive) -> p
    org.bouncycastle.asn1.ASN1Primitive fromByteArray(byte[]) -> q
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
org.bouncycastle.asn1.ASN1PrintableString -> j5.b0:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1PrintableString createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1PrintableString$1 -> j5.b0$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1RelativeOID -> j5.c0:
    byte[] contents -> R2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> S2
    java.lang.String identifier -> Q2
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1RelativeOID createPrimitive(byte[],boolean) -> t
    void doOutput(java.io.ByteArrayOutputStream) -> u
    byte[] getContents() -> v
    java.lang.String getId() -> w
    boolean isValidIdentifier(java.lang.String,int) -> x
    void writeField(java.io.ByteArrayOutputStream,long) -> y
    void writeField(java.io.ByteArrayOutputStream,java.math.BigInteger) -> z
org.bouncycastle.asn1.ASN1RelativeOID$1 -> j5.c0$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1Sequence -> j5.d0:
    org.bouncycastle.asn1.ASN1Encodable[] elements -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    org.bouncycastle.asn1.ASN1External toASN1External() -> A
    org.bouncycastle.asn1.ASN1OctetString toASN1OctetString() -> B
    org.bouncycastle.asn1.ASN1Set toASN1Set() -> C
    org.bouncycastle.asn1.ASN1Encodable[] toArrayInternal() -> D
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    boolean encodeConstructed() -> l
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1BitString[] getConstructedBitStrings() -> t
    org.bouncycastle.asn1.ASN1OctetString[] getConstructedOctetStrings() -> u
    org.bouncycastle.asn1.ASN1Sequence getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> v
    org.bouncycastle.asn1.ASN1Sequence getInstance(java.lang.Object) -> w
    org.bouncycastle.asn1.ASN1Encodable getObjectAt(int) -> x
    java.util.Enumeration getObjects() -> y
    org.bouncycastle.asn1.ASN1BitString toASN1BitString() -> z
org.bouncycastle.asn1.ASN1Sequence$1 -> j5.d0$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitConstructed(org.bouncycastle.asn1.ASN1Sequence) -> c
org.bouncycastle.asn1.ASN1Sequence$2 -> j5.d0$b:
    org.bouncycastle.asn1.ASN1Sequence this$0 -> b
    int pos -> a
org.bouncycastle.asn1.ASN1Set -> j5.e0:
    org.bouncycastle.asn1.ASN1Encodable[] elements -> Q2
    boolean isSorted -> R2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> S2
    org.bouncycastle.asn1.ASN1Encodable[] toArray() -> A
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    boolean encodeConstructed() -> l
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    byte[] getDEREncoded(org.bouncycastle.asn1.ASN1Encodable) -> t
    org.bouncycastle.asn1.ASN1Set getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> u
    org.bouncycastle.asn1.ASN1Set getInstance(java.lang.Object) -> v
    org.bouncycastle.asn1.ASN1Encodable getObjectAt(int) -> w
    java.util.Enumeration getObjects() -> x
    boolean lessThanOrEqual(byte[],byte[]) -> y
    void sort(org.bouncycastle.asn1.ASN1Encodable[]) -> z
org.bouncycastle.asn1.ASN1Set$1 -> j5.e0$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitConstructed(org.bouncycastle.asn1.ASN1Sequence) -> c
org.bouncycastle.asn1.ASN1Set$2 -> j5.e0$b:
    org.bouncycastle.asn1.ASN1Set this$0 -> b
    int pos -> a
org.bouncycastle.asn1.ASN1StreamParser -> j5.f0:
    byte[][] tmpBuffers -> c
    java.io.InputStream _in -> a
    int _limit -> b
    org.bouncycastle.asn1.ASN1Encodable implParseObject(int) -> a
    org.bouncycastle.asn1.ASN1Primitive loadTaggedDL(int,int,boolean) -> b
    org.bouncycastle.asn1.ASN1Primitive loadTaggedIL(int,int) -> c
    org.bouncycastle.asn1.ASN1Encodable parseImplicitConstructedDL(int) -> d
    org.bouncycastle.asn1.ASN1Encodable parseImplicitConstructedIL(int) -> e
    org.bouncycastle.asn1.ASN1Encodable parseImplicitPrimitive(int,org.bouncycastle.asn1.DefiniteLengthInputStream) -> f
    org.bouncycastle.asn1.ASN1Encodable readObject() -> g
    org.bouncycastle.asn1.ASN1EncodableVector readVector() -> h
    void set00Check(boolean) -> i
org.bouncycastle.asn1.ASN1String -> j5.g0:
    java.lang.String getString() -> g
org.bouncycastle.asn1.ASN1T61String -> j5.h0:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1T61String createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1T61String$1 -> j5.h0$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1Tag -> j5.i0:
    int tagNumber -> b
    int tagClass -> a
    org.bouncycastle.asn1.ASN1Tag create(int,int) -> a
org.bouncycastle.asn1.ASN1TaggedObject -> j5.j0:
    int tagNo -> S2
    org.bouncycastle.asn1.ASN1Encodable obj -> T2
    int explicitness -> Q2
    int tagClass -> R2
    org.bouncycastle.asn1.ASN1Primitive getObject() -> A
    int getTagClass() -> B
    int getTagNo() -> C
    boolean isExplicit() -> D
    org.bouncycastle.asn1.ASN1Sequence rebuildConstructed(org.bouncycastle.asn1.ASN1Primitive) -> E
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1TaggedObject checkedCast(org.bouncycastle.asn1.ASN1Primitive) -> t
    org.bouncycastle.asn1.ASN1Primitive createConstructedDL(int,int,org.bouncycastle.asn1.ASN1EncodableVector) -> u
    org.bouncycastle.asn1.ASN1Primitive createConstructedIL(int,int,org.bouncycastle.asn1.ASN1EncodableVector) -> v
    org.bouncycastle.asn1.ASN1Primitive createPrimitive(int,int,byte[]) -> w
    org.bouncycastle.asn1.ASN1Primitive getBaseUniversal(boolean,org.bouncycastle.asn1.ASN1UniversalType) -> x
    org.bouncycastle.asn1.ASN1Object getExplicitBaseObject() -> y
    org.bouncycastle.asn1.ASN1TaggedObject getInstance(java.lang.Object) -> z
org.bouncycastle.asn1.ASN1Type -> j5.k0:
    java.lang.Class javaClass -> a
org.bouncycastle.asn1.ASN1UTCTime -> j5.l0:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1UTCTime createPrimitive(byte[]) -> t
    java.lang.String getAdjustedTime() -> u
    java.lang.String getTime() -> v
    boolean isDigit(int) -> w
org.bouncycastle.asn1.ASN1UTCTime$1 -> j5.l0$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1UTF8String -> j5.m0:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1UTF8String createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1UTF8String$1 -> j5.m0$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1UniversalString -> j5.n0:
    char[] table -> S2
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1UniversalString createPrimitive(byte[]) -> t
    void encodeHexByte(java.lang.StringBuffer,int) -> u
    void encodeHexDL(java.lang.StringBuffer,int) -> v
org.bouncycastle.asn1.ASN1UniversalString$1 -> j5.n0$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1UniversalType -> j5.o0:
    org.bouncycastle.asn1.ASN1Tag tag -> b
    org.bouncycastle.asn1.ASN1Primitive checkedCast(org.bouncycastle.asn1.ASN1Primitive) -> a
    org.bouncycastle.asn1.ASN1Primitive fromByteArray(byte[]) -> b
    org.bouncycastle.asn1.ASN1Primitive fromImplicitConstructed(org.bouncycastle.asn1.ASN1Sequence) -> c
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
    org.bouncycastle.asn1.ASN1Primitive getContextInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> e
org.bouncycastle.asn1.ASN1Util -> j5.p0:
    java.lang.String getTagText(int,int) -> a
org.bouncycastle.asn1.ASN1VideotexString -> j5.q0:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1VideotexString createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1VideotexString$1 -> j5.q0$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.ASN1VisibleString -> j5.r0:
    byte[] contents -> Q2
    org.bouncycastle.asn1.ASN1UniversalType TYPE -> R2
    java.lang.String getString() -> g
    boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive) -> j
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1VisibleString createPrimitive(byte[]) -> t
org.bouncycastle.asn1.ASN1VisibleString$1 -> j5.r0$a:
    org.bouncycastle.asn1.ASN1Primitive fromImplicitPrimitive(org.bouncycastle.asn1.DEROctetString) -> d
org.bouncycastle.asn1.BERApplicationSpecific -> j5.s0:
org.bouncycastle.asn1.BERApplicationSpecificParser -> j5.t0:
org.bouncycastle.asn1.BERBitString -> j5.u0:
    org.bouncycastle.asn1.ASN1BitString[] elements -> U2
    int segmentLimit -> T2
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    byte[] flattenBitStrings(org.bouncycastle.asn1.ASN1BitString[]) -> y
org.bouncycastle.asn1.BERBitStringParser -> j5.v0:
    org.bouncycastle.asn1.ASN1StreamParser _parser -> Q2
    org.bouncycastle.asn1.ConstructedBitStream _bitStream -> R2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    java.io.InputStream getBitStream() -> b
    org.bouncycastle.asn1.BERBitString parse(org.bouncycastle.asn1.ASN1StreamParser) -> c
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    int getPadBits() -> h
org.bouncycastle.asn1.BERFactory -> j5.w0:
    org.bouncycastle.asn1.BERSet EMPTY_SET -> b
    org.bouncycastle.asn1.BERSequence EMPTY_SEQUENCE -> a
    org.bouncycastle.asn1.BERSequence createSequence(org.bouncycastle.asn1.ASN1EncodableVector) -> a
org.bouncycastle.asn1.BEROctetString -> j5.x0:
    int segmentLimit -> T2
    org.bouncycastle.asn1.ASN1OctetString[] elements -> U2
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    byte[] flattenOctetStrings(org.bouncycastle.asn1.ASN1OctetString[]) -> x
org.bouncycastle.asn1.BEROctetStringParser -> j5.y0:
    org.bouncycastle.asn1.ASN1StreamParser _parser -> Q2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    org.bouncycastle.asn1.BEROctetString parse(org.bouncycastle.asn1.ASN1StreamParser) -> c
    java.io.InputStream getOctetStream() -> e
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
org.bouncycastle.asn1.BERSequence -> j5.z0:
    org.bouncycastle.asn1.ASN1External toASN1External() -> A
    org.bouncycastle.asn1.ASN1OctetString toASN1OctetString() -> B
    org.bouncycastle.asn1.ASN1Set toASN1Set() -> C
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1BitString toASN1BitString() -> z
org.bouncycastle.asn1.BERSequenceParser -> j5.a1:
    org.bouncycastle.asn1.ASN1StreamParser _parser -> Q2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    org.bouncycastle.asn1.BERSequence parse(org.bouncycastle.asn1.ASN1StreamParser) -> c
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
org.bouncycastle.asn1.BERSet -> j5.b1:
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    int encodedLength(boolean) -> o
org.bouncycastle.asn1.BERSetParser -> j5.c1:
    org.bouncycastle.asn1.ASN1StreamParser _parser -> Q2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    org.bouncycastle.asn1.BERSet parse(org.bouncycastle.asn1.ASN1StreamParser) -> c
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
org.bouncycastle.asn1.BERTaggedObject -> j5.d1:
    org.bouncycastle.asn1.ASN1Sequence rebuildConstructed(org.bouncycastle.asn1.ASN1Primitive) -> E
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
org.bouncycastle.asn1.BERTaggedObjectParser -> j5.e1:
    org.bouncycastle.asn1.ASN1StreamParser _parser -> S2
    int _tagClass -> Q2
    int _tagNo -> R2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
org.bouncycastle.asn1.ConstructedBitStream -> j5.f1:
    org.bouncycastle.asn1.ASN1BitStringParser _currentParser -> U2
    java.io.InputStream _currentStream -> V2
    org.bouncycastle.asn1.ASN1StreamParser _parser -> Q2
    int _padBits -> T2
    boolean _octetAligned -> R2
    boolean _first -> S2
    org.bouncycastle.asn1.ASN1BitStringParser getNextParser() -> a
    int getPadBits() -> b
org.bouncycastle.asn1.ConstructedOctetStream -> j5.g1:
    org.bouncycastle.asn1.ASN1StreamParser _parser -> Q2
    boolean _first -> R2
    java.io.InputStream _currentStream -> S2
    org.bouncycastle.asn1.ASN1OctetStringParser getNextParser() -> a
org.bouncycastle.asn1.DERApplicationSpecific -> j5.h1:
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
org.bouncycastle.asn1.DERBMPString -> j5.i1:
org.bouncycastle.asn1.DERBitString -> j5.j1:
    org.bouncycastle.asn1.DERBitString getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> A
    org.bouncycastle.asn1.DERBitString getInstance(java.lang.Object) -> B
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.DERBitString convert(org.bouncycastle.asn1.ASN1BitString) -> y
    org.bouncycastle.asn1.DERBitString fromOctetString(org.bouncycastle.asn1.ASN1OctetString) -> z
org.bouncycastle.asn1.DERExternal -> j5.k1:
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1Sequence buildSequence() -> t
org.bouncycastle.asn1.DERExternalParser -> j5.l1:
    org.bouncycastle.asn1.ASN1StreamParser _parser -> Q2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    org.bouncycastle.asn1.DLExternal parse(org.bouncycastle.asn1.ASN1StreamParser) -> c
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
org.bouncycastle.asn1.DERGeneralString -> j5.m1:
org.bouncycastle.asn1.DERGeneralizedTime -> j5.n1:
    byte[] getDERTime() -> E
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
org.bouncycastle.asn1.DERGraphicString -> j5.o1:
org.bouncycastle.asn1.DERIA5String -> j5.p1:
org.bouncycastle.asn1.DERNull -> j5.q1:
    byte[] zeroBytes -> S2
    org.bouncycastle.asn1.DERNull INSTANCE -> R2
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
org.bouncycastle.asn1.DERNumericString -> j5.r1:
org.bouncycastle.asn1.DEROctetString -> j5.s1:
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean,byte[],int,int) -> x
    int encodedLength(boolean,int) -> y
org.bouncycastle.asn1.DEROctetStringParser -> j5.t1:
    org.bouncycastle.asn1.DefiniteLengthInputStream stream -> Q2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    java.io.InputStream getOctetStream() -> e
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
org.bouncycastle.asn1.DEROutputStream -> j5.u1:
    org.bouncycastle.asn1.DEROutputStream getDERSubStream() -> d
    void writeElements(org.bouncycastle.asn1.ASN1Encodable[]) -> l
    void writePrimitive(org.bouncycastle.asn1.ASN1Primitive,boolean) -> v
    void writePrimitives(org.bouncycastle.asn1.ASN1Primitive[]) -> w
org.bouncycastle.asn1.DERPrintableString -> j5.v1:
org.bouncycastle.asn1.DERSequence -> j5.w1:
    int contentsLength -> S2
    org.bouncycastle.asn1.ASN1External toASN1External() -> A
    org.bouncycastle.asn1.ASN1OctetString toASN1OctetString() -> B
    org.bouncycastle.asn1.ASN1Set toASN1Set() -> C
    org.bouncycastle.asn1.DERSequence convert(org.bouncycastle.asn1.ASN1Sequence) -> E
    int getContentsLength() -> F
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1BitString toASN1BitString() -> z
org.bouncycastle.asn1.DERSet -> j5.x1:
    int contentsLength -> T2
    boolean checkSorted(boolean) -> B
    int getContentsLength() -> C
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
org.bouncycastle.asn1.DERT61String -> j5.y1:
org.bouncycastle.asn1.DERTaggedObject -> j5.z1:
    org.bouncycastle.asn1.ASN1Sequence rebuildConstructed(org.bouncycastle.asn1.ASN1Primitive) -> E
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
org.bouncycastle.asn1.DERUTF8String -> j5.a2:
org.bouncycastle.asn1.DERUniversalString -> j5.b2:
org.bouncycastle.asn1.DERVideotexString -> j5.c2:
org.bouncycastle.asn1.DERVisibleString -> j5.d2:
org.bouncycastle.asn1.DLApplicationSpecific -> j5.e2:
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
org.bouncycastle.asn1.DLBitString -> j5.f2:
    int encodedLength(boolean,int) -> A
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean,byte,byte[],int,int) -> y
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean,byte[],int,int) -> z
org.bouncycastle.asn1.DLBitStringParser -> j5.g2:
    org.bouncycastle.asn1.DefiniteLengthInputStream stream -> Q2
    int padBits -> R2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    java.io.InputStream getBitStream() -> b
    java.io.InputStream getBitStream(boolean) -> c
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    int getPadBits() -> h
org.bouncycastle.asn1.DLExternal -> j5.h2:
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1Sequence buildSequence() -> t
org.bouncycastle.asn1.DLFactory -> j5.i2:
    org.bouncycastle.asn1.DLSequence EMPTY_SEQUENCE -> a
    org.bouncycastle.asn1.DLSet EMPTY_SET -> b
    org.bouncycastle.asn1.DLSequence createSequence(org.bouncycastle.asn1.ASN1EncodableVector) -> a
    org.bouncycastle.asn1.DLSet createSet(org.bouncycastle.asn1.ASN1EncodableVector) -> b
org.bouncycastle.asn1.DLOutputStream -> j5.j2:
    org.bouncycastle.asn1.DLOutputStream getDLSubStream() -> e
    void writeElements(org.bouncycastle.asn1.ASN1Encodable[]) -> l
    void writePrimitive(org.bouncycastle.asn1.ASN1Primitive,boolean) -> v
    void writePrimitives(org.bouncycastle.asn1.ASN1Primitive[]) -> w
org.bouncycastle.asn1.DLSequence -> j5.k2:
    int contentsLength -> S2
    org.bouncycastle.asn1.ASN1External toASN1External() -> A
    org.bouncycastle.asn1.ASN1OctetString toASN1OctetString() -> B
    org.bouncycastle.asn1.ASN1Set toASN1Set() -> C
    int getContentsLength() -> E
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1BitString toASN1BitString() -> z
org.bouncycastle.asn1.DLSequenceParser -> j5.l2:
    org.bouncycastle.asn1.ASN1StreamParser _parser -> Q2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
org.bouncycastle.asn1.DLSet -> j5.m2:
    int contentsLength -> T2
    int getContentsLength() -> B
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
org.bouncycastle.asn1.DLSetParser -> j5.n2:
    org.bouncycastle.asn1.ASN1StreamParser _parser -> Q2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
org.bouncycastle.asn1.DLTaggedObject -> j5.o2:
    org.bouncycastle.asn1.ASN1Sequence rebuildConstructed(org.bouncycastle.asn1.ASN1Primitive) -> E
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    boolean encodeConstructed() -> l
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
org.bouncycastle.asn1.DLTaggedObjectParser -> j5.p2:
    boolean _constructed -> T2
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
org.bouncycastle.asn1.DefiniteLengthInputStream -> j5.q2:
    int _originalLength -> S2
    int _remaining -> T2
    byte[] EMPTY_BYTES -> U2
    int getRemaining() -> c
    void readAllIntoByteArray(byte[]) -> d
    byte[] toByteArray() -> e
org.bouncycastle.asn1.InMemoryRepresentable -> j5.r2:
    org.bouncycastle.asn1.ASN1Primitive getLoadedObject() -> a
org.bouncycastle.asn1.IndefiniteLengthInputStream -> j5.s2:
    boolean _eofOn00 -> V2
    int _b1 -> S2
    int _b2 -> T2
    boolean _eofReached -> U2
    boolean checkForEof() -> c
    void setEofOn00(boolean) -> d
org.bouncycastle.asn1.LazyConstructionEnumeration -> j5.t2:
    java.lang.Object nextObj -> b
    org.bouncycastle.asn1.ASN1InputStream aIn -> a
    java.lang.Object readObject() -> a
org.bouncycastle.asn1.LazyEncodedSequence -> j5.u2:
    byte[] encoded -> S2
    org.bouncycastle.asn1.ASN1External toASN1External() -> A
    org.bouncycastle.asn1.ASN1OctetString toASN1OctetString() -> B
    org.bouncycastle.asn1.ASN1Set toASN1Set() -> C
    void force() -> E
    byte[] getContents() -> F
    void encode(org.bouncycastle.asn1.ASN1OutputStream,boolean) -> k
    int encodedLength(boolean) -> o
    org.bouncycastle.asn1.ASN1Primitive toDERObject() -> r
    org.bouncycastle.asn1.ASN1Primitive toDLObject() -> s
    org.bouncycastle.asn1.ASN1Encodable getObjectAt(int) -> x
    java.util.Enumeration getObjects() -> y
    org.bouncycastle.asn1.ASN1BitString toASN1BitString() -> z
org.bouncycastle.asn1.LimitedInputStream -> j5.v2:
    int _limit -> R2
    java.io.InputStream _in -> Q2
    int getLimit() -> a
    void setParentEofDetect(boolean) -> b
org.bouncycastle.asn1.OIDTokenizer -> j5.w2:
    java.lang.String oid -> a
    int index -> b
    boolean hasMoreTokens() -> a
    java.lang.String nextToken() -> b
org.bouncycastle.asn1.StreamUtil -> j5.x2:
    long MAX_MEMORY -> a
    int findLimit(java.io.InputStream) -> a
org.bouncycastle.asn1.bc.BCObjectIdentifiers -> k5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHA256 -> K
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha1_pkcs12_aes128_cbc -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHA256ph -> G
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha1_pkcs5 -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_with_SHA256 -> S
    org.bouncycastle.asn1.ASN1ObjectIdentifier sphincs256_with_BLAKE512 -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_with_SHA256 -> O
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha256_pkcs12_aes192_cbc -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA -> W
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHA256ph -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha1 -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt -> F
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHA256 -> B
    org.bouncycastle.asn1.ASN1ObjectIdentifier newHope -> f0
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHA512 -> L
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha1_pkcs12_aes192_cbc -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier linkedCertificate -> h0
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA_Rnd1_p_III -> b0
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHA512ph -> H
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha1_pkcs12 -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA_p_III -> d0
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_with_SHA512 -> T
    org.bouncycastle.asn1.ASN1ObjectIdentifier sphincs256_with_SHA512 -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_with_SHA512 -> P
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha256_pkcs12_aes256_cbc -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA_Rnd1_I -> X
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHA512ph -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHA512 -> C
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha256 -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHAKE128 -> M
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha1_pkcs12_aes256_cbc -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHAKE128ph -> I
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha256_pkcs5 -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_with_SHAKE128 -> U
    org.bouncycastle.asn1.ASN1ObjectIdentifier sphincs256_with_SHA3_512 -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_with_SHAKE128 -> Q
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_sig -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA_Rnd1_III_size -> Y
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHAKE128ph -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHAKE128 -> D
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha384 -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha256_pkcs12 -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_ext -> g0
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHAKE256 -> N
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha224 -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA_p_I -> c0
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHAKE256ph -> J
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_exch -> e0
    org.bouncycastle.asn1.ASN1ObjectIdentifier sphincs256 -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_with_SHAKE256 -> V
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA_Rnd1_p_I -> a0
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha256_pkcs12_aes128_cbc -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_with_SHAKE256 -> R
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA_Rnd1_III_speed -> Z
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHAKE256 -> E
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe_sha512 -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHAKE256ph -> A
    org.bouncycastle.asn1.ASN1ObjectIdentifier bc_pbe -> b
org.bouncycastle.asn1.bsi.BSIObjectIdentifiers -> l5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_SHA3_384 -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier algorithm -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_SHA512 -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_SHA3_224 -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_X963kdf_SHA384 -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_X963kdf_RIPEMD160 -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_X963kdf -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_X963kdf_SHA224 -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_SessionKDF_3DES -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_SessionKDF_AES192 -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_signatures -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_SHA224 -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier bsi_de -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_SHA3_256 -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_SHA3_512 -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_SHA384 -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_RIPEMD160 -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_X963kdf_SHA256 -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_X963kdf_SHA512 -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_X963kdf_SHA1 -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_SessionKDF -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_SessionKDF_AES128 -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_SHA1 -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_plain_SHA256 -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecka_eg_SessionKDF_AES256 -> A
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecc -> b
org.bouncycastle.asn1.cms.CMSObjectIdentifiers -> m5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier timestampedData -> K
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ri -> L
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ri_ocsp_response -> M
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ri_scvp -> N
    org.bouncycastle.asn1.ASN1ObjectIdentifier encryptedData -> G
    org.bouncycastle.asn1.ASN1ObjectIdentifier authenticatedData -> H
    org.bouncycastle.asn1.ASN1ObjectIdentifier compressedData -> I
    org.bouncycastle.asn1.ASN1ObjectIdentifier authEnvelopedData -> J
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecdsa_with_shake256 -> S
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg -> O
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_RSASSA_PSS_SHAKE128 -> P
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_RSASSA_PSS_SHAKE256 -> Q
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecdsa_with_shake128 -> R
    org.bouncycastle.asn1.ASN1ObjectIdentifier signedData -> C
    org.bouncycastle.asn1.ASN1ObjectIdentifier envelopedData -> D
    org.bouncycastle.asn1.ASN1ObjectIdentifier signedAndEnvelopedData -> E
    org.bouncycastle.asn1.ASN1ObjectIdentifier digestedData -> F
    org.bouncycastle.asn1.ASN1ObjectIdentifier data -> B
org.bouncycastle.asn1.cms.ContentInfo -> m5.b:
    org.bouncycastle.asn1.ASN1Encodable content -> R2
    org.bouncycastle.asn1.ASN1ObjectIdentifier contentType -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1Encodable getContent() -> j
    org.bouncycastle.asn1.cms.ContentInfo getInstance(java.lang.Object) -> k
org.bouncycastle.asn1.cms.EncryptedContentInfo -> m5.c:
    org.bouncycastle.asn1.ASN1OctetString encryptedContent -> S2
    org.bouncycastle.asn1.ASN1ObjectIdentifier contentType -> Q2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier contentEncryptionAlgorithm -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getContentEncryptionAlgorithm() -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier getContentType() -> k
    org.bouncycastle.asn1.ASN1OctetString getEncryptedContent() -> l
    org.bouncycastle.asn1.cms.EncryptedContentInfo getInstance(java.lang.Object) -> m
org.bouncycastle.asn1.cms.EnvelopedData -> m5.d:
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    org.bouncycastle.asn1.cms.OriginatorInfo originatorInfo -> R2
    org.bouncycastle.asn1.ASN1Set recipientInfos -> S2
    org.bouncycastle.asn1.cms.EncryptedContentInfo encryptedContentInfo -> T2
    org.bouncycastle.asn1.ASN1Set unprotectedAttrs -> U2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    int calculateVersion(org.bouncycastle.asn1.cms.OriginatorInfo,org.bouncycastle.asn1.ASN1Set,org.bouncycastle.asn1.ASN1Set) -> j
    org.bouncycastle.asn1.cms.EncryptedContentInfo getEncryptedContentInfo() -> k
    org.bouncycastle.asn1.cms.EnvelopedData getInstance(java.lang.Object) -> l
    org.bouncycastle.asn1.cms.OriginatorInfo getOriginatorInfo() -> m
    org.bouncycastle.asn1.ASN1Set getRecipientInfos() -> n
    org.bouncycastle.asn1.ASN1Set getUnprotectedAttrs() -> o
org.bouncycastle.asn1.cms.IssuerAndSerialNumber -> m5.e:
    org.bouncycastle.asn1.ASN1Integer serialNumber -> R2
    org.bouncycastle.asn1.x500.X500Name name -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cms.IssuerAndSerialNumber getInstance(java.lang.Object) -> j
    org.bouncycastle.asn1.x500.X500Name getName() -> k
    org.bouncycastle.asn1.ASN1Integer getSerialNumber() -> l
org.bouncycastle.asn1.cms.KEKIdentifier -> m5.f:
    org.bouncycastle.asn1.ASN1GeneralizedTime date -> R2
    org.bouncycastle.asn1.ASN1OctetString keyIdentifier -> Q2
    org.bouncycastle.asn1.cms.OtherKeyAttribute other -> S2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cms.KEKIdentifier getInstance(java.lang.Object) -> j
    org.bouncycastle.asn1.ASN1OctetString getKeyIdentifier() -> k
org.bouncycastle.asn1.cms.KEKRecipientInfo -> m5.g:
    org.bouncycastle.asn1.ASN1OctetString encryptedKey -> T2
    org.bouncycastle.asn1.cms.KEKIdentifier kekid -> R2
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier keyEncryptionAlgorithm -> S2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1OctetString getEncryptedKey() -> j
    org.bouncycastle.asn1.cms.KEKRecipientInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> k
    org.bouncycastle.asn1.cms.KEKRecipientInfo getInstance(java.lang.Object) -> l
    org.bouncycastle.asn1.cms.KEKIdentifier getKekid() -> m
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm() -> n
    org.bouncycastle.asn1.ASN1Integer getVersion() -> o
org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier -> m5.h:
    org.bouncycastle.asn1.cms.IssuerAndSerialNumber issuerSerial -> Q2
    org.bouncycastle.asn1.cms.RecipientKeyIdentifier rKeyID -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier getInstance(java.lang.Object) -> j
    org.bouncycastle.asn1.cms.IssuerAndSerialNumber getIssuerAndSerialNumber() -> k
    org.bouncycastle.asn1.cms.RecipientKeyIdentifier getRKeyID() -> l
org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo -> m5.i:
    org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey originator -> R2
    org.bouncycastle.asn1.ASN1OctetString ukm -> S2
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    org.bouncycastle.asn1.ASN1Sequence recipientEncryptedKeys -> U2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier keyEncryptionAlgorithm -> T2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> j
    org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo getInstance(java.lang.Object) -> k
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm() -> l
    org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey getOriginator() -> m
    org.bouncycastle.asn1.ASN1Sequence getRecipientEncryptedKeys() -> n
    org.bouncycastle.asn1.ASN1OctetString getUserKeyingMaterial() -> o
    org.bouncycastle.asn1.ASN1Integer getVersion() -> p
org.bouncycastle.asn1.cms.KeyTransRecipientInfo -> m5.j:
    org.bouncycastle.asn1.cms.RecipientIdentifier rid -> R2
    org.bouncycastle.asn1.ASN1OctetString encryptedKey -> T2
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier keyEncryptionAlgorithm -> S2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1OctetString getEncryptedKey() -> j
    org.bouncycastle.asn1.cms.KeyTransRecipientInfo getInstance(java.lang.Object) -> k
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm() -> l
    org.bouncycastle.asn1.cms.RecipientIdentifier getRecipientIdentifier() -> m
    org.bouncycastle.asn1.ASN1Integer getVersion() -> n
org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey -> m5.k:
    org.bouncycastle.asn1.ASN1Encodable id -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> j
    org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey getInstance(java.lang.Object) -> k
    org.bouncycastle.asn1.cms.IssuerAndSerialNumber getIssuerAndSerialNumber() -> l
    org.bouncycastle.asn1.cms.OriginatorPublicKey getOriginatorKey() -> m
    org.bouncycastle.asn1.x509.SubjectKeyIdentifier getSubjectKeyIdentifier() -> n
org.bouncycastle.asn1.cms.OriginatorInfo -> m5.l:
    org.bouncycastle.asn1.ASN1Set certs -> Q2
    org.bouncycastle.asn1.ASN1Set crls -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cms.OriginatorInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> j
    org.bouncycastle.asn1.cms.OriginatorInfo getInstance(java.lang.Object) -> k
org.bouncycastle.asn1.cms.OriginatorPublicKey -> m5.m:
    org.bouncycastle.asn1.DERBitString publicKey -> R2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier algorithm -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cms.OriginatorPublicKey getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> j
    org.bouncycastle.asn1.cms.OriginatorPublicKey getInstance(java.lang.Object) -> k
    org.bouncycastle.asn1.DERBitString getPublicKey() -> l
org.bouncycastle.asn1.cms.OtherKeyAttribute -> m5.n:
    org.bouncycastle.asn1.ASN1Encodable keyAttr -> R2
    org.bouncycastle.asn1.ASN1ObjectIdentifier keyAttrId -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cms.OtherKeyAttribute getInstance(java.lang.Object) -> j
org.bouncycastle.asn1.cms.OtherRecipientInfo -> m5.o:
    org.bouncycastle.asn1.ASN1Encodable oriValue -> R2
    org.bouncycastle.asn1.ASN1ObjectIdentifier oriType -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cms.OtherRecipientInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> j
    org.bouncycastle.asn1.cms.OtherRecipientInfo getInstance(java.lang.Object) -> k
org.bouncycastle.asn1.cms.PasswordRecipientInfo -> m5.p:
    org.bouncycastle.asn1.ASN1OctetString encryptedKey -> T2
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier keyEncryptionAlgorithm -> S2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier keyDerivationAlgorithm -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1OctetString getEncryptedKey() -> j
    org.bouncycastle.asn1.cms.PasswordRecipientInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> k
    org.bouncycastle.asn1.cms.PasswordRecipientInfo getInstance(java.lang.Object) -> l
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyDerivationAlgorithm() -> m
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm() -> n
    org.bouncycastle.asn1.ASN1Integer getVersion() -> o
org.bouncycastle.asn1.cms.RecipientEncryptedKey -> m5.q:
    org.bouncycastle.asn1.ASN1OctetString encryptedKey -> R2
    org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier identifier -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1OctetString getEncryptedKey() -> j
    org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier getIdentifier() -> k
    org.bouncycastle.asn1.cms.RecipientEncryptedKey getInstance(java.lang.Object) -> l
org.bouncycastle.asn1.cms.RecipientIdentifier -> m5.r:
    org.bouncycastle.asn1.ASN1Encodable id -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1Encodable getId() -> j
    org.bouncycastle.asn1.cms.RecipientIdentifier getInstance(java.lang.Object) -> k
    boolean isTagged() -> l
org.bouncycastle.asn1.cms.RecipientInfo -> m5.s:
    org.bouncycastle.asn1.ASN1Encodable info -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1Encodable getInfo() -> j
    org.bouncycastle.asn1.cms.RecipientInfo getInstance(java.lang.Object) -> k
    org.bouncycastle.asn1.cms.KEKRecipientInfo getKEKInfo(org.bouncycastle.asn1.ASN1TaggedObject) -> l
    org.bouncycastle.asn1.ASN1Integer getVersion() -> m
org.bouncycastle.asn1.cms.RecipientKeyIdentifier -> m5.t:
    org.bouncycastle.asn1.ASN1GeneralizedTime date -> R2
    org.bouncycastle.asn1.ASN1OctetString subjectKeyIdentifier -> Q2
    org.bouncycastle.asn1.cms.OtherKeyAttribute other -> S2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cms.RecipientKeyIdentifier getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> j
    org.bouncycastle.asn1.cms.RecipientKeyIdentifier getInstance(java.lang.Object) -> k
    org.bouncycastle.asn1.ASN1OctetString getSubjectKeyIdentifier() -> l
org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers -> n5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_94 -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3411_94_with_gostR3410_94 -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_Gost28147_89_CryptoPro_A_ParamSet -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_Gost28147_89_CryptoPro_C_ParamSet -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_94_CryptoPro_D -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_94_CryptoPro_XchB -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3411_94_CryptoProParamSet -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_94_CryptoPro_B -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_2001_CryptoPro_A -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_2001_CryptoPro_C -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3411Hmac -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier gost_ElSgDH3410_1 -> D
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_Gost28147_89_CryptoPro_KeyWrap -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_2001DH -> F
    org.bouncycastle.asn1.ASN1ObjectIdentifier GOST_id -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_2001_CryptoPro_XchB -> B
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_Gost28147_89_CryptoPro_D_ParamSet -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_2001 -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_Gost28147_89_CryptoPro_TestParamSet -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_Gost28147_89_CryptoPro_B_ParamSet -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_94_CryptoPro_C -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_94_CryptoPro_XchA -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3411_94_with_gostR3410_2001 -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_94_CryptoPro_A -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_94_CryptoPro_XchC -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_2001_CryptoPro_B -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier gost_ElSgDH3410_default -> C
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_Gost28147_89_None_KeyWrap -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_2001_CryptoPro_ESDH -> E
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR28147_gcfb -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3410_2001_CryptoPro_XchA -> A
    org.bouncycastle.asn1.ASN1ObjectIdentifier gostR3411 -> b
org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey -> n5.b:
    byte[] macKey -> S2
    byte[] maskKey -> R2
    byte[] encryptedKey -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    byte[] getEncryptedKey() -> j
    org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey getInstance(java.lang.Object) -> k
    byte[] getMacKey() -> l
org.bouncycastle.asn1.cryptopro.GostR3410KeyTransport -> n5.c:
    org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey sessionEncryptedKey -> Q2
    org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters transportParameters -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.cryptopro.GostR3410KeyTransport getInstance(java.lang.Object) -> j
    org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey getSessionEncryptedKey() -> k
    org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters getTransportParameters() -> l
org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters -> n5.d:
    byte[] ukm -> S2
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo ephemeralPublicKey -> R2
    org.bouncycastle.asn1.ASN1ObjectIdentifier encryptionParamSet -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier getEncryptionParamSet() -> j
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getEphemeralPublicKey() -> k
    org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> l
    byte[] getUkm() -> m
org.bouncycastle.asn1.eac.EACObjectIdentifiers -> o5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_RSA -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_RSA_v1_5_SHA_1 -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_RSA_v1_5_SHA_256 -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_RSA_PSS_SHA_1 -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_CA_DH_3DES_CBC_CBC -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_CA_ECDH -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_CA_ECDH_3DES_CBC_CBC -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_ECDSA_SHA_1 -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_ECDSA_SHA_224 -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_ECDSA_SHA_256 -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_ECDSA_SHA_384 -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_RSA_PSS_SHA_256 -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_RSA_v1_5_SHA_512 -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_RSA_PSS_SHA_512 -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_ECDSA -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_TA_ECDSA_SHA_512 -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_EAC_ePassport -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_PK_DH -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_PK_ECDH -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_CA -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_CA_DH -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier bsi_de -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_PK -> b
org.bouncycastle.asn1.edec.EdECObjectIdentifiers -> p5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_X448 -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_Ed25519 -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_Ed448 -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_edwards_curve_algs -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_X25519 -> b
org.bouncycastle.asn1.isara.IsaraObjectIdentifiers -> q5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_xmss -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_xmssmt -> b
org.bouncycastle.asn1.kisa.KISAObjectIdentifiers -> r5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithSHA1AndSEED_CBC -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_npki_app_cmsSeed_wrap -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_mod_cms_seed -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_seedCBC -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_seedMAC -> b
org.bouncycastle.asn1.nist.NISTObjectIdentifiers -> s5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes192_GCM -> K
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_sha3_512 -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes192_CBC -> G
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_sha512_256 -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes256_GCM -> S
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_shake256_len -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes256_CBC -> O
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA3_256 -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_dsa_with_sha2 -> W
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes128_ECB -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_sha256 -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes192_ECB -> F
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_rsassa_pkcs1_v1_5_with_sha3_256 -> k0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes128_wrap -> B
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_rsassa_pkcs1_v1_5_with_sha3_512 -> m0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecdsa_with_sha3_224 -> f0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes192_CCM -> L
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_shake128 -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecdsa_with_sha3_384 -> h0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_dsa_with_sha3_224 -> b0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes192_OFB -> H
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_sha3_224 -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_dsa_with_sha3_384 -> d0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes256_CCM -> T
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_KmacWithSHAKE128 -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes256_OFB -> P
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA3_384 -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier dsa_with_sha224 -> X
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes128_CBC -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes128_GCM -> C
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_sha384 -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes192_wrap_pad -> M
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_shake256 -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes192_CFB -> I
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_sha3_256 -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes256_wrap_pad -> U
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_KmacWithSHAKE256 -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes256_CFB -> Q
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA3_512 -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier dsa_with_sha256 -> Y
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes128_OFB -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes128_CCM -> D
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_sha512 -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_rsassa_pkcs1_v1_5_with_sha3_224 -> j0
    org.bouncycastle.asn1.ASN1ObjectIdentifier nistAlgorithm -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_rsassa_pkcs1_v1_5_with_sha3_384 -> l0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_sha3_384 -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecdsa_with_sha3_256 -> g0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes256_ECB -> N
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecdsa_with_sha3_512 -> i0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_sha512_224 -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_dsa_with_sha3_256 -> c0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes192_wrap -> J
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_dsa_with_sha3_512 -> e0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_shake128_len -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier sigAlgs -> V
    org.bouncycastle.asn1.ASN1ObjectIdentifier dsa_with_sha512 -> a0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA3_224 -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes256_wrap -> R
    org.bouncycastle.asn1.ASN1ObjectIdentifier aes -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier dsa_with_sha384 -> Z
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes128_wrap_pad -> E
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_sha224 -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aes128_CFB -> A
    org.bouncycastle.asn1.ASN1ObjectIdentifier hashAlgs -> b
org.bouncycastle.asn1.ntt.NTTObjectIdentifiers -> t5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_camellia256_cbc -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_camellia128_wrap -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_camellia192_wrap -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_camellia256_wrap -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_camellia128_cbc -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_camellia192_cbc -> b
org.bouncycastle.asn1.oiw.OIWObjectIdentifiers -> u5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier sha1WithRSA -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier elGamalAlgorithm -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier desCFB -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier desEDE -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier idSHA1 -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier dsaWithSHA1 -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier md4WithRSAEncryption -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier desECB -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier desCBC -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier desOFB -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier md4WithRSA -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier md5WithRSA -> b
org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers -> v5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA224 -> F0
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_binarySigningTime -> g1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithSHAAnd40BitRC2_CBC -> K2
    org.bouncycastle.asn1.ASN1ObjectIdentifier md2 -> B0
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_signingDescription -> c1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithSHAAnd40BitRC4 -> G2
    org.bouncycastle.asn1.ASN1ObjectIdentifier secretBag -> C2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_contentIdentifier -> W1
    org.bouncycastle.asn1.ASN1ObjectIdentifier bagtypes -> x2
    org.bouncycastle.asn1.ASN1ObjectIdentifier encryptionAlgorithm -> w0
    org.bouncycastle.asn1.ASN1ObjectIdentifier md2WithRSAEncryption -> W
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_contentReference -> S1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_otherSigCert -> t2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithSHA1AndDES_CBC -> s0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa -> O1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_communityIdentifiers -> p2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithMD2AndDES_CBC -> o0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_cti_ets_proofOfDelivery -> K1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_decryptKeyID -> l2
    org.bouncycastle.asn1.ASN1ObjectIdentifier sha512_256WithRSAEncryption -> k0
    org.bouncycastle.asn1.ASN1ObjectIdentifier sha256WithRSAEncryption -> f0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_cti_ets_proofOfReceipt -> J1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_archiveTimestamp -> k2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_RSAES_OAEP -> b0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_hkdf_with_sha384 -> F1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_certValues -> g2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_rsa_KEM -> B1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_otherSigCert -> c2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_challengePassword -> Z0
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_contentType -> V0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ct_compressedData -> w1
    org.bouncycastle.asn1.ASN1ObjectIdentifier encryptedData -> R0
    org.bouncycastle.asn1.ASN1ObjectIdentifier sMIMECapabilitiesVersions -> s1
    org.bouncycastle.asn1.ASN1ObjectIdentifier md4WithRSAEncryption -> X
    org.bouncycastle.asn1.ASN1ObjectIdentifier signedData -> N0
    org.bouncycastle.asn1.ASN1ObjectIdentifier x509Crl -> o1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA512_224 -> J0
    org.bouncycastle.asn1.ASN1ObjectIdentifier certTypes -> k1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_ESDH -> O2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithSHAAnd3_KeyTripleDES_CBC -> H2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA256 -> G0
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_friendlyName -> h1
    org.bouncycastle.asn1.ASN1ObjectIdentifier safeContentsBag -> D2
    org.bouncycastle.asn1.ASN1ObjectIdentifier md4 -> C0
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_extensionRequest -> d1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_1 -> U
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_signatureTimeStampToken -> X1
    org.bouncycastle.asn1.ASN1ObjectIdentifier keyBag -> y2
    org.bouncycastle.asn1.ASN1ObjectIdentifier des_EDE3_CBC -> x0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_encrypKeyPref -> T1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_spq_ets_uri -> u2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithSHA1AndRC2_CBC -> t0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_receiptRequest -> P1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_sigPolicyId -> q2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithMD2AndRC2_CBC -> p0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_cti_ets_proofOfSender -> L1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_implCryptoAlgs -> m2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_3 -> l0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_hkdf_with_sha512 -> G1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_revocationValues -> h2
    org.bouncycastle.asn1.ASN1ObjectIdentifier sha384WithRSAEncryption -> g0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_hss_lms_hashsig -> C1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_contentTimestamp -> d2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_mgf1 -> c0
    org.bouncycastle.asn1.ASN1ObjectIdentifier rsaEncryption -> V
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_messageDigest -> W0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ct_authEnvelopedData -> x1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9 -> S0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ct -> t1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_SSDH -> P2
    org.bouncycastle.asn1.ASN1ObjectIdentifier envelopedData -> O0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_cmsAlgorithmProtect -> p1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbewithSHAAnd40BitRC2_CBC -> L2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA512_256 -> K0
    org.bouncycastle.asn1.ASN1ObjectIdentifier x509Certificate -> l1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithSHAAnd2_KeyTripleDES_CBC -> I2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA384 -> H0
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_localKeyId -> i1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_12PbeIds -> E2
    org.bouncycastle.asn1.ASN1ObjectIdentifier md5 -> D0
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_smimeCapabilities -> e1
    org.bouncycastle.asn1.ASN1ObjectIdentifier certBag -> A2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_unstructuredAddress -> a1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_sigPolicyId -> Y1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs8ShroudedKeyBag -> z2
    org.bouncycastle.asn1.ASN1ObjectIdentifier RC2_CBC -> y0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_signingCertificate -> U1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_spq_ets_unotice -> v2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_PBES2 -> u0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_contentHint -> Q1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_commitmentType -> r2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithMD5AndDES_CBC -> q0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_cti_ets_proofOfApproval -> M1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_asymmDecryptKeyID -> n2
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhKeyAgreement -> m0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_cti -> H1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_escTimeStamp -> i2
    org.bouncycastle.asn1.ASN1ObjectIdentifier sha512WithRSAEncryption -> h0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_AEADChaCha20Poly1305 -> D1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_certificateRefs -> e2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_pSpecified -> d0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_signerLocation -> a2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_signingTime -> X0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ct_timestampedData -> y1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_emailAddress -> T0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ct_authData -> u1
    org.bouncycastle.asn1.ASN1ObjectIdentifier signedAndEnvelopedData -> P0
    org.bouncycastle.asn1.ASN1ObjectIdentifier preferSignedData -> q1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_CMS3DESwrap -> M2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_7 -> L0
    org.bouncycastle.asn1.ASN1ObjectIdentifier sdsiCertificate -> m1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithSHAAnd128BitRC2_CBC -> J2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA512 -> I0
    org.bouncycastle.asn1.ASN1ObjectIdentifier x509certType -> j1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithSHAAnd128BitRC4 -> F2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_hmacWithSHA1 -> E0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_smime -> f1
    org.bouncycastle.asn1.ASN1ObjectIdentifier crlBag -> B2
    org.bouncycastle.asn1.ASN1ObjectIdentifier digestAlgorithm -> A0
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_extendedCertificateAttributes -> b1
    org.bouncycastle.asn1.ASN1ObjectIdentifier rc4 -> z0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_PBKDF2 -> v0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_commitmentType -> Z1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pbeWithMD5AndRC2_CBC -> r0
    org.bouncycastle.asn1.ASN1ObjectIdentifier md5WithRSAEncryption -> Y
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_signingCertificateV2 -> V1
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_12 -> w2
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_5 -> n0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_msgSigDigest -> R1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_signerLocation -> s2
    org.bouncycastle.asn1.ASN1ObjectIdentifier sha512_224WithRSAEncryption -> j0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_cti_ets_proofOfCreation -> N1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_implCompressAlgs -> o2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_cti_ets_proofOfOrigin -> I1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_certCRLTimestamp -> j2
    org.bouncycastle.asn1.ASN1ObjectIdentifier sha224WithRSAEncryption -> i0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_hkdf_with_sha256 -> E1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_revocationRefs -> f2
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_RSASSA_PSS -> e0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_PWRI_KEK -> A1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_aa_ets_signerAttr -> b2
    org.bouncycastle.asn1.ASN1ObjectIdentifier srsaOAEPEncryptionSET -> a0
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_counterSignature -> Y0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg -> z1
    org.bouncycastle.asn1.ASN1ObjectIdentifier sha1WithRSAEncryption -> Z
    org.bouncycastle.asn1.ASN1ObjectIdentifier pkcs_9_at_unstructuredName -> U0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ct_TSTInfo -> v1
    org.bouncycastle.asn1.ASN1ObjectIdentifier digestedData -> Q0
    org.bouncycastle.asn1.ASN1ObjectIdentifier canNotDecryptAny -> r1
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_alg_CMSRC2wrap -> N2
    org.bouncycastle.asn1.ASN1ObjectIdentifier data -> M0
    org.bouncycastle.asn1.ASN1ObjectIdentifier crlTypes -> n1
org.bouncycastle.asn1.pkcs.PrivateKeyInfo -> v5.b:
    org.bouncycastle.asn1.ASN1BitString publicKey -> U2
    org.bouncycastle.asn1.ASN1OctetString privateKey -> S2
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    org.bouncycastle.asn1.ASN1Set attributes -> T2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier privateKeyAlgorithm -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1Set getAttributes() -> j
    org.bouncycastle.asn1.pkcs.PrivateKeyInfo getInstance(java.lang.Object) -> k
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getPrivateKeyAlgorithm() -> l
    org.bouncycastle.asn1.ASN1BitString getPublicKeyData() -> m
    int getVersionValue(org.bouncycastle.asn1.ASN1Integer) -> n
    org.bouncycastle.asn1.ASN1Encodable parsePrivateKey() -> o
org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers -> w5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_agreement -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_agreement_gost_3410_12_256 -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_agreement_gost_3410_12_512 -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_3410_12_256_paramSet -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_3410_12_256 -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_3410_12_512 -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_signwithdigest_gost_3410_12_256 -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_signwithdigest_gost_3410_12_512 -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_3410_12_512_paramSetC -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_28147_param_Z -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_3410_12_256_paramSetA -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_3410_12_512_paramSet -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_3410_12_512_paramSetA -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_3410_12_512_paramSetB -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_3411_12_256 -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_gost_3411_12_512 -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_hmac_gost_3411_12_256 -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26_hmac_gost_3411_12_512 -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier rosstandart -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_tc26 -> b
org.bouncycastle.asn1.sec.SECObjectIdentifiers -> x5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhSinglePass_stdDH_sha256kdf_scheme -> K
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect163r2 -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp192r1 -> G
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp112r2 -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqvSinglePass_sha256kdf_scheme -> S
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect233r1 -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhSinglePass_cofactorDH_sha256kdf_scheme -> O
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect131r2 -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqvFull_sha256kdf_scheme -> W
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp192k1 -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect163r1 -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect571r1 -> F
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp521r1 -> B
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhSinglePass_stdDH_sha384kdf_scheme -> L
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect283k1 -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp256r1 -> H
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp160r1 -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqvSinglePass_sha384kdf_scheme -> T
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp128r1 -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhSinglePass_cofactorDH_sha384kdf_scheme -> P
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect193r1 -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqvFull_sha384kdf_scheme -> X
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp224k1 -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect409k1 -> C
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect239k1 -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhSinglePass_stdDH_sha512kdf_scheme -> M
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect283r1 -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier secg_scheme -> I
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp160k1 -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqvSinglePass_sha512kdf_scheme -> U
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp128r2 -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhSinglePass_cofactorDH_sha512kdf_scheme -> Q
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect193r2 -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqvFull_sha512kdf_scheme -> Y
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp224r1 -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect409r1 -> D
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect113r1 -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier ellipticCurve -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp256k1 -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhSinglePass_cofactorDH_sha224kdf_scheme -> N
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp112r1 -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhSinglePass_stdDH_sha224kdf_scheme -> J
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect233k1 -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqvFull_sha224kdf_scheme -> V
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect131r1 -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqvSinglePass_sha224kdf_scheme -> R
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp160r2 -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect571k1 -> E
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect113r2 -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier secp384r1 -> A
    org.bouncycastle.asn1.ASN1ObjectIdentifier sect163k1 -> b
org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers -> y5.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecc_brainpool -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier versionOne -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier rsaSignatureWithripemd256 -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecSignWithSha1 -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP224t1 -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP256t1 -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP160t1 -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP192t1 -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP320t1 -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP384t1 -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier ripemd128 -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier teleTrusTRSAsignatureAlgorithm -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier teleTrusTAlgorithm -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP512t1 -> B
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecSignWithRipemd160 -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier ellipticCurve -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier rsaSignatureWithripemd128 -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecSign -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP224r1 -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP256r1 -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP160r1 -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP192r1 -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP320r1 -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP384r1 -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier ripemd256 -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier rsaSignatureWithripemd160 -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier brainpoolP512r1 -> A
    org.bouncycastle.asn1.ASN1ObjectIdentifier ripemd160 -> b
org.bouncycastle.asn1.x500.AttributeTypeAndValue -> z5.a:
    org.bouncycastle.asn1.ASN1Encodable value -> R2
    org.bouncycastle.asn1.ASN1ObjectIdentifier type -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x500.AttributeTypeAndValue getInstance(java.lang.Object) -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier getType() -> k
    org.bouncycastle.asn1.ASN1Encodable getValue() -> l
org.bouncycastle.asn1.x500.RDN -> z5.b:
    org.bouncycastle.asn1.ASN1Set values -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x500.AttributeTypeAndValue getFirst() -> j
    org.bouncycastle.asn1.x500.RDN getInstance(java.lang.Object) -> k
    org.bouncycastle.asn1.x500.AttributeTypeAndValue[] getTypesAndValues() -> l
    boolean isMultiValued() -> m
org.bouncycastle.asn1.x500.X500Name -> z5.c:
    org.bouncycastle.asn1.x500.X500NameStyle style -> S2
    org.bouncycastle.asn1.DERSequence rdnSeq -> U2
    boolean isHashCodeCalculated -> Q2
    int hashCodeValue -> R2
    org.bouncycastle.asn1.x500.X500NameStyle defaultStyle -> V2
    org.bouncycastle.asn1.x500.RDN[] rdns -> T2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x500.X500Name getInstance(java.lang.Object) -> j
    org.bouncycastle.asn1.x500.RDN[] getRDNs() -> k
org.bouncycastle.asn1.x500.X500NameStyle -> z5.d:
    boolean areEqual(org.bouncycastle.asn1.x500.X500Name,org.bouncycastle.asn1.x500.X500Name) -> a
    java.lang.String toString(org.bouncycastle.asn1.x500.X500Name) -> b
    int calculateHashCode(org.bouncycastle.asn1.x500.X500Name) -> c
org.bouncycastle.asn1.x500.style.AbstractX500NameStyle -> a6.a:
    boolean areEqual(org.bouncycastle.asn1.x500.X500Name,org.bouncycastle.asn1.x500.X500Name) -> a
    int calculateHashCode(org.bouncycastle.asn1.x500.X500Name) -> c
    int calcHashCode(org.bouncycastle.asn1.ASN1Encodable) -> d
    java.util.Hashtable copyHashTable(java.util.Hashtable) -> e
    boolean foundMatch(boolean,org.bouncycastle.asn1.x500.RDN,org.bouncycastle.asn1.x500.RDN[]) -> f
    boolean rdnAreEqual(org.bouncycastle.asn1.x500.RDN,org.bouncycastle.asn1.x500.RDN) -> g
org.bouncycastle.asn1.x500.style.BCStyle -> a6.b:
    java.util.Hashtable defaultSymbols -> b
    org.bouncycastle.asn1.ASN1ObjectIdentifier UnstructuredAddress -> K
    org.bouncycastle.asn1.ASN1ObjectIdentifier ST -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier DC -> M
    org.bouncycastle.asn1.ASN1ObjectIdentifier GIVENNAME -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier NAME -> G
    org.bouncycastle.asn1.ASN1ObjectIdentifier SN -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier EmailAddress -> I
    org.bouncycastle.asn1.ASN1ObjectIdentifier SERIALNUMBER -> j
    org.bouncycastle.asn1.x500.X500NameStyle INSTANCE -> Q
    org.bouncycastle.asn1.ASN1ObjectIdentifier POSTAL_CODE -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier PSEUDONYM -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier GENERATION -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier DESCRIPTION -> r
    java.util.Hashtable DefaultSymbols -> O
    org.bouncycastle.asn1.ASN1ObjectIdentifier DATE_OF_BIRTH -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier GENDER -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier C -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier POSTAL_ADDRESS -> D
    org.bouncycastle.asn1.ASN1ObjectIdentifier OU -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier TELEPHONE_NUMBER -> F
    org.bouncycastle.asn1.ASN1ObjectIdentifier COUNTRY_OF_RESIDENCE -> B
    org.bouncycastle.asn1.ASN1ObjectIdentifier L -> k
    java.util.Hashtable defaultLookUp -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier E -> L
    org.bouncycastle.asn1.ASN1ObjectIdentifier SURNAME -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier UID -> N
    org.bouncycastle.asn1.ASN1ObjectIdentifier CN -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier ORGANIZATION_IDENTIFIER -> H
    org.bouncycastle.asn1.ASN1ObjectIdentifier STREET -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier UnstructuredName -> J
    org.bouncycastle.asn1.ASN1ObjectIdentifier BUSINESS_CATEGORY -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier DN_QUALIFIER -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier INITIALS -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier UNIQUE_IDENTIFIER -> q
    java.util.Hashtable DefaultLookUp -> P
    org.bouncycastle.asn1.ASN1ObjectIdentifier ROLE -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier PLACE_OF_BIRTH -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier NAME_AT_BIRTH -> C
    org.bouncycastle.asn1.ASN1ObjectIdentifier O -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier DMD_NAME -> E
    org.bouncycastle.asn1.ASN1ObjectIdentifier T -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier COUNTRY_OF_CITIZENSHIP -> A
    java.lang.String toString(org.bouncycastle.asn1.x500.X500Name) -> b
org.bouncycastle.asn1.x500.style.IETFUtils -> a6.c:
    void appendRDN(java.lang.StringBuffer,org.bouncycastle.asn1.x500.RDN,java.util.Hashtable) -> a
    void appendTypeAndValue(java.lang.StringBuffer,org.bouncycastle.asn1.x500.AttributeTypeAndValue,java.util.Hashtable) -> b
    boolean atvAreEqual(org.bouncycastle.asn1.x500.AttributeTypeAndValue,org.bouncycastle.asn1.x500.AttributeTypeAndValue) -> c
    java.lang.String canonicalString(org.bouncycastle.asn1.ASN1Encodable) -> d
    java.lang.String canonicalize(java.lang.String) -> e
    org.bouncycastle.asn1.ASN1Primitive decodeObject(java.lang.String) -> f
    boolean rDNAreEqual(org.bouncycastle.asn1.x500.RDN,org.bouncycastle.asn1.x500.RDN) -> g
    java.lang.String stripInternalSpaces(java.lang.String) -> h
    java.lang.String valueToString(org.bouncycastle.asn1.ASN1Encodable) -> i
org.bouncycastle.asn1.x509.AlgorithmIdentifier -> b6.a:
    org.bouncycastle.asn1.ASN1Encodable parameters -> R2
    org.bouncycastle.asn1.ASN1ObjectIdentifier algorithm -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier getAlgorithm() -> j
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> k
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getInstance(java.lang.Object) -> l
    org.bouncycastle.asn1.ASN1Encodable getParameters() -> m
org.bouncycastle.asn1.x509.Certificate -> b6.b:
    org.bouncycastle.asn1.ASN1Sequence seq -> Q2
    org.bouncycastle.asn1.ASN1BitString sig -> T2
    org.bouncycastle.asn1.x509.TBSCertificate tbsCert -> R2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId -> S2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.Certificate getInstance(java.lang.Object) -> j
    org.bouncycastle.asn1.x500.X500Name getIssuer() -> k
    org.bouncycastle.asn1.ASN1Integer getSerialNumber() -> l
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo() -> m
    org.bouncycastle.asn1.x509.TBSCertificate getTBSCertificate() -> n
org.bouncycastle.asn1.x509.Extension -> b6.c:
    org.bouncycastle.asn1.ASN1ObjectIdentifier cRLDistributionPoints -> i3
    org.bouncycastle.asn1.ASN1ObjectIdentifier certificatePolicies -> j3
    org.bouncycastle.asn1.ASN1ObjectIdentifier policyMappings -> k3
    org.bouncycastle.asn1.ASN1ObjectIdentifier authorityKeyIdentifier -> l3
    org.bouncycastle.asn1.ASN1ObjectIdentifier deltaCRLIndicator -> e3
    org.bouncycastle.asn1.ASN1ObjectIdentifier issuingDistributionPoint -> f3
    org.bouncycastle.asn1.ASN1ObjectIdentifier certificateIssuer -> g3
    org.bouncycastle.asn1.ASN1ObjectIdentifier nameConstraints -> h3
    org.bouncycastle.asn1.ASN1ObjectIdentifier cRLNumber -> a3
    org.bouncycastle.asn1.ASN1ObjectIdentifier reasonCode -> b3
    org.bouncycastle.asn1.ASN1ObjectIdentifier instructionCode -> c3
    org.bouncycastle.asn1.ASN1ObjectIdentifier invalidityDate -> d3
    boolean critical -> R2
    org.bouncycastle.asn1.ASN1ObjectIdentifier subjectAlternativeName -> X2
    org.bouncycastle.asn1.ASN1ObjectIdentifier expiredCertsOnCRL -> y3
    org.bouncycastle.asn1.ASN1ObjectIdentifier issuerAlternativeName -> Y2
    org.bouncycastle.asn1.ASN1ObjectIdentifier basicConstraints -> Z2
    org.bouncycastle.asn1.ASN1ObjectIdentifier subjectDirectoryAttributes -> T2
    org.bouncycastle.asn1.ASN1ObjectIdentifier qCStatements -> u3
    org.bouncycastle.asn1.ASN1ObjectIdentifier subjectKeyIdentifier -> U2
    org.bouncycastle.asn1.ASN1ObjectIdentifier auditIdentity -> v3
    org.bouncycastle.asn1.ASN1ObjectIdentifier keyUsage -> V2
    org.bouncycastle.asn1.ASN1ObjectIdentifier noRevAvail -> w3
    org.bouncycastle.asn1.ASN1OctetString value -> S2
    org.bouncycastle.asn1.ASN1ObjectIdentifier privateKeyUsagePeriod -> W2
    org.bouncycastle.asn1.ASN1ObjectIdentifier targetInformation -> x3
    org.bouncycastle.asn1.ASN1ObjectIdentifier authorityInfoAccess -> q3
    org.bouncycastle.asn1.ASN1ObjectIdentifier extnId -> Q2
    org.bouncycastle.asn1.ASN1ObjectIdentifier subjectInfoAccess -> r3
    org.bouncycastle.asn1.ASN1ObjectIdentifier logoType -> s3
    org.bouncycastle.asn1.ASN1ObjectIdentifier biometricInfo -> t3
    org.bouncycastle.asn1.ASN1ObjectIdentifier policyConstraints -> m3
    org.bouncycastle.asn1.ASN1ObjectIdentifier extendedKeyUsage -> n3
    org.bouncycastle.asn1.ASN1ObjectIdentifier freshestCRL -> o3
    org.bouncycastle.asn1.ASN1ObjectIdentifier inhibitAnyPolicy -> p3
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.ASN1Primitive convertValueToObject(org.bouncycastle.asn1.x509.Extension) -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier getExtnId() -> k
    org.bouncycastle.asn1.ASN1OctetString getExtnValue() -> l
    org.bouncycastle.asn1.x509.Extension getInstance(java.lang.Object) -> m
    org.bouncycastle.asn1.ASN1Encodable getParsedValue() -> n
    boolean isCritical() -> o
org.bouncycastle.asn1.x509.Extensions -> b6.d:
    java.util.Hashtable extensions -> Q2
    java.util.Vector ordering -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.Extension getExtension(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> j
    org.bouncycastle.asn1.x509.Extensions getInstance(java.lang.Object) -> k
org.bouncycastle.asn1.x509.SubjectKeyIdentifier -> b6.e:
    byte[] keyidentifier -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.SubjectKeyIdentifier getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> j
    org.bouncycastle.asn1.x509.SubjectKeyIdentifier getInstance(java.lang.Object) -> k
    byte[] getKeyIdentifier() -> l
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo -> b6.f:
    org.bouncycastle.asn1.ASN1BitString keyData -> R2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier algId -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithm() -> j
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject,boolean) -> k
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getInstance(java.lang.Object) -> l
    org.bouncycastle.asn1.ASN1BitString getPublicKeyData() -> m
    org.bouncycastle.asn1.ASN1Primitive parsePublicKey() -> n
org.bouncycastle.asn1.x509.TBSCertificate -> b6.g:
    org.bouncycastle.asn1.ASN1Sequence seq -> Q2
    org.bouncycastle.asn1.x509.Time endDate -> W2
    org.bouncycastle.asn1.x500.X500Name subject -> X2
    org.bouncycastle.asn1.x509.Time startDate -> V2
    org.bouncycastle.asn1.ASN1Integer serialNumber -> S2
    org.bouncycastle.asn1.ASN1Integer version -> R2
    org.bouncycastle.asn1.x500.X500Name issuer -> U2
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo subjectPublicKeyInfo -> Y2
    org.bouncycastle.asn1.ASN1BitString issuerUniqueId -> Z2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier signature -> T2
    org.bouncycastle.asn1.ASN1BitString subjectUniqueId -> a3
    org.bouncycastle.asn1.x509.Extensions extensions -> b3
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.Extensions getExtensions() -> j
    org.bouncycastle.asn1.x509.TBSCertificate getInstance(java.lang.Object) -> k
    org.bouncycastle.asn1.x500.X500Name getIssuer() -> l
    org.bouncycastle.asn1.ASN1Integer getSerialNumber() -> m
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo() -> n
org.bouncycastle.asn1.x509.TBSCertificateStructure -> b6.h:
    org.bouncycastle.asn1.ASN1Sequence seq -> Q2
    org.bouncycastle.asn1.x509.Time endDate -> W2
    org.bouncycastle.asn1.x500.X500Name subject -> X2
    org.bouncycastle.asn1.x509.Time startDate -> V2
    org.bouncycastle.asn1.ASN1Integer serialNumber -> S2
    org.bouncycastle.asn1.ASN1Integer version -> R2
    org.bouncycastle.asn1.x500.X500Name issuer -> U2
    org.bouncycastle.asn1.x509.X509Extensions extensions -> b3
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo subjectPublicKeyInfo -> Y2
    org.bouncycastle.asn1.ASN1BitString issuerUniqueId -> Z2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier signature -> T2
    org.bouncycastle.asn1.ASN1BitString subjectUniqueId -> a3
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.TBSCertificateStructure getInstance(java.lang.Object) -> j
    org.bouncycastle.asn1.x500.X500Name getIssuer() -> k
    org.bouncycastle.asn1.ASN1Integer getSerialNumber() -> l
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo() -> m
org.bouncycastle.asn1.x509.Time -> b6.i:
    org.bouncycastle.asn1.ASN1Primitive time -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.Time getInstance(java.lang.Object) -> j
    java.lang.String getTime() -> k
org.bouncycastle.asn1.x509.X509Extension -> b6.j:
    org.bouncycastle.asn1.ASN1ObjectIdentifier instructionCode -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier deltaCRLIndicator -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier targetInformation -> G
    org.bouncycastle.asn1.ASN1ObjectIdentifier issuerAlternativeName -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier cRLNumber -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier policyMappings -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier policyConstraints -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier certificateIssuer -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier cRLDistributionPoints -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier freshestCRL -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier authorityInfoAccess -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier subjectDirectoryAttributes -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier qCStatements -> D
    org.bouncycastle.asn1.ASN1ObjectIdentifier keyUsage -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier noRevAvail -> F
    org.bouncycastle.asn1.ASN1ObjectIdentifier logoType -> B
    org.bouncycastle.asn1.ASN1ObjectIdentifier reasonCode -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier invalidityDate -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier subjectAlternativeName -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier basicConstraints -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier certificatePolicies -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier authorityKeyIdentifier -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier issuingDistributionPoint -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier nameConstraints -> q
    org.bouncycastle.asn1.ASN1OctetString value -> b
    org.bouncycastle.asn1.ASN1ObjectIdentifier extendedKeyUsage -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier inhibitAnyPolicy -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier biometricInfo -> C
    org.bouncycastle.asn1.ASN1ObjectIdentifier subjectKeyIdentifier -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier auditIdentity -> E
    org.bouncycastle.asn1.ASN1ObjectIdentifier privateKeyUsagePeriod -> f
    boolean critical -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier subjectInfoAccess -> A
    org.bouncycastle.asn1.ASN1OctetString getValue() -> a
    boolean isCritical() -> b
org.bouncycastle.asn1.x509.X509Extensions -> b6.k:
    java.util.Hashtable extensions -> Q2
    org.bouncycastle.asn1.ASN1ObjectIdentifier CertificatePolicies -> i3
    org.bouncycastle.asn1.ASN1ObjectIdentifier PolicyMappings -> j3
    org.bouncycastle.asn1.ASN1ObjectIdentifier AuthorityKeyIdentifier -> k3
    org.bouncycastle.asn1.ASN1ObjectIdentifier PolicyConstraints -> l3
    org.bouncycastle.asn1.ASN1ObjectIdentifier IssuingDistributionPoint -> e3
    org.bouncycastle.asn1.ASN1ObjectIdentifier CertificateIssuer -> f3
    org.bouncycastle.asn1.ASN1ObjectIdentifier NameConstraints -> g3
    org.bouncycastle.asn1.ASN1ObjectIdentifier CRLDistributionPoints -> h3
    org.bouncycastle.asn1.ASN1ObjectIdentifier ReasonCode -> a3
    org.bouncycastle.asn1.ASN1ObjectIdentifier InstructionCode -> b3
    org.bouncycastle.asn1.ASN1ObjectIdentifier InvalidityDate -> c3
    org.bouncycastle.asn1.ASN1ObjectIdentifier DeltaCRLIndicator -> d3
    org.bouncycastle.asn1.ASN1ObjectIdentifier IssuerAlternativeName -> X2
    org.bouncycastle.asn1.ASN1ObjectIdentifier BasicConstraints -> Y2
    java.util.Vector ordering -> R2
    org.bouncycastle.asn1.ASN1ObjectIdentifier CRLNumber -> Z2
    org.bouncycastle.asn1.ASN1ObjectIdentifier SubjectKeyIdentifier -> T2
    org.bouncycastle.asn1.ASN1ObjectIdentifier AuditIdentity -> u3
    org.bouncycastle.asn1.ASN1ObjectIdentifier KeyUsage -> U2
    org.bouncycastle.asn1.ASN1ObjectIdentifier NoRevAvail -> v3
    org.bouncycastle.asn1.ASN1ObjectIdentifier PrivateKeyUsagePeriod -> V2
    org.bouncycastle.asn1.ASN1ObjectIdentifier TargetInformation -> w3
    org.bouncycastle.asn1.ASN1ObjectIdentifier SubjectAlternativeName -> W2
    org.bouncycastle.asn1.ASN1ObjectIdentifier SubjectInfoAccess -> q3
    org.bouncycastle.asn1.ASN1ObjectIdentifier LogoType -> r3
    org.bouncycastle.asn1.ASN1ObjectIdentifier BiometricInfo -> s3
    org.bouncycastle.asn1.ASN1ObjectIdentifier SubjectDirectoryAttributes -> S2
    org.bouncycastle.asn1.ASN1ObjectIdentifier QCStatements -> t3
    org.bouncycastle.asn1.ASN1ObjectIdentifier ExtendedKeyUsage -> m3
    org.bouncycastle.asn1.ASN1ObjectIdentifier FreshestCRL -> n3
    org.bouncycastle.asn1.ASN1ObjectIdentifier InhibitAnyPolicy -> o3
    org.bouncycastle.asn1.ASN1ObjectIdentifier AuthorityInfoAccess -> p3
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.X509Extensions getInstance(java.lang.Object) -> j
org.bouncycastle.asn1.x509.X509ObjectIdentifiers -> b6.l:
    org.bouncycastle.asn1.ASN1ObjectIdentifier ripemd160WithRSAEncryption -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_pkix -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_at_name -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_SHA1 -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ce -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ad_caIssuers -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_rsassa_pss_shake256 -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecdsa_with_shake256 -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier ocspAccessMethod -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier localityName -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier organization -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier commonName -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier ripemd160 -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ea_rsa -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_at_telephoneNumber -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_at_organizationIdentifier -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_pe -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ad -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_rsassa_pss_shake128 -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecdsa_with_shake128 -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ad_ocsp -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier crlAccessMethod -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier stateOrProvinceName -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier organizationalUnitName -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier countryName -> b
org.bouncycastle.asn1.x9.X9ObjectIdentifiers -> c6.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2pnb368w1 -> K
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_with_SHA2 -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2onb239v5 -> G
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecSigType -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier prime239v3 -> S
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2pnb163v2 -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier prime192v2 -> O
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_with_SHA512 -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier x9_63_scheme -> W
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2tnb191v2 -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier prime_field -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_kdf_kdf3 -> o0
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2onb239v4 -> F
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqv1 -> k0
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2pnb208w1 -> B
    org.bouncycastle.asn1.ASN1ObjectIdentifier x9_44_components -> m0
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhOneFlow -> f0
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2tnb431r1 -> L
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_with_SHA224 -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhHybrid2 -> h0
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhpublicnumber -> b0
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2pnb272w1 -> H
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_with_SHA1 -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhStatic -> d0
    org.bouncycastle.asn1.ASN1ObjectIdentifier prime256v1 -> T
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2pnb163v3 -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier prime192v3 -> P
    org.bouncycastle.asn1.ASN1ObjectIdentifier ellipticCurve -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhSinglePass_stdDH_sha1kdf_scheme -> X
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2tnb191v3 -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2tnb239v1 -> C
    org.bouncycastle.asn1.ASN1ObjectIdentifier characteristic_two_field -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier primeCurve -> M
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_with_SHA256 -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2pnb304w1 -> I
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_publicKeyType -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_dsa -> U
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2pnb176w1 -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier prime239v1 -> Q
    org.bouncycastle.asn1.ASN1ObjectIdentifier cTwoCurve -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhSinglePass_cofactorDH_sha1kdf_scheme -> Y
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2onb191v4 -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_kdf_kdf2 -> n0
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2tnb239v2 -> D
    org.bouncycastle.asn1.ASN1ObjectIdentifier gnBasis -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqv2 -> j0
    org.bouncycastle.asn1.ASN1ObjectIdentifier ansi_X9_62 -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier x9_44 -> l0
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_ecPublicKey -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhHybrid1 -> g0
    org.bouncycastle.asn1.ASN1ObjectIdentifier prime192v1 -> N
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhHybridOneFlow -> i0
    org.bouncycastle.asn1.ASN1ObjectIdentifier ppBasis -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier x9_42_schemes -> c0
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2tnb359v1 -> J
    org.bouncycastle.asn1.ASN1ObjectIdentifier dhEphem -> e0
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2pnb163v1 -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_dsa_with_sha1 -> V
    org.bouncycastle.asn1.ASN1ObjectIdentifier ansi_X9_42 -> a0
    org.bouncycastle.asn1.ASN1ObjectIdentifier ecdsa_with_SHA384 -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier prime239v2 -> R
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2tnb191v1 -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier mqvSinglePass_sha1kdf_scheme -> Z
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2tnb239v3 -> E
    org.bouncycastle.asn1.ASN1ObjectIdentifier tpBasis -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier c2onb191v5 -> A
    org.bouncycastle.asn1.ASN1ObjectIdentifier id_fieldType -> b
org.bouncycastle.cert.CertIOException -> d6.a:
    java.lang.Throwable cause -> Q2
org.bouncycastle.cert.CertUtils -> d6.b:
    java.util.List EMPTY_LIST -> b
    java.util.Set EMPTY_SET -> a
    org.bouncycastle.asn1.ASN1Primitive parseNonEmptyASN1(byte[]) -> a
org.bouncycastle.cert.X509CertificateHolder -> d6.c:
    org.bouncycastle.asn1.x509.Certificate x509Certificate -> Q2
    org.bouncycastle.asn1.x509.Extensions extensions -> R2
    org.bouncycastle.asn1.x509.Extension getExtension(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> a
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo() -> b
    void init(org.bouncycastle.asn1.x509.Certificate) -> c
    org.bouncycastle.asn1.x509.Certificate parseBytes(byte[]) -> d
    org.bouncycastle.asn1.x509.Certificate toASN1Structure() -> e
org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator -> e6.a:
    byte[] calculateKeyId(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> a
org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest -> e6.a$a:
    byte[] xBuf -> a
    long byteCount -> c
    int xBufOff -> b
    void finish() -> a
    void processBlock() -> b
    void processLength(long) -> c
    void processWord(byte[],int) -> d
    void reset() -> e
    void update(byte) -> f
    void update(byte[],int,int) -> g
org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest -> e6.a$b:
    int[] X -> i
    int xOff -> j
    int H5 -> h
    int H3 -> f
    int H4 -> g
    int H1 -> d
    int H2 -> e
    void processBlock() -> b
    void processLength(long) -> c
    void processWord(byte[],int) -> d
    void reset() -> e
    int doFinal(byte[],int) -> h
    int f(int,int,int) -> i
    int g(int,int,int) -> j
    int getDigestSize() -> k
    int h(int,int,int) -> l
org.bouncycastle.cert.selector.X509CertificateHolderSelector -> e6.b:
    byte[] subjectKeyId -> Q2
    org.bouncycastle.asn1.x500.X500Name issuer -> R2
    java.math.BigInteger serialNumber -> S2
    boolean match(java.lang.Object) -> S
    boolean equalsObj(java.lang.Object,java.lang.Object) -> a
    org.bouncycastle.asn1.x500.X500Name getIssuer() -> b
    java.math.BigInteger getSerialNumber() -> c
    byte[] getSubjectKeyIdentifier() -> d
org.bouncycastle.cms.AuthAttributesProvider -> f6.a:
    boolean isAead() -> a
    org.bouncycastle.asn1.ASN1Set getAuthAttributes() -> b
org.bouncycastle.cms.CMSAlgorithm -> f6.b:
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECCDH_SHA256KDF -> K
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES128_GCM -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECDH_SHA224KDF -> G
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES256_CBC -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECDHGOST3410_2001 -> S
    org.bouncycastle.asn1.ASN1ObjectIdentifier DES_EDE3_WRAP -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECMQV_SHA384KDF -> O
    org.bouncycastle.asn1.ASN1ObjectIdentifier CAMELLIA192_CBC -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECKA_EG_X963KDF_SHA256 -> W
    org.bouncycastle.asn1.ASN1ObjectIdentifier CAMELLIA128_WRAP -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier RC2_CBC -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECMQV_SHA1KDF -> F
    org.bouncycastle.asn1.ASN1ObjectIdentifier RIPEMD256 -> k0
    org.bouncycastle.asn1.ASN1ObjectIdentifier GOST28147_WRAP -> B
    org.bouncycastle.asn1.ASN1ObjectIdentifier GOST3411 -> f0
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECMQV_SHA256KDF -> L
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES192_GCM -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier GOST3411_2012_512 -> h0
    org.bouncycastle.asn1.ASN1ObjectIdentifier SHA256 -> b0
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECCDH_SHA224KDF -> H
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES128_CCM -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier SHA512 -> d0
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECDHGOST3410_2012_256 -> T
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES128_WRAP -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECDH_SHA512KDF -> P
    org.bouncycastle.asn1.ASN1ObjectIdentifier CAMELLIA256_CBC -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECKA_EG_X963KDF_SHA384 -> X
    org.bouncycastle.asn1.ASN1ObjectIdentifier CAMELLIA192_WRAP -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier GOST28147_CRYPTOPRO_WRAP -> C
    org.bouncycastle.asn1.ASN1ObjectIdentifier IDEA_CBC -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECDH_SHA384KDF -> M
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES256_GCM -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECMQV_SHA224KDF -> I
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES192_CCM -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECDHGOST3410_2012_512 -> U
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES192_WRAP -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECCDH_SHA512KDF -> Q
    org.bouncycastle.asn1.ASN1ObjectIdentifier GOST28147_GCFB -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECKA_EG_X963KDF_SHA512 -> Y
    org.bouncycastle.asn1.ASN1ObjectIdentifier CAMELLIA256_WRAP -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECDH_SHA1KDF -> D
    org.bouncycastle.asn1.ASN1ObjectIdentifier CAST5_CBC -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier RIPEMD160 -> j0
    org.bouncycastle.asn1.ASN1ObjectIdentifier DES_CBC -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES256_CCM -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier GOST3411_2012_256 -> g0
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECCDH_SHA384KDF -> N
    org.bouncycastle.asn1.ASN1ObjectIdentifier RIPEMD128 -> i0
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES192_CBC -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier SHA384 -> c0
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECDH_SHA256KDF -> J
    org.bouncycastle.asn1.ASN1ObjectIdentifier MD5 -> e0
    org.bouncycastle.asn1.ASN1ObjectIdentifier SEED_CBC -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECKA_EG_X963KDF -> V
    org.bouncycastle.asn1.ASN1ObjectIdentifier SHA224 -> a0
    org.bouncycastle.asn1.ASN1ObjectIdentifier CAMELLIA128_CBC -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECMQV_SHA512KDF -> R
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES256_WRAP -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier SHA1 -> Z
    org.bouncycastle.asn1.ASN1ObjectIdentifier ECCDH_SHA1KDF -> E
    org.bouncycastle.asn1.ASN1ObjectIdentifier AES128_CBC -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier SEED_WRAP -> A
    org.bouncycastle.asn1.ASN1ObjectIdentifier DES_EDE3_CBC -> b
org.bouncycastle.cms.CMSEnvelopedData -> f6.c:
    org.bouncycastle.cms.OriginatorInformation originatorInfo -> U2
    org.bouncycastle.asn1.cms.ContentInfo contentInfo -> R2
    org.bouncycastle.cms.RecipientInformationStore recipientInfoStore -> Q2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier encAlg -> S2
    org.bouncycastle.asn1.ASN1Set unprotectedAttributes -> T2
    org.bouncycastle.cms.RecipientInformationStore getRecipientInfos() -> a
org.bouncycastle.cms.CMSEnvelopedGenerator -> f6.d:
    java.lang.String CAMELLIA192_CBC -> g
    java.lang.String CAMELLIA128_CBC -> f
    java.lang.String SEED_CBC -> i
    java.lang.String CAMELLIA256_CBC -> h
    java.lang.String AES128_WRAP -> k
    java.lang.String DES_EDE3_WRAP -> j
    java.lang.String AES256_WRAP -> m
    java.lang.String AES192_WRAP -> l
    java.lang.String CAMELLIA192_WRAP -> o
    java.lang.String CAMELLIA128_WRAP -> n
    java.lang.String SEED_WRAP -> q
    java.lang.String CAMELLIA256_WRAP -> p
    java.lang.String ECMQV_SHA1KDF -> s
    java.lang.String ECDH_SHA1KDF -> r
    java.lang.String DES_EDE3_CBC -> a
    java.lang.String AES128_CBC -> c
    java.lang.String RC2_CBC -> b
    java.lang.String AES256_CBC -> e
    java.lang.String AES192_CBC -> d
org.bouncycastle.cms.CMSEnvelopedHelper -> f6.e:
    org.bouncycastle.cms.RecipientInformationStore buildRecipientInformationStore(org.bouncycastle.asn1.ASN1Set,org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.cms.CMSSecureReadable) -> a
    org.bouncycastle.cms.RecipientInformationStore buildRecipientInformationStore(org.bouncycastle.asn1.ASN1Set,org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.cms.CMSSecureReadable,org.bouncycastle.cms.AuthAttributesProvider) -> b
    void readRecipientInfo(java.util.List,org.bouncycastle.asn1.cms.RecipientInfo,org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.cms.CMSSecureReadable,org.bouncycastle.cms.AuthAttributesProvider) -> c
org.bouncycastle.cms.CMSEnvelopedHelper$CMSEnvelopedSecureReadable -> f6.e$a:
    org.bouncycastle.cms.CMSReadable readable -> c
    org.bouncycastle.asn1.x509.AlgorithmIdentifier algorithm -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier contentType -> b
    java.io.InputStream getInputStream() -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier getContentType() -> b
org.bouncycastle.cms.CMSException -> f6.f:
    java.lang.Exception e -> Q2
org.bouncycastle.cms.CMSProcessableByteArray -> f6.g:
    byte[] bytes -> b
    org.bouncycastle.asn1.ASN1ObjectIdentifier type -> a
    java.io.InputStream getInputStream() -> a
org.bouncycastle.cms.CMSReadable -> f6.h:
    java.io.InputStream getInputStream() -> a
org.bouncycastle.cms.CMSSecureReadable -> f6.i:
    java.io.InputStream getInputStream() -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier getContentType() -> b
org.bouncycastle.cms.CMSTypedStream -> f6.j:
    java.io.InputStream _in -> b
    org.bouncycastle.asn1.ASN1ObjectIdentifier _oid -> a
    java.io.InputStream getContentStream() -> a
org.bouncycastle.cms.CMSTypedStream$FullReaderStream -> f6.j$a:
org.bouncycastle.cms.CMSUtils -> f6.k:
    java.util.Set ecAlgs -> c
    java.util.Set gostAlgs -> d
    java.util.Set des -> a
    java.util.Set mqvAlgs -> b
    org.bouncycastle.asn1.cms.ContentInfo readContentInfo(org.bouncycastle.asn1.ASN1InputStream) -> a
    org.bouncycastle.asn1.cms.ContentInfo readContentInfo(byte[]) -> b
    byte[] streamToByteArray(java.io.InputStream) -> c
org.bouncycastle.cms.KEKRecipient -> f6.l:
    org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.asn1.x509.AlgorithmIdentifier,byte[]) -> a
org.bouncycastle.cms.KEKRecipientId -> f6.m:
    byte[] keyIdentifier -> R2
    boolean match(java.lang.Object) -> S
org.bouncycastle.cms.KEKRecipientInformation -> f6.n:
    org.bouncycastle.asn1.cms.KEKRecipientInfo info -> g
    org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.cms.Recipient) -> d
org.bouncycastle.cms.KeyAgreeRecipient -> f6.o:
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getPrivateKeyAlgorithmIdentifier() -> d
    org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.asn1.x509.SubjectPublicKeyInfo,org.bouncycastle.asn1.ASN1OctetString,byte[]) -> e
org.bouncycastle.cms.KeyAgreeRecipientId -> f6.p:
    org.bouncycastle.cert.selector.X509CertificateHolderSelector baseSelector -> R2
    boolean match(java.lang.Object) -> S
org.bouncycastle.cms.KeyAgreeRecipientInformation -> f6.q:
    org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo info -> g
    org.bouncycastle.asn1.ASN1OctetString encryptedKey -> h
    org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.cms.Recipient) -> d
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getPublicKeyInfoFromOriginatorId(org.bouncycastle.cms.OriginatorId) -> e
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getPublicKeyInfoFromOriginatorPublicKey(org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.asn1.cms.OriginatorPublicKey) -> f
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSenderPublicKeyInfo(org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey) -> g
    void readRecipientInfo(java.util.List,org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo,org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.cms.CMSSecureReadable,org.bouncycastle.cms.AuthAttributesProvider) -> h
org.bouncycastle.cms.KeyTransRecipient -> f6.r:
    org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.asn1.x509.AlgorithmIdentifier,byte[]) -> a
org.bouncycastle.cms.KeyTransRecipientId -> f6.s:
    org.bouncycastle.cert.selector.X509CertificateHolderSelector baseSelector -> R2
    boolean match(java.lang.Object) -> S
    org.bouncycastle.asn1.x500.X500Name getIssuer() -> a
    java.math.BigInteger getSerialNumber() -> b
    byte[] getSubjectKeyIdentifier() -> c
org.bouncycastle.cms.KeyTransRecipientInformation -> f6.t:
    org.bouncycastle.asn1.cms.KeyTransRecipientInfo info -> g
    org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.cms.Recipient) -> d
org.bouncycastle.cms.OriginatorId -> f6.u:
    byte[] subjectKeyId -> Q2
    org.bouncycastle.asn1.x500.X500Name issuer -> R2
    java.math.BigInteger serialNumber -> S2
    boolean equalsObj(java.lang.Object,java.lang.Object) -> a
    void setIssuerAndSerial(org.bouncycastle.asn1.x500.X500Name,java.math.BigInteger) -> b
    void setSubjectKeyID(byte[]) -> c
org.bouncycastle.cms.OriginatorInformation -> f6.v:
    org.bouncycastle.asn1.cms.OriginatorInfo originatorInfo -> a
org.bouncycastle.cms.PasswordRecipient -> f6.w:
    org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.asn1.x509.AlgorithmIdentifier,byte[],byte[]) -> b
    int getPasswordConversionScheme() -> c
    byte[] calculateDerivedKey(int,org.bouncycastle.asn1.x509.AlgorithmIdentifier,int) -> f
org.bouncycastle.cms.PasswordRecipient$PRF -> f6.w$a:
    org.bouncycastle.cms.PasswordRecipient$PRF HMacSHA512 -> g
    org.bouncycastle.cms.PasswordRecipient$PRF HMacSHA384 -> f
    org.bouncycastle.asn1.x509.AlgorithmIdentifier prfAlgID -> b
    org.bouncycastle.cms.PasswordRecipient$PRF HMacSHA1 -> c
    org.bouncycastle.cms.PasswordRecipient$PRF HMacSHA256 -> e
    org.bouncycastle.cms.PasswordRecipient$PRF HMacSHA224 -> d
    java.lang.String hmac -> a
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmID() -> a
org.bouncycastle.cms.PasswordRecipientId -> f6.x:
    boolean match(java.lang.Object) -> S
org.bouncycastle.cms.PasswordRecipientInformation -> f6.y:
    java.util.Map BLOCKSIZES -> i
    org.bouncycastle.asn1.cms.PasswordRecipientInfo info -> g
    java.util.Map KEYSIZES -> h
    org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.cms.Recipient) -> d
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyDerivationAlgorithm() -> e
org.bouncycastle.cms.Recipient -> f6.z:
org.bouncycastle.cms.RecipientId -> f6.a0:
    int type -> Q2
org.bouncycastle.cms.RecipientInformation -> f6.b0:
    org.bouncycastle.asn1.x509.AlgorithmIdentifier messageAlgorithm -> c
    org.bouncycastle.asn1.x509.AlgorithmIdentifier keyEncAlg -> b
    org.bouncycastle.cms.AuthAttributesProvider additionalData -> e
    org.bouncycastle.cms.RecipientId rid -> a
    org.bouncycastle.cms.RecipientOperator operator -> f
    org.bouncycastle.cms.CMSSecureReadable secureReadable -> d
    byte[] getContent(org.bouncycastle.cms.Recipient) -> a
    org.bouncycastle.cms.CMSTypedStream getContentStream(org.bouncycastle.cms.Recipient) -> b
    org.bouncycastle.cms.RecipientId getRID() -> c
    org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.cms.Recipient) -> d
org.bouncycastle.cms.RecipientInformationStore -> f6.c0:
    java.util.List all -> Q2
    java.util.Map table -> R2
    org.bouncycastle.cms.RecipientInformation get(org.bouncycastle.cms.RecipientId) -> a
    java.util.Collection getRecipients() -> b
    java.util.Collection getRecipients(org.bouncycastle.cms.RecipientId) -> e
org.bouncycastle.cms.RecipientOperator -> f6.d0:
    java.lang.Object operator -> a
    java.io.OutputStream getAADStream() -> a
    java.io.InputStream getInputStream(java.io.InputStream) -> b
org.bouncycastle.cms.jcajce.CMSUtils -> g6.a:
    java.util.Set gostAlgs -> c
    java.util.Set mqvAlgs -> a
    java.util.Set ecAlgs -> b
    java.security.PrivateKey cleanPrivateKey(java.security.PrivateKey) -> a
    boolean isGOST(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> b
    void loadParameters(java.security.AlgorithmParameters,org.bouncycastle.asn1.ASN1Encodable) -> c
org.bouncycastle.cms.jcajce.DefaultJcaJceExtHelper -> g6.b:
    org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper createAsymmetricUnwrapper(org.bouncycastle.asn1.x509.AlgorithmIdentifier,java.security.PrivateKey) -> d
org.bouncycastle.cms.jcajce.EnvelopedDataHelper -> g6.c:
    short[] rc2Table -> h
    org.bouncycastle.operator.SecretKeySizeProvider KEY_SIZE_PROVIDER -> b
    java.util.Map BASE_CIPHER_NAMES -> d
    short[] rc2Ekb -> i
    java.util.Set authEnvelopedAlgorithms -> c
    org.bouncycastle.cms.jcajce.JcaJceExtHelper helper -> a
    java.util.Map CIPHER_ALG_NAMES -> e
    java.util.Map MAC_ALG_NAMES -> f
    java.util.Map PBKDF2_ALG_NAMES -> g
    java.security.AlgorithmParameters createAlgorithmParameters(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> a
    org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper createAsymmetricUnwrapper(org.bouncycastle.asn1.x509.AlgorithmIdentifier,java.security.PrivateKey) -> b
    javax.crypto.Cipher createCipher(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> c
    javax.crypto.Cipher createContentCipher(java.security.Key,org.bouncycastle.asn1.x509.AlgorithmIdentifier) -> d
    javax.crypto.KeyAgreement createKeyAgreement(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> e
    java.security.KeyFactory createKeyFactory(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> f
    java.lang.Object execute(org.bouncycastle.cms.jcajce.EnvelopedDataHelper$JCECallback) -> g
    java.lang.String getBaseCipherName(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> h
    java.security.Key getJceKey(org.bouncycastle.asn1.ASN1ObjectIdentifier,org.bouncycastle.operator.GenericKey) -> i
    void keySizeCheck(org.bouncycastle.asn1.x509.AlgorithmIdentifier,java.security.Key) -> j
org.bouncycastle.cms.jcajce.EnvelopedDataHelper$1 -> g6.c$a:
    java.security.Key val$sKey -> b
    org.bouncycastle.asn1.x509.AlgorithmIdentifier val$encryptionAlgID -> a
    org.bouncycastle.cms.jcajce.EnvelopedDataHelper this$0 -> c
    java.lang.Object doInJCE() -> a
org.bouncycastle.cms.jcajce.EnvelopedDataHelper$JCECallback -> g6.c$b:
    java.lang.Object doInJCE() -> a
org.bouncycastle.cms.jcajce.JcaJceExtHelper -> g6.d:
    org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper createAsymmetricUnwrapper(org.bouncycastle.asn1.x509.AlgorithmIdentifier,java.security.PrivateKey) -> d
org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient -> g6.e:
    org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.asn1.x509.AlgorithmIdentifier,byte[]) -> a
org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient$1 -> g6.e$a:
    org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient this$0 -> c
    javax.crypto.Cipher val$dataCipher -> b
    org.bouncycastle.asn1.x509.AlgorithmIdentifier val$contentEncryptionAlgorithm -> a
    java.io.InputStream getInputStream(java.io.InputStream) -> b
org.bouncycastle.cms.jcajce.JceKeyTransRecipient -> g6.f:
    java.util.Map extraMappings -> d
    java.security.PrivateKey recipientKey -> a
    boolean validateKeySize -> e
    boolean unwrappedKeyMustBeEncodable -> f
    org.bouncycastle.cms.jcajce.EnvelopedDataHelper contentHelper -> c
    org.bouncycastle.cms.jcajce.EnvelopedDataHelper helper -> b
    java.security.Key extractSecretKey(org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.asn1.x509.AlgorithmIdentifier,byte[]) -> g
    org.bouncycastle.cms.jcajce.JceKeyTransRecipient setProvider(java.lang.String) -> h
org.bouncycastle.cms.jcajce.NamedJcaJceExtHelper -> g6.g:
    org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper createAsymmetricUnwrapper(org.bouncycastle.asn1.x509.AlgorithmIdentifier,java.security.PrivateKey) -> d
org.bouncycastle.crypto.BlockCipher -> h6.a:
    void init(boolean,org.bouncycastle.crypto.CipherParameters) -> a
    void reset() -> b
    int processBlock(byte[],int,byte[],int) -> c
    int getBlockSize() -> d
org.bouncycastle.crypto.BufferedBlockCipher -> h6.b:
    org.bouncycastle.crypto.BlockCipher cipher -> d
    byte[] buf -> a
    int bufOff -> b
    boolean forEncryption -> c
    int getBlockSize() -> a
    void reset() -> b
org.bouncycastle.crypto.CipherParameters -> h6.c:
org.bouncycastle.crypto.CryptoException -> h6.d:
    java.lang.Throwable cause -> Q2
org.bouncycastle.crypto.DataLengthException -> h6.e:
org.bouncycastle.crypto.Digest -> h6.f:
    void update(byte[],int,int) -> a
    int doFinal(byte[],int) -> b
    void update(byte) -> c
    java.lang.String getAlgorithmName() -> d
    int getDigestSize() -> e
org.bouncycastle.crypto.InvalidCipherTextException -> h6.g:
org.bouncycastle.crypto.OutputLengthException -> h6.h:
org.bouncycastle.crypto.RuntimeCryptoException -> h6.i:
org.bouncycastle.crypto.Xof -> h6.j:
    int doFinal(byte[],int,int) -> f
org.bouncycastle.crypto.digests.GeneralDigest -> i6.a:
    byte[] xBuf -> a
    long byteCount -> c
    int xBufOff -> b
    void update(byte[],int,int) -> a
    void update(byte) -> c
    void finish() -> g
    void processBlock() -> h
    void processLength(long) -> i
    void processWord(byte[],int) -> j
    void reset() -> k
org.bouncycastle.crypto.digests.KeccakDigest -> i6.b:
    byte[] dataQueue -> b
    long[] state -> a
    boolean squeezing -> f
    int bitsInQueue -> d
    int fixedOutputLength -> e
    long[] KeccakRoundConstants -> g
    int rate -> c
    void update(byte[],int,int) -> a
    int doFinal(byte[],int) -> b
    void update(byte) -> c
    int getDigestSize() -> e
    void KeccakAbsorb(byte[],int) -> g
    void KeccakExtract() -> h
    void KeccakPermutation() -> i
    void absorb(byte) -> j
    void absorb(byte[],int,int) -> k
    void absorbBits(int,int) -> l
    void init(int) -> m
    void initSponge(int) -> n
    void padAndSwitchToSqueezingPhase() -> o
    void reset() -> p
    void squeeze(byte[],int,long) -> q
org.bouncycastle.crypto.digests.LongDigest -> i6.c:
    long H6 -> j
    int wOff -> n
    long H5 -> i
    long H8 -> l
    long H7 -> k
    long H2 -> f
    long H1 -> e
    long H4 -> h
    long H3 -> g
    long byteCount2 -> d
    long[] W -> m
    long byteCount1 -> c
    int xBufOff -> b
    byte[] xBuf -> a
    long[] K -> o
    void update(byte[],int,int) -> a
    void update(byte) -> c
    long Ch(long,long,long) -> g
    long Maj(long,long,long) -> h
    long Sigma0(long) -> i
    long Sigma1(long) -> j
    long Sum0(long) -> k
    long Sum1(long) -> l
    void adjustByteCounts() -> m
    void finish() -> n
    void processBlock() -> o
    void processLength(long,long) -> p
    void processWord(byte[],int) -> q
    void reset() -> r
org.bouncycastle.crypto.digests.MD5Digest -> i6.d:
    int[] X -> h
    int xOff -> i
    int H3 -> f
    int H4 -> g
    int H1 -> d
    int H2 -> e
    int doFinal(byte[],int) -> b
    java.lang.String getAlgorithmName() -> d
    int getDigestSize() -> e
    void processBlock() -> h
    void processLength(long) -> i
    void processWord(byte[],int) -> j
    void reset() -> k
    int F(int,int,int) -> l
    int G(int,int,int) -> m
    int H(int,int,int) -> n
    int K(int,int,int) -> o
    int rotateLeft(int,int) -> p
    void unpackWord(int,byte[],int) -> q
org.bouncycastle.crypto.digests.SHA1Digest -> i6.e:
    int[] X -> i
    int xOff -> j
    int H5 -> h
    int H3 -> f
    int H4 -> g
    int H1 -> d
    int H2 -> e
    int doFinal(byte[],int) -> b
    java.lang.String getAlgorithmName() -> d
    int getDigestSize() -> e
    void processBlock() -> h
    void processLength(long) -> i
    void processWord(byte[],int) -> j
    void reset() -> k
    int f(int,int,int) -> l
    int g(int,int,int) -> m
    int h(int,int,int) -> n
org.bouncycastle.crypto.digests.SHA224Digest -> i6.f:
    int xOff -> m
    int H7 -> j
    int H8 -> k
    int H5 -> h
    int H6 -> i
    int H3 -> f
    int[] K -> n
    int H4 -> g
    int H1 -> d
    int H2 -> e
    int[] X -> l
    int doFinal(byte[],int) -> b
    java.lang.String getAlgorithmName() -> d
    int getDigestSize() -> e
    void processBlock() -> h
    void processLength(long) -> i
    void processWord(byte[],int) -> j
    void reset() -> k
    int Ch(int,int,int) -> l
    int Maj(int,int,int) -> m
    int Sum0(int) -> n
    int Sum1(int) -> o
    int Theta0(int) -> p
    int Theta1(int) -> q
org.bouncycastle.crypto.digests.SHA256Digest -> i6.g:
    int xOff -> m
    int H7 -> j
    int H8 -> k
    int H5 -> h
    int H6 -> i
    int H3 -> f
    int[] K -> n
    int H4 -> g
    int H1 -> d
    int H2 -> e
    int[] X -> l
    int doFinal(byte[],int) -> b
    java.lang.String getAlgorithmName() -> d
    int getDigestSize() -> e
    void processBlock() -> h
    void processLength(long) -> i
    void processWord(byte[],int) -> j
    void reset() -> k
    int Ch(int,int,int) -> l
    int Maj(int,int,int) -> m
    int Sum0(int) -> n
    int Sum1(int) -> o
    int Theta0(int) -> p
    int Theta1(int) -> q
org.bouncycastle.crypto.digests.SHA384Digest -> i6.h:
    int doFinal(byte[],int) -> b
    java.lang.String getAlgorithmName() -> d
    int getDigestSize() -> e
    void reset() -> r
org.bouncycastle.crypto.digests.SHA3Digest -> i6.i:
    int doFinal(byte[],int) -> b
    java.lang.String getAlgorithmName() -> d
    int checkBitLength(int) -> r
org.bouncycastle.crypto.digests.SHA512Digest -> i6.j:
    int doFinal(byte[],int) -> b
    java.lang.String getAlgorithmName() -> d
    int getDigestSize() -> e
    void reset() -> r
org.bouncycastle.crypto.digests.SHAKEDigest -> i6.k:
    int doFinal(byte[],int) -> b
    java.lang.String getAlgorithmName() -> d
    int getDigestSize() -> e
    int doFinal(byte[],int,int) -> f
    int checkBitLength(int) -> r
    int doOutput(byte[],int,int) -> s
org.bouncycastle.crypto.engines.AESFastEngine -> j6.a:
    int[] rcon -> f
    int[][] WorkingKey -> b
    int[] T -> g
    int[] Tinv -> h
    byte[] S -> d
    boolean forEncryption -> c
    int ROUNDS -> a
    byte[] Si -> e
    void init(boolean,org.bouncycastle.crypto.CipherParameters) -> a
    void reset() -> b
    int processBlock(byte[],int,byte[],int) -> c
    int getBlockSize() -> d
    int FFmulX(int) -> e
    int FFmulX2(int) -> f
    void decryptBlock(byte[],int,byte[],int,int[][]) -> g
    void encryptBlock(byte[],int,byte[],int,int[][]) -> h
    int[][] generateWorkingKey(byte[],boolean) -> i
    int inv_mcol(int) -> j
    int shift(int,int) -> k
    int subWord(int) -> l
org.bouncycastle.crypto.engines.GOST28147Engine -> j6.b:
    byte[] ESbox_Test -> b
    byte[] Sbox_Default -> a
    byte[] DSbox_Test -> h
    java.util.Hashtable sBoxes -> j
    byte[] Param_Z -> g
    byte[] DSbox_A -> i
    byte[] ESbox_B -> d
    byte[] ESbox_A -> c
    byte[] ESbox_D -> f
    byte[] ESbox_C -> e
    void addSBox(java.lang.String,byte[]) -> e
    byte[] getSBox(java.lang.String) -> f
org.bouncycastle.crypto.io.CipherIOException -> k6.a:
    java.lang.Throwable cause -> Q2
org.bouncycastle.crypto.io.InvalidCipherTextIOException -> k6.b:
org.bouncycastle.crypto.modes.CBCBlockCipher -> l6.a:
    org.bouncycastle.crypto.BlockCipher cipher -> e
    byte[] cbcV -> b
    byte[] IV -> a
    boolean encrypting -> f
    int blockSize -> d
    byte[] cbcNextV -> c
    void init(boolean,org.bouncycastle.crypto.CipherParameters) -> a
    void reset() -> b
    int processBlock(byte[],int,byte[],int) -> c
    int getBlockSize() -> d
    int decryptBlock(byte[],int,byte[],int) -> e
    int encryptBlock(byte[],int,byte[],int) -> f
org.bouncycastle.crypto.paddings.BlockCipherPadding -> m6.a:
    int padCount(byte[]) -> a
    int addPadding(byte[],int) -> b
    void init(java.security.SecureRandom) -> c
org.bouncycastle.crypto.paddings.PKCS7Padding -> m6.b:
    int padCount(byte[]) -> a
    int addPadding(byte[],int) -> b
    void init(java.security.SecureRandom) -> c
org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher -> m6.c:
    org.bouncycastle.crypto.paddings.BlockCipherPadding padding -> e
    int doFinal(byte[],int) -> c
    int getOutputSize(int) -> d
    int getUpdateOutputSize(int) -> e
    void init(boolean,org.bouncycastle.crypto.CipherParameters) -> f
    int processBytes(byte[],int,int,byte[],int) -> g
org.bouncycastle.crypto.params.AsymmetricKeyParameter -> n6.a:
    boolean privateKey -> Q2
org.bouncycastle.crypto.params.KeyParameter -> n6.b:
    byte[] key -> Q2
    byte[] getKey() -> a
org.bouncycastle.crypto.params.ParametersWithIV -> n6.c:
    byte[] iv -> Q2
    org.bouncycastle.crypto.CipherParameters parameters -> R2
    byte[] getIV() -> a
    org.bouncycastle.crypto.CipherParameters getParameters() -> b
org.bouncycastle.crypto.params.ParametersWithRandom -> n6.d:
    java.security.SecureRandom random -> Q2
    org.bouncycastle.crypto.CipherParameters parameters -> R2
    org.bouncycastle.crypto.CipherParameters getParameters() -> a
    java.security.SecureRandom getRandom() -> b
org.bouncycastle.crypto.util.DigestFactory -> o6.a:
    java.util.Map cloneMap -> a
    org.bouncycastle.crypto.Digest createMD5() -> a
    org.bouncycastle.crypto.Digest createSHA1() -> b
    org.bouncycastle.crypto.Digest createSHA224() -> c
    org.bouncycastle.crypto.Digest createSHA256() -> d
    org.bouncycastle.crypto.Digest createSHA384() -> e
    org.bouncycastle.crypto.Digest createSHA3_224() -> f
    org.bouncycastle.crypto.Digest createSHA3_256() -> g
    org.bouncycastle.crypto.Digest createSHA3_384() -> h
    org.bouncycastle.crypto.Digest createSHA3_512() -> i
    org.bouncycastle.crypto.Digest createSHA512() -> j
    org.bouncycastle.crypto.Digest createSHAKE128() -> k
    org.bouncycastle.crypto.Digest createSHAKE256() -> l
org.bouncycastle.crypto.util.DigestFactory$1 -> o6.a$d:
org.bouncycastle.crypto.util.DigestFactory$10 -> o6.a$a:
org.bouncycastle.crypto.util.DigestFactory$11 -> o6.a$b:
org.bouncycastle.crypto.util.DigestFactory$12 -> o6.a$c:
org.bouncycastle.crypto.util.DigestFactory$2 -> o6.a$e:
org.bouncycastle.crypto.util.DigestFactory$3 -> o6.a$f:
org.bouncycastle.crypto.util.DigestFactory$4 -> o6.a$g:
org.bouncycastle.crypto.util.DigestFactory$5 -> o6.a$h:
org.bouncycastle.crypto.util.DigestFactory$6 -> o6.a$i:
org.bouncycastle.crypto.util.DigestFactory$7 -> o6.a$j:
org.bouncycastle.crypto.util.DigestFactory$8 -> o6.a$k:
org.bouncycastle.crypto.util.DigestFactory$9 -> o6.a$l:
org.bouncycastle.jcajce.io.CipherInputStream -> p6.a:
    javax.crypto.Cipher cipher -> Q2
    int maxBuf -> U2
    byte[] inputBuffer -> R2
    int bufOff -> V2
    boolean finalized -> S2
    byte[] buf -> T2
    byte[] finaliseCipher() -> a
    int nextChunk() -> b
org.bouncycastle.jcajce.provider.config.ConfigurableProvider -> q6.a:
org.bouncycastle.jcajce.provider.config.ProviderConfiguration -> q6.b:
org.bouncycastle.jcajce.provider.config.ProviderConfigurationPermission -> q6.c:
    java.lang.String actions -> Q2
    int permissionMask -> R2
    int calculateMask(java.lang.String) -> a
org.bouncycastle.jcajce.provider.symmetric.util.ClassUtil -> r6.a:
    java.lang.Class loadClass(java.lang.Class,java.lang.String) -> a
org.bouncycastle.jcajce.provider.symmetric.util.ClassUtil$1 -> r6.a$a:
    java.lang.String val$className -> a
org.bouncycastle.jcajce.provider.util.AlgorithmProvider -> s6.a:
    void configure(org.bouncycastle.jcajce.provider.config.ConfigurableProvider) -> a
org.bouncycastle.jcajce.provider.util.AsymmetricKeyInfoConverter -> s6.b:
org.bouncycastle.jcajce.spec.GOST28147WrapParameterSpec -> t6.a:
    byte[] sBox -> b
    java.util.Map oidMappings -> c
    byte[] ukm -> a
    java.lang.String getName(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> a
org.bouncycastle.jcajce.spec.UserKeyingMaterialSpec -> t6.b:
    byte[] userKeyingMaterial -> a
org.bouncycastle.jcajce.util.AlgorithmParametersUtils -> u6.a:
    void loadParameters(java.security.AlgorithmParameters,org.bouncycastle.asn1.ASN1Encodable) -> a
org.bouncycastle.jcajce.util.AnnotatedPrivateKey -> u6.b:
    java.util.Map annotations -> R2
    java.security.PrivateKey key -> Q2
    java.security.PrivateKey getKey() -> a
org.bouncycastle.jcajce.util.DefaultJcaJceHelper -> u6.c:
    javax.crypto.Cipher createCipher(java.lang.String) -> a
    java.security.AlgorithmParameters createAlgorithmParameters(java.lang.String) -> b
    javax.crypto.KeyAgreement createKeyAgreement(java.lang.String) -> c
    java.security.KeyFactory createKeyFactory(java.lang.String) -> e
org.bouncycastle.jcajce.util.JcaJceHelper -> u6.d:
    javax.crypto.Cipher createCipher(java.lang.String) -> a
    java.security.AlgorithmParameters createAlgorithmParameters(java.lang.String) -> b
    javax.crypto.KeyAgreement createKeyAgreement(java.lang.String) -> c
    java.security.KeyFactory createKeyFactory(java.lang.String) -> e
org.bouncycastle.jcajce.util.NamedJcaJceHelper -> u6.e:
    java.lang.String providerName -> a
    javax.crypto.Cipher createCipher(java.lang.String) -> a
    java.security.AlgorithmParameters createAlgorithmParameters(java.lang.String) -> b
    javax.crypto.KeyAgreement createKeyAgreement(java.lang.String) -> c
    java.security.KeyFactory createKeyFactory(java.lang.String) -> e
org.bouncycastle.jce.provider.BouncyCastleProvider -> v6.a:
    java.util.Map keyInfoConverters -> S2
    java.lang.String[] SYMMETRIC_MACS -> V2
    java.lang.String[] SYMMETRIC_GENERIC -> U2
    java.lang.String[] DIGESTS -> Z2
    java.lang.String[] ASYMMETRIC_CIPHERS -> Y2
    java.lang.String[] ASYMMETRIC_GENERIC -> X2
    java.lang.String[] SYMMETRIC_CIPHERS -> W2
    java.lang.Class revChkClass -> T2
    org.bouncycastle.jcajce.provider.config.ProviderConfiguration CONFIGURATION -> R2
    java.lang.String info -> Q2
    java.lang.String[] SECURE_RANDOMS -> b3
    java.lang.String[] KEYSTORES -> a3
    void access$000(org.bouncycastle.jce.provider.BouncyCastleProvider) -> a
    void addKeyInfoConverter(org.bouncycastle.asn1.ASN1ObjectIdentifier,org.bouncycastle.jcajce.provider.util.AsymmetricKeyInfoConverter) -> b
    void loadAlgorithms(java.lang.String,java.lang.String[]) -> c
    void loadPQCKeys() -> d
    void setup() -> e
org.bouncycastle.jce.provider.BouncyCastleProvider$1 -> v6.a$a:
    org.bouncycastle.jce.provider.BouncyCastleProvider this$0 -> a
org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration -> v6.b:
    java.lang.ThreadLocal ecThreadSpec -> a
    java.util.Map additionalECParameters -> d
    java.security.Permission BC_ADDITIONAL_EC_CURVE_PERMISSION -> j
    java.lang.ThreadLocal dhThreadSpec -> b
    java.util.Set acceptableNamedCurves -> c
    java.security.Permission BC_EC_LOCAL_PERMISSION -> e
    java.security.Permission BC_EC_CURVE_PERMISSION -> i
    java.security.Permission BC_DH_PERMISSION -> h
    java.security.Permission BC_DH_LOCAL_PERMISSION -> g
    java.security.Permission BC_EC_PERMISSION -> f
org.bouncycastle.operator.AADProcessor -> w6.a:
    java.io.OutputStream getAADStream() -> a
org.bouncycastle.operator.AsymmetricKeyUnwrapper -> w6.b:
    org.bouncycastle.asn1.x509.AlgorithmIdentifier algorithmId -> a
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmIdentifier() -> a
org.bouncycastle.operator.DefaultSecretKeySizeProvider -> w6.c:
    java.util.Map KEY_SIZES -> b
    org.bouncycastle.operator.SecretKeySizeProvider INSTANCE -> a
    int getKeySize(org.bouncycastle.asn1.x509.AlgorithmIdentifier) -> a
    int getKeySize(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> b
org.bouncycastle.operator.DefaultSignatureNameFinder -> w6.d:
    java.util.Map oids -> a
    java.util.Map digests -> b
org.bouncycastle.operator.GenericKey -> w6.e:
    java.lang.Object representation -> b
    org.bouncycastle.asn1.x509.AlgorithmIdentifier algorithmIdentifier -> a
    java.lang.Object getRepresentation() -> a
org.bouncycastle.operator.InputAEADDecryptor -> w6.f:
org.bouncycastle.operator.InputDecryptor -> w6.g:
    java.io.InputStream getInputStream(java.io.InputStream) -> b
org.bouncycastle.operator.MacCalculator -> w6.h:
    java.io.OutputStream getOutputStream() -> a
org.bouncycastle.operator.OperatorCreationException -> w6.i:
org.bouncycastle.operator.OperatorException -> w6.j:
    java.lang.Throwable cause -> Q2
org.bouncycastle.operator.SecretKeySizeProvider -> w6.k:
    int getKeySize(org.bouncycastle.asn1.x509.AlgorithmIdentifier) -> a
org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper -> x6.a:
    java.security.PrivateKey privKey -> d
    java.util.Map extraMappings -> c
    boolean unwrappedKeyMustBeEncodable -> e
    org.bouncycastle.operator.jcajce.OperatorHelper helper -> b
    org.bouncycastle.operator.GenericKey generateUnwrappedKey(org.bouncycastle.asn1.x509.AlgorithmIdentifier,byte[]) -> b
    org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper setAlgorithmMapping(org.bouncycastle.asn1.ASN1ObjectIdentifier,java.lang.String) -> c
    org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper setMustProduceEncodableUnwrappedKey(boolean) -> d
    org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper setProvider(java.lang.String) -> e
org.bouncycastle.operator.jcajce.JceGenericKey -> x6.b:
    java.lang.Object getRepresentation(java.security.Key) -> b
org.bouncycastle.operator.jcajce.OperatorHelper -> x6.c:
    java.util.Map oids -> b
    java.util.Map asymmetricWrapperAlgNames -> c
    java.util.Map symmetricWrapperAlgNames -> d
    org.bouncycastle.jcajce.util.JcaJceHelper helper -> a
    org.bouncycastle.operator.DefaultSignatureNameFinder sigFinder -> g
    java.util.Map symmetricKeyAlgNames -> e
    java.util.Map symmetricWrapperKeySizes -> f
    java.security.AlgorithmParameters createAlgorithmParameters(org.bouncycastle.asn1.x509.AlgorithmIdentifier) -> a
    javax.crypto.Cipher createAsymmetricWrapper(org.bouncycastle.asn1.ASN1ObjectIdentifier,java.util.Map) -> b
    java.lang.String getKeyAlgorithmName(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> c
org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey -> y6.a:
    byte[] encField -> S2
    byte[] encP -> U2
    byte[] encGp -> T2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier digest -> V2
    int n -> Q2
    int k -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigest() -> j
    org.bouncycastle.pqc.math.linearalgebra.GF2mField getField() -> k
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly() -> l
    org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey getInstance(java.lang.Object) -> m
    int getK() -> n
    int getN() -> o
    org.bouncycastle.pqc.math.linearalgebra.Permutation getP() -> p
org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey -> y6.b:
    int n -> Q2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix g -> S2
    int t -> R2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier digest -> T2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigest() -> j
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG() -> k
    org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey getInstance(java.lang.Object) -> l
    int getN() -> m
    int getT() -> n
org.bouncycastle.pqc.asn1.McEliecePrivateKey -> y6.c:
    byte[] encField -> S2
    byte[] encP2 -> W2
    byte[] encP1 -> V2
    byte[] encSInv -> U2
    byte[] encGp -> T2
    int n -> Q2
    int k -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.pqc.math.linearalgebra.GF2mField getField() -> j
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly() -> k
    org.bouncycastle.pqc.asn1.McEliecePrivateKey getInstance(java.lang.Object) -> l
    int getK() -> m
    int getN() -> n
    org.bouncycastle.pqc.math.linearalgebra.Permutation getP1() -> o
    org.bouncycastle.pqc.math.linearalgebra.Permutation getP2() -> p
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getSInv() -> q
org.bouncycastle.pqc.asn1.McEliecePublicKey -> y6.d:
    int n -> Q2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix g -> S2
    int t -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG() -> j
    org.bouncycastle.pqc.asn1.McEliecePublicKey getInstance(java.lang.Object) -> k
    int getN() -> l
    int getT() -> m
org.bouncycastle.pqc.asn1.PQCObjectIdentifiers -> y6.e:
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHA256 -> K
    org.bouncycastle.asn1.ASN1ObjectIdentifier gmssWithSha512 -> l
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHA256ph -> G
    org.bouncycastle.asn1.ASN1ObjectIdentifier gmssWithSha1 -> h
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_with_SHA256 -> S
    org.bouncycastle.asn1.ASN1ObjectIdentifier sphincs256_with_SHA512 -> t
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_with_SHA256 -> O
    org.bouncycastle.asn1.ASN1ObjectIdentifier mcEliecePointcheval -> p
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA -> W
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHA256ph -> x
    org.bouncycastle.asn1.ASN1ObjectIdentifier rainbowWithSha224 -> c
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt -> F
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHA256 -> B
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHA512 -> L
    org.bouncycastle.asn1.ASN1ObjectIdentifier mcEliece -> m
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHA512ph -> H
    org.bouncycastle.asn1.ASN1ObjectIdentifier gmssWithSha224 -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_with_SHA512 -> T
    org.bouncycastle.asn1.ASN1ObjectIdentifier sphincs256_with_SHA3_512 -> u
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_with_SHA512 -> P
    org.bouncycastle.asn1.ASN1ObjectIdentifier mcElieceKobara_Imai -> q
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA_p_I -> X
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHA512ph -> y
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHA512 -> C
    org.bouncycastle.asn1.ASN1ObjectIdentifier rainbowWithSha256 -> d
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHAKE128 -> M
    org.bouncycastle.asn1.ASN1ObjectIdentifier mcElieceCca2 -> n
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHAKE128ph -> I
    org.bouncycastle.asn1.ASN1ObjectIdentifier gmssWithSha256 -> j
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_with_SHAKE128 -> U
    org.bouncycastle.asn1.ASN1ObjectIdentifier newHope -> v
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_with_SHAKE128 -> Q
    org.bouncycastle.asn1.ASN1ObjectIdentifier sphincs256 -> r
    org.bouncycastle.asn1.ASN1ObjectIdentifier qTESLA_p_III -> Y
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHAKE128ph -> z
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHAKE128 -> D
    org.bouncycastle.asn1.ASN1ObjectIdentifier rainbowWithSha384 -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier rainbow -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier gmssWithSha384 -> k
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHAKE256 -> N
    org.bouncycastle.asn1.ASN1ObjectIdentifier gmss -> g
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_SHAKE256ph -> J
    org.bouncycastle.asn1.ASN1ObjectIdentifier sphincs256_with_BLAKE512 -> s
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_mt_with_SHAKE256 -> V
    org.bouncycastle.asn1.ASN1ObjectIdentifier mcElieceFujisaki -> o
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_with_SHAKE256 -> R
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss -> w
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHAKE256 -> E
    org.bouncycastle.asn1.ASN1ObjectIdentifier rainbowWithSha512 -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier xmss_SHAKE256ph -> A
    org.bouncycastle.asn1.ASN1ObjectIdentifier rainbowWithSha1 -> b
org.bouncycastle.pqc.asn1.RainbowPrivateKey -> y6.f:
    byte[] vi -> W2
    byte[] b2 -> V2
    byte[] b1 -> T2
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    org.bouncycastle.asn1.ASN1ObjectIdentifier oid -> R2
    byte[][] invA2 -> U2
    byte[][] invA1 -> S2
    org.bouncycastle.pqc.crypto.rainbow.Layer[] layers -> X2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    short[] getB1() -> j
    short[] getB2() -> k
    org.bouncycastle.pqc.asn1.RainbowPrivateKey getInstance(java.lang.Object) -> l
    short[][] getInvA1() -> m
    short[][] getInvA2() -> n
    org.bouncycastle.pqc.crypto.rainbow.Layer[] getLayers() -> o
    int[] getVi() -> p
org.bouncycastle.pqc.asn1.RainbowPublicKey -> y6.g:
    byte[] coeffScalar -> V2
    org.bouncycastle.asn1.ASN1Integer docLength -> S2
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    org.bouncycastle.asn1.ASN1ObjectIdentifier oid -> R2
    byte[][] coeffQuadratic -> T2
    byte[][] coeffSingular -> U2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    short[][] getCoeffQuadratic() -> j
    short[] getCoeffScalar() -> k
    short[][] getCoeffSingular() -> l
    int getDocLength() -> m
    org.bouncycastle.pqc.asn1.RainbowPublicKey getInstance(java.lang.Object) -> n
org.bouncycastle.pqc.asn1.SPHINCS256KeyParams -> y6.h:
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier treeDigest -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.pqc.asn1.SPHINCS256KeyParams getInstance(java.lang.Object) -> j
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getTreeDigest() -> k
org.bouncycastle.pqc.asn1.XMSSKeyParams -> y6.i:
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier treeDigest -> S2
    int height -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    int getHeight() -> j
    org.bouncycastle.pqc.asn1.XMSSKeyParams getInstance(java.lang.Object) -> k
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getTreeDigest() -> l
org.bouncycastle.pqc.asn1.XMSSMTKeyParams -> y6.j:
    int layers -> S2
    org.bouncycastle.asn1.ASN1Integer version -> Q2
    int height -> R2
    org.bouncycastle.asn1.x509.AlgorithmIdentifier treeDigest -> T2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    int getHeight() -> j
    org.bouncycastle.pqc.asn1.XMSSMTKeyParams getInstance(java.lang.Object) -> k
    int getLayers() -> l
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getTreeDigest() -> m
org.bouncycastle.pqc.asn1.XMSSMTPrivateKey -> y6.k:
    byte[] root -> W2
    byte[] publicSeed -> V2
    byte[] secretKeyPRF -> U2
    byte[] secretKeySeed -> T2
    long index -> R2
    long maxIndex -> S2
    byte[] bdsState -> X2
    int version -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    byte[] getBdsState() -> j
    long getIndex() -> k
    org.bouncycastle.pqc.asn1.XMSSMTPrivateKey getInstance(java.lang.Object) -> l
    long getMaxIndex() -> m
    byte[] getPublicSeed() -> n
    byte[] getRoot() -> o
    byte[] getSecretKeyPRF() -> p
    byte[] getSecretKeySeed() -> q
    int getVersion() -> r
org.bouncycastle.pqc.asn1.XMSSMTPublicKey -> y6.l:
    byte[] root -> R2
    byte[] publicSeed -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
org.bouncycastle.pqc.asn1.XMSSPrivateKey -> y6.m:
    byte[] secretKeySeed -> S2
    byte[] root -> V2
    byte[] publicSeed -> U2
    int maxIndex -> W2
    byte[] secretKeyPRF -> T2
    byte[] bdsState -> X2
    int version -> Q2
    int index -> R2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    byte[] getBdsState() -> j
    int getIndex() -> k
    org.bouncycastle.pqc.asn1.XMSSPrivateKey getInstance(java.lang.Object) -> l
    int getMaxIndex() -> m
    byte[] getPublicSeed() -> n
    byte[] getRoot() -> o
    byte[] getSecretKeyPRF() -> p
    byte[] getSecretKeySeed() -> q
    int getVersion() -> r
org.bouncycastle.pqc.asn1.XMSSPublicKey -> y6.n:
    byte[] root -> R2
    byte[] publicSeed -> Q2
    org.bouncycastle.asn1.ASN1Primitive toASN1Primitive() -> f
    org.bouncycastle.pqc.asn1.XMSSPublicKey getInstance(java.lang.Object) -> j
    byte[] getPublicSeed() -> k
    byte[] getRoot() -> l
org.bouncycastle.pqc.crypto.lms.Composer -> z6.a:
    java.io.ByteArrayOutputStream bos -> a
    org.bouncycastle.pqc.crypto.lms.Composer bool(boolean) -> a
    byte[] build() -> b
    org.bouncycastle.pqc.crypto.lms.Composer bytes(org.bouncycastle.util.Encodable) -> c
    org.bouncycastle.pqc.crypto.lms.Composer bytes(byte[]) -> d
    org.bouncycastle.pqc.crypto.lms.Composer bytes(byte[][]) -> e
    org.bouncycastle.pqc.crypto.lms.Composer compose() -> f
    org.bouncycastle.pqc.crypto.lms.Composer padUntil(int,int) -> g
    org.bouncycastle.pqc.crypto.lms.Composer u16str(int) -> h
    org.bouncycastle.pqc.crypto.lms.Composer u32str(int) -> i
    org.bouncycastle.pqc.crypto.lms.Composer u64str(long) -> j
org.bouncycastle.pqc.crypto.lms.DigestUtil -> z6.b:
    java.util.Map nameToOid -> a
    java.util.Map oidToName -> b
    org.bouncycastle.crypto.Digest getDigest(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> a
org.bouncycastle.pqc.crypto.lms.HSSPrivateKeyParameters -> z6.c:
    long indexLimit -> V2
    boolean isShard -> S2
    long index -> W2
    org.bouncycastle.pqc.crypto.lms.HSSPublicKeyParameters publicKey -> X2
    java.util.List sig -> U2
    int l -> R2
    java.util.List keys -> T2
    org.bouncycastle.pqc.crypto.lms.HSSPrivateKeyParameters getInstance(java.lang.Object) -> a
    org.bouncycastle.pqc.crypto.lms.HSSPrivateKeyParameters getInstance(byte[],byte[]) -> b
    int getL() -> c
    org.bouncycastle.pqc.crypto.lms.HSSPublicKeyParameters getPublicKey() -> d
    org.bouncycastle.pqc.crypto.lms.LMSPrivateKeyParameters getRootKey() -> e
    org.bouncycastle.pqc.crypto.lms.HSSPrivateKeyParameters makeCopy(org.bouncycastle.pqc.crypto.lms.HSSPrivateKeyParameters) -> f
org.bouncycastle.pqc.crypto.lms.HSSPublicKeyParameters -> z6.d:
    int l -> R2
    org.bouncycastle.pqc.crypto.lms.LMSPublicKeyParameters lmsPublicKey -> S2
    org.bouncycastle.pqc.crypto.lms.HSSPublicKeyParameters getInstance(java.lang.Object) -> a
    int getL() -> b
    org.bouncycastle.pqc.crypto.lms.LMSPublicKeyParameters getLMSPublicKey() -> c
org.bouncycastle.pqc.crypto.lms.LMOtsParameters -> z6.e:
    org.bouncycastle.asn1.ASN1ObjectIdentifier digestOID -> g
    org.bouncycastle.pqc.crypto.lms.LMOtsParameters sha256_n32_w8 -> k
    int sigLen -> f
    org.bouncycastle.pqc.crypto.lms.LMOtsParameters sha256_n32_w2 -> i
    org.bouncycastle.pqc.crypto.lms.LMOtsParameters sha256_n32_w4 -> j
    int p -> d
    int ls -> e
    org.bouncycastle.pqc.crypto.lms.LMOtsParameters sha256_n32_w1 -> h
    java.util.Map suppliers -> l
    int n -> b
    int w -> c
    int type -> a
    int access$000(org.bouncycastle.pqc.crypto.lms.LMOtsParameters) -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier getDigestOID() -> b
    int getN() -> c
    int getP() -> d
    org.bouncycastle.pqc.crypto.lms.LMOtsParameters getParametersForType(int) -> e
    int getType() -> f
    int getW() -> g
org.bouncycastle.pqc.crypto.lms.LMOtsParameters$1 -> z6.e$a:
org.bouncycastle.pqc.crypto.lms.LMOtsSignature -> z6.f:
    byte[] y -> S2
    byte[] C -> R2
    org.bouncycastle.pqc.crypto.lms.LMOtsParameters type -> Q2
    org.bouncycastle.pqc.crypto.lms.LMOtsSignature getInstance(java.lang.Object) -> a
org.bouncycastle.pqc.crypto.lms.LMSKeyParameters -> z6.g:
org.bouncycastle.pqc.crypto.lms.LMSPrivateKeyParameters -> z6.h:
    int maxQ -> U2
    byte[] I -> R2
    org.bouncycastle.pqc.crypto.lms.LMSPrivateKeyParameters$CacheKey T1 -> b3
    org.bouncycastle.pqc.crypto.lms.LMSigParameters parameters -> S2
    org.bouncycastle.crypto.Digest tDigest -> Y2
    byte[] masterSecret -> V2
    int q -> Z2
    org.bouncycastle.pqc.crypto.lms.LMSPrivateKeyParameters$CacheKey[] internedKeys -> c3
    org.bouncycastle.pqc.crypto.lms.LMOtsParameters otsParameters -> T2
    int maxCacheR -> X2
    org.bouncycastle.pqc.crypto.lms.LMSPublicKeyParameters publicKey -> a3
    java.util.Map tCache -> W2
    byte[] calcT(int) -> a
    byte[] findT(int) -> b
    byte[] findT(org.bouncycastle.pqc.crypto.lms.LMSPrivateKeyParameters$CacheKey) -> c
    byte[] getI() -> d
    org.bouncycastle.pqc.crypto.lms.LMSPrivateKeyParameters getInstance(java.lang.Object) -> e
    org.bouncycastle.pqc.crypto.lms.LMSPrivateKeyParameters getInstance(byte[],byte[]) -> f
    byte[] getMasterSecret() -> g
    org.bouncycastle.pqc.crypto.lms.LMOtsParameters getOtsParameters() -> h
    org.bouncycastle.pqc.crypto.lms.LMSPublicKeyParameters getPublicKey() -> i
    org.bouncycastle.pqc.crypto.lms.LMSigParameters getSigParameters() -> j
org.bouncycastle.pqc.crypto.lms.LMSPrivateKeyParameters$CacheKey -> z6.h$a:
    int index -> a
    int access$000(org.bouncycastle.pqc.crypto.lms.LMSPrivateKeyParameters$CacheKey) -> a
org.bouncycastle.pqc.crypto.lms.LMSPublicKeyParameters -> z6.i:
    org.bouncycastle.pqc.crypto.lms.LMSigParameters parameterSet -> R2
    org.bouncycastle.pqc.crypto.lms.LMOtsParameters lmOtsType -> S2
    byte[] T1 -> U2
    byte[] I -> T2
    org.bouncycastle.pqc.crypto.lms.LMSPublicKeyParameters getInstance(java.lang.Object) -> a
    byte[] toByteArray() -> b
org.bouncycastle.pqc.crypto.lms.LMSSignature -> z6.j:
    org.bouncycastle.pqc.crypto.lms.LMSigParameters parameter -> S2
    org.bouncycastle.pqc.crypto.lms.LMOtsSignature otsSignature -> R2
    int q -> Q2
    byte[][] y -> T2
    org.bouncycastle.pqc.crypto.lms.LMSSignature getInstance(java.lang.Object) -> a
org.bouncycastle.pqc.crypto.lms.LMSigParameters -> z6.k:
    org.bouncycastle.pqc.crypto.lms.LMSigParameters lms_sha256_n32_h5 -> e
    org.bouncycastle.asn1.ASN1ObjectIdentifier digestOid -> d
    java.util.Map paramBuilders -> j
    int m -> b
    org.bouncycastle.pqc.crypto.lms.LMSigParameters lms_sha256_n32_h15 -> g
    int h -> c
    org.bouncycastle.pqc.crypto.lms.LMSigParameters lms_sha256_n32_h10 -> f
    org.bouncycastle.pqc.crypto.lms.LMSigParameters lms_sha256_n32_h25 -> i
    int type -> a
    org.bouncycastle.pqc.crypto.lms.LMSigParameters lms_sha256_n32_h20 -> h
    int access$000(org.bouncycastle.pqc.crypto.lms.LMSigParameters) -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier getDigestOID() -> b
    int getH() -> c
    int getM() -> d
    org.bouncycastle.pqc.crypto.lms.LMSigParameters getParametersForType(int) -> e
    int getType() -> f
org.bouncycastle.pqc.crypto.lms.LMSigParameters$1 -> z6.k$a:
org.bouncycastle.pqc.crypto.lms.LM_OTS -> z6.l:
    byte[] lms_ots_generatePublicKey(org.bouncycastle.pqc.crypto.lms.LMOtsParameters,byte[],int,byte[]) -> a
org.bouncycastle.pqc.crypto.lms.LmsUtils -> z6.m:
    void byteArray(byte[],org.bouncycastle.crypto.Digest) -> a
    void u16str(short,org.bouncycastle.crypto.Digest) -> b
    void u32str(int,org.bouncycastle.crypto.Digest) -> c
org.bouncycastle.pqc.crypto.lms.SeedDerive -> z6.n:
    byte[] masterSeed -> b
    byte[] I -> a
    org.bouncycastle.crypto.Digest digest -> c
    int q -> d
    int j -> e
    void deriveSeed(byte[],boolean,int) -> a
    byte[] deriveSeed(byte[],int) -> b
    void setJ(int) -> c
    void setQ(int) -> d
org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2KeyParameters -> a7.a:
    java.lang.String params -> R2
    java.lang.String getDigest() -> a
org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters -> a7.b:
    int n -> S2
    int k -> T2
    org.bouncycastle.pqc.math.linearalgebra.Permutation p -> W2
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM[] qInv -> Y2
    org.bouncycastle.pqc.math.linearalgebra.GF2mField field -> U2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix h -> X2
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM goppaPoly -> V2
    org.bouncycastle.pqc.math.linearalgebra.GF2mField getField() -> b
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly() -> c
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getH() -> d
    int getK() -> e
    int getN() -> f
    org.bouncycastle.pqc.math.linearalgebra.Permutation getP() -> g
org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PublicKeyParameters -> a7.c:
    int n -> S2
    int t -> T2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix matrixG -> U2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG() -> b
    int getN() -> c
    int getT() -> d
org.bouncycastle.pqc.crypto.mceliece.McElieceKeyParameters -> a7.d:
org.bouncycastle.pqc.crypto.mceliece.McElieceParameters -> a7.e:
org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters -> a7.f:
    int k -> S2
    org.bouncycastle.pqc.math.linearalgebra.Permutation p2 -> X2
    org.bouncycastle.pqc.math.linearalgebra.Permutation p1 -> W2
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM[] qInv -> Z2
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM goppaPoly -> U2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix h -> Y2
    org.bouncycastle.pqc.math.linearalgebra.GF2mField field -> T2
    int n -> R2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix sInv -> V2
    org.bouncycastle.pqc.math.linearalgebra.GF2mField getField() -> a
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly() -> b
    int getK() -> c
    int getN() -> d
    org.bouncycastle.pqc.math.linearalgebra.Permutation getP1() -> e
    org.bouncycastle.pqc.math.linearalgebra.Permutation getP2() -> f
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getSInv() -> g
org.bouncycastle.pqc.crypto.mceliece.McEliecePublicKeyParameters -> a7.g:
    int t -> S2
    int n -> R2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix g -> T2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG() -> a
    int getN() -> b
    int getT() -> c
org.bouncycastle.pqc.crypto.newhope.NHPrivateKeyParameters -> b7.a:
    short[] secData -> R2
    short[] getSecData() -> a
org.bouncycastle.pqc.crypto.newhope.NHPublicKeyParameters -> b7.b:
    byte[] pubData -> R2
    byte[] getPubData() -> a
org.bouncycastle.pqc.crypto.qtesla.QTESLAPrivateKeyParameters -> c7.a:
    byte[] privateKey -> S2
    int securityCategory -> R2
    byte[] getSecret() -> a
    int getSecurityCategory() -> b
org.bouncycastle.pqc.crypto.qtesla.QTESLAPublicKeyParameters -> c7.b:
    byte[] publicKey -> S2
    int securityCategory -> R2
    byte[] getPublicData() -> a
    int getSecurityCategory() -> b
org.bouncycastle.pqc.crypto.qtesla.QTESLASecurityCategory -> c7.c:
    java.lang.String getName(int) -> a
    int getPrivateSize(int) -> b
    int getPublicSize(int) -> c
org.bouncycastle.pqc.crypto.rainbow.Layer -> d7.a:
    short[] coeff_eta -> g
    short[][][] coeff_beta -> e
    short[][][] coeff_alpha -> d
    short[][] coeff_gamma -> f
    int viNext -> b
    int oi -> c
    int vi -> a
    short[][][] getCoeffAlpha() -> a
    short[][][] getCoeffBeta() -> b
    short[] getCoeffEta() -> c
    short[][] getCoeffGamma() -> d
    int getOi() -> e
    int getVi() -> f
    int getViNext() -> g
org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil -> e7.a:
    byte[] convertArray(short[]) -> a
    short[] convertArray(byte[]) -> b
    byte[][] convertArray(short[][]) -> c
    short[][] convertArray(byte[][]) -> d
    byte[][][] convertArray(short[][][]) -> e
    short[][][] convertArray(byte[][][]) -> f
    int[] convertArraytoInt(byte[]) -> g
    byte[] convertIntArray(int[]) -> h
    boolean equals(short[],short[]) -> i
    boolean equals(short[][],short[][]) -> j
    boolean equals(short[][][],short[][][]) -> k
org.bouncycastle.pqc.crypto.sphincs.SPHINCSKeyParameters -> f7.a:
    java.lang.String treeDigest -> R2
    java.lang.String getTreeDigest() -> a
org.bouncycastle.pqc.crypto.sphincs.SPHINCSPrivateKeyParameters -> f7.b:
    byte[] keyData -> S2
    byte[] getKeyData() -> b
org.bouncycastle.pqc.crypto.sphincs.SPHINCSPublicKeyParameters -> f7.c:
    byte[] keyData -> S2
    byte[] getKeyData() -> b
org.bouncycastle.pqc.crypto.util.PrivateKeyFactory -> g7.a:
    short[] convert(byte[]) -> a
    org.bouncycastle.crypto.params.AsymmetricKeyParameter createKey(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> b
org.bouncycastle.pqc.crypto.util.PrivateKeyInfoFactory -> g7.b:
    org.bouncycastle.asn1.pkcs.PrivateKeyInfo createPrivateKeyInfo(org.bouncycastle.crypto.params.AsymmetricKeyParameter,org.bouncycastle.asn1.ASN1Set) -> a
    org.bouncycastle.pqc.asn1.XMSSPrivateKey xmssCreateKeyStructure(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters) -> b
    org.bouncycastle.pqc.asn1.XMSSMTPrivateKey xmssmtCreateKeyStructure(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters) -> c
org.bouncycastle.pqc.crypto.util.PublicKeyFactory -> g7.c:
    java.util.Map converters -> a
    org.bouncycastle.crypto.params.AsymmetricKeyParameter createKey(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> a
    org.bouncycastle.crypto.params.AsymmetricKeyParameter createKey(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo,java.lang.Object) -> b
org.bouncycastle.pqc.crypto.util.PublicKeyFactory$1 -> g7.c$a:
org.bouncycastle.pqc.crypto.util.PublicKeyFactory$LMSConverter -> g7.c$b:
    org.bouncycastle.crypto.params.AsymmetricKeyParameter getPublicKeyParameters(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo,java.lang.Object) -> a
org.bouncycastle.pqc.crypto.util.PublicKeyFactory$McElieceCCA2Converter -> g7.c$c:
    org.bouncycastle.crypto.params.AsymmetricKeyParameter getPublicKeyParameters(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo,java.lang.Object) -> a
org.bouncycastle.pqc.crypto.util.PublicKeyFactory$NHConverter -> g7.c$d:
    org.bouncycastle.crypto.params.AsymmetricKeyParameter getPublicKeyParameters(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo,java.lang.Object) -> a
org.bouncycastle.pqc.crypto.util.PublicKeyFactory$QTeslaConverter -> g7.c$e:
    org.bouncycastle.crypto.params.AsymmetricKeyParameter getPublicKeyParameters(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo,java.lang.Object) -> a
org.bouncycastle.pqc.crypto.util.PublicKeyFactory$SPHINCSConverter -> g7.c$f:
    org.bouncycastle.crypto.params.AsymmetricKeyParameter getPublicKeyParameters(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo,java.lang.Object) -> a
org.bouncycastle.pqc.crypto.util.PublicKeyFactory$SubjectPublicKeyInfoConverter -> g7.c$g:
    org.bouncycastle.crypto.params.AsymmetricKeyParameter getPublicKeyParameters(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo,java.lang.Object) -> a
org.bouncycastle.pqc.crypto.util.PublicKeyFactory$XMSSConverter -> g7.c$h:
    org.bouncycastle.crypto.params.AsymmetricKeyParameter getPublicKeyParameters(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo,java.lang.Object) -> a
org.bouncycastle.pqc.crypto.util.PublicKeyFactory$XMSSMTConverter -> g7.c$i:
    org.bouncycastle.crypto.params.AsymmetricKeyParameter getPublicKeyParameters(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo,java.lang.Object) -> a
org.bouncycastle.pqc.crypto.util.SubjectPublicKeyInfoFactory -> g7.d:
    org.bouncycastle.asn1.x509.SubjectPublicKeyInfo createSubjectPublicKeyInfo(org.bouncycastle.crypto.params.AsymmetricKeyParameter) -> a
org.bouncycastle.pqc.crypto.util.Utils -> g7.e:
    org.bouncycastle.asn1.x509.AlgorithmIdentifier XMSS_SHA256 -> e
    org.bouncycastle.asn1.x509.AlgorithmIdentifier SPHINCS_SHA512_256 -> d
    org.bouncycastle.asn1.x509.AlgorithmIdentifier SPHINCS_SHA3_256 -> c
    org.bouncycastle.asn1.x509.AlgorithmIdentifier AlgID_qTESLA_p_III -> b
    org.bouncycastle.asn1.x509.AlgorithmIdentifier XMSS_SHAKE256 -> h
    org.bouncycastle.asn1.x509.AlgorithmIdentifier XMSS_SHAKE128 -> g
    org.bouncycastle.asn1.x509.AlgorithmIdentifier XMSS_SHA512 -> f
    java.util.Map categories -> i
    org.bouncycastle.asn1.x509.AlgorithmIdentifier AlgID_qTESLA_p_I -> a
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmIdentifier(java.lang.String) -> a
    org.bouncycastle.crypto.Digest getDigest(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> b
    java.lang.String getDigestName(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> c
    org.bouncycastle.asn1.x509.AlgorithmIdentifier qTeslaLookupAlgID(int) -> d
    int qTeslaLookupSecurityCategory(org.bouncycastle.asn1.x509.AlgorithmIdentifier) -> e
    org.bouncycastle.asn1.x509.AlgorithmIdentifier sphincs256LookupTreeAlgID(java.lang.String) -> f
    java.lang.String sphincs256LookupTreeAlgName(org.bouncycastle.pqc.asn1.SPHINCS256KeyParams) -> g
    org.bouncycastle.asn1.x509.AlgorithmIdentifier xmssLookupTreeAlgID(java.lang.String) -> h
org.bouncycastle.pqc.crypto.xmss.BDS -> h7.a:
    java.util.List treeHashInstances -> S2
    int k -> T2
    org.bouncycastle.pqc.crypto.xmss.XMSSNode root -> U2
    int index -> Z2
    java.util.Stack stack -> X2
    boolean used -> a3
    java.util.Map retain -> W2
    int treeHeight -> R2
    int maxIndex -> b3
    java.util.Map keep -> Y2
    org.bouncycastle.pqc.crypto.xmss.WOTSPlus wotsPlus -> Q2
    java.util.List authenticationPath -> V2
    org.bouncycastle.pqc.crypto.xmss.BDSTreeHash getBDSTreeHashInstanceForUpdate() -> a
    int getIndex() -> b
    int getMaxIndex() -> c
    org.bouncycastle.pqc.crypto.xmss.BDS getNextState(byte[],byte[],org.bouncycastle.pqc.crypto.xmss.OTSHashAddress) -> d
    void initialize(byte[],byte[],org.bouncycastle.pqc.crypto.xmss.OTSHashAddress) -> e
    void nextAuthenticationPath(byte[],byte[],org.bouncycastle.pqc.crypto.xmss.OTSHashAddress) -> f
    void validate() -> g
    org.bouncycastle.pqc.crypto.xmss.BDS withWOTSDigest(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> h
org.bouncycastle.pqc.crypto.xmss.BDSStateMap -> h7.b:
    java.util.Map bdsState -> Q2
    long maxIndex -> R2
    org.bouncycastle.pqc.crypto.xmss.BDS get(int) -> a
    long getMaxIndex() -> b
    void put(int,org.bouncycastle.pqc.crypto.xmss.BDS) -> c
    org.bouncycastle.pqc.crypto.xmss.BDS update(int,byte[],byte[],org.bouncycastle.pqc.crypto.xmss.OTSHashAddress) -> d
    void updateState(org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters,long,byte[],byte[]) -> e
    org.bouncycastle.pqc.crypto.xmss.BDSStateMap withWOTSDigest(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> f
org.bouncycastle.pqc.crypto.xmss.BDSTreeHash -> h7.c:
    boolean finished -> V2
    int height -> S2
    int nextIndex -> T2
    boolean initialized -> U2
    org.bouncycastle.pqc.crypto.xmss.XMSSNode tailNode -> Q2
    int initialHeight -> R2
    org.bouncycastle.pqc.crypto.xmss.BDSTreeHash clone() -> a
    int getHeight() -> b
    int getIndexLeaf() -> c
    org.bouncycastle.pqc.crypto.xmss.XMSSNode getTailNode() -> d
    void initialize(int) -> e
    boolean isFinished() -> f
    boolean isInitialized() -> g
    void setNode(org.bouncycastle.pqc.crypto.xmss.XMSSNode) -> h
    void update(java.util.Stack,org.bouncycastle.pqc.crypto.xmss.WOTSPlus,byte[],byte[],org.bouncycastle.pqc.crypto.xmss.OTSHashAddress) -> i
org.bouncycastle.pqc.crypto.xmss.DefaultXMSSMTOid -> h7.d:
    java.util.Map oidLookupTable -> c
    java.lang.String stringRepresentation -> b
    int oid -> a
    int getOid() -> a
    java.lang.String createKey(java.lang.String,int,int,int,int,int) -> b
    org.bouncycastle.pqc.crypto.xmss.DefaultXMSSMTOid lookup(java.lang.String,int,int,int,int,int) -> c
org.bouncycastle.pqc.crypto.xmss.DefaultXMSSOid -> h7.e:
    java.util.Map oidLookupTable -> c
    java.lang.String stringRepresentation -> b
    int oid -> a
    int getOid() -> a
    java.lang.String createKey(java.lang.String,int,int,int,int) -> b
    org.bouncycastle.pqc.crypto.xmss.DefaultXMSSOid lookup(java.lang.String,int,int,int,int) -> c
org.bouncycastle.pqc.crypto.xmss.DigestUtil -> h7.f:
    java.util.Map nameToOid -> a
    java.util.Map oidToName -> b
    org.bouncycastle.crypto.Digest getDigest(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> a
    java.lang.String getDigestName(org.bouncycastle.asn1.ASN1ObjectIdentifier) -> b
    org.bouncycastle.asn1.ASN1ObjectIdentifier getDigestOID(java.lang.String) -> c
org.bouncycastle.pqc.crypto.xmss.HashTreeAddress -> h7.g:
    int treeHeight -> f
    int treeIndex -> g
    int padding -> e
    byte[] toByteArray() -> d
    int getTreeHeight() -> e
    int getTreeIndex() -> f
org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$1 -> h7.g$a:
org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder -> h7.g$b:
    int treeIndex -> f
    int treeHeight -> e
    org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder getThis() -> e
    int access$000(org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder) -> i
    int access$100(org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder) -> j
    org.bouncycastle.pqc.crypto.xmss.XMSSAddress build() -> k
    org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder getThis() -> l
    org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder withTreeHeight(int) -> m
    org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder withTreeIndex(int) -> n
org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions -> h7.h:
    org.bouncycastle.crypto.Digest digest -> a
    int digestSize -> b
    byte[] F(byte[],byte[]) -> a
    byte[] H(byte[],byte[]) -> b
    byte[] PRF(byte[],byte[]) -> c
    byte[] coreDigest(int,byte[],byte[]) -> d
org.bouncycastle.pqc.crypto.xmss.LTreeAddress -> h7.i:
    int treeHeight -> f
    int treeIndex -> g
    int lTreeAddress -> e
    byte[] toByteArray() -> d
    int getLTreeAddress() -> e
    int getTreeHeight() -> f
    int getTreeIndex() -> g
org.bouncycastle.pqc.crypto.xmss.LTreeAddress$1 -> h7.i$a:
org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder -> h7.i$b:
    int treeHeight -> f
    int treeIndex -> g
    int lTreeAddress -> e
    org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder getThis() -> e
    int access$000(org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder) -> i
    int access$100(org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder) -> j
    int access$200(org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder) -> k
    org.bouncycastle.pqc.crypto.xmss.XMSSAddress build() -> l
    org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder getThis() -> m
    org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder withLTreeAddress(int) -> n
    org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder withTreeHeight(int) -> o
    org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder withTreeIndex(int) -> p
org.bouncycastle.pqc.crypto.xmss.OTSHashAddress -> h7.j:
    int chainAddress -> f
    int hashAddress -> g
    int otsAddress -> e
    byte[] toByteArray() -> d
    int getChainAddress() -> e
    int getHashAddress() -> f
    int getOTSAddress() -> g
org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$1 -> h7.j$a:
org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder -> h7.j$b:
    int chainAddress -> f
    int hashAddress -> g
    int otsAddress -> e
    org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder getThis() -> e
    int access$000(org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder) -> i
    int access$100(org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder) -> j
    int access$200(org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder) -> k
    org.bouncycastle.pqc.crypto.xmss.XMSSAddress build() -> l
    org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder getThis() -> m
    org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder withChainAddress(int) -> n
    org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder withHashAddress(int) -> o
    org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder withOTSAddress(int) -> p
org.bouncycastle.pqc.crypto.xmss.WOTSPlus -> h7.k:
    org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters params -> a
    org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions khf -> b
    byte[] publicSeed -> d
    byte[] secretKeySeed -> c
    byte[] chain(byte[],int,int,org.bouncycastle.pqc.crypto.xmss.OTSHashAddress) -> a
    byte[] expandSecretKeySeed(int) -> b
    org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions getKhf() -> c
    org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters getParams() -> d
    org.bouncycastle.pqc.crypto.xmss.WOTSPlusPublicKeyParameters getPublicKey(org.bouncycastle.pqc.crypto.xmss.OTSHashAddress) -> e
    byte[] getPublicSeed() -> f
    byte[] getWOTSPlusSecretKey(byte[],org.bouncycastle.pqc.crypto.xmss.OTSHashAddress) -> g
    void importKeys(byte[],byte[]) -> h
org.bouncycastle.pqc.crypto.xmss.WOTSPlusOid -> h7.l:
    java.util.Map oidLookupTable -> c
    java.lang.String stringRepresentation -> b
    int oid -> a
    int getOid() -> a
    java.lang.String createKey(java.lang.String,int,int,int) -> b
    org.bouncycastle.pqc.crypto.xmss.WOTSPlusOid lookup(java.lang.String,int,int,int) -> c
org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters -> h7.m:
    org.bouncycastle.pqc.crypto.xmss.XMSSOid oid -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier treeDigest -> g
    int len2 -> f
    int len -> d
    int len1 -> e
    int digestSize -> b
    int winternitzParameter -> c
    int getLen() -> a
    org.bouncycastle.asn1.ASN1ObjectIdentifier getTreeDigest() -> b
    int getTreeDigestSize() -> c
    int getWinternitzParameter() -> d
org.bouncycastle.pqc.crypto.xmss.WOTSPlusPublicKeyParameters -> h7.n:
    byte[][] publicKey -> a
    byte[][] toByteArray() -> a
org.bouncycastle.pqc.crypto.xmss.XMSSAddress -> h7.o:
    long treeAddress -> b
    int keyAndMask -> d
    int type -> c
    int layerAddress -> a
    int getKeyAndMask() -> a
    int getLayerAddress() -> b
    long getTreeAddress() -> c
    byte[] toByteArray() -> d
org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder -> h7.o$a:
    int keyAndMask -> d
    long treeAddress -> c
    int layerAddress -> b
    int type -> a
    int access$000(org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder) -> a
    long access$100(org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder) -> b
    int access$200(org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder) -> c
    int access$300(org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder) -> d
    org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder getThis() -> e
    org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder withKeyAndMask(int) -> f
    org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder withLayerAddress(int) -> g
    org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder withTreeAddress(long) -> h
org.bouncycastle.pqc.crypto.xmss.XMSSKeyParameters -> h7.p:
    java.lang.String treeDigest -> R2
    java.lang.String getTreeDigest() -> a
org.bouncycastle.pqc.crypto.xmss.XMSSMTKeyParameters -> h7.q:
    java.lang.String treeDigest -> R2
    java.lang.String getTreeDigest() -> a
org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters -> h7.r:
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters xmssParams -> b
    org.bouncycastle.pqc.crypto.xmss.XMSSOid oid -> a
    int layers -> d
    java.util.Map paramsLookupTable -> e
    int height -> c
    int getHeight() -> a
    int getLayers() -> b
    int getLen() -> c
    org.bouncycastle.pqc.crypto.xmss.XMSSOid getOid() -> d
    java.lang.String getTreeDigest() -> e
    int getTreeDigestSize() -> f
    int getWinternitzParameter() -> g
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters getXMSSParameters() -> h
    org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters lookupByOID(int) -> i
    int xmssTreeHeight(int,int) -> j
org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters -> h7.s:
    org.bouncycastle.pqc.crypto.xmss.BDSStateMap bdsState -> Y2
    byte[] root -> W2
    byte[] publicSeed -> V2
    byte[] secretKeyPRF -> U2
    long index -> X2
    byte[] secretKeySeed -> T2
    org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters params -> S2
    org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters getParameters() -> b
    byte[] toByteArray() -> c
org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$1 -> h7.s$a:
org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder -> h7.s$b:
    org.bouncycastle.pqc.crypto.xmss.BDSStateMap bdsState -> h
    long index -> b
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters xmss -> j
    org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters params -> a
    byte[] root -> g
    long maxIndex -> c
    byte[] privateKey -> i
    byte[] secretKeySeed -> d
    byte[] publicSeed -> f
    byte[] secretKeyPRF -> e
    org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters access$000(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder) -> a
    byte[] access$100(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder) -> b
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters access$200(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder) -> c
    long access$300(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder) -> d
    byte[] access$400(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder) -> e
    byte[] access$500(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder) -> f
    byte[] access$600(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder) -> g
    byte[] access$700(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder) -> h
    org.bouncycastle.pqc.crypto.xmss.BDSStateMap access$800(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder) -> i
    long access$900(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder) -> j
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters build() -> k
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withBDSState(org.bouncycastle.pqc.crypto.xmss.BDSStateMap) -> l
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withIndex(long) -> m
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withMaxIndex(long) -> n
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withPublicSeed(byte[]) -> o
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withRoot(byte[]) -> p
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withSecretKeyPRF(byte[]) -> q
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withSecretKeySeed(byte[]) -> r
org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters -> h7.t:
    int oid -> T2
    byte[] publicSeed -> V2
    byte[] root -> U2
    org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters params -> S2
    org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters getParameters() -> b
    byte[] getPublicSeed() -> c
    byte[] getRoot() -> d
    byte[] toByteArray() -> e
org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$1 -> h7.t$a:
org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder -> h7.t$b:
    byte[] root -> b
    org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters params -> a
    byte[] publicKey -> d
    byte[] publicSeed -> c
    org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters access$000(org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder) -> a
    byte[] access$100(org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder) -> b
    byte[] access$200(org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder) -> c
    byte[] access$300(org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder) -> d
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters build() -> e
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder withPublicKey(byte[]) -> f
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder withPublicSeed(byte[]) -> g
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder withRoot(byte[]) -> h
org.bouncycastle.pqc.crypto.xmss.XMSSNode -> h7.u:
    byte[] value -> R2
    int height -> Q2
    int getHeight() -> a
    byte[] getValue() -> b
org.bouncycastle.pqc.crypto.xmss.XMSSNodeUtil -> h7.v:
    org.bouncycastle.pqc.crypto.xmss.XMSSNode lTree(org.bouncycastle.pqc.crypto.xmss.WOTSPlus,org.bouncycastle.pqc.crypto.xmss.WOTSPlusPublicKeyParameters,org.bouncycastle.pqc.crypto.xmss.LTreeAddress) -> a
    org.bouncycastle.pqc.crypto.xmss.XMSSNode randomizeHash(org.bouncycastle.pqc.crypto.xmss.WOTSPlus,org.bouncycastle.pqc.crypto.xmss.XMSSNode,org.bouncycastle.pqc.crypto.xmss.XMSSNode,org.bouncycastle.pqc.crypto.xmss.XMSSAddress) -> b
org.bouncycastle.pqc.crypto.xmss.XMSSOid -> h7.w:
    int getOid() -> a
org.bouncycastle.pqc.crypto.xmss.XMSSParameters -> h7.x:
    org.bouncycastle.pqc.crypto.xmss.XMSSOid oid -> a
    java.lang.String treeDigest -> f
    java.util.Map paramsLookupTable -> i
    org.bouncycastle.asn1.ASN1ObjectIdentifier treeDigestOID -> d
    int treeDigestSize -> g
    int winternitzParameter -> e
    int height -> b
    org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters wotsPlusParams -> h
    int k -> c
    int determineMinK() -> a
    int getHeight() -> b
    int getK() -> c
    int getLen() -> d
    org.bouncycastle.pqc.crypto.xmss.XMSSOid getOid() -> e
    java.lang.String getTreeDigest() -> f
    org.bouncycastle.asn1.ASN1ObjectIdentifier getTreeDigestOID() -> g
    int getTreeDigestSize() -> h
    org.bouncycastle.pqc.crypto.xmss.WOTSPlus getWOTSPlus() -> i
    int getWinternitzParameter() -> j
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters lookupByOID(int) -> k
org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters -> h7.y:
    byte[] root -> W2
    byte[] publicSeed -> V2
    byte[] secretKeyPRF -> U2
    byte[] secretKeySeed -> T2
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters params -> S2
    org.bouncycastle.pqc.crypto.xmss.BDS bdsState -> X2
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters getParameters() -> b
    byte[] toByteArray() -> c
org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$1 -> h7.y$a:
org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder -> h7.y$b:
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters params -> a
    byte[] root -> g
    byte[] privateKey -> i
    int index -> b
    byte[] secretKeySeed -> d
    int maxIndex -> c
    byte[] publicSeed -> f
    org.bouncycastle.pqc.crypto.xmss.BDS bdsState -> h
    byte[] secretKeyPRF -> e
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters access$000(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder) -> a
    byte[] access$100(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder) -> b
    byte[] access$200(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder) -> c
    byte[] access$300(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder) -> d
    byte[] access$400(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder) -> e
    byte[] access$500(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder) -> f
    org.bouncycastle.pqc.crypto.xmss.BDS access$600(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder) -> g
    int access$700(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder) -> h
    int access$800(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder) -> i
    org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters build() -> j
    org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withBDSState(org.bouncycastle.pqc.crypto.xmss.BDS) -> k
    org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withIndex(int) -> l
    org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withMaxIndex(int) -> m
    org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withPublicSeed(byte[]) -> n
    org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withRoot(byte[]) -> o
    org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withSecretKeyPRF(byte[]) -> p
    org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withSecretKeySeed(byte[]) -> q
org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters -> h7.z:
    int oid -> T2
    byte[] publicSeed -> V2
    byte[] root -> U2
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters params -> S2
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters getParameters() -> b
    byte[] getPublicSeed() -> c
    byte[] getRoot() -> d
    byte[] toByteArray() -> e
org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$1 -> h7.z$a:
org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder -> h7.z$b:
    byte[] root -> b
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters params -> a
    byte[] publicKey -> d
    byte[] publicSeed -> c
    org.bouncycastle.pqc.crypto.xmss.XMSSParameters access$000(org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder) -> a
    byte[] access$100(org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder) -> b
    byte[] access$200(org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder) -> c
    byte[] access$300(org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder) -> d
    org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters build() -> e
    org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder withPublicKey(byte[]) -> f
    org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder withPublicSeed(byte[]) -> g
    org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder withRoot(byte[]) -> h
org.bouncycastle.pqc.crypto.xmss.XMSSUtil -> h7.a0:
    long bytesToXBigEndian(byte[],int,int) -> a
    int calculateTau(int,int) -> b
    byte[] cloneArray(byte[]) -> c
    byte[][] cloneArray(byte[][]) -> d
    void copyBytesAtOffset(byte[],byte[],int) -> e
    java.lang.Object deserialize(byte[],java.lang.Class) -> f
    byte[] extractBytesAtOffset(byte[],int,int) -> g
    int getDigestSize(org.bouncycastle.crypto.Digest) -> h
    int getLeafIndex(long,int) -> i
    long getTreeIndex(long,int) -> j
    boolean hasNullPointer(byte[][]) -> k
    boolean isIndexValid(int,long) -> l
    boolean isNewAuthenticationPathNeeded(long,int,int) -> m
    boolean isNewBDSInitNeeded(long,int,int) -> n
    int log2(int) -> o
    byte[] serialize(java.lang.Object) -> p
    byte[] toBytesBigEndian(long,int) -> q
org.bouncycastle.pqc.crypto.xmss.XMSSUtil$CheckingStream -> h7.a0$a:
    boolean found -> R2
    java.lang.Class mainClass -> Q2
    java.util.Set components -> S2
org.bouncycastle.pqc.jcajce.provider.BouncyCastlePQCProvider -> i7.a:
    java.util.Map keyInfoConverters -> S2
    java.lang.String[] ALGORITHMS -> T2
    java.lang.String PROVIDER_NAME -> R2
    java.lang.String info -> Q2
    void access$000(org.bouncycastle.pqc.jcajce.provider.BouncyCastlePQCProvider) -> a
    void loadAlgorithms(java.lang.String,java.lang.String[]) -> b
    java.lang.Class loadClass(java.lang.Class,java.lang.String) -> c
    void setup() -> d
org.bouncycastle.pqc.jcajce.provider.BouncyCastlePQCProvider$1 -> i7.a$a:
    org.bouncycastle.pqc.jcajce.provider.BouncyCastlePQCProvider this$0 -> a
org.bouncycastle.pqc.jcajce.provider.BouncyCastlePQCProvider$2 -> i7.a$b:
    java.lang.String val$className -> a
org.bouncycastle.pqc.jcajce.provider.lms.BCLMSPrivateKey -> j7.a:
    org.bouncycastle.pqc.crypto.lms.LMSKeyParameters keyParams -> Q2
    org.bouncycastle.asn1.ASN1Set attributes -> R2
    void init(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.lms.BCLMSPublicKey -> j7.b:
    org.bouncycastle.pqc.crypto.lms.LMSKeyParameters keyParams -> Q2
    void init(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.lms.LMSKeyFactorySpi -> j7.c:
    java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
    java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> b
org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey -> k7.a:
    org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters params -> Q2
    org.bouncycastle.pqc.math.linearalgebra.GF2mField getField() -> a
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly() -> b
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getH() -> c
    int getK() -> d
    int getN() -> e
    org.bouncycastle.pqc.math.linearalgebra.Permutation getP() -> f
org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey -> k7.b:
    org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PublicKeyParameters params -> Q2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG() -> a
    int getN() -> b
    int getT() -> c
org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey -> k7.c:
    org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters params -> Q2
    org.bouncycastle.pqc.math.linearalgebra.GF2mField getField() -> a
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly() -> b
    int getK() -> c
    int getN() -> d
    org.bouncycastle.pqc.math.linearalgebra.Permutation getP1() -> e
    org.bouncycastle.pqc.math.linearalgebra.Permutation getP2() -> f
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getSInv() -> g
org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey -> k7.d:
    org.bouncycastle.pqc.crypto.mceliece.McEliecePublicKeyParameters params -> Q2
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG() -> a
    int getN() -> b
    int getT() -> c
org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceCCA2KeyFactorySpi -> k7.e:
org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceKeyFactorySpi -> k7.f:
org.bouncycastle.pqc.jcajce.provider.mceliece.Utils -> k7.g:
    org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigAlgId(java.lang.String) -> a
    org.bouncycastle.crypto.Digest getDigest(org.bouncycastle.asn1.x509.AlgorithmIdentifier) -> b
org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPrivateKey -> l7.a:
    org.bouncycastle.pqc.crypto.newhope.NHPrivateKeyParameters params -> Q2
    org.bouncycastle.asn1.ASN1Set attributes -> R2
    void init(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPublicKey -> l7.b:
    org.bouncycastle.pqc.crypto.newhope.NHPublicKeyParameters params -> Q2
    void init(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.newhope.NHKeyFactorySpi -> l7.c:
    java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
    java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> b
org.bouncycastle.pqc.jcajce.provider.qtesla.BCqTESLAPrivateKey -> m7.a:
    org.bouncycastle.pqc.crypto.qtesla.QTESLAPrivateKeyParameters keyParams -> Q2
    org.bouncycastle.asn1.ASN1Set attributes -> R2
    void init(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.qtesla.BCqTESLAPublicKey -> m7.b:
    org.bouncycastle.pqc.crypto.qtesla.QTESLAPublicKeyParameters keyParams -> Q2
    void init(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.qtesla.QTESLAKeyFactorySpi -> m7.c:
    java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
    java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> b
org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey -> n7.a:
    org.bouncycastle.pqc.crypto.rainbow.Layer[] layers -> U2
    short[][] A2inv -> S2
    short[] b2 -> T2
    short[] b1 -> R2
    int[] vi -> V2
    short[][] A1inv -> Q2
    short[] getB1() -> a
    short[] getB2() -> b
    short[][] getInvA1() -> c
    short[][] getInvA2() -> d
    org.bouncycastle.pqc.crypto.rainbow.Layer[] getLayers() -> e
    int[] getVi() -> f
org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey -> n7.b:
    short[][] coeffsingular -> R2
    int docLength -> T2
    short[] coeffscalar -> S2
    short[][] coeffquadratic -> Q2
    short[][] getCoeffQuadratic() -> a
    short[] getCoeffScalar() -> b
    short[][] getCoeffSingular() -> c
    int getDocLength() -> d
org.bouncycastle.pqc.jcajce.provider.rainbow.RainbowKeyFactorySpi -> n7.c:
    java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
    java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> b
org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PrivateKey -> o7.a:
    org.bouncycastle.asn1.ASN1ObjectIdentifier treeDigest -> Q2
    org.bouncycastle.pqc.crypto.sphincs.SPHINCSPrivateKeyParameters params -> R2
    org.bouncycastle.asn1.ASN1Set attributes -> S2
    void init(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PublicKey -> o7.b:
    org.bouncycastle.asn1.ASN1ObjectIdentifier treeDigest -> Q2
    org.bouncycastle.pqc.crypto.sphincs.SPHINCSPublicKeyParameters params -> R2
    void init(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.sphincs.Sphincs256KeyFactorySpi -> o7.c:
    java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
    java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> b
org.bouncycastle.pqc.jcajce.provider.util.KeyUtil -> p7.a:
    byte[] getEncodedSubjectPublicKeyInfo(org.bouncycastle.asn1.x509.AlgorithmIdentifier,org.bouncycastle.asn1.ASN1Encodable) -> a
    byte[] getEncodedSubjectPublicKeyInfo(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> b
org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPrivateKey -> q7.a:
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters keyParams -> R2
    org.bouncycastle.asn1.ASN1ObjectIdentifier treeDigest -> Q2
    org.bouncycastle.asn1.ASN1Set attributes -> S2
    void init(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPublicKey -> q7.b:
    org.bouncycastle.asn1.ASN1ObjectIdentifier treeDigest -> Q2
    org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters keyParams -> R2
    void init(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPrivateKey -> q7.c:
    org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters keyParams -> Q2
    org.bouncycastle.asn1.ASN1ObjectIdentifier treeDigest -> R2
    org.bouncycastle.asn1.ASN1Set attributes -> S2
    void init(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPublicKey -> q7.d:
    org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters keyParams -> Q2
    org.bouncycastle.asn1.ASN1ObjectIdentifier treeDigest -> R2
    void init(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> a
org.bouncycastle.pqc.jcajce.provider.xmss.DigestUtil -> q7.e:
    org.bouncycastle.asn1.ASN1ObjectIdentifier getDigestOID(java.lang.String) -> a
org.bouncycastle.pqc.jcajce.provider.xmss.XMSSKeyFactorySpi -> q7.f:
    java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
    java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> b
org.bouncycastle.pqc.jcajce.provider.xmss.XMSSMTKeyFactorySpi -> q7.g:
    java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo) -> a
    java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo) -> b
org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec -> r7.a:
    org.bouncycastle.pqc.crypto.rainbow.Layer[] layers -> V2
    short[][] A2inv -> S2
    short[] b2 -> T2
    int[] vi -> U2
    short[] b1 -> R2
    short[][] A1inv -> Q2
    short[] getB1() -> a
    short[] getB2() -> b
    short[][] getInvA1() -> c
    short[][] getInvA2() -> d
    org.bouncycastle.pqc.crypto.rainbow.Layer[] getLayers() -> e
    int[] getVi() -> f
org.bouncycastle.pqc.jcajce.spec.RainbowPublicKeySpec -> r7.b:
    short[][] coeffsingular -> R2
    int docLength -> T2
    short[] coeffscalar -> S2
    short[][] coeffquadratic -> Q2
    short[][] getCoeffQuadratic() -> a
    short[] getCoeffScalar() -> b
    short[][] getCoeffSingular() -> c
    int getDocLength() -> d
org.bouncycastle.pqc.math.linearalgebra.GF2Matrix -> s7.a:
    int[][] matrix -> c
    int length -> d
    byte[] getEncoded() -> c
org.bouncycastle.pqc.math.linearalgebra.GF2mField -> s7.b:
    int polynomial -> b
    int degree -> a
    int add(int,int) -> a
    java.lang.String elementToStr(int) -> b
    int exp(int,int) -> c
    int getDegree() -> d
    byte[] getEncoded() -> e
    int inverse(int) -> f
    boolean isElementOfThisField(int) -> g
    int mult(int,int) -> h
    java.lang.String polyToString(int) -> i
org.bouncycastle.pqc.math.linearalgebra.GoppaCode -> s7.c:
    org.bouncycastle.pqc.math.linearalgebra.GF2Matrix createCanonicalCheckMatrix(org.bouncycastle.pqc.math.linearalgebra.GF2mField,org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM) -> a
org.bouncycastle.pqc.math.linearalgebra.IntUtils -> s7.d:
    int[] clone(int[]) -> a
    boolean equals(int[],int[]) -> b
org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions -> s7.e:
    int[] jacobiTable -> g
    java.math.BigInteger ONE -> b
    java.math.BigInteger ZERO -> a
    java.math.BigInteger FOUR -> d
    java.math.BigInteger TWO -> c
    int[] SMALL_PRIMES -> e
    java.security.SecureRandom sr -> f
    int ceilLog256(int) -> a
org.bouncycastle.pqc.math.linearalgebra.LittleEndianConversions -> s7.f:
    void I2OSP(int,byte[],int) -> a
    void I2OSP(int,byte[],int,int) -> b
    byte[] I2OSP(int) -> c
    int OS2IP(byte[]) -> d
    int OS2IP(byte[],int) -> e
    int OS2IP(byte[],int,int) -> f
org.bouncycastle.pqc.math.linearalgebra.Matrix -> s7.g:
    int numColumns -> b
    int numRows -> a
    int getNumColumns() -> a
    int getNumRows() -> b
org.bouncycastle.pqc.math.linearalgebra.Permutation -> s7.h:
    int[] perm -> a
    byte[] getEncoded() -> a
    boolean isPermutation(int[]) -> b
org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM -> s7.i:
    int[] coefficients -> c
    int degree -> b
    org.bouncycastle.pqc.math.linearalgebra.GF2mField field -> a
    int[] add(int[],int[]) -> a
    void addToThis(org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM) -> b
    int computeDegree(int[]) -> c
    void computeDegree() -> d
    int evaluateAt(int) -> e
    int getCoefficient(int) -> f
    int getDegree() -> g
    byte[] getEncoded() -> h
    int headCoefficient(int[]) -> i
    boolean isEqual(int[],int[]) -> j
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM mod(org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM) -> k
    int[] mod(int[],int[]) -> l
    void multThisWithElement(int) -> m
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM multWithElement(int) -> n
    int[] multWithElement(int[],int) -> o
    int[] multWithMonomial(int[],int) -> p
    int[] normalForm(int[]) -> q
org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2 -> s7.j:
    int degree(int) -> a
    int gcd(int,int) -> b
    boolean isIrreducible(int) -> c
    int modMultiply(int,int,int) -> d
    int remainder(int,int) -> e
org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m -> s7.k:
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM p -> b
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM[] sqRootMatrix -> d
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM[] sqMatrix -> c
    org.bouncycastle.pqc.math.linearalgebra.GF2mField field -> a
    void computeSquareRootMatrix() -> a
    void computeSquaringMatrix() -> b
    org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM[] getSquareRootMatrix() -> c
    void swapColumns(org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM[],int,int) -> d
org.bouncycastle.util.Arrays -> t7.a:
    boolean areEqual(byte[],byte[]) -> a
    boolean areEqual(char[],char[]) -> b
    boolean areEqual(short[],short[]) -> c
    byte[] clone(byte[]) -> d
    short[] clone(short[]) -> e
    byte[] concatenate(byte[],byte[]) -> f
    byte[] copyOfRange(byte[],int,int) -> g
    void fill(byte[],byte) -> h
    int getLength(int,int) -> i
    int hashCode(byte[]) -> j
    int hashCode(byte[],int,int) -> k
    int hashCode(char[]) -> l
    int hashCode(int[]) -> m
    int hashCode(short[]) -> n
    int hashCode(short[][]) -> o
    int hashCode(short[][][]) -> p
    boolean isNullOrContainsNull(java.lang.Object[]) -> q
    byte[] prepend(byte[],byte) -> r
org.bouncycastle.util.Arrays$Iterator -> t7.a$a:
    java.lang.Object[] dataArray -> Q2
    int position -> R2
org.bouncycastle.util.BigIntegers -> t7.b:
    java.math.BigInteger SMALL_PRIMES_PRODUCT -> e
    java.math.BigInteger ONE -> b
    java.math.BigInteger ZERO -> a
    java.math.BigInteger THREE -> d
    java.math.BigInteger TWO -> c
    int MAX_SMALL -> f
org.bouncycastle.util.Encodable -> t7.c:
org.bouncycastle.util.Integers -> t7.d:
    java.lang.Integer valueOf(int) -> a
org.bouncycastle.util.Objects -> t7.e:
    boolean areEqual(java.lang.Object,java.lang.Object) -> a
    int hashCode(java.lang.Object) -> b
org.bouncycastle.util.Pack -> t7.f:
    int bigEndianToInt(byte[],int) -> a
    long bigEndianToLong(byte[],int) -> b
    void intToBigEndian(int,byte[],int) -> c
    void intToLittleEndian(int,byte[],int) -> d
    int littleEndianToInt(byte[],int) -> e
    long littleEndianToLong(byte[],int) -> f
    short littleEndianToShort(byte[],int) -> g
    void longToBigEndian(long,byte[],int) -> h
    void longToLittleEndian(long,byte[],int) -> i
    void longToLittleEndian(long[],int,int,byte[],int) -> j
    void shortToBigEndian(short,byte[],int) -> k
    void shortToLittleEndian(short,byte[],int) -> l
org.bouncycastle.util.Properties -> t7.g:
    java.lang.ThreadLocal threadProperties -> a
    java.lang.String getPropertyValue(java.lang.String) -> a
    boolean isOverrideSet(java.lang.String) -> b
    boolean isSetTrue(java.lang.String) -> c
org.bouncycastle.util.Properties$1 -> t7.g$a:
    java.lang.String val$propertyName -> a
org.bouncycastle.util.Properties$2 -> t7.g$b:
    java.lang.String val$propertyName -> a
org.bouncycastle.util.Selector -> t7.h:
    boolean match(java.lang.Object) -> S
org.bouncycastle.util.Strings -> t7.i:
    java.lang.String LINE_SEPARATOR -> a
    char[] asCharArray(byte[]) -> a
    java.lang.String fromByteArray(byte[]) -> b
    java.lang.String fromUTF8ByteArray(byte[]) -> c
    byte[] toByteArray(java.lang.String) -> d
    java.lang.String toLowerCase(java.lang.String) -> e
    java.lang.String toUpperCase(java.lang.String) -> f
org.bouncycastle.util.Strings$1 -> t7.i$a:
    java.lang.String run() -> a
org.bouncycastle.util.encoders.DecoderException -> u7.a:
    java.lang.Throwable cause -> Q2
org.bouncycastle.util.encoders.EncoderException -> u7.b:
    java.lang.Throwable cause -> Q2
org.bouncycastle.util.encoders.Hex -> u7.c:
    org.bouncycastle.util.encoders.HexEncoder encoder -> a
    byte[] decodeStrict(java.lang.String,int,int) -> a
    byte[] encode(byte[]) -> b
    byte[] encode(byte[],int,int) -> c
    java.lang.String toHexString(byte[]) -> d
    java.lang.String toHexString(byte[],int,int) -> e
org.bouncycastle.util.encoders.HexEncoder -> u7.d:
    byte[] decodingTable -> b
    byte[] encodingTable -> a
    byte[] decodeStrict(java.lang.String,int,int) -> a
    int encode(byte[],int,int,java.io.OutputStream) -> b
    int encode(byte[],int,int,byte[],int) -> c
    void initialiseDecodingTable() -> d
org.bouncycastle.util.encoders.UTF8 -> u7.e:
    byte[] transitionTable -> b
    short[] firstUnitTable -> a
    void fill(byte[],int,int,byte) -> a
    int transcodeToUTF16(byte[],char[]) -> b
org.bouncycastle.util.io.Streams -> v7.a:
    int BUFFER_SIZE -> a
    void pipeAll(java.io.InputStream,java.io.OutputStream) -> a
    void pipeAll(java.io.InputStream,java.io.OutputStream,int) -> b
    byte[] readAll(java.io.InputStream) -> c
    int readFully(java.io.InputStream,byte[],int,int) -> d
org.bouncycastle.util.io.TeeInputStream -> v7.b:
    java.io.OutputStream output -> R2
    java.io.InputStream input -> Q2
org.slf4j.ILoggerFactory -> w7.a:
    org.slf4j.Logger getLogger(java.lang.String) -> a
org.slf4j.Logger -> w7.b:
    boolean isWarnEnabled() -> a
    void error(java.lang.String) -> b
    void debug(java.lang.String) -> c
    void error(java.lang.String,java.lang.Throwable) -> d
    java.lang.String getName() -> e
    void info(java.lang.String) -> f
    void warn(java.lang.String) -> g
    boolean isErrorEnabled() -> h
org.slf4j.LoggerFactory -> w7.c:
    java.lang.String STATIC_LOGGER_BINDER_PATH -> f
    org.slf4j.helpers.NOPLoggerFactory NOP_FALLBACK_FACTORY -> c
    java.lang.String[] API_COMPATIBILITY_LIST -> e
    org.slf4j.helpers.SubstituteLoggerFactory SUBST_FACTORY -> b
    int INITIALIZATION_STATE -> a
    boolean DETECT_LOGGER_NAME_MISMATCH -> d
    void bind() -> a
    void emitReplayOrSubstituionWarning(org.slf4j.event.SubstituteLoggingEvent,int) -> b
    void emitReplayWarning(int) -> c
    void emitSubstitutionWarning() -> d
    void failedBinding(java.lang.Throwable) -> e
    java.util.Set findPossibleStaticLoggerBinderPathSet() -> f
    void fixSubstituteLoggers() -> g
    org.slf4j.ILoggerFactory getILoggerFactory() -> h
    org.slf4j.Logger getLogger(java.lang.Class) -> i
    org.slf4j.Logger getLogger(java.lang.String) -> j
    boolean isAmbiguousStaticLoggerBinderPathSet(java.util.Set) -> k
    boolean isAndroid() -> l
    boolean messageContainsOrgSlf4jImplStaticLoggerBinder(java.lang.String) -> m
    boolean nonMatchingClasses(java.lang.Class,java.lang.Class) -> n
    void performInitialization() -> o
    void postBindCleanUp() -> p
    void replayEvents() -> q
    void replaySingleEvent(org.slf4j.event.SubstituteLoggingEvent) -> r
    void reportActualBinding(java.util.Set) -> s
    void reportMultipleBindingAmbiguity(java.util.Set) -> t
    void versionSanityCheck() -> u
org.slf4j.Marker -> w7.d:
org.slf4j.event.EventRecodingLogger -> x7.a:
    java.util.Queue eventQueue -> S2
    org.slf4j.helpers.SubstituteLogger logger -> R2
    java.lang.String name -> Q2
    boolean isWarnEnabled() -> a
    void error(java.lang.String) -> b
    void debug(java.lang.String) -> c
    void error(java.lang.String,java.lang.Throwable) -> d
    java.lang.String getName() -> e
    void info(java.lang.String) -> f
    void warn(java.lang.String) -> g
    boolean isErrorEnabled() -> h
    void recordEvent(org.slf4j.event.Level,org.slf4j.Marker,java.lang.String,java.lang.Object[],java.lang.Throwable) -> i
    void recordEvent_0Args(org.slf4j.event.Level,org.slf4j.Marker,java.lang.String,java.lang.Throwable) -> j
org.slf4j.event.Level -> x7.b:
    org.slf4j.event.Level WARN -> T2
    org.slf4j.event.Level ERROR -> S2
    org.slf4j.event.Level DEBUG -> V2
    org.slf4j.event.Level INFO -> U2
    java.lang.String levelStr -> R2
    int levelInt -> Q2
    org.slf4j.event.Level TRACE -> W2
    org.slf4j.event.Level[] $VALUES -> X2
org.slf4j.event.LoggingEvent -> x7.c:
org.slf4j.event.SubstituteLoggingEvent -> x7.d:
    java.lang.String message -> f
    org.slf4j.helpers.SubstituteLogger logger -> d
    org.slf4j.event.Level level -> a
    long timeStamp -> h
    org.slf4j.Marker marker -> b
    java.lang.String loggerName -> c
    java.lang.String threadName -> e
    java.lang.Object[] argArray -> g
    java.lang.Throwable throwable -> i
    org.slf4j.helpers.SubstituteLogger getLogger() -> a
    void setArgumentArray(java.lang.Object[]) -> b
    void setLevel(org.slf4j.event.Level) -> c
    void setLogger(org.slf4j.helpers.SubstituteLogger) -> d
    void setLoggerName(java.lang.String) -> e
    void setMarker(org.slf4j.Marker) -> f
    void setMessage(java.lang.String) -> g
    void setThreadName(java.lang.String) -> h
    void setThrowable(java.lang.Throwable) -> i
    void setTimeStamp(long) -> j
org.slf4j.helpers.MarkerIgnoringBase -> y7.a:
    java.lang.String getName() -> e
org.slf4j.helpers.NOPLogger -> y7.b:
    org.slf4j.helpers.NOPLogger NOP_LOGGER -> Q2
    boolean isWarnEnabled() -> a
    void error(java.lang.String) -> b
    void debug(java.lang.String) -> c
    void error(java.lang.String,java.lang.Throwable) -> d
    java.lang.String getName() -> e
    void info(java.lang.String) -> f
    void warn(java.lang.String) -> g
    boolean isErrorEnabled() -> h
org.slf4j.helpers.NOPLoggerFactory -> y7.c:
    org.slf4j.Logger getLogger(java.lang.String) -> a
org.slf4j.helpers.NamedLoggerBase -> y7.d:
org.slf4j.helpers.SubstituteLogger -> y7.e:
    org.slf4j.event.EventRecodingLogger eventRecodingLogger -> U2
    boolean createdPostInitialization -> W2
    org.slf4j.Logger _delegate -> R2
    java.lang.reflect.Method logMethodCache -> T2
    java.lang.String name -> Q2
    java.lang.Boolean delegateEventAware -> S2
    java.util.Queue eventQueue -> V2
    boolean isWarnEnabled() -> a
    void error(java.lang.String) -> b
    void debug(java.lang.String) -> c
    void error(java.lang.String,java.lang.Throwable) -> d
    java.lang.String getName() -> e
    void info(java.lang.String) -> f
    void warn(java.lang.String) -> g
    boolean isErrorEnabled() -> h
    org.slf4j.Logger delegate() -> i
    org.slf4j.Logger getEventRecordingLogger() -> j
    boolean isDelegateEventAware() -> k
    boolean isDelegateNOP() -> l
    boolean isDelegateNull() -> m
    void log(org.slf4j.event.LoggingEvent) -> n
    void setDelegate(org.slf4j.Logger) -> o
org.slf4j.helpers.SubstituteLoggerFactory -> y7.f:
    java.util.Map loggers -> b
    java.util.concurrent.LinkedBlockingQueue eventQueue -> c
    boolean postInitialization -> a
    org.slf4j.Logger getLogger(java.lang.String) -> a
    void clear() -> b
    java.util.concurrent.LinkedBlockingQueue getEventQueue() -> c
    java.util.List getLoggers() -> d
    void postInitialization() -> e
org.slf4j.helpers.Util -> y7.g:
    boolean SECURITY_MANAGER_CREATION_ALREADY_ATTEMPTED -> b
    org.slf4j.helpers.Util$ClassContextSecurityManager SECURITY_MANAGER -> a
    java.lang.Class getCallingClass() -> a
    org.slf4j.helpers.Util$ClassContextSecurityManager getSecurityManager() -> b
    void report(java.lang.String) -> c
    void report(java.lang.String,java.lang.Throwable) -> d
    org.slf4j.helpers.Util$ClassContextSecurityManager safeCreateSecurityManager() -> e
    boolean safeGetBooleanSystemProperty(java.lang.String) -> f
    java.lang.String safeGetSystemProperty(java.lang.String) -> g
org.slf4j.helpers.Util$1 -> y7.g$a:
org.slf4j.helpers.Util$ClassContextSecurityManager -> y7.g$b:
org.w3c.dom.Attr -> z7.a:
    void setValue(java.lang.String) -> F
    org.w3c.dom.Element getOwnerElement() -> Z
    boolean getSpecified() -> d0
    java.lang.String getName() -> e
org.w3c.dom.CDATASection -> z7.b:
org.w3c.dom.CharacterData -> z7.c:
    void setData(java.lang.String) -> D
    java.lang.String getData() -> h
    void appendData(java.lang.String) -> o0
org.w3c.dom.Comment -> z7.d:
org.w3c.dom.DOMException -> z7.e:
    short code -> Q2
org.w3c.dom.DOMImplementation -> z7.f:
    boolean hasFeature(java.lang.String,java.lang.String) -> a
org.w3c.dom.DOMStringList -> z7.g:
org.w3c.dom.Document -> z7.h:
    org.w3c.dom.Element createElement(java.lang.String) -> A0
    org.w3c.dom.Attr createAttributeNS(java.lang.String,java.lang.String) -> G
    org.w3c.dom.ProcessingInstruction createProcessingInstruction(java.lang.String,java.lang.String) -> K
    org.w3c.dom.Attr createAttribute(java.lang.String) -> f0
    org.w3c.dom.Comment createComment(java.lang.String) -> h0
    org.w3c.dom.Element createElementNS(java.lang.String,java.lang.String) -> k0
    org.w3c.dom.CDATASection createCDATASection(java.lang.String) -> m
    org.w3c.dom.Text createTextNode(java.lang.String) -> m0
    org.w3c.dom.DOMImplementation getImplementation() -> q0
    org.w3c.dom.DocumentType getDoctype() -> u
    org.w3c.dom.EntityReference createEntityReference(java.lang.String) -> v0
org.w3c.dom.DocumentFragment -> z7.i:
org.w3c.dom.DocumentType -> z7.j:
    java.lang.String getPublicId() -> a
    java.lang.String getSystemId() -> b
    java.lang.String getInternalSubset() -> k
    org.w3c.dom.NamedNodeMap getEntities() -> o
    org.w3c.dom.NamedNodeMap getNotations() -> w
org.w3c.dom.Element -> z7.k:
    org.w3c.dom.Attr setAttributeNode(org.w3c.dom.Attr) -> A
    org.w3c.dom.Attr setAttributeNodeNS(org.w3c.dom.Attr) -> H
    org.w3c.dom.Attr getAttributeNode(java.lang.String) -> U
    void setAttribute(java.lang.String,java.lang.String) -> Y
    org.w3c.dom.Attr getAttributeNodeNS(java.lang.String,java.lang.String) -> p0
    void setAttributeNS(java.lang.String,java.lang.String,java.lang.String) -> s
org.w3c.dom.Entity -> z7.l:
    java.lang.String getPublicId() -> a
    java.lang.String getSystemId() -> b
    java.lang.String getNotationName() -> l0
org.w3c.dom.EntityReference -> z7.m:
org.w3c.dom.NamedNodeMap -> z7.n:
    org.w3c.dom.Node setNamedItemNS(org.w3c.dom.Node) -> a
    org.w3c.dom.Node removeNamedItem(java.lang.String) -> b
    int getLength() -> c
    org.w3c.dom.Node item(int) -> d
    org.w3c.dom.Node getNamedItem(java.lang.String) -> e
    org.w3c.dom.Node setNamedItem(org.w3c.dom.Node) -> f
org.w3c.dom.Node -> z7.o:
    java.lang.String getNodeName() -> B
    java.lang.String getNamespaceURI() -> B0
    org.w3c.dom.Node getLastChild() -> C
    boolean hasAttributes() -> E
    org.w3c.dom.Node getFirstChild() -> N
    org.w3c.dom.Node removeChild(org.w3c.dom.Node) -> R
    void setNodeValue(java.lang.String) -> T
    org.w3c.dom.NodeList getChildNodes() -> W
    java.lang.String getPrefix() -> g
    org.w3c.dom.Node insertBefore(org.w3c.dom.Node,org.w3c.dom.Node) -> j
    org.w3c.dom.Document getOwnerDocument() -> j0
    short getNodeType() -> n0
    org.w3c.dom.Node cloneNode(boolean) -> p
    java.lang.String getLocalName() -> r
    org.w3c.dom.Node appendChild(org.w3c.dom.Node) -> r0
    org.w3c.dom.Node getPreviousSibling() -> t
    org.w3c.dom.NamedNodeMap getAttributes() -> t0
    org.w3c.dom.Node getParentNode() -> u0
    boolean hasChildNodes() -> w0
    java.lang.String getNodeValue() -> x
    org.w3c.dom.Node getNextSibling() -> y
org.w3c.dom.NodeList -> z7.p:
    int getLength() -> c
    org.w3c.dom.Node item(int) -> d
org.w3c.dom.Notation -> z7.q:
    java.lang.String getPublicId() -> a
    java.lang.String getSystemId() -> b
org.w3c.dom.ProcessingInstruction -> z7.r:
    java.lang.String getTarget() -> P
    java.lang.String getData() -> h
org.w3c.dom.Text -> z7.s:
org.w3c.dom.UserDataHandler -> z7.t:
    void handle(short,java.lang.String,java.lang.Object,org.w3c.dom.Node,org.w3c.dom.Node) -> a
org.w3c.dom.events.Event -> a8.a:
org.w3c.dom.events.EventException -> a8.b:
    short code -> Q2
org.w3c.dom.events.EventListener -> a8.c:
    void handleEvent(org.w3c.dom.events.Event) -> a
org.w3c.dom.events.EventTarget -> a8.d:
org.w3c.dom.events.MutationEvent -> a8.e:
    void initMutationEvent(java.lang.String,boolean,boolean,org.w3c.dom.Node,java.lang.String,java.lang.String,java.lang.String,short) -> a
org.w3c.dom.ls.LSInput -> b8.a:
    java.lang.String getPublicId() -> a
    java.lang.String getSystemId() -> b
    java.lang.String getEncoding() -> e
    java.lang.String getBaseURI() -> f
    java.io.InputStream getByteStream() -> g
    java.io.Reader getCharacterStream() -> h
    java.lang.String getStringData() -> i
org.w3c.dom.ls.LSParserFilter -> b8.b:
    int getWhatToShow() -> a
    short acceptNode(org.w3c.dom.Node) -> b
    short startElement(org.w3c.dom.Element) -> c
org.w3c.dom.ls.LSResourceResolver -> b8.c:
    org.w3c.dom.ls.LSInput resolveResource(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
org.xml.sax.AttributeList -> c8.a:
org.xml.sax.Attributes -> c8.b:
org.xml.sax.ContentHandler -> c8.c:
    void processingInstruction(java.lang.String,java.lang.String) -> a
    void endDocument() -> b
    void setDocumentLocator(org.xml.sax.Locator) -> c
    void characters(char[],int,int) -> d
    void startDocument() -> e
    void skippedEntity(java.lang.String) -> i
    void endElement(java.lang.String,java.lang.String,java.lang.String) -> j
    void startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes) -> m
    void endPrefixMapping(java.lang.String) -> n
    void startPrefixMapping(java.lang.String,java.lang.String) -> p
org.xml.sax.DTDHandler -> c8.d:
    void unparsedEntityDecl(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> l
    void notationDecl(java.lang.String,java.lang.String,java.lang.String) -> o
org.xml.sax.DocumentHandler -> c8.e:
    void processingInstruction(java.lang.String,java.lang.String) -> a
    void endDocument() -> b
    void setDocumentLocator(org.xml.sax.Locator) -> c
    void characters(char[],int,int) -> d
    void startDocument() -> e
    void startElement(java.lang.String,org.xml.sax.AttributeList) -> f
    void endElement(java.lang.String) -> g
org.xml.sax.EntityResolver -> c8.f:
    org.xml.sax.InputSource resolveEntity(java.lang.String,java.lang.String) -> f
org.xml.sax.ErrorHandler -> c8.g:
    void fatalError(org.xml.sax.SAXParseException) -> g
    void warning(org.xml.sax.SAXParseException) -> h
    void error(org.xml.sax.SAXParseException) -> q
org.xml.sax.InputSource -> c8.h:
    java.lang.String publicId -> a
    java.io.InputStream byteStream -> c
    java.lang.String systemId -> b
    java.io.Reader characterStream -> e
    java.lang.String encoding -> d
    java.io.InputStream getByteStream() -> a
    java.io.Reader getCharacterStream() -> b
    java.lang.String getEncoding() -> c
    java.lang.String getPublicId() -> d
    java.lang.String getSystemId() -> e
    void setByteStream(java.io.InputStream) -> f
    void setCharacterStream(java.io.Reader) -> g
org.xml.sax.Locator -> c8.i:
    java.lang.String getPublicId() -> a
    java.lang.String getSystemId() -> b
    int getColumnNumber() -> d
    int getLineNumber() -> g
org.xml.sax.SAXException -> c8.j:
    java.lang.Exception exception -> Q2
    java.lang.Exception getException() -> a
org.xml.sax.SAXNotRecognizedException -> c8.k:
org.xml.sax.SAXNotSupportedException -> c8.l:
org.xml.sax.SAXParseException -> c8.m:
    int columnNumber -> U2
    int lineNumber -> T2
    java.lang.String systemId -> S2
    java.lang.String publicId -> R2
    int getColumnNumber() -> b
    int getLineNumber() -> c
    java.lang.String getPublicId() -> d
    java.lang.String getSystemId() -> e
    void init(java.lang.String,java.lang.String,int,int) -> f
org.xml.sax.ext.DeclHandler -> d8.a:
    void internalEntityDecl(java.lang.String,java.lang.String) -> a
    void externalEntityDecl(java.lang.String,java.lang.String,java.lang.String) -> b
    void elementDecl(java.lang.String,java.lang.String) -> c
    void attributeDecl(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> d
org.xml.sax.ext.EntityResolver2 -> d8.b:
    org.xml.sax.InputSource getExternalSubset(java.lang.String,java.lang.String) -> k
    org.xml.sax.InputSource resolveEntity(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> r
org.xml.sax.ext.LexicalHandler -> d8.c:
    void endEntity(java.lang.String) -> a
    void endDTD() -> b
    void startDTD(java.lang.String,java.lang.String,java.lang.String) -> c
    void endCDATA() -> d
    void startEntity(java.lang.String) -> e
    void startCDATA() -> f
    void comment(char[],int,int) -> g
org.xml.sax.helpers.DefaultHandler -> e8.a:
    void processingInstruction(java.lang.String,java.lang.String) -> a
    void endDocument() -> b
    void setDocumentLocator(org.xml.sax.Locator) -> c
    void characters(char[],int,int) -> d
    void startDocument() -> e
    org.xml.sax.InputSource resolveEntity(java.lang.String,java.lang.String) -> f
    void fatalError(org.xml.sax.SAXParseException) -> g
    void warning(org.xml.sax.SAXParseException) -> h
    void skippedEntity(java.lang.String) -> i
    void endElement(java.lang.String,java.lang.String,java.lang.String) -> j
    void unparsedEntityDecl(java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> l
    void startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes) -> m
    void endPrefixMapping(java.lang.String) -> n
    void notationDecl(java.lang.String,java.lang.String,java.lang.String) -> o
    void startPrefixMapping(java.lang.String,java.lang.String) -> p
org.xml.sax.helpers.LocatorImpl -> e8.b:
    java.lang.String publicId -> a
    int columnNumber -> d
    java.lang.String systemId -> b
    int lineNumber -> c
    java.lang.String getPublicId() -> a
    java.lang.String getSystemId() -> b
    void setColumnNumber(int) -> c
    int getColumnNumber() -> d
    void setLineNumber(int) -> e
    void setPublicId(java.lang.String) -> f
    int getLineNumber() -> g
    void setSystemId(java.lang.String) -> h
p0.ByteBufferRandomAccessSource$$ExternalSyntheticLambda0 -> p0.e:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    java.nio.ByteBuffer com.itextpdf.io.source.ByteBufferRandomAccessSource$$InternalSyntheticLambda$1$b906af0b6b472e462748a00b8d7db0c34d97ea72a295e49ad5c7aa1687821f55$0.f$0 -> a
    void com.itextpdf.io.source.ByteBufferRandomAccessSource$$InternalSyntheticLambda$1$b906af0b6b472e462748a00b8d7db0c34d97ea72a295e49ad5c7aa1687821f55$0.<init>(java.nio.ByteBuffer) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object com.itextpdf.io.source.ByteBufferRandomAccessSource$$InternalSyntheticLambda$1$b906af0b6b472e462748a00b8d7db0c34d97ea72a295e49ad5c7aa1687821f55$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
p0.ByteBufferRandomAccessSource$$ExternalSyntheticLambda1 -> p0.f:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    com.itextpdf.io.source.ByteBufferRandomAccessSource$$InternalSyntheticLambda$1$fd55495c0bd7f7763926c7bebdd8a3fab1a58400a15e11190106e8763b1f2299$0 com.itextpdf.io.source.ByteBufferRandomAccessSource$$InternalSyntheticLambda$1$fd55495c0bd7f7763926c7bebdd8a3fab1a58400a15e11190106e8763b1f2299$0.INSTANCE -> a
    void com.itextpdf.io.source.ByteBufferRandomAccessSource$$InternalSyntheticLambda$1$fd55495c0bd7f7763926c7bebdd8a3fab1a58400a15e11190106e8763b1f2299$0.<clinit>() -> <clinit>
      # {"id":"com.android.tools.r8.synthesized"}
    void com.itextpdf.io.source.ByteBufferRandomAccessSource$$InternalSyntheticLambda$1$fd55495c0bd7f7763926c7bebdd8a3fab1a58400a15e11190106e8763b1f2299$0.<init>() -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object com.itextpdf.io.source.ByteBufferRandomAccessSource$$InternalSyntheticLambda$1$fd55495c0bd7f7763926c7bebdd8a3fab1a58400a15e11190106e8763b1f2299$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
q2.FlutterLoader$1$$ExternalSyntheticLambda0 -> q2.c:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    io.flutter.embedding.engine.loader.FlutterLoader$1 io.flutter.embedding.engine.loader.FlutterLoader$1$$InternalSyntheticLambda$0$4c58083b2370a8fcdf0f833c7e06d30029e23fa1df6021353fa19987ec472ed7$0.f$0 -> Q2
    void io.flutter.embedding.engine.loader.FlutterLoader$1$$InternalSyntheticLambda$0$4c58083b2370a8fcdf0f833c7e06d30029e23fa1df6021353fa19987ec472ed7$0.<init>(io.flutter.embedding.engine.loader.FlutterLoader$1) -> <init>
      # {"id":"com.android.tools.r8.synthesized"}
    void io.flutter.embedding.engine.loader.FlutterLoader$1$$InternalSyntheticLambda$0$4c58083b2370a8fcdf0f833c7e06d30029e23fa1df6021353fa19987ec472ed7$0.run() -> run
      # {"id":"com.android.tools.r8.synthesized"}
